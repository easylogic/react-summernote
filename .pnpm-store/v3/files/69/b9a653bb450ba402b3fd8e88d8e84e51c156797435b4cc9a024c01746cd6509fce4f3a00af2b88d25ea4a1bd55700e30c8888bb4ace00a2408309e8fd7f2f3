{"version":3,"sources":["../src/constants.ts","../src/preview/withPseudoState.ts","../src/preview/splitSelectors.ts","../src/preview/rewriteStyleSheet.ts","../src/preview.ts"],"names":["ADDON_ID","TOOL_ID","PARAM_KEY","EXCLUDED_PSEUDO_ELEMENT_PATTERNS","PSEUDO_STATES","DOCS_RENDERED","FORCE_REMOUNT","FORCE_RE_RENDER","GLOBALS_UPDATED","STORY_CHANGED","STORY_RENDERED","UPDATE_GLOBALS","addons","useEffect","useMemo","isAtRule","selector","splitSelectors","selectors","result","parentheses","brackets","i","len","char","pseudoStates","pseudoStatesPattern","matchOne","matchAll","warnings","warnOnce","message","replacePseudoStates","allClass","negativeLookbehind","acc","state","replacePseudoStatesWithAncestorSelector","forShadowDOM","additionalHostSelectors","states","withoutPseudoStates","extractPseudoStates","s","_","rewriteNotSelectors","match","originalNot","selectorList","rewrittenNot","rewriteNotSelector","negatedSelectorList","rewrittenSelectors","negatedSelector","rewriteRule","cssText","selectorText","replacementSelectors","classSelector","ancestorSelector","matches","hostInnerSelector","descendantSelector","withNotsReplaced","rewriteStyleSheet","sheet","count","rewriteRuleContainer","e","ruleContainer","rewriteLimit","index","cssRule","numRewritten","styleRule","newRule","channel","shadowHosts","applyClasses","element","classnames","classname","querySelectorPiercingShadowDOM","root","results","el","applyParameter","rootElement","parameter","map","add","target","value","sel","key","keyWithoutAll","updateShadowHost","shadowHost","node","pseudoConfig","rootSelector","pseudoStateConfig","equals","a","b","withPseudoState","StoryFn","viewMode","parameters","id","globalsArgs","globals","config","timeout","rewriteStyleSheets","shadowRoot","styleSheets","init","decorators"],"mappings":"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","sourcesContent":["export const ADDON_ID = \"storybook/pseudo-states\"\nexport const TOOL_ID = `${ADDON_ID}/tool`\nexport const PARAM_KEY = \"pseudo\"\n\n// Regex patterns for pseudo-elements which are not allowed to have classes applied on them\n// E.g. ::-webkit-scrollbar-thumb.pseudo-hover is not a valid selector\nexport const EXCLUDED_PSEUDO_ELEMENT_PATTERNS = [\"::-(webkit|moz|ms)-[a-z-]+\", \"::part\\\\([^)]+\\\\)\"]\n\n// Dynamic pseudo-classes\n// @see https://www.w3.org/TR/2018/REC-selectors-3-20181106/#dynamic-pseudos\nexport const PSEUDO_STATES = {\n  hover: \"hover\",\n  active: \"active\",\n  focusVisible: \"focus-visible\",\n  focusWithin: \"focus-within\",\n  focus: \"focus\", // must come after its alternatives\n  visited: \"visited\",\n  link: \"link\",\n  target: \"target\",\n} as const\n\nexport type PseudoState = keyof typeof PSEUDO_STATES\n","/* eslint-env browser */\nimport {\n  DOCS_RENDERED,\n  FORCE_REMOUNT,\n  FORCE_RE_RENDER,\n  GLOBALS_UPDATED,\n  STORY_CHANGED,\n  STORY_RENDERED,\n  UPDATE_GLOBALS,\n} from \"@storybook/core-events\"\nimport { DecoratorFunction } from \"@storybook/types\"\nimport { addons, useEffect, useMemo } from \"@storybook/preview-api\"\n\nimport { PSEUDO_STATES, PseudoState } from \"../constants\"\nimport { rewriteStyleSheet } from \"./rewriteStyleSheet\"\n\ntype PseudoStateConfig = {\n  [P in PseudoState]?: boolean | string | string[]\n}\n\nexport interface PseudoParameter extends PseudoStateConfig {\n  rootSelector?: string\n}\n\nconst channel = addons.getChannel()\nconst shadowHosts = new Set<Element>()\n\n// Drops any existing pseudo state classnames that carried over from a previously viewed story\n// before adding the new classnames. We use forEach for IE compatibility.\nconst applyClasses = (element: Element, classnames: Set<string>) => {\n  Object.values(PSEUDO_STATES).forEach((state) => {\n    element.classList.remove(`pseudo-${state}`)\n    element.classList.remove(`pseudo-${state}-all`)\n  })\n  classnames.forEach((classname) => element.classList.add(classname))\n}\n\nfunction querySelectorPiercingShadowDOM(root: Element | ShadowRoot, selector: string) {\n  const results: Element[] = [];\n  root.querySelectorAll('*').forEach((el) => {\n    if (el.shadowRoot) {\n      results.push(...querySelectorPiercingShadowDOM(el.shadowRoot, selector))\n    }\n  })\n  results.push(...root.querySelectorAll(selector).values())\n  return results\n}\n\nconst applyParameter = (rootElement: Element, parameter: PseudoStateConfig = {}) => {\n  const map = new Map([[rootElement, new Set<PseudoState>()]])\n  const add = (target: Element, state: PseudoState) =>\n    map.set(target, new Set([...(map.get(target) || []), state]))\n\n  ;(Object.entries(parameter || {}) as [PseudoState, any]).forEach(([state, value]) => {\n    if (typeof value === \"boolean\") {\n      // default API - applying pseudo class to root element.\n      if (value) add(rootElement, `${state}-all` as PseudoState)\n    } else if (typeof value === \"string\") {\n      // explicit selectors API - applying pseudo class to a specific element\n      querySelectorPiercingShadowDOM(rootElement, value).forEach((el) => add(el, state))\n    } else if (Array.isArray(value)) {\n      // explicit selectors API - we have an array (of strings) recursively handle each one\n      value.forEach((sel) => querySelectorPiercingShadowDOM(rootElement, sel).forEach((el) => add(el, state)))\n    }\n  })\n\n  map.forEach((states, target) => {\n    const classnames = new Set<string>()\n    states.forEach((key) => {\n      const keyWithoutAll = key.replace(\"-all\", \"\") as PseudoState\n      if (PSEUDO_STATES[key]) {\n        classnames.add(`pseudo-${PSEUDO_STATES[key]}`)\n      } else if (PSEUDO_STATES[keyWithoutAll]) {\n        classnames.add(`pseudo-${PSEUDO_STATES[keyWithoutAll]}-all`)\n      }\n    })\n    applyClasses(target, classnames)\n  })\n}\n\n// Traverses ancestry to collect relevant pseudo classnames, and applies them to the shadow host.\n// Shadow DOM can only access classes on its host. Traversing is needed to mimic the CSS cascade.\nconst updateShadowHost = (shadowHost: Element) => {\n  const classnames = new Set<string>()\n  // Keep any existing \"pseudo-*\" classes (but not \"pseudo-*-all\").\n  // \"pseudo-*-all\" classes may be stale and will be re-added as needed.\n  shadowHost.className\n    .split(\" \")\n    .filter((classname) => classname.match(/^pseudo-(.(?!-all))+$/))\n    .forEach((classname) => classnames.add(classname))\n  // Adopt \"pseudo-*-all\" classes from ancestors (across shadow boundaries)\n  for (let node = shadowHost.parentNode; node;) {\n    if (node instanceof ShadowRoot) {\n      node = node.host\n      continue\n    }\n    if (node instanceof Element) {\n      const element = node\n      if (element.className) {\n        element.className\n          .split(\" \")\n          .filter((classname) => classname.match(/^pseudo-.+-all$/) !== null)\n          .forEach((classname) => classnames.add(classname))\n      }\n    }\n    node = node.parentNode\n  }\n  applyClasses(shadowHost, classnames)\n}\n\n// Drops the rootSelector from the parameter object, as it is not a pseudo state.\nconst pseudoConfig = (parameter: PseudoParameter) => {\n  const { rootSelector, ...pseudoStateConfig } = parameter || {}\n  return pseudoStateConfig\n}\n\n// Compares two pseudo state configs to see if they are equal.\n// Uses JSON.stringify to handle arrays, so the order of selectors in the array matters.\nconst equals = (a: PseudoStateConfig = {}, b: PseudoStateConfig = {}) =>\n  a !== null &&\n  b !== null &&\n  Object.keys(a).length === Object.keys(b).length &&\n  (Object.keys(a) as PseudoState[]).every(\n    (key) => JSON.stringify(a[key]) === JSON.stringify(b[key])\n  )\n\n// Global decorator that rewrites stylesheets and applies classnames to render pseudo styles\nexport const withPseudoState: DecoratorFunction = (\n  StoryFn,\n  { viewMode, parameters, id, globals: globalsArgs }\n) => {\n  const { pseudo: parameter } = parameters\n  const { pseudo: globals } = globalsArgs\n  const { rootSelector } = parameter || {}\n\n  const rootElement = useMemo(() => {\n    if (rootSelector) {\n      return document.querySelector(rootSelector)\n    }\n    if (viewMode === \"docs\") {\n      return document.getElementById(`story--${id}`)\n    }\n    return (\n      document.getElementById(\"storybook-root\") || // Storybook 7.0+\n      document.getElementById(\"root\")\n    )\n  }, [rootSelector, viewMode, id])\n\n  // Sync parameter to globals, used by the toolbar (only in canvas as this\n  // doesn't make sense for docs because many stories are displayed at once)\n  useEffect(() => {\n    const config = pseudoConfig(parameter)\n    if (viewMode === \"story\" && !equals(config, globals)) {\n      channel.emit(UPDATE_GLOBALS, {\n        globals: { pseudo: config },\n      })\n    }\n  }, [parameter, viewMode])\n\n  // Convert selected states to classnames and apply them to the story root element.\n  // Then update each shadow host to redetermine its own pseudo classnames.\n  useEffect(() => {\n    if (!rootElement) return\n    const timeout = setTimeout(() => {\n      applyParameter(rootElement, globals || pseudoConfig(parameter))\n      shadowHosts.forEach(updateShadowHost)\n    }, 0)\n    return () => clearTimeout(timeout)\n  }, [rootElement, globals, parameter])\n\n  return StoryFn()\n}\n\n// Rewrite CSS rules for pseudo-states on all stylesheets to add an alternative selector\nconst rewriteStyleSheets = (shadowRoot?: ShadowRoot) => {\n  let styleSheets = Array.from(shadowRoot ? shadowRoot.styleSheets : document.styleSheets)\n  if (shadowRoot?.adoptedStyleSheets?.length) styleSheets = shadowRoot.adoptedStyleSheets\n  styleSheets.forEach((sheet) => rewriteStyleSheet(sheet, !!shadowRoot))\n  if (shadowRoot && shadowHosts) shadowHosts.add(shadowRoot.host)\n}\n\n// Only track shadow hosts for the current story\nchannel.on(STORY_CHANGED, () => shadowHosts.clear())\n\n// Reinitialize CSS enhancements every time the story changes\nchannel.on(STORY_RENDERED, () => rewriteStyleSheets())\nchannel.on(GLOBALS_UPDATED, () => rewriteStyleSheets())\nchannel.on(FORCE_RE_RENDER, () => rewriteStyleSheets())\nchannel.on(FORCE_REMOUNT, () => rewriteStyleSheets())\n\n// Reinitialize CSS enhancements every time a docs page is rendered\nchannel.on(DOCS_RENDERED, () => rewriteStyleSheets())\n\n// IE doesn't support shadow DOM\nif (Element.prototype.attachShadow) {\n  // Monkeypatch the attachShadow method so we can handle pseudo styles inside shadow DOM\n  // @ts-expect-error (Monkeypatch)\n  Element.prototype._attachShadow = Element.prototype.attachShadow\n  Element.prototype.attachShadow = function attachShadow(init) {\n    // Force \"open\" mode, so we can access the shadowRoot\n    // @ts-expect-error (Monkeypatch)\n    const shadowRoot = this._attachShadow({ ...init, mode: \"open\" })\n    // Wait for it to render and apply its styles before rewriting them\n    requestAnimationFrame(() => {\n      rewriteStyleSheets(shadowRoot)\n      if (shadowHosts.has(shadowRoot.host)) updateShadowHost(shadowRoot.host)\n    })\n    return shadowRoot\n  }\n}\n","const isAtRule = (selector: string) => selector.indexOf(\"@\") === 0\n\nexport const splitSelectors = (selectors: string) => {\n  if (isAtRule(selectors)) return [selectors]\n\n  let result = []\n  let parentheses = 0\n  let brackets = 0\n  let selector = \"\"\n\n  for (let i = 0, len = selectors.length; i < len; i++) {\n    const char = selectors[i]\n    if (char === \"(\") {\n      parentheses += 1\n    } else if (char === \")\") {\n      parentheses -= 1\n    } else if (char === \"[\") {\n      brackets += 1\n    } else if (char === \"]\") {\n      brackets -= 1\n    } else if (char === \",\") {\n      if (!parentheses && !brackets) {\n        result.push(selector.trim())\n        selector = \"\"\n        continue\n      }\n    }\n    selector += char\n  }\n\n  result.push(selector.trim())\n  return result\n}\n","import { PSEUDO_STATES, EXCLUDED_PSEUDO_ELEMENT_PATTERNS } from \"../constants\"\nimport { splitSelectors } from \"./splitSelectors\"\n\nconst pseudoStates = Object.values(PSEUDO_STATES)\nconst pseudoStatesPattern = `:(${pseudoStates.join(\"|\")})`\nconst matchOne = new RegExp(pseudoStatesPattern)\nconst matchAll = new RegExp(pseudoStatesPattern, \"g\")\n  \nconst warnings = new Set()\nconst warnOnce = (message: string) => {\n  if (warnings.has(message)) return\n  // eslint-disable-next-line no-console\n  console.warn(message)\n  warnings.add(message)\n}\n\nconst replacePseudoStates = (selector: string, allClass?: boolean) => {\n  const negativeLookbehind = `(?<!(?:${EXCLUDED_PSEUDO_ELEMENT_PATTERNS.join(\"|\")})\\\\S*)`\n  return pseudoStates.reduce((acc, state) => acc.replace(\n    new RegExp(`${negativeLookbehind}:${state}`, \"g\"), \n    `.pseudo-${state}${allClass ? \"-all\" : \"\"}`\n  ), selector)\n}\n\n// Does not handle :host() or :not() containing pseudo-states. Need to call replaceNotSelectors on the input first.\nconst replacePseudoStatesWithAncestorSelector = (selector: string, forShadowDOM: boolean, additionalHostSelectors?: string) => {\n  let { states, withoutPseudoStates } = extractPseudoStates(selector)\n  if (states.length === 0 && !additionalHostSelectors) {\n    return selector\n  }\n  const selectors = `${additionalHostSelectors ?? \"\"}${states.map((s) => `.pseudo-${s}-all`).join(\"\")}`\n\n  // If there was a :host-context() containing only pseudo-states, we will later add a :host selector that replaces it.\n  withoutPseudoStates = withoutPseudoStates.replace(\":host-context(*)\", \"\").trimStart()\n\n  // If there is a :host-context() selector, we don't need to introduce a :host() selector.\n  // We can just append the pseudo-state classes to the :host-context() selector.\n  return withoutPseudoStates.startsWith(\":host-context(\")\n    ? withoutPseudoStates.replace(/(?<=:host-context\\(\\S+)\\)/, `)${selectors}`)\n    : forShadowDOM\n      ? `:host(${selectors}) ${withoutPseudoStates}`\n      : `${selectors} ${withoutPseudoStates}`\n}\n\nconst extractPseudoStates = (selector: string) => {\n  const states = new Set()\n  const withoutPseudoStates = selector\n    .replace(matchAll, (_, state) => {\n      states.add(state)\n      return \"\"\n    })\n    // If removing pseudo-state selectors from inside a functional selector left it empty (thus invalid), must fix it by adding '*'.\n    .replaceAll(\"()\", \"(*)\")\n    // If a selector list was left with blank items (e.g. \", foo, , bar, \"), remove the extra commas/spaces.\n    .replace(/(?<=[\\s(]),\\s+|(,\\s+)+(?=\\))/g, \"\") || \"*\"\n\n  return {\n    states: Array.from(states),\n    withoutPseudoStates\n  }\n}\n\nconst rewriteNotSelectors = (selector: string, forShadowDOM: boolean) => {\n  return [...selector.matchAll(/:not\\(([^)]+)\\)/g)].reduce((acc, match) => {\n    const originalNot = match[0]\n    const selectorList = match[1]\n    const rewrittenNot = rewriteNotSelector(selectorList, forShadowDOM)\n    return acc.replace(originalNot, rewrittenNot)\n  }, selector)\n}\n\nconst rewriteNotSelector = (negatedSelectorList: string, forShadowDOM: boolean) => {\n  const rewrittenSelectors: string[] = []\n  // For each negated selector\n  for (const negatedSelector of negatedSelectorList.split(/,\\s*/)) {\n    // :not cannot be nested and cannot contain pseudo-elements, so no need to worry about that.\n    // Also, there's no compelling use case for :host() inside :not(), so we don't handle that.\n    rewrittenSelectors.push(replacePseudoStatesWithAncestorSelector(negatedSelector, forShadowDOM))\n  }\n  return `:not(${rewrittenSelectors.join(\", \")})`\n}\n\nconst rewriteRule = ({ cssText, selectorText }: CSSStyleRule, forShadowDOM: boolean) => {\n  return cssText.replace(\n    selectorText,\n    splitSelectors(selectorText)\n      .flatMap((selector) => {\n        if (selector.includes(\".pseudo-\")) {\n          return []\n        }\n        const replacementSelectors = [selector]\n        if (!matchOne.test(selector)) {\n          return replacementSelectors\n        }\n\n        const classSelector = replacePseudoStates(selector)\n        if (classSelector !== selector) {\n          replacementSelectors.push(classSelector)\n        }\n\n        let ancestorSelector = \"\"\n        \n        if (selector.startsWith(\":host(\")) {\n          const matches = selector.match(/^:host\\((\\S+)\\)\\s+(.+)$/)\n          if (matches && matchOne.test(matches[2])) {\n            // Simple replacement won't work on pseudo-state selectors outside of :host().\n            // E.g. :host(.foo) .bar:hover -> :host(.foo.pseudo-hover-all) .bar\n            // E.g. :host(.foo:focus) .bar:hover -> :host(.foo.pseudo-focus-all.pseudo-hover-all) .bar\n            let hostInnerSelector = matches[1]\n            let descendantSelector = matches[2]\n            // Simple replacement is fine for pseudo-state selectors inside :host() (even if inside :not()).\n            hostInnerSelector = replacePseudoStates(hostInnerSelector, true)\n            // Rewrite any :not selectors in the descendant selector.\n            descendantSelector = rewriteNotSelectors(descendantSelector, true)\n            // Any remaining pseudo-states in the descendant selector need to be moved into the host selector.\n            ancestorSelector = replacePseudoStatesWithAncestorSelector(descendantSelector, true, hostInnerSelector)\n          } else {\n            // Don't need to specially handle :not() because:\n            //  - if inside :host(), simple replacement is sufficient\n            //  - if outside :host(), didn't match any pseudo-states\n            ancestorSelector = replacePseudoStates(selector, true)\n          }\n        } else {\n          const withNotsReplaced = rewriteNotSelectors(selector, forShadowDOM)\n          ancestorSelector = replacePseudoStatesWithAncestorSelector(withNotsReplaced, forShadowDOM)\n        }\n        replacementSelectors.push(ancestorSelector)\n\n        return replacementSelectors\n      })\n      .join(\", \")\n  )\n}\n\n// Rewrites the style sheet to add alternative selectors for any rule that targets a pseudo state.\n// A sheet can only be rewritten once, and may carry over between stories.\nexport const rewriteStyleSheet = (\n  sheet: CSSStyleSheet,\n  forShadowDOM = false\n): boolean => {\n  try {\n    const maximumRulesToRewrite = 1000\n    const count = rewriteRuleContainer(sheet, maximumRulesToRewrite, forShadowDOM);\n    \n    if (count >= maximumRulesToRewrite) {\n      warnOnce(\"Reached maximum of 1000 pseudo selectors per sheet, skipping the rest.\")\n    }\n\n    return count > 0\n  } catch (e) {\n    if (String(e).includes(\"cssRules\")) {\n      warnOnce(`Can't access cssRules, likely due to CORS restrictions: ${sheet.href}`)\n    } else {\n      // eslint-disable-next-line no-console\n      console.error(e, sheet.href)\n    }\n    return false\n  }\n}\n\nconst rewriteRuleContainer = (\n  ruleContainer: CSSStyleSheet | CSSGroupingRule,\n  rewriteLimit: number,\n  forShadowDOM: boolean\n): number => {\n  let count = 0\n  let index = -1\n  for (const cssRule of ruleContainer.cssRules) {\n    index++\n    let numRewritten = 0\n\n    // @ts-expect-error\n    if (cssRule.__processed) {\n      // @ts-expect-error\n      numRewritten = cssRule.__pseudoStatesRewrittenCount\n    } else {\n      if (\"cssRules\" in cssRule && (cssRule.cssRules as CSSRuleList).length) {\n        numRewritten = rewriteRuleContainer(cssRule as CSSGroupingRule, rewriteLimit - count, forShadowDOM)\n      } else {\n        if (!(\"selectorText\" in cssRule)) continue\n        const styleRule = cssRule as CSSStyleRule\n        if (matchOne.test(styleRule.selectorText)) {\n          const newRule = rewriteRule(styleRule, forShadowDOM)\n          ruleContainer.deleteRule(index)\n          ruleContainer.insertRule(newRule, index)\n          numRewritten = 1\n        }\n      }\n      // @ts-expect-error\n      cssRule.__processed = true\n      // @ts-expect-error\n      cssRule.__pseudoStatesRewrittenCount = numRewritten\n    }\n    count += numRewritten\n\n    if (count >= rewriteLimit) {\n      break\n    }\n  }\n\n  return count\n}\n","import { PARAM_KEY } from \"./constants\"\nimport { withPseudoState } from \"./preview/withPseudoState\"\n\nexport const decorators = [withPseudoState]\nexport const globals = { [PARAM_KEY]: false }\n"]}