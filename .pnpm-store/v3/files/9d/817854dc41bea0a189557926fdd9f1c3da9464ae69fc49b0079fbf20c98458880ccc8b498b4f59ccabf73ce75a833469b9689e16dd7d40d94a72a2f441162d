"use strict";
var a2 = Object.create;
var la = Object.defineProperty;
var o2 = Object.getOwnPropertyDescriptor;
var l2 = Object.getOwnPropertyNames;
var u2 = Object.getPrototypeOf, c2 = Object.prototype.hasOwnProperty;
var n = (t, e) => la(t, "name", { value: e, configurable: !0 });
var w = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), p2 = (t, e) => {
  for (var r in e)
    la(t, r, { get: e[r], enumerable: !0 });
}, ex = (t, e, r, s) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of l2(e))
      !c2.call(t, i) && i !== r && la(t, i, { get: () => e[i], enumerable: !(s = o2(e, i)) || s.enumerable });
  return t;
};
var $t = (t, e, r) => (r = t != null ? a2(u2(t)) : {}, ex(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e || !t || !t.__esModule ? la(r, "default", { value: t, enumerable: !0 }) : r,
  t
)), f2 = (t) => ex(la({}, "__esModule", { value: !0 }), t);

// ../node_modules/ts-dedent/dist/index.js
var ul = w((ua) => {
  "use strict";
  Object.defineProperty(ua, "__esModule", { value: !0 });
  ua.dedent = void 0;
  function tx(t) {
    for (var e = [], r = 1; r < arguments.length; r++)
      e[r - 1] = arguments[r];
    var s = Array.from(typeof t == "string" ? [t] : t);
    s[s.length - 1] = s[s.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var i = s.reduce(function(l, u) {
      var c = u.match(/\n([\t ]+|(?!\s).)/g);
      return c ? l.concat(c.map(function(p) {
        var f, m;
        return (m = (f = p.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !== null && m !== void 0 ? m : 0;
      })) : l;
    }, []);
    if (i.length) {
      var a = new RegExp(`
[	 ]{` + Math.min.apply(Math, i) + "}", "g");
      s = s.map(function(l) {
        return l.replace(a, `
`);
      });
    }
    s[0] = s[0].replace(/^\r?\n/, "");
    var o = s[0];
    return e.forEach(function(l, u) {
      var c = o.match(/(?:^|\n)( *)$/), p = c ? c[1] : "", f = l;
      typeof l == "string" && l.includes(`
`) && (f = String(l).split(`
`).map(function(m, y) {
        return y === 0 ? m : "" + p + m;
      }).join(`
`)), o += f + s[u + 1];
    }), o;
  }
  n(tx, "dedent");
  ua.dedent = tx;
  ua.default = tx;
});

// ../node_modules/@babel/types/lib/utils/shallowEqual.js
var cl = w((tp) => {
  "use strict";
  Object.defineProperty(tp, "__esModule", {
    value: !0
  });
  tp.default = h2;
  function h2(t, e) {
    let r = Object.keys(e);
    for (let s of r)
      if (t[s] !== e[s])
        return !1;
    return !0;
  }
  n(h2, "shallowEqual");
});

// ../node_modules/@babel/types/lib/utils/deprecationWarning.js
var ca = w((rp) => {
  "use strict";
  Object.defineProperty(rp, "__esModule", {
    value: !0
  });
  rp.default = d2;
  var rx = /* @__PURE__ */ new Set();
  function d2(t, e, r = "") {
    if (rx.has(t)) return;
    rx.add(t);
    let {
      internal: s,
      trace: i
    } = m2(1, 2);
    s || console.warn(`${r}\`${t}\` has been deprecated, please migrate to \`${e}\`
${i}`);
  }
  n(d2, "deprecationWarning");
  function m2(t, e) {
    let {
      stackTraceLimit: r,
      prepareStackTrace: s
    } = Error, i;
    if (Error.stackTraceLimit = 1 + t + e, Error.prepareStackTrace = function(o, l) {
      i = l;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = s, !i) return {
      internal: !1,
      trace: ""
    };
    let a = i.slice(1 + t, 1 + t + e);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  n(m2, "captureShortStackTrace");
});

// ../node_modules/@babel/types/lib/validators/generated/index.js
var jt = w((S) => {
  "use strict";
  Object.defineProperty(S, "__esModule", {
    value: !0
  });
  S.isAccessor = NL;
  S.isAnyTypeAnnotation = zO;
  S.isArgumentPlaceholder = vD;
  S.isArrayExpression = y2;
  S.isArrayPattern = dO;
  S.isArrayTypeAnnotation = GO;
  S.isArrowFunctionExpression = mO;
  S.isAssignmentExpression = T2;
  S.isAssignmentPattern = hO;
  S.isAwaitExpression = jO;
  S.isBigIntLiteral = UO;
  S.isBinary = Q_;
  S.isBinaryExpression = b2;
  S.isBindExpression = CD;
  S.isBlock = tL;
  S.isBlockParent = eL;
  S.isBlockStatement = P2;
  S.isBooleanLiteral = K2;
  S.isBooleanLiteralTypeAnnotation = ZO;
  S.isBooleanTypeAnnotation = QO;
  S.isBreakStatement = E2;
  S.isCallExpression = A2;
  S.isCatchClause = v2;
  S.isClass = CL;
  S.isClassAccessorProperty = YO;
  S.isClassBody = yO;
  S.isClassDeclaration = bO;
  S.isClassExpression = TO;
  S.isClassImplements = tk;
  S.isClassMethod = OO;
  S.isClassPrivateMethod = XO;
  S.isClassPrivateProperty = JO;
  S.isClassProperty = WO;
  S.isCompletionStatement = iL;
  S.isConditional = nL;
  S.isConditionalExpression = C2;
  S.isContinueStatement = I2;
  S.isDebuggerStatement = w2;
  S.isDecimalLiteral = _D;
  S.isDeclaration = dL;
  S.isDeclareClass = rk;
  S.isDeclareExportAllDeclaration = pk;
  S.isDeclareExportDeclaration = ck;
  S.isDeclareFunction = sk;
  S.isDeclareInterface = ik;
  S.isDeclareModule = nk;
  S.isDeclareModuleExports = ak;
  S.isDeclareOpaqueType = lk;
  S.isDeclareTypeAlias = ok;
  S.isDeclareVariable = uk;
  S.isDeclaredPredicate = fk;
  S.isDecorator = wD;
  S.isDirective = S2;
  S.isDirectiveLiteral = g2;
  S.isDoExpression = ND;
  S.isDoWhileStatement = N2;
  S.isEmptyStatement = O2;
  S.isEmptyTypeAnnotation = Ek;
  S.isEnumBody = BL;
  S.isEnumBooleanBody = Gk;
  S.isEnumBooleanMember = tD;
  S.isEnumDeclaration = zk;
  S.isEnumDefaultedMember = iD;
  S.isEnumMember = FL;
  S.isEnumNumberBody = Qk;
  S.isEnumNumberMember = rD;
  S.isEnumStringBody = Zk;
  S.isEnumStringMember = sD;
  S.isEnumSymbolBody = eD;
  S.isExistsTypeAnnotation = hk;
  S.isExportAllDeclaration = xO;
  S.isExportDeclaration = IL;
  S.isExportDefaultDeclaration = SO;
  S.isExportDefaultSpecifier = OD;
  S.isExportNamedDeclaration = gO;
  S.isExportNamespaceSpecifier = qO;
  S.isExportSpecifier = PO;
  S.isExpression = G_;
  S.isExpressionStatement = k2;
  S.isExpressionWrapper = lL;
  S.isFile = D2;
  S.isFlow = kL;
  S.isFlowBaseAnnotation = _L;
  S.isFlowDeclaration = LL;
  S.isFlowPredicate = ML;
  S.isFlowType = DL;
  S.isFor = uL;
  S.isForInStatement = _2;
  S.isForOfStatement = EO;
  S.isForStatement = L2;
  S.isForXStatement = cL;
  S.isFunction = pL;
  S.isFunctionDeclaration = M2;
  S.isFunctionExpression = B2;
  S.isFunctionParent = fL;
  S.isFunctionTypeAnnotation = dk;
  S.isFunctionTypeParam = mk;
  S.isGenericTypeAnnotation = yk;
  S.isIdentifier = F2;
  S.isIfStatement = j2;
  S.isImmutable = xL;
  S.isImport = RO;
  S.isImportAttribute = ID;
  S.isImportDeclaration = AO;
  S.isImportDefaultSpecifier = vO;
  S.isImportExpression = wO;
  S.isImportNamespaceSpecifier = CO;
  S.isImportOrExportDeclaration = sx;
  S.isImportSpecifier = IO;
  S.isIndexedAccessType = nD;
  S.isInferredPredicate = Tk;
  S.isInterfaceDeclaration = xk;
  S.isInterfaceExtends = bk;
  S.isInterfaceTypeAnnotation = Sk;
  S.isInterpreterDirective = x2;
  S.isIntersectionTypeAnnotation = gk;
  S.isJSX = jL;
  S.isJSXAttribute = oD;
  S.isJSXClosingElement = lD;
  S.isJSXClosingFragment = gD;
  S.isJSXElement = uD;
  S.isJSXEmptyExpression = cD;
  S.isJSXExpressionContainer = pD;
  S.isJSXFragment = xD;
  S.isJSXIdentifier = hD;
  S.isJSXMemberExpression = dD;
  S.isJSXNamespacedName = mD;
  S.isJSXOpeningElement = yD;
  S.isJSXOpeningFragment = SD;
  S.isJSXSpreadAttribute = TD;
  S.isJSXSpreadChild = fD;
  S.isJSXText = bD;
  S.isLVal = yL;
  S.isLabeledStatement = R2;
  S.isLiteral = bL;
  S.isLogicalExpression = Y2;
  S.isLoop = aL;
  S.isMemberExpression = J2;
  S.isMetaProperty = NO;
  S.isMethod = gL;
  S.isMiscellaneous = RL;
  S.isMixedTypeAnnotation = Pk;
  S.isModuleDeclaration = $L;
  S.isModuleExpression = LD;
  S.isModuleSpecifier = wL;
  S.isNewExpression = X2;
  S.isNoop = PD;
  S.isNullLiteral = V2;
  S.isNullLiteralTypeAnnotation = ek;
  S.isNullableTypeAnnotation = Ak;
  S.isNumberLiteral = WL;
  S.isNumberLiteralTypeAnnotation = vk;
  S.isNumberTypeAnnotation = Ck;
  S.isNumericLiteral = q2;
  S.isObjectExpression = H2;
  S.isObjectMember = PL;
  S.isObjectMethod = z2;
  S.isObjectPattern = kO;
  S.isObjectProperty = G2;
  S.isObjectTypeAnnotation = Ik;
  S.isObjectTypeCallProperty = Nk;
  S.isObjectTypeIndexer = Ok;
  S.isObjectTypeInternalSlot = wk;
  S.isObjectTypeProperty = kk;
  S.isObjectTypeSpreadProperty = Dk;
  S.isOpaqueType = _k;
  S.isOptionalCallExpression = KO;
  S.isOptionalIndexedAccessType = aD;
  S.isOptionalMemberExpression = VO;
  S.isParenthesizedExpression = tO;
  S.isPattern = vL;
  S.isPatternLike = mL;
  S.isPipelineBareFunction = FD;
  S.isPipelinePrimaryTopicReference = jD;
  S.isPipelineTopicExpression = BD;
  S.isPlaceholder = ED;
  S.isPrivate = OL;
  S.isPrivateName = $O;
  S.isProgram = $2;
  S.isProperty = EL;
  S.isPureish = hL;
  S.isQualifiedTypeIdentifier = Lk;
  S.isRecordExpression = kD;
  S.isRegExpLiteral = W2;
  S.isRegexLiteral = YL;
  S.isRestElement = Q2;
  S.isRestProperty = JL;
  S.isReturnStatement = Z2;
  S.isScopable = Z_;
  S.isSequenceExpression = eO;
  S.isSpreadElement = DO;
  S.isSpreadProperty = XL;
  S.isStandardized = z_;
  S.isStatement = rL;
  S.isStaticBlock = HO;
  S.isStringLiteral = U2;
  S.isStringLiteralTypeAnnotation = Mk;
  S.isStringTypeAnnotation = Bk;
  S.isSuper = _O;
  S.isSwitchCase = rO;
  S.isSwitchStatement = sO;
  S.isSymbolTypeAnnotation = Fk;
  S.isTSAnyKeyword = $D;
  S.isTSArrayType = d_;
  S.isTSAsExpression = __;
  S.isTSBaseType = KL;
  S.isTSBigIntKeyword = zD;
  S.isTSBooleanKeyword = HD;
  S.isTSCallSignatureDeclaration = KD;
  S.isTSConditionalType = g_;
  S.isTSConstructSignatureDeclaration = WD;
  S.isTSConstructorType = u_;
  S.isTSDeclareFunction = UD;
  S.isTSDeclareMethod = qD;
  S.isTSEntityName = TL;
  S.isTSEnumDeclaration = B_;
  S.isTSEnumMember = F_;
  S.isTSExportAssignment = W_;
  S.isTSExpressionWithTypeArguments = w_;
  S.isTSExternalModuleReference = V_;
  S.isTSFunctionType = l_;
  S.isTSImportEqualsDeclaration = q_;
  S.isTSImportType = U_;
  S.isTSIndexSignature = XD;
  S.isTSIndexedAccessType = v_;
  S.isTSInferType = P_;
  S.isTSInstantiationExpression = D_;
  S.isTSInterfaceBody = O_;
  S.isTSInterfaceDeclaration = N_;
  S.isTSIntersectionType = S_;
  S.isTSIntrinsicKeyword = GD;
  S.isTSLiteralType = I_;
  S.isTSMappedType = C_;
  S.isTSMethodSignature = JD;
  S.isTSModuleBlock = R_;
  S.isTSModuleDeclaration = j_;
  S.isTSNamedTupleMember = b_;
  S.isTSNamespaceExportDeclaration = Y_;
  S.isTSNeverKeyword = QD;
  S.isTSNonNullExpression = K_;
  S.isTSNullKeyword = ZD;
  S.isTSNumberKeyword = e_;
  S.isTSObjectKeyword = t_;
  S.isTSOptionalType = y_;
  S.isTSParameterProperty = RD;
  S.isTSParenthesizedType = E_;
  S.isTSPropertySignature = YD;
  S.isTSQualifiedName = VD;
  S.isTSRestType = T_;
  S.isTSSatisfiesExpression = L_;
  S.isTSStringKeyword = r_;
  S.isTSSymbolKeyword = s_;
  S.isTSThisType = o_;
  S.isTSTupleType = m_;
  S.isTSType = VL;
  S.isTSTypeAliasDeclaration = k_;
  S.isTSTypeAnnotation = J_;
  S.isTSTypeAssertion = M_;
  S.isTSTypeElement = qL;
  S.isTSTypeLiteral = h_;
  S.isTSTypeOperator = A_;
  S.isTSTypeParameter = H_;
  S.isTSTypeParameterDeclaration = $_;
  S.isTSTypeParameterInstantiation = X_;
  S.isTSTypePredicate = p_;
  S.isTSTypeQuery = f_;
  S.isTSTypeReference = c_;
  S.isTSUndefinedKeyword = i_;
  S.isTSUnionType = x_;
  S.isTSUnknownKeyword = n_;
  S.isTSVoidKeyword = a_;
  S.isTaggedTemplateExpression = LO;
  S.isTemplateElement = MO;
  S.isTemplateLiteral = BO;
  S.isTerminatorless = sL;
  S.isThisExpression = iO;
  S.isThisTypeAnnotation = jk;
  S.isThrowStatement = nO;
  S.isTopicReference = MD;
  S.isTryStatement = aO;
  S.isTupleExpression = DD;
  S.isTupleTypeAnnotation = Rk;
  S.isTypeAlias = qk;
  S.isTypeAnnotation = Vk;
  S.isTypeCastExpression = Kk;
  S.isTypeParameter = Wk;
  S.isTypeParameterDeclaration = Yk;
  S.isTypeParameterInstantiation = Jk;
  S.isTypeScript = UL;
  S.isTypeofTypeAnnotation = Uk;
  S.isUnaryExpression = oO;
  S.isUnaryLike = AL;
  S.isUnionTypeAnnotation = Xk;
  S.isUpdateExpression = lO;
  S.isUserWhitespacable = SL;
  S.isV8IntrinsicIdentifier = AD;
  S.isVariableDeclaration = uO;
  S.isVariableDeclarator = cO;
  S.isVariance = $k;
  S.isVoidTypeAnnotation = Hk;
  S.isWhile = oL;
  S.isWhileStatement = pO;
  S.isWithStatement = fO;
  S.isYieldExpression = FO;
  var C = cl(), pa = ca();
  function y2(t, e) {
    return !t || t.type !== "ArrayExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(y2, "isArrayExpression");
  function T2(t, e) {
    return !t || t.type !== "AssignmentExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(T2, "isAssignmentExpression");
  function b2(t, e) {
    return !t || t.type !== "BinaryExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(b2, "isBinaryExpression");
  function x2(t, e) {
    return !t || t.type !== "InterpreterDirective" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(x2, "isInterpreterDirective");
  function S2(t, e) {
    return !t || t.type !== "Directive" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(S2, "isDirective");
  function g2(t, e) {
    return !t || t.type !== "DirectiveLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(g2, "isDirectiveLiteral");
  function P2(t, e) {
    return !t || t.type !== "BlockStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(P2, "isBlockStatement");
  function E2(t, e) {
    return !t || t.type !== "BreakStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(E2, "isBreakStatement");
  function A2(t, e) {
    return !t || t.type !== "CallExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(A2, "isCallExpression");
  function v2(t, e) {
    return !t || t.type !== "CatchClause" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(v2, "isCatchClause");
  function C2(t, e) {
    return !t || t.type !== "ConditionalExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(C2, "isConditionalExpression");
  function I2(t, e) {
    return !t || t.type !== "ContinueStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(I2, "isContinueStatement");
  function w2(t, e) {
    return !t || t.type !== "DebuggerStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(w2, "isDebuggerStatement");
  function N2(t, e) {
    return !t || t.type !== "DoWhileStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(N2, "isDoWhileStatement");
  function O2(t, e) {
    return !t || t.type !== "EmptyStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(O2, "isEmptyStatement");
  function k2(t, e) {
    return !t || t.type !== "ExpressionStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(k2, "isExpressionStatement");
  function D2(t, e) {
    return !t || t.type !== "File" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(D2, "isFile");
  function _2(t, e) {
    return !t || t.type !== "ForInStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(_2, "isForInStatement");
  function L2(t, e) {
    return !t || t.type !== "ForStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(L2, "isForStatement");
  function M2(t, e) {
    return !t || t.type !== "FunctionDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(M2, "isFunctionDeclaration");
  function B2(t, e) {
    return !t || t.type !== "FunctionExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(B2, "isFunctionExpression");
  function F2(t, e) {
    return !t || t.type !== "Identifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(F2, "isIdentifier");
  function j2(t, e) {
    return !t || t.type !== "IfStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(j2, "isIfStatement");
  function R2(t, e) {
    return !t || t.type !== "LabeledStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(R2, "isLabeledStatement");
  function U2(t, e) {
    return !t || t.type !== "StringLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(U2, "isStringLiteral");
  function q2(t, e) {
    return !t || t.type !== "NumericLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(q2, "isNumericLiteral");
  function V2(t, e) {
    return !t || t.type !== "NullLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(V2, "isNullLiteral");
  function K2(t, e) {
    return !t || t.type !== "BooleanLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(K2, "isBooleanLiteral");
  function W2(t, e) {
    return !t || t.type !== "RegExpLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(W2, "isRegExpLiteral");
  function Y2(t, e) {
    return !t || t.type !== "LogicalExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Y2, "isLogicalExpression");
  function J2(t, e) {
    return !t || t.type !== "MemberExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(J2, "isMemberExpression");
  function X2(t, e) {
    return !t || t.type !== "NewExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(X2, "isNewExpression");
  function $2(t, e) {
    return !t || t.type !== "Program" ? !1 : e == null || (0, C.default)(t, e);
  }
  n($2, "isProgram");
  function H2(t, e) {
    return !t || t.type !== "ObjectExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(H2, "isObjectExpression");
  function z2(t, e) {
    return !t || t.type !== "ObjectMethod" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(z2, "isObjectMethod");
  function G2(t, e) {
    return !t || t.type !== "ObjectProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(G2, "isObjectProperty");
  function Q2(t, e) {
    return !t || t.type !== "RestElement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Q2, "isRestElement");
  function Z2(t, e) {
    return !t || t.type !== "ReturnStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Z2, "isReturnStatement");
  function eO(t, e) {
    return !t || t.type !== "SequenceExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(eO, "isSequenceExpression");
  function tO(t, e) {
    return !t || t.type !== "ParenthesizedExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(tO, "isParenthesizedExpression");
  function rO(t, e) {
    return !t || t.type !== "SwitchCase" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(rO, "isSwitchCase");
  function sO(t, e) {
    return !t || t.type !== "SwitchStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(sO, "isSwitchStatement");
  function iO(t, e) {
    return !t || t.type !== "ThisExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(iO, "isThisExpression");
  function nO(t, e) {
    return !t || t.type !== "ThrowStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(nO, "isThrowStatement");
  function aO(t, e) {
    return !t || t.type !== "TryStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(aO, "isTryStatement");
  function oO(t, e) {
    return !t || t.type !== "UnaryExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(oO, "isUnaryExpression");
  function lO(t, e) {
    return !t || t.type !== "UpdateExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(lO, "isUpdateExpression");
  function uO(t, e) {
    return !t || t.type !== "VariableDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(uO, "isVariableDeclaration");
  function cO(t, e) {
    return !t || t.type !== "VariableDeclarator" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(cO, "isVariableDeclarator");
  function pO(t, e) {
    return !t || t.type !== "WhileStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(pO, "isWhileStatement");
  function fO(t, e) {
    return !t || t.type !== "WithStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(fO, "isWithStatement");
  function hO(t, e) {
    return !t || t.type !== "AssignmentPattern" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(hO, "isAssignmentPattern");
  function dO(t, e) {
    return !t || t.type !== "ArrayPattern" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(dO, "isArrayPattern");
  function mO(t, e) {
    return !t || t.type !== "ArrowFunctionExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(mO, "isArrowFunctionExpression");
  function yO(t, e) {
    return !t || t.type !== "ClassBody" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(yO, "isClassBody");
  function TO(t, e) {
    return !t || t.type !== "ClassExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(TO, "isClassExpression");
  function bO(t, e) {
    return !t || t.type !== "ClassDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(bO, "isClassDeclaration");
  function xO(t, e) {
    return !t || t.type !== "ExportAllDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(xO, "isExportAllDeclaration");
  function SO(t, e) {
    return !t || t.type !== "ExportDefaultDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(SO, "isExportDefaultDeclaration");
  function gO(t, e) {
    return !t || t.type !== "ExportNamedDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(gO, "isExportNamedDeclaration");
  function PO(t, e) {
    return !t || t.type !== "ExportSpecifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(PO, "isExportSpecifier");
  function EO(t, e) {
    return !t || t.type !== "ForOfStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(EO, "isForOfStatement");
  function AO(t, e) {
    return !t || t.type !== "ImportDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(AO, "isImportDeclaration");
  function vO(t, e) {
    return !t || t.type !== "ImportDefaultSpecifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(vO, "isImportDefaultSpecifier");
  function CO(t, e) {
    return !t || t.type !== "ImportNamespaceSpecifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(CO, "isImportNamespaceSpecifier");
  function IO(t, e) {
    return !t || t.type !== "ImportSpecifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(IO, "isImportSpecifier");
  function wO(t, e) {
    return !t || t.type !== "ImportExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(wO, "isImportExpression");
  function NO(t, e) {
    return !t || t.type !== "MetaProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(NO, "isMetaProperty");
  function OO(t, e) {
    return !t || t.type !== "ClassMethod" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(OO, "isClassMethod");
  function kO(t, e) {
    return !t || t.type !== "ObjectPattern" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(kO, "isObjectPattern");
  function DO(t, e) {
    return !t || t.type !== "SpreadElement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(DO, "isSpreadElement");
  function _O(t, e) {
    return !t || t.type !== "Super" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(_O, "isSuper");
  function LO(t, e) {
    return !t || t.type !== "TaggedTemplateExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(LO, "isTaggedTemplateExpression");
  function MO(t, e) {
    return !t || t.type !== "TemplateElement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(MO, "isTemplateElement");
  function BO(t, e) {
    return !t || t.type !== "TemplateLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(BO, "isTemplateLiteral");
  function FO(t, e) {
    return !t || t.type !== "YieldExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(FO, "isYieldExpression");
  function jO(t, e) {
    return !t || t.type !== "AwaitExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(jO, "isAwaitExpression");
  function RO(t, e) {
    return !t || t.type !== "Import" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(RO, "isImport");
  function UO(t, e) {
    return !t || t.type !== "BigIntLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(UO, "isBigIntLiteral");
  function qO(t, e) {
    return !t || t.type !== "ExportNamespaceSpecifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(qO, "isExportNamespaceSpecifier");
  function VO(t, e) {
    return !t || t.type !== "OptionalMemberExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(VO, "isOptionalMemberExpression");
  function KO(t, e) {
    return !t || t.type !== "OptionalCallExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(KO, "isOptionalCallExpression");
  function WO(t, e) {
    return !t || t.type !== "ClassProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(WO, "isClassProperty");
  function YO(t, e) {
    return !t || t.type !== "ClassAccessorProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(YO, "isClassAccessorProperty");
  function JO(t, e) {
    return !t || t.type !== "ClassPrivateProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(JO, "isClassPrivateProperty");
  function XO(t, e) {
    return !t || t.type !== "ClassPrivateMethod" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(XO, "isClassPrivateMethod");
  function $O(t, e) {
    return !t || t.type !== "PrivateName" ? !1 : e == null || (0, C.default)(t, e);
  }
  n($O, "isPrivateName");
  function HO(t, e) {
    return !t || t.type !== "StaticBlock" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(HO, "isStaticBlock");
  function zO(t, e) {
    return !t || t.type !== "AnyTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(zO, "isAnyTypeAnnotation");
  function GO(t, e) {
    return !t || t.type !== "ArrayTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(GO, "isArrayTypeAnnotation");
  function QO(t, e) {
    return !t || t.type !== "BooleanTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(QO, "isBooleanTypeAnnotation");
  function ZO(t, e) {
    return !t || t.type !== "BooleanLiteralTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ZO, "isBooleanLiteralTypeAnnotation");
  function ek(t, e) {
    return !t || t.type !== "NullLiteralTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ek, "isNullLiteralTypeAnnotation");
  function tk(t, e) {
    return !t || t.type !== "ClassImplements" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(tk, "isClassImplements");
  function rk(t, e) {
    return !t || t.type !== "DeclareClass" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(rk, "isDeclareClass");
  function sk(t, e) {
    return !t || t.type !== "DeclareFunction" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(sk, "isDeclareFunction");
  function ik(t, e) {
    return !t || t.type !== "DeclareInterface" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ik, "isDeclareInterface");
  function nk(t, e) {
    return !t || t.type !== "DeclareModule" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(nk, "isDeclareModule");
  function ak(t, e) {
    return !t || t.type !== "DeclareModuleExports" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ak, "isDeclareModuleExports");
  function ok(t, e) {
    return !t || t.type !== "DeclareTypeAlias" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ok, "isDeclareTypeAlias");
  function lk(t, e) {
    return !t || t.type !== "DeclareOpaqueType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(lk, "isDeclareOpaqueType");
  function uk(t, e) {
    return !t || t.type !== "DeclareVariable" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(uk, "isDeclareVariable");
  function ck(t, e) {
    return !t || t.type !== "DeclareExportDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ck, "isDeclareExportDeclaration");
  function pk(t, e) {
    return !t || t.type !== "DeclareExportAllDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(pk, "isDeclareExportAllDeclaration");
  function fk(t, e) {
    return !t || t.type !== "DeclaredPredicate" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(fk, "isDeclaredPredicate");
  function hk(t, e) {
    return !t || t.type !== "ExistsTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(hk, "isExistsTypeAnnotation");
  function dk(t, e) {
    return !t || t.type !== "FunctionTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(dk, "isFunctionTypeAnnotation");
  function mk(t, e) {
    return !t || t.type !== "FunctionTypeParam" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(mk, "isFunctionTypeParam");
  function yk(t, e) {
    return !t || t.type !== "GenericTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(yk, "isGenericTypeAnnotation");
  function Tk(t, e) {
    return !t || t.type !== "InferredPredicate" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Tk, "isInferredPredicate");
  function bk(t, e) {
    return !t || t.type !== "InterfaceExtends" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(bk, "isInterfaceExtends");
  function xk(t, e) {
    return !t || t.type !== "InterfaceDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(xk, "isInterfaceDeclaration");
  function Sk(t, e) {
    return !t || t.type !== "InterfaceTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Sk, "isInterfaceTypeAnnotation");
  function gk(t, e) {
    return !t || t.type !== "IntersectionTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(gk, "isIntersectionTypeAnnotation");
  function Pk(t, e) {
    return !t || t.type !== "MixedTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Pk, "isMixedTypeAnnotation");
  function Ek(t, e) {
    return !t || t.type !== "EmptyTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Ek, "isEmptyTypeAnnotation");
  function Ak(t, e) {
    return !t || t.type !== "NullableTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Ak, "isNullableTypeAnnotation");
  function vk(t, e) {
    return !t || t.type !== "NumberLiteralTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(vk, "isNumberLiteralTypeAnnotation");
  function Ck(t, e) {
    return !t || t.type !== "NumberTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Ck, "isNumberTypeAnnotation");
  function Ik(t, e) {
    return !t || t.type !== "ObjectTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Ik, "isObjectTypeAnnotation");
  function wk(t, e) {
    return !t || t.type !== "ObjectTypeInternalSlot" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(wk, "isObjectTypeInternalSlot");
  function Nk(t, e) {
    return !t || t.type !== "ObjectTypeCallProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Nk, "isObjectTypeCallProperty");
  function Ok(t, e) {
    return !t || t.type !== "ObjectTypeIndexer" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Ok, "isObjectTypeIndexer");
  function kk(t, e) {
    return !t || t.type !== "ObjectTypeProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(kk, "isObjectTypeProperty");
  function Dk(t, e) {
    return !t || t.type !== "ObjectTypeSpreadProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Dk, "isObjectTypeSpreadProperty");
  function _k(t, e) {
    return !t || t.type !== "OpaqueType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(_k, "isOpaqueType");
  function Lk(t, e) {
    return !t || t.type !== "QualifiedTypeIdentifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Lk, "isQualifiedTypeIdentifier");
  function Mk(t, e) {
    return !t || t.type !== "StringLiteralTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Mk, "isStringLiteralTypeAnnotation");
  function Bk(t, e) {
    return !t || t.type !== "StringTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Bk, "isStringTypeAnnotation");
  function Fk(t, e) {
    return !t || t.type !== "SymbolTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Fk, "isSymbolTypeAnnotation");
  function jk(t, e) {
    return !t || t.type !== "ThisTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(jk, "isThisTypeAnnotation");
  function Rk(t, e) {
    return !t || t.type !== "TupleTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Rk, "isTupleTypeAnnotation");
  function Uk(t, e) {
    return !t || t.type !== "TypeofTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Uk, "isTypeofTypeAnnotation");
  function qk(t, e) {
    return !t || t.type !== "TypeAlias" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(qk, "isTypeAlias");
  function Vk(t, e) {
    return !t || t.type !== "TypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Vk, "isTypeAnnotation");
  function Kk(t, e) {
    return !t || t.type !== "TypeCastExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Kk, "isTypeCastExpression");
  function Wk(t, e) {
    return !t || t.type !== "TypeParameter" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Wk, "isTypeParameter");
  function Yk(t, e) {
    return !t || t.type !== "TypeParameterDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Yk, "isTypeParameterDeclaration");
  function Jk(t, e) {
    return !t || t.type !== "TypeParameterInstantiation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Jk, "isTypeParameterInstantiation");
  function Xk(t, e) {
    return !t || t.type !== "UnionTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Xk, "isUnionTypeAnnotation");
  function $k(t, e) {
    return !t || t.type !== "Variance" ? !1 : e == null || (0, C.default)(t, e);
  }
  n($k, "isVariance");
  function Hk(t, e) {
    return !t || t.type !== "VoidTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Hk, "isVoidTypeAnnotation");
  function zk(t, e) {
    return !t || t.type !== "EnumDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(zk, "isEnumDeclaration");
  function Gk(t, e) {
    return !t || t.type !== "EnumBooleanBody" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Gk, "isEnumBooleanBody");
  function Qk(t, e) {
    return !t || t.type !== "EnumNumberBody" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Qk, "isEnumNumberBody");
  function Zk(t, e) {
    return !t || t.type !== "EnumStringBody" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Zk, "isEnumStringBody");
  function eD(t, e) {
    return !t || t.type !== "EnumSymbolBody" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(eD, "isEnumSymbolBody");
  function tD(t, e) {
    return !t || t.type !== "EnumBooleanMember" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(tD, "isEnumBooleanMember");
  function rD(t, e) {
    return !t || t.type !== "EnumNumberMember" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(rD, "isEnumNumberMember");
  function sD(t, e) {
    return !t || t.type !== "EnumStringMember" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(sD, "isEnumStringMember");
  function iD(t, e) {
    return !t || t.type !== "EnumDefaultedMember" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(iD, "isEnumDefaultedMember");
  function nD(t, e) {
    return !t || t.type !== "IndexedAccessType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(nD, "isIndexedAccessType");
  function aD(t, e) {
    return !t || t.type !== "OptionalIndexedAccessType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(aD, "isOptionalIndexedAccessType");
  function oD(t, e) {
    return !t || t.type !== "JSXAttribute" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(oD, "isJSXAttribute");
  function lD(t, e) {
    return !t || t.type !== "JSXClosingElement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(lD, "isJSXClosingElement");
  function uD(t, e) {
    return !t || t.type !== "JSXElement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(uD, "isJSXElement");
  function cD(t, e) {
    return !t || t.type !== "JSXEmptyExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(cD, "isJSXEmptyExpression");
  function pD(t, e) {
    return !t || t.type !== "JSXExpressionContainer" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(pD, "isJSXExpressionContainer");
  function fD(t, e) {
    return !t || t.type !== "JSXSpreadChild" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(fD, "isJSXSpreadChild");
  function hD(t, e) {
    return !t || t.type !== "JSXIdentifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(hD, "isJSXIdentifier");
  function dD(t, e) {
    return !t || t.type !== "JSXMemberExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(dD, "isJSXMemberExpression");
  function mD(t, e) {
    return !t || t.type !== "JSXNamespacedName" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(mD, "isJSXNamespacedName");
  function yD(t, e) {
    return !t || t.type !== "JSXOpeningElement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(yD, "isJSXOpeningElement");
  function TD(t, e) {
    return !t || t.type !== "JSXSpreadAttribute" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(TD, "isJSXSpreadAttribute");
  function bD(t, e) {
    return !t || t.type !== "JSXText" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(bD, "isJSXText");
  function xD(t, e) {
    return !t || t.type !== "JSXFragment" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(xD, "isJSXFragment");
  function SD(t, e) {
    return !t || t.type !== "JSXOpeningFragment" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(SD, "isJSXOpeningFragment");
  function gD(t, e) {
    return !t || t.type !== "JSXClosingFragment" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(gD, "isJSXClosingFragment");
  function PD(t, e) {
    return !t || t.type !== "Noop" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(PD, "isNoop");
  function ED(t, e) {
    return !t || t.type !== "Placeholder" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ED, "isPlaceholder");
  function AD(t, e) {
    return !t || t.type !== "V8IntrinsicIdentifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(AD, "isV8IntrinsicIdentifier");
  function vD(t, e) {
    return !t || t.type !== "ArgumentPlaceholder" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(vD, "isArgumentPlaceholder");
  function CD(t, e) {
    return !t || t.type !== "BindExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(CD, "isBindExpression");
  function ID(t, e) {
    return !t || t.type !== "ImportAttribute" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ID, "isImportAttribute");
  function wD(t, e) {
    return !t || t.type !== "Decorator" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(wD, "isDecorator");
  function ND(t, e) {
    return !t || t.type !== "DoExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ND, "isDoExpression");
  function OD(t, e) {
    return !t || t.type !== "ExportDefaultSpecifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(OD, "isExportDefaultSpecifier");
  function kD(t, e) {
    return !t || t.type !== "RecordExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(kD, "isRecordExpression");
  function DD(t, e) {
    return !t || t.type !== "TupleExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(DD, "isTupleExpression");
  function _D(t, e) {
    return !t || t.type !== "DecimalLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(_D, "isDecimalLiteral");
  function LD(t, e) {
    return !t || t.type !== "ModuleExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(LD, "isModuleExpression");
  function MD(t, e) {
    return !t || t.type !== "TopicReference" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(MD, "isTopicReference");
  function BD(t, e) {
    return !t || t.type !== "PipelineTopicExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(BD, "isPipelineTopicExpression");
  function FD(t, e) {
    return !t || t.type !== "PipelineBareFunction" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(FD, "isPipelineBareFunction");
  function jD(t, e) {
    return !t || t.type !== "PipelinePrimaryTopicReference" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(jD, "isPipelinePrimaryTopicReference");
  function RD(t, e) {
    return !t || t.type !== "TSParameterProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(RD, "isTSParameterProperty");
  function UD(t, e) {
    return !t || t.type !== "TSDeclareFunction" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(UD, "isTSDeclareFunction");
  function qD(t, e) {
    return !t || t.type !== "TSDeclareMethod" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(qD, "isTSDeclareMethod");
  function VD(t, e) {
    return !t || t.type !== "TSQualifiedName" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(VD, "isTSQualifiedName");
  function KD(t, e) {
    return !t || t.type !== "TSCallSignatureDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(KD, "isTSCallSignatureDeclaration");
  function WD(t, e) {
    return !t || t.type !== "TSConstructSignatureDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(WD, "isTSConstructSignatureDeclaration");
  function YD(t, e) {
    return !t || t.type !== "TSPropertySignature" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(YD, "isTSPropertySignature");
  function JD(t, e) {
    return !t || t.type !== "TSMethodSignature" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(JD, "isTSMethodSignature");
  function XD(t, e) {
    return !t || t.type !== "TSIndexSignature" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(XD, "isTSIndexSignature");
  function $D(t, e) {
    return !t || t.type !== "TSAnyKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n($D, "isTSAnyKeyword");
  function HD(t, e) {
    return !t || t.type !== "TSBooleanKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(HD, "isTSBooleanKeyword");
  function zD(t, e) {
    return !t || t.type !== "TSBigIntKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(zD, "isTSBigIntKeyword");
  function GD(t, e) {
    return !t || t.type !== "TSIntrinsicKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(GD, "isTSIntrinsicKeyword");
  function QD(t, e) {
    return !t || t.type !== "TSNeverKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(QD, "isTSNeverKeyword");
  function ZD(t, e) {
    return !t || t.type !== "TSNullKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ZD, "isTSNullKeyword");
  function e_(t, e) {
    return !t || t.type !== "TSNumberKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(e_, "isTSNumberKeyword");
  function t_(t, e) {
    return !t || t.type !== "TSObjectKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(t_, "isTSObjectKeyword");
  function r_(t, e) {
    return !t || t.type !== "TSStringKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(r_, "isTSStringKeyword");
  function s_(t, e) {
    return !t || t.type !== "TSSymbolKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(s_, "isTSSymbolKeyword");
  function i_(t, e) {
    return !t || t.type !== "TSUndefinedKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(i_, "isTSUndefinedKeyword");
  function n_(t, e) {
    return !t || t.type !== "TSUnknownKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(n_, "isTSUnknownKeyword");
  function a_(t, e) {
    return !t || t.type !== "TSVoidKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(a_, "isTSVoidKeyword");
  function o_(t, e) {
    return !t || t.type !== "TSThisType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(o_, "isTSThisType");
  function l_(t, e) {
    return !t || t.type !== "TSFunctionType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(l_, "isTSFunctionType");
  function u_(t, e) {
    return !t || t.type !== "TSConstructorType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(u_, "isTSConstructorType");
  function c_(t, e) {
    return !t || t.type !== "TSTypeReference" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(c_, "isTSTypeReference");
  function p_(t, e) {
    return !t || t.type !== "TSTypePredicate" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(p_, "isTSTypePredicate");
  function f_(t, e) {
    return !t || t.type !== "TSTypeQuery" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(f_, "isTSTypeQuery");
  function h_(t, e) {
    return !t || t.type !== "TSTypeLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(h_, "isTSTypeLiteral");
  function d_(t, e) {
    return !t || t.type !== "TSArrayType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(d_, "isTSArrayType");
  function m_(t, e) {
    return !t || t.type !== "TSTupleType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(m_, "isTSTupleType");
  function y_(t, e) {
    return !t || t.type !== "TSOptionalType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(y_, "isTSOptionalType");
  function T_(t, e) {
    return !t || t.type !== "TSRestType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(T_, "isTSRestType");
  function b_(t, e) {
    return !t || t.type !== "TSNamedTupleMember" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(b_, "isTSNamedTupleMember");
  function x_(t, e) {
    return !t || t.type !== "TSUnionType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(x_, "isTSUnionType");
  function S_(t, e) {
    return !t || t.type !== "TSIntersectionType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(S_, "isTSIntersectionType");
  function g_(t, e) {
    return !t || t.type !== "TSConditionalType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(g_, "isTSConditionalType");
  function P_(t, e) {
    return !t || t.type !== "TSInferType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(P_, "isTSInferType");
  function E_(t, e) {
    return !t || t.type !== "TSParenthesizedType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(E_, "isTSParenthesizedType");
  function A_(t, e) {
    return !t || t.type !== "TSTypeOperator" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(A_, "isTSTypeOperator");
  function v_(t, e) {
    return !t || t.type !== "TSIndexedAccessType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(v_, "isTSIndexedAccessType");
  function C_(t, e) {
    return !t || t.type !== "TSMappedType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(C_, "isTSMappedType");
  function I_(t, e) {
    return !t || t.type !== "TSLiteralType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(I_, "isTSLiteralType");
  function w_(t, e) {
    return !t || t.type !== "TSExpressionWithTypeArguments" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(w_, "isTSExpressionWithTypeArguments");
  function N_(t, e) {
    return !t || t.type !== "TSInterfaceDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(N_, "isTSInterfaceDeclaration");
  function O_(t, e) {
    return !t || t.type !== "TSInterfaceBody" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(O_, "isTSInterfaceBody");
  function k_(t, e) {
    return !t || t.type !== "TSTypeAliasDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(k_, "isTSTypeAliasDeclaration");
  function D_(t, e) {
    return !t || t.type !== "TSInstantiationExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(D_, "isTSInstantiationExpression");
  function __(t, e) {
    return !t || t.type !== "TSAsExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(__, "isTSAsExpression");
  function L_(t, e) {
    return !t || t.type !== "TSSatisfiesExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(L_, "isTSSatisfiesExpression");
  function M_(t, e) {
    return !t || t.type !== "TSTypeAssertion" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(M_, "isTSTypeAssertion");
  function B_(t, e) {
    return !t || t.type !== "TSEnumDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(B_, "isTSEnumDeclaration");
  function F_(t, e) {
    return !t || t.type !== "TSEnumMember" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(F_, "isTSEnumMember");
  function j_(t, e) {
    return !t || t.type !== "TSModuleDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(j_, "isTSModuleDeclaration");
  function R_(t, e) {
    return !t || t.type !== "TSModuleBlock" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(R_, "isTSModuleBlock");
  function U_(t, e) {
    return !t || t.type !== "TSImportType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(U_, "isTSImportType");
  function q_(t, e) {
    return !t || t.type !== "TSImportEqualsDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(q_, "isTSImportEqualsDeclaration");
  function V_(t, e) {
    return !t || t.type !== "TSExternalModuleReference" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(V_, "isTSExternalModuleReference");
  function K_(t, e) {
    return !t || t.type !== "TSNonNullExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(K_, "isTSNonNullExpression");
  function W_(t, e) {
    return !t || t.type !== "TSExportAssignment" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(W_, "isTSExportAssignment");
  function Y_(t, e) {
    return !t || t.type !== "TSNamespaceExportDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Y_, "isTSNamespaceExportDeclaration");
  function J_(t, e) {
    return !t || t.type !== "TSTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(J_, "isTSTypeAnnotation");
  function X_(t, e) {
    return !t || t.type !== "TSTypeParameterInstantiation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(X_, "isTSTypeParameterInstantiation");
  function $_(t, e) {
    return !t || t.type !== "TSTypeParameterDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n($_, "isTSTypeParameterDeclaration");
  function H_(t, e) {
    return !t || t.type !== "TSTypeParameter" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(H_, "isTSTypeParameter");
  function z_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(z_, "isStandardized");
  function G_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(G_, "isExpression");
  function Q_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(Q_, "isBinary");
  function Z_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(Z_, "isScopable");
  function eL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(eL, "isBlockParent");
  function tL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(tL, "isBlock");
  function rL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(rL, "isStatement");
  function sL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(sL, "isTerminatorless");
  function iL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(iL, "isCompletionStatement");
  function nL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(nL, "isConditional");
  function aL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(aL, "isLoop");
  function oL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(oL, "isWhile");
  function lL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(lL, "isExpressionWrapper");
  function uL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(uL, "isFor");
  function cL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(cL, "isForXStatement");
  function pL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(pL, "isFunction");
  function fL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(fL, "isFunctionParent");
  function hL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(hL, "isPureish");
  function dL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if (t.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(dL, "isDeclaration");
  function mL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(mL, "isPatternLike");
  function yL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(yL, "isLVal");
  function TL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (t.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(TL, "isTSEntityName");
  function bL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(bL, "isLiteral");
  function xL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(xL, "isImmutable");
  function SL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(SL, "isUserWhitespacable");
  function gL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(gL, "isMethod");
  function PL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(PL, "isObjectMember");
  function EL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(EL, "isProperty");
  function AL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(AL, "isUnaryLike");
  function vL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (t.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(vL, "isPattern");
  function CL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(CL, "isClass");
  function sx(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(sx, "isImportOrExportDeclaration");
  function IL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(IL, "isExportDeclaration");
  function wL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(wL, "isModuleSpecifier");
  function NL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(NL, "isAccessor");
  function OL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(OL, "isPrivate");
  function kL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(kL, "isFlow");
  function DL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(DL, "isFlowType");
  function _L(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(_L, "isFlowBaseAnnotation");
  function LL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(LL, "isFlowDeclaration");
  function ML(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(ML, "isFlowPredicate");
  function BL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(BL, "isEnumBody");
  function FL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(FL, "isEnumMember");
  function jL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(jL, "isJSX");
  function RL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(RL, "isMiscellaneous");
  function UL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(UL, "isTypeScript");
  function qL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(qL, "isTSTypeElement");
  function VL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(VL, "isTSType");
  function KL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(KL, "isTSBaseType");
  function WL(t, e) {
    return (0, pa.default)("isNumberLiteral", "isNumericLiteral"), !t || t.type !== "NumberLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(WL, "isNumberLiteral");
  function YL(t, e) {
    return (0, pa.default)("isRegexLiteral", "isRegExpLiteral"), !t || t.type !== "RegexLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(YL, "isRegexLiteral");
  function JL(t, e) {
    return (0, pa.default)("isRestProperty", "isRestElement"), !t || t.type !== "RestProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(JL, "isRestProperty");
  function XL(t, e) {
    return (0, pa.default)("isSpreadProperty", "isSpreadElement"), !t || t.type !== "SpreadProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(XL, "isSpreadProperty");
  function $L(t, e) {
    return (0, pa.default)("isModuleDeclaration", "isImportOrExportDeclaration"), sx(t, e);
  }
  n($L, "isModuleDeclaration");
});

// ../node_modules/@babel/types/lib/validators/matchesPattern.js
var ip = w((sp) => {
  "use strict";
  Object.defineProperty(sp, "__esModule", {
    value: !0
  });
  sp.default = HL;
  var fa = jt();
  function HL(t, e, r) {
    if (!(0, fa.isMemberExpression)(t)) return !1;
    let s = Array.isArray(e) ? e : e.split("."), i = [], a;
    for (a = t; (0, fa.isMemberExpression)(a); a = a.object)
      i.push(a.property);
    if (i.push(a), i.length < s.length || !r && i.length > s.length) return !1;
    for (let o = 0, l = i.length - 1; o < s.length; o++, l--) {
      let u = i[l], c;
      if ((0, fa.isIdentifier)(u))
        c = u.name;
      else if ((0, fa.isStringLiteral)(u))
        c = u.value;
      else if ((0, fa.isThisExpression)(u))
        c = "this";
      else
        return !1;
      if (s[o] !== c) return !1;
    }
    return !0;
  }
  n(HL, "matchesPattern");
});

// ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var ap = w((np) => {
  "use strict";
  Object.defineProperty(np, "__esModule", {
    value: !0
  });
  np.default = GL;
  var zL = ip();
  function GL(t, e) {
    let r = t.split(".");
    return (s) => (0, zL.default)(s, r, e);
  }
  n(GL, "buildMatchMemberExpression");
});

// ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var ix = w((pl) => {
  "use strict";
  Object.defineProperty(pl, "__esModule", {
    value: !0
  });
  pl.default = void 0;
  var QL = ap(), ZL = (0, QL.default)("React.Component"), TLe = pl.default = ZL;
});

// ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var nx = w((op) => {
  "use strict";
  Object.defineProperty(op, "__esModule", {
    value: !0
  });
  op.default = eM;
  function eM(t) {
    return !!t && /^[a-z]/.test(t);
  }
  n(eM, "isCompatTag");
});

// ../node_modules/to-fast-properties/index.js
var lp = w((gLe, ax) => {
  "use strict";
  var ha = null;
  function da(t) {
    if (ha !== null && typeof ha.property) {
      let e = ha;
      return ha = da.prototype = null, e;
    }
    return ha = da.prototype = t ?? /* @__PURE__ */ Object.create(null), new da();
  }
  n(da, "FastObject");
  da();
  ax.exports = /* @__PURE__ */ n(function(e) {
    return da(e);
  }, "toFastproperties");
});

// ../node_modules/@babel/types/lib/validators/isType.js
var fl = w((up) => {
  "use strict";
  Object.defineProperty(up, "__esModule", {
    value: !0
  });
  up.default = tM;
  var ox = Br();
  function tM(t, e) {
    if (t === e) return !0;
    if (t == null || ox.ALIAS_KEYS[e]) return !1;
    let r = ox.FLIPPED_ALIAS_KEYS[e];
    if (r) {
      if (r[0] === t) return !0;
      for (let s of r)
        if (t === s) return !0;
    }
    return !1;
  }
  n(tM, "isType");
});

// ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var pp = w((cp) => {
  "use strict";
  Object.defineProperty(cp, "__esModule", {
    value: !0
  });
  cp.default = sM;
  var rM = Br();
  function sM(t, e) {
    if (t === e) return !0;
    let r = rM.PLACEHOLDERS_ALIAS[t];
    if (r) {
      for (let s of r)
        if (e === s) return !0;
    }
    return !1;
  }
  n(sM, "isPlaceholderType");
});

// ../node_modules/@babel/types/lib/validators/is.js
var cn = w((fp) => {
  "use strict";
  Object.defineProperty(fp, "__esModule", {
    value: !0
  });
  fp.default = lM;
  var iM = cl(), nM = fl(), aM = pp(), oM = Br();
  function lM(t, e, r) {
    return e ? (0, nM.default)(e.type, t) ? typeof r > "u" ? !0 : (0, iM.default)(e, r) : !r && e.type === "Placeholder" && t in oM.FLIPPED_ALIAS_KEYS ?
    (0, aM.default)(e.expectedNode, t) : !1 : !1;
  }
  n(lM, "is");
});

// ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var fx = w((ma) => {
  "use strict";
  Object.defineProperty(ma, "__esModule", {
    value: !0
  });
  ma.isIdentifierChar = px;
  ma.isIdentifierName = fM;
  ma.isIdentifierStart = cx;
  var dp = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  lx = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", uM = new RegExp("[" + dp + "]"), cM = new RegExp("[" + dp + lx + "]");
  dp = lx = null;
  var ux = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], pM = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2,
  5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6,
  1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function hp(t, e) {
    let r = 65536;
    for (let s = 0, i = e.length; s < i; s += 2) {
      if (r += e[s], r > t) return !1;
      if (r += e[s + 1], r >= t) return !0;
    }
    return !1;
  }
  n(hp, "isInAstralSet");
  function cx(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && uM.test(String.fromCharCode(t)) :
    hp(t, ux);
  }
  n(cx, "isIdentifierStart");
  function px(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && cM.test(
    String.fromCharCode(t)) : hp(t, ux) || hp(t, pM);
  }
  n(px, "isIdentifierChar");
  function fM(t) {
    let e = !0;
    for (let r = 0; r < t.length; r++) {
      let s = t.charCodeAt(r);
      if ((s & 64512) === 55296 && r + 1 < t.length) {
        let i = t.charCodeAt(++r);
        (i & 64512) === 56320 && (s = 65536 + ((s & 1023) << 10) + (i & 1023));
      }
      if (e) {
        if (e = !1, !cx(s))
          return !1;
      } else if (!px(s))
        return !1;
    }
    return !e;
  }
  n(fM, "isIdentifierName");
});

// ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var yx = w((wi) => {
  "use strict";
  Object.defineProperty(wi, "__esModule", {
    value: !0
  });
  wi.isKeyword = TM;
  wi.isReservedWord = hx;
  wi.isStrictBindOnlyReservedWord = mx;
  wi.isStrictBindReservedWord = yM;
  wi.isStrictReservedWord = dx;
  var mp = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, hM = new Set(mp.keyword), dM = new Set(mp.strict), mM = new Set(mp.strictBind);
  function hx(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(hx, "isReservedWord");
  function dx(t, e) {
    return hx(t, e) || dM.has(t);
  }
  n(dx, "isStrictReservedWord");
  function mx(t) {
    return mM.has(t);
  }
  n(mx, "isStrictBindOnlyReservedWord");
  function yM(t, e) {
    return dx(t, e) || mx(t);
  }
  n(yM, "isStrictBindReservedWord");
  function TM(t) {
    return hM.has(t);
  }
  n(TM, "isKeyword");
});

// ../node_modules/@babel/helper-validator-identifier/lib/index.js
var Ta = w((is) => {
  "use strict";
  Object.defineProperty(is, "__esModule", {
    value: !0
  });
  Object.defineProperty(is, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return yp.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(is, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return yp.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(is, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return yp.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(is, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ya.isKeyword;
    }, "get")
  });
  Object.defineProperty(is, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ya.isReservedWord;
    }, "get")
  });
  Object.defineProperty(is, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ya.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(is, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ya.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(is, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ya.isStrictReservedWord;
    }, "get")
  });
  var yp = fx(), ya = yx();
});

// ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var pn = w((bp) => {
  "use strict";
  Object.defineProperty(bp, "__esModule", {
    value: !0
  });
  bp.default = bM;
  var Tp = Ta();
  function bM(t, e = !0) {
    return typeof t != "string" || e && ((0, Tp.isKeyword)(t) || (0, Tp.isStrictReservedWord)(t, !0)) ? !1 : (0, Tp.isIdentifierName)(t);
  }
  n(bM, "isValidIdentifier");
});

// ../node_modules/@babel/helper-string-parser/lib/index.js
var Sx = w((ba) => {
  "use strict";
  Object.defineProperty(ba, "__esModule", {
    value: !0
  });
  ba.readCodePoint = xx;
  ba.readInt = bx;
  ba.readStringContents = SM;
  var xM = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), Tx = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, hl = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function SM(t, e, r, s, i, a) {
    let o = r, l = s, u = i, c = "", p = null, f = r, {
      length: m
    } = e;
    for (; ; ) {
      if (r >= m) {
        a.unterminated(o, l, u), c += e.slice(f, r);
        break;
      }
      let y = e.charCodeAt(r);
      if (gM(t, y, e, r)) {
        c += e.slice(f, r);
        break;
      }
      if (y === 92) {
        c += e.slice(f, r);
        let T = PM(e, r, s, i, t === "template", a);
        T.ch === null && !p ? p = {
          pos: r,
          lineStart: s,
          curLine: i
        } : c += T.ch, {
          pos: r,
          lineStart: s,
          curLine: i
        } = T, f = r;
      } else y === 8232 || y === 8233 ? (++r, ++i, s = r) : y === 10 || y === 13 ? t === "template" ? (c += e.slice(f, r) + `
`, ++r, y === 13 && e.charCodeAt(r) === 10 && ++r, ++i, f = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: s,
      curLine: i,
      containsInvalid: !!p
    };
  }
  n(SM, "readStringContents");
  function gM(t, e, r, s) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(s + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(gM, "isStringEnd");
  function PM(t, e, r, s, i, a) {
    let o = !i;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = xp(t, e, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = xx(t, e, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (i)
          return l(null);
        a.strictNumericEscape(e - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, f = t.slice(c, e + 2).match(/^[0-7]+/)[0], m = parseInt(f, 8);
          m > 255 && (f = f.slice(0, -1), m = parseInt(f, 8)), e += f.length - 1;
          let y = t.charCodeAt(e);
          if (f !== "0" || y === 56 || y === 57) {
            if (i)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(m));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(PM, "readEscapedChar");
  function xp(t, e, r, s, i, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = bx(t, e, r, s, 16, i, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(xp, "readHexChar");
  function bx(t, e, r, s, i, a, o, l, u, c) {
    let p = e, f = i === 16 ? Tx.hex : Tx.decBinOct, m = i === 16 ? hl.hex : i === 10 ? hl.dec : i === 8 ? hl.oct : hl.bin, y = !1, T = 0;
    for (let L = 0, q = a ?? 1 / 0; L < q; ++L) {
      let _ = t.charCodeAt(e), U;
      if (_ === 95 && l !== "bail") {
        let J = t.charCodeAt(e - 1), ie = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(ie) || !m(ie) || f.has(J) || f.has(ie)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, s);
        }
        ++e;
        continue;
      }
      if (_ >= 97 ? U = _ - 97 + 10 : _ >= 65 ? U = _ - 65 + 10 : xM(_) ? U = _ - 48 : U = 1 / 0, U >= i) {
        if (U <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (U <= 9 && u.invalidDigit(e, r, s, i))
          U = 0;
        else if (o)
          U = 0, y = !0;
        else
          break;
      }
      ++e, T = T * i + U;
    }
    return e === p || a != null && e - p !== a || y ? {
      n: null,
      pos: e
    } : {
      n: T,
      pos: e
    };
  }
  n(bx, "readInt");
  function xx(t, e, r, s, i, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = xp(t, e, r, s, t.indexOf("}", e) - e, !0, i, a), ++e, l !== null && l > 1114111)
        if (i)
          a.invalidCodePoint(e, r, s);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = xp(t, e, r, s, 4, !1, i, a));
    return {
      code: l,
      pos: e
    };
  }
  n(xx, "readCodePoint");
});

// ../node_modules/@babel/types/lib/constants/index.js
var Ys = w((qe) => {
  "use strict";
  Object.defineProperty(qe, "__esModule", {
    value: !0
  });
  qe.UPDATE_OPERATORS = qe.UNARY_OPERATORS = qe.STRING_UNARY_OPERATORS = qe.STATEMENT_OR_BLOCK_KEYS = qe.NUMBER_UNARY_OPERATORS = qe.NUMBER_BINARY_OPERATORS =
  qe.NOT_LOCAL_BINDING = qe.LOGICAL_OPERATORS = qe.INHERIT_KEYS = qe.FOR_INIT_KEYS = qe.FLATTENABLE_KEYS = qe.EQUALITY_BINARY_OPERATORS = qe.
  COMPARISON_BINARY_OPERATORS = qe.COMMENT_KEYS = qe.BOOLEAN_UNARY_OPERATORS = qe.BOOLEAN_NUMBER_BINARY_OPERATORS = qe.BOOLEAN_BINARY_OPERATORS =
  qe.BLOCK_SCOPED_SYMBOL = qe.BINARY_OPERATORS = qe.ASSIGNMENT_OPERATORS = void 0;
  var RLe = qe.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], ULe = qe.FLATTENABLE_KEYS = ["body", "expressions"], qLe = qe.
  FOR_INIT_KEYS = ["left", "init"], VLe = qe.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], EM = qe.LOGICAL_OPERATORS =
  ["||", "&&", "??"], KLe = qe.UPDATE_OPERATORS = ["++", "--"], AM = qe.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], vM = qe.EQUALITY_BINARY_OPERATORS =
  ["==", "===", "!=", "!=="], CM = qe.COMPARISON_BINARY_OPERATORS = [...vM, "in", "instanceof"], IM = qe.BOOLEAN_BINARY_OPERATORS = [...CM, ...AM],
  gx = qe.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], WLe = qe.BINARY_OPERATORS = ["+", ...gx, ...IM,
  "|>"], YLe = qe.ASSIGNMENT_OPERATORS = ["=", "+=", ...gx.map((t) => t + "="), ...EM.map((t) => t + "=")], wM = qe.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], NM = qe.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], OM = qe.STRING_UNARY_OPERATORS = ["typeof"], JLe = qe.UNARY_OPERATORS =
  ["void", "throw", ...wM, ...NM, ...OM], XLe = qe.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  }, $Le = qe.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), HLe = qe.NOT_LOCAL_BINDING = Symbol.for("should not be consid\
ered a local binding");
});

// ../node_modules/@babel/types/lib/definitions/utils.js
var ds = w((rt) => {
  "use strict";
  Object.defineProperty(rt, "__esModule", {
    value: !0
  });
  rt.VISITOR_KEYS = rt.NODE_PARENT_VALIDATIONS = rt.NODE_FIELDS = rt.FLIPPED_ALIAS_KEYS = rt.DEPRECATED_KEYS = rt.BUILDER_KEYS = rt.ALIAS_KEYS =
  void 0;
  rt.arrayOf = Ex;
  rt.arrayOfType = Ax;
  rt.assertEach = vx;
  rt.assertNodeOrValueType = VM;
  rt.assertNodeType = gp;
  rt.assertOneOf = qM;
  rt.assertOptionalChainStart = WM;
  rt.assertShape = KM;
  rt.assertValueType = Ap;
  rt.chain = Cx;
  rt.default = Ix;
  rt.defineAliasedType = XM;
  rt.typeIs = yl;
  rt.validate = Ep;
  rt.validateArrayOfType = UM;
  rt.validateOptional = jM;
  rt.validateOptionalType = RM;
  rt.validateType = FM;
  var Px = cn(), ml = Tl(), kM = rt.VISITOR_KEYS = {}, DM = rt.ALIAS_KEYS = {}, Sp = rt.FLIPPED_ALIAS_KEYS = {}, _M = rt.NODE_FIELDS = {}, LM = rt.
  BUILDER_KEYS = {}, MM = rt.DEPRECATED_KEYS = {}, BM = rt.NODE_PARENT_VALIDATIONS = {};
  function dl(t) {
    return Array.isArray(t) ? "array" : t === null ? "null" : typeof t;
  }
  n(dl, "getType");
  function Ep(t) {
    return {
      validate: t
    };
  }
  n(Ep, "validate");
  function yl(t) {
    return typeof t == "string" ? gp(t) : gp(...t);
  }
  n(yl, "typeIs");
  function FM(t) {
    return Ep(yl(t));
  }
  n(FM, "validateType");
  function jM(t) {
    return {
      validate: t,
      optional: !0
    };
  }
  n(jM, "validateOptional");
  function RM(t) {
    return {
      validate: yl(t),
      optional: !0
    };
  }
  n(RM, "validateOptionalType");
  function Ex(t) {
    return Cx(Ap("array"), vx(t));
  }
  n(Ex, "arrayOf");
  function Ax(t) {
    return Ex(yl(t));
  }
  n(Ax, "arrayOfType");
  function UM(t) {
    return Ep(Ax(t));
  }
  n(UM, "validateArrayOfType");
  function vx(t) {
    function e(r, s, i) {
      if (Array.isArray(i))
        for (let a = 0; a < i.length; a++) {
          let o = `${s}[${a}]`, l = i[a];
          t(r, o, l), process.env.BABEL_TYPES_8_BREAKING && (0, ml.validateChild)(r, o, l);
        }
    }
    return n(e, "validator"), e.each = t, e;
  }
  n(vx, "assertEach");
  function qM(...t) {
    function e(r, s, i) {
      if (t.indexOf(i) < 0)
        throw new TypeError(`Property ${s} expected value to be one of ${JSON.stringify(t)} but got ${JSON.stringify(i)}`);
    }
    return n(e, "validate"), e.oneOf = t, e;
  }
  n(qM, "assertOneOf");
  function gp(...t) {
    function e(r, s, i) {
      for (let a of t)
        if ((0, Px.default)(a, i)) {
          (0, ml.validateChild)(r, s, i);
          return;
        }
      throw new TypeError(`Property ${s} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(i?.
      type)}`);
    }
    return n(e, "validate"), e.oneOfNodeTypes = t, e;
  }
  n(gp, "assertNodeType");
  function VM(...t) {
    function e(r, s, i) {
      for (let a of t)
        if (dl(i) === a || (0, Px.default)(a, i)) {
          (0, ml.validateChild)(r, s, i);
          return;
        }
      throw new TypeError(`Property ${s} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(i?.
      type)}`);
    }
    return n(e, "validate"), e.oneOfNodeOrValueTypes = t, e;
  }
  n(VM, "assertNodeOrValueType");
  function Ap(t) {
    function e(r, s, i) {
      if (!(dl(i) === t))
        throw new TypeError(`Property ${s} expected type of ${t} but got ${dl(i)}`);
    }
    return n(e, "validate"), e.type = t, e;
  }
  n(Ap, "assertValueType");
  function KM(t) {
    function e(r, s, i) {
      let a = [];
      for (let o of Object.keys(t))
        try {
          (0, ml.validateField)(r, o, i[o], t[o]);
        } catch (l) {
          if (l instanceof TypeError) {
            a.push(l.message);
            continue;
          }
          throw l;
        }
      if (a.length)
        throw new TypeError(`Property ${s} of ${r.type} expected to have the following:
${a.join(`
`)}`);
    }
    return n(e, "validate"), e.shapeOf = t, e;
  }
  n(KM, "assertShape");
  function WM() {
    function t(e) {
      var r;
      let s = e;
      for (; e; ) {
        let {
          type: i
        } = s;
        if (i === "OptionalCallExpression") {
          if (s.optional) return;
          s = s.callee;
          continue;
        }
        if (i === "OptionalMemberExpression") {
          if (s.optional) return;
          s = s.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${e.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(r = s) == null ? void 0 : r.type}`);
    }
    return n(t, "validate"), t;
  }
  n(WM, "assertOptionalChainStart");
  function Cx(...t) {
    function e(...r) {
      for (let s of t)
        s(...r);
    }
    if (n(e, "validate"), e.chainOf = t, t.length >= 2 && "type" in t[0] && t[0].type === "array" && !("each" in t[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return e;
  }
  n(Cx, "chain");
  var YM = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], JM = ["default", "optional", "deprecated",
  "validate"], Pp = {};
  function XM(...t) {
    return (e, r = {}) => {
      let s = r.aliases;
      if (!s) {
        var i, a;
        r.inherits && (s = (i = Pp[r.inherits].aliases) == null ? void 0 : i.slice()), (a = s) != null || (s = []), r.aliases = s;
      }
      let o = t.filter((l) => !s.includes(l));
      s.unshift(...o), Ix(e, r);
    };
  }
  n(XM, "defineAliasedType");
  function Ix(t, e = {}) {
    let r = e.inherits && Pp[e.inherits] || {}, s = e.fields;
    if (!s && (s = {}, r.fields)) {
      let l = Object.getOwnPropertyNames(r.fields);
      for (let u of l) {
        let c = r.fields[u], p = c.default;
        if (Array.isArray(p) ? p.length > 0 : p && typeof p == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        s[u] = {
          default: Array.isArray(p) ? [] : p,
          optional: c.optional,
          deprecated: c.deprecated,
          validate: c.validate
        };
      }
    }
    let i = e.visitor || r.visitor || [], a = e.aliases || r.aliases || [], o = e.builder || r.builder || e.visitor || [];
    for (let l of Object.keys(e))
      if (YM.indexOf(l) === -1)
        throw new Error(`Unknown type option "${l}" on ${t}`);
    e.deprecatedAlias && (MM[e.deprecatedAlias] = t);
    for (let l of i.concat(o))
      s[l] = s[l] || {};
    for (let l of Object.keys(s)) {
      let u = s[l];
      u.default !== void 0 && o.indexOf(l) === -1 && (u.optional = !0), u.default === void 0 ? u.default = null : !u.validate && u.default !=
      null && (u.validate = Ap(dl(u.default)));
      for (let c of Object.keys(u))
        if (JM.indexOf(c) === -1)
          throw new Error(`Unknown field key "${c}" on ${t}.${l}`);
    }
    kM[t] = e.visitor = i, LM[t] = e.builder = o, _M[t] = e.fields = s, DM[t] = e.aliases = a, a.forEach((l) => {
      Sp[l] = Sp[l] || [], Sp[l].push(t);
    }), e.validate && (BM[t] = e.validate), Pp[t] = e;
  }
  n(Ix, "defineType");
});

// ../node_modules/@babel/types/lib/definitions/core.js
var Cp = w((wr) => {
  "use strict";
  Object.defineProperty(wr, "__esModule", {
    value: !0
  });
  wr.patternLikeCommon = wr.functionTypeAnnotationCommon = wr.functionDeclarationCommon = wr.functionCommon = wr.classMethodOrPropertyCommon =
  wr.classMethodOrDeclareMethodCommon = void 0;
  var lr = cn(), $M = pn(), wx = Ta(), HM = Sx(), xa = Ys(), h = ds(), ee = (0, h.defineAliasedType)("Standardized");
  ee("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeOrValueType)("null", "Expression", "Spread\
Element"))),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  ee("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, h.assertValueType)("string");
          let t = (0, h.assertOneOf)(...xa.ASSIGNMENT_OPERATORS), e = (0, h.assertOneOf)("=");
          return function(r, s, i) {
            ((0, lr.default)("Pattern", r.left) ? e : t)(r, s, i);
          };
        }()
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, h.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, h.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  ee("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, h.assertOneOf)(...xa.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let t = (0, h.assertNodeType)("Expression"), e = (0, h.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(s, i, a) {
            (s.operator === "in" ? e : t)(s, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, h.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  ee("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, h.assertValueType)("string")
      }
    }
  });
  ee("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, h.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  ee("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, h.assertValueType)("string")
      }
    }
  });
  ee("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  ee("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, h.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  ee("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, h.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Expression", "SpreadElement", "Argu\
mentPlaceholder")))
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, h.assertOneOf)(!0, !1),
        optional: !0
      }
    }, {
      typeArguments: {
        validate: (0, h.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, h.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  ee("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, h.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, h.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  ee("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, h.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, h.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, h.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  ee("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, h.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  ee("DebuggerStatement", {
    aliases: ["Statement"]
  });
  ee("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, h.assertNodeType)("Expression")
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  ee("EmptyStatement", {
    aliases: ["Statement"]
  });
  ee("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, h.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  ee("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, h.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.assertEach)((0, h.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, h.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  ee("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, h.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, h.assertNodeType)("Expression")
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      }
    }
  });
  ee("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, h.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      }
    }
  });
  var fn = /* @__PURE__ */ n(() => ({
    params: {
      validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  wr.functionCommon = fn;
  var Ni = /* @__PURE__ */ n(() => ({
    returnType: {
      validate: (0, h.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, h.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  wr.functionTypeAnnotationCommon = Ni;
  var Nx = /* @__PURE__ */ n(() => Object.assign({}, fn(), {
    declare: {
      validate: (0, h.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, h.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  wr.functionDeclarationCommon = Nx;
  ee("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, Nx(), Ni(), {
      body: {
        validate: (0, h.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, h.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING) return () => {
      };
      let t = (0, h.assertNodeType)("Identifier");
      return function(e, r, s) {
        (0, lr.default)("ExportDefaultDeclaration", e) || t(s, "id", s.id);
      };
    }()
  });
  ee("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, fn(), Ni(), {
      id: {
        validate: (0, h.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, h.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, h.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var hn = /* @__PURE__ */ n(() => ({
    typeAnnotation: {
      validate: (0, h.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, h.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "patternLikeCommon");
  wr.patternLikeCommon = hn;
  ee("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, hn(), {
      name: {
        validate: (0, h.chain)((0, h.assertValueType)("string"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && !(0, $M.default)(r, !1))
            throw new TypeError(`"${r}" is not a valid identifier name`);
        }, {
          type: "string"
        }))
      }
    }),
    validate(t, e, r) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let s = /\.(\w+)$/.exec(e);
      if (!s) return;
      let [, i] = s, a = {
        computed: !1
      };
      if (i === "property") {
        if ((0, lr.default)("MemberExpression", t, a) || (0, lr.default)("OptionalMemberExpression", t, a)) return;
      } else if (i === "key") {
        if ((0, lr.default)("Property", t, a) || (0, lr.default)("Method", t, a)) return;
      } else if (i === "exported") {
        if ((0, lr.default)("ExportSpecifier", t)) return;
      } else if (i === "imported") {
        if ((0, lr.default)("ImportSpecifier", t, {
          imported: r
        })) return;
      } else if (i === "meta" && (0, lr.default)("MetaProperty", t, {
        meta: r
      }))
        return;
      if (((0, wx.isKeyword)(r.name) || (0, wx.isReservedWord)(r.name, !1)) && r.name !== "this")
        throw new TypeError(`"${r.name}" is not a valid identifier`);
    }
  });
  ee("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, h.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, h.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, h.assertNodeType)("Statement")
      }
    }
  });
  ee("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, h.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      }
    }
  });
  ee("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, h.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ee("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, h.chain)((0, h.assertValueType)("number"), Object.assign(function(t, e, r) {
          if (1 / r < 0 || !Number.isFinite(r)) {
            let s = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ee("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ee("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, h.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ee("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, h.assertValueType)("string")
      },
      flags: {
        validate: (0, h.chain)((0, h.assertValueType)("string"), Object.assign(function(t, e, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let s = /[^gimsuy]/.exec(r);
          if (s)
            throw new TypeError(`"${s[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  });
  ee("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, h.assertOneOf)(...xa.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, h.assertNodeType)("Expression")
      },
      right: {
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, h.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let t = (0, h.assertNodeType)("Identifier", "PrivateName"), e = (0, h.assertNodeType)("Expression"), r = /* @__PURE__ */ n(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, h.assertOneOf)(!0, !1),
        optional: !0
      }
    })
  });
  ee("NewExpression", {
    inherits: "CallExpression"
  });
  ee("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, h.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, h.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  ee("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ObjectMethod", "ObjectProperty", "S\
preadElement")))
      }
    }
  });
  ee("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, fn(), Ni(), {
      kind: Object.assign({
        validate: (0, h.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, h.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, h.assertNodeType)("Expres\
sion"), r = /* @__PURE__ */ n(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
        }()
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      },
      body: {
        validate: (0, h.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  ee("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, h.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), e = (0, h.
          assertNodeType)("Expression");
          return Object.assign(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, h.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, h.chain)((0, h.assertValueType)("boolean"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && t.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, {
          type: "boolean"
        }), function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !(0, lr.default)("Identifier", t.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }),
        default: !1
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      let t = (0, h.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), e = (0, h.assertNodeType)("Expression");
      return function(r, s, i) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        ((0, lr.default)("ObjectPattern", r) ? t : e)(i, "value", i.value);
      };
    }()
  });
  ee("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, hn(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, h.assertNodeType)("LVal")
      }
    }),
    validate(t, e) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let r = /(\w+)\[(\d+)\]/.exec(e);
      if (!r) throw new Error("Internal Babel error: malformed key.");
      let [, s, i] = r;
      if (t[s].length > +i + 1)
        throw new TypeError(`RestElement must be last element of ${s}`);
    }
  });
  ee("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  ee("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  ee("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Statement")))
      }
    }
  });
  ee("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, h.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("SwitchCase")))
      }
    }
  });
  ee("ThisExpression", {
    aliases: ["Expression"]
  });
  ee("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, h.chain)((0, h.assertNodeType)("BlockStatement"), Object.assign(function(t) {
          if (process.env.BABEL_TYPES_8_BREAKING && !t.handler && !t.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: !0,
        validate: (0, h.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, h.assertNodeType)("BlockStatement")
      }
    }
  });
  ee("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, h.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, h.assertOneOf)(...xa.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  ee("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.assertNodeType)("Identifier", "MemberExpression") : (0, h.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, h.assertOneOf)(...xa.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  ee("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, h.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(t, e, r) {
      if (process.env.BABEL_TYPES_8_BREAKING && (0, lr.default)("ForXStatement", t, {
        left: r
      }) && r.declarations.length !== 1)
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${t.type}`);
    }
  });
  ee("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, h.assertNodeType)("LVal");
          let t = (0, h.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), e = (0, h.assertNodeType)("Identifier");
          return function(r, s, i) {
            (r.init ? t : e)(r, s, i);
          };
        }()
      },
      definite: {
        optional: !0,
        validate: (0, h.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, h.assertNodeType)("Expression")
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      }
    }
  });
  ee("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, h.assertNodeType)("Expression")
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      }
    }
  });
  ee("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, hn(), {
      left: {
        validate: (0, h.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, h.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      }
    })
  });
  ee("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, hn(), {
      elements: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  ee("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, fn(), Ni(), {
      expression: {
        validate: (0, h.assertValueType)("boolean")
      },
      body: {
        validate: (0, h.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, h.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  ee("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ClassMethod", "ClassPrivateMethod",
        "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  });
  ee("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, h.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, h.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, h.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, h.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, h.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, h.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  ee("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, h.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, h.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, h.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, h.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, h.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, h.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: function() {
      let t = (0, h.assertNodeType)("Identifier");
      return function(e, r, s) {
        process.env.BABEL_TYPES_8_BREAKING && ((0, lr.default)("ExportDefaultDeclaration", e) || t(s, "id", s.id));
      };
    }()
  });
  ee("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, h.assertNodeType)("StringLiteral")
      },
      exportKind: (0, h.validateOptional)((0, h.assertOneOf)("type", "value")),
      attributes: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportAttribute")))
      }
    }
  });
  ee("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, h.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, h.validateOptional)((0, h.assertOneOf)("value"))
    }
  });
  ee("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertNodeType)("Declaration"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && t.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && t.source)
            throw new TypeError("Cannot export a declaration from a source");
        })
      },
      attributes: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)(function() {
          let t = (0, h.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), e = (0, h.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(r, s, i) {
            (r.source ? t : e)(r, s, i);
          } : t;
        }()))
      },
      source: {
        validate: (0, h.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, h.validateOptional)((0, h.assertOneOf)("type", "value"))
    }
  });
  ee("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, h.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, h.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, h.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  ee("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, h.assertNodeType)("VariableDeclaration", "LVal");
          let t = (0, h.assertNodeType)("VariableDeclaration"), e = (0, h.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(r, s, i) {
            (0, lr.default)("VariableDeclaration", i) ? t(r, s, i) : e(r, s, i);
          };
        }()
      },
      right: {
        validate: (0, h.assertNodeType)("Expression")
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  ee("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportAttribute")))
      },
      module: {
        optional: !0,
        validate: (0, h.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, h.assertOneOf)("source", "defer")
      },
      specifiers: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportSpecifier", "ImportDefaultSpe\
cifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, h.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, h.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  ee("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, h.assertNodeType)("Identifier")
      }
    }
  });
  ee("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, h.assertNodeType)("Identifier")
      }
    }
  });
  ee("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, h.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, h.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, h.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  ee("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, h.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, h.assertNodeType)("Expression")
      },
      options: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  ee("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, h.chain)((0, h.assertNodeType)("Identifier"), Object.assign(function(t, e, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let s;
          switch (r.name) {
            case "function":
              s = "sent";
              break;
            case "new":
              s = "target";
              break;
            case "import":
              s = "meta";
              break;
          }
          if (!(0, lr.default)("Identifier", t.property, {
            name: s
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, h.assertNodeType)("Identifier")
      }
    }
  });
  var bl = /* @__PURE__ */ n(() => ({
    abstract: {
      validate: (0, h.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, h.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, h.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, h.chain)(function() {
        let t = (0, h.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, h.assertNodeType)("Expressi\
on");
        return function(r, s, i) {
          (r.computed ? e : t)(r, s, i);
        };
      }(), (0, h.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  wr.classMethodOrPropertyCommon = bl;
  var vp = /* @__PURE__ */ n(() => Object.assign({}, fn(), bl(), {
    params: {
      validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Identifier", "Pattern", "RestElement",
      "TSParameterProperty")))
    },
    kind: {
      validate: (0, h.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, h.chain)((0, h.assertValueType)("string"), (0, h.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  wr.classMethodOrDeclareMethodCommon = vp;
  ee("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, vp(), Ni(), {
      body: {
        validate: (0, h.assertNodeType)("BlockStatement")
      }
    })
  });
  ee("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, hn(), {
      properties: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  });
  ee("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("Super", {
    aliases: ["Expression"]
  });
  ee("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, h.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, h.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, h.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  ee("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, h.chain)((0, h.assertShape)({
          raw: {
            validate: (0, h.assertValueType)("string")
          },
          cooked: {
            validate: (0, h.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ n(function(e) {
          let r = e.value.raw, s = !1, i = /* @__PURE__ */ n(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, HM.readStringContents)("template", r, 0, 0, 0, {
            unterminated() {
              s = !0;
            },
            strictNumericEscape: i,
            invalidEscapeSequence: i,
            numericSeparatorInEscapeSequence: i,
            unexpectedNumericSeparator: i,
            invalidDigit: i,
            invalidCodePoint: i
          });
          if (!s) throw new Error("Invalid raw");
          e.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  ee("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Expression", "TSType")), function(t, e, r) {
          if (t.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${t.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${t.quasis.length}`);
        })
      }
    }
  });
  ee("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, h.chain)((0, h.assertValueType)("boolean"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !t.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("Import", {
    aliases: ["Expression"]
  });
  ee("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, h.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ee("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, h.assertNodeType)("Identifier")
      }
    }
  });
  ee("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, h.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let t = (0, h.assertNodeType)("Identifier"), e = (0, h.assertNodeType)("Expression");
          return Object.assign(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.chain)((0, h.assertValueType)("boolean"), (0, h.assertOptionalChainStart)()) : (0, h.
        assertValueType)("boolean")
      }
    }
  });
  ee("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, h.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Expression", "SpreadElement", "Argu\
mentPlaceholder")))
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.chain)((0, h.assertValueType)("boolean"), (0, h.assertOptionalChainStart)()) : (0, h.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, h.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, h.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  ee("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, bl(), {
      value: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, h.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, h.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  ee("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, bl(), {
      key: {
        validate: (0, h.chain)(function() {
          let t = (0, h.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), e = (0, h.assertNodeType)(
          "Expression");
          return function(r, s, i) {
            (r.computed ? e : t)(r, s, i);
          };
        }(), (0, h.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, h.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, h.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  ee("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, h.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, h.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      },
      static: {
        validate: (0, h.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, h.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  ee("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, vp(), Ni(), {
      kind: {
        validate: (0, h.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, h.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, h.assertNodeType)("BlockStatement")
      }
    })
  });
  ee("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, h.assertNodeType)("Identifier")
      }
    }
  });
  ee("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
});

// ../node_modules/@babel/types/lib/definitions/flow.js
var Ox = w(() => {
  "use strict";
  var V = ds(), be = (0, V.defineAliasedType)("Flow"), Ip = /* @__PURE__ */ n((t) => {
    let e = t === "DeclareClass";
    be(t, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...e ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, V.validateType)("Identifier"),
        typeParameters: (0, V.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, V.validateOptional)((0, V.arrayOfType)("InterfaceExtends"))
      }, e ? {
        mixins: (0, V.validateOptional)((0, V.arrayOfType)("InterfaceExtends")),
        implements: (0, V.validateOptional)((0, V.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, V.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  be("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, V.validateType)("FlowType")
    }
  });
  be("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      typeParameters: (0, V.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Ip("DeclareClass");
  be("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      predicate: (0, V.validateOptionalType)("DeclaredPredicate")
    }
  });
  Ip("DeclareInterface");
  be("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)(["Identifier", "StringLiteral"]),
      body: (0, V.validateType)("BlockStatement"),
      kind: (0, V.validateOptional)((0, V.assertOneOf)("CommonJS", "ES"))
    }
  });
  be("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, V.validateType)("TypeAnnotation")
    }
  });
  be("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      typeParameters: (0, V.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, V.validateType)("FlowType")
    }
  });
  be("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      typeParameters: (0, V.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, V.validateOptionalType)("FlowType"),
      impltype: (0, V.validateOptionalType)("FlowType")
    }
  });
  be("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)("Identifier")
    }
  });
  be("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, V.validateOptionalType)("Flow"),
      specifiers: (0, V.validateOptional)((0, V.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, V.validateOptionalType)("StringLiteral"),
      default: (0, V.validateOptional)((0, V.assertValueType)("boolean"))
    }
  });
  be("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, V.validateType)("StringLiteral"),
      exportKind: (0, V.validateOptional)((0, V.assertOneOf)("type", "value"))
    }
  });
  be("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, V.validateType)("Flow")
    }
  });
  be("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  be("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, V.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, V.validate)((0, V.arrayOfType)("FunctionTypeParam")),
      rest: (0, V.validateOptionalType)("FunctionTypeParam"),
      this: (0, V.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, V.validateType)("FlowType")
    }
  });
  be("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, V.validateOptionalType)("Identifier"),
      typeAnnotation: (0, V.validateType)("FlowType"),
      optional: (0, V.validateOptional)((0, V.assertValueType)("boolean"))
    }
  });
  be("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, V.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, V.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  be("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  be("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, V.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, V.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Ip("InterfaceDeclaration");
  be("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, V.validateOptional)((0, V.arrayOfType)("InterfaceExtends")),
      body: (0, V.validateType)("ObjectTypeAnnotation")
    }
  });
  be("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, V.validate)((0, V.arrayOfType)("FlowType"))
    }
  });
  be("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, V.validateType)("FlowType")
    }
  });
  be("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, V.validate)((0, V.assertValueType)("number"))
    }
  });
  be("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, V.validate)((0, V.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, V.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, V.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, V.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, V.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, V.validateOptional)((0, V.assertValueType)("boolean"))
    }
  });
  be("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      value: (0, V.validateType)("FlowType"),
      optional: (0, V.validate)((0, V.assertValueType)("boolean")),
      static: (0, V.validate)((0, V.assertValueType)("boolean")),
      method: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, V.validateType)("FlowType"),
      static: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, V.validateOptionalType)("Identifier"),
      key: (0, V.validateType)("FlowType"),
      value: (0, V.validateType)("FlowType"),
      static: (0, V.validate)((0, V.assertValueType)("boolean")),
      variance: (0, V.validateOptionalType)("Variance")
    }
  });
  be("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, V.validateType)(["Identifier", "StringLiteral"]),
      value: (0, V.validateType)("FlowType"),
      kind: (0, V.validate)((0, V.assertOneOf)("init", "get", "set")),
      static: (0, V.validate)((0, V.assertValueType)("boolean")),
      proto: (0, V.validate)((0, V.assertValueType)("boolean")),
      optional: (0, V.validate)((0, V.assertValueType)("boolean")),
      variance: (0, V.validateOptionalType)("Variance"),
      method: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, V.validateType)("FlowType")
    }
  });
  be("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      typeParameters: (0, V.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, V.validateOptionalType)("FlowType"),
      impltype: (0, V.validateType)("FlowType")
    }
  });
  be("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      qualification: (0, V.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  be("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, V.validate)((0, V.assertValueType)("string"))
    }
  });
  be("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, V.validate)((0, V.arrayOfType)("FlowType"))
    }
  });
  be("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, V.validateType)("FlowType")
    }
  });
  be("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      typeParameters: (0, V.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, V.validateType)("FlowType")
    }
  });
  be("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, V.validateType)("FlowType")
    }
  });
  be("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, V.validateType)("Expression"),
      typeAnnotation: (0, V.validateType)("TypeAnnotation")
    }
  });
  be("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, V.validate)((0, V.assertValueType)("string")),
      bound: (0, V.validateOptionalType)("TypeAnnotation"),
      default: (0, V.validateOptionalType)("FlowType"),
      variance: (0, V.validateOptionalType)("Variance")
    }
  });
  be("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, V.validate)((0, V.arrayOfType)("TypeParameter"))
    }
  });
  be("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, V.validate)((0, V.arrayOfType)("FlowType"))
    }
  });
  be("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, V.validate)((0, V.arrayOfType)("FlowType"))
    }
  });
  be("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, V.validate)((0, V.assertOneOf)("minus", "plus"))
    }
  });
  be("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      body: (0, V.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  be("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, V.validate)((0, V.assertValueType)("boolean")),
      members: (0, V.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, V.validate)((0, V.assertValueType)("boolean")),
      members: (0, V.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, V.validate)((0, V.assertValueType)("boolean")),
      members: (0, V.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, V.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      init: (0, V.validateType)("BooleanLiteral")
    }
  });
  be("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      init: (0, V.validateType)("NumericLiteral")
    }
  });
  be("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      init: (0, V.validateType)("StringLiteral")
    }
  });
  be("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, V.validateType)("Identifier")
    }
  });
  be("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, V.validateType)("FlowType"),
      indexType: (0, V.validateType)("FlowType")
    }
  });
  be("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, V.validateType)("FlowType"),
      indexType: (0, V.validateType)("FlowType"),
      optional: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/jsx.js
var kx = w(() => {
  "use strict";
  var lt = ds(), ur = (0, lt.defineAliasedType)("JSX");
  ur("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, lt.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, lt.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  ur("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, lt.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  ur("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, lt.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, lt.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, lt.chain)((0, lt.assertValueType)("array"), (0, lt.assertEach)((0, lt.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, lt.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  ur("JSXEmptyExpression", {});
  ur("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, lt.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  ur("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, lt.assertNodeType)("Expression")
      }
    }
  });
  ur("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, lt.assertValueType)("string")
      }
    }
  });
  ur("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, lt.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, lt.assertNodeType)("JSXIdentifier")
      }
    }
  });
  ur("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, lt.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, lt.assertNodeType)("JSXIdentifier")
      }
    }
  });
  ur("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, lt.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: {
        validate: (0, lt.chain)((0, lt.assertValueType)("array"), (0, lt.assertEach)((0, lt.assertNodeType)("JSXAttribute", "JSXSpreadAttrib\
ute")))
      },
      typeParameters: {
        validate: (0, lt.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  ur("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, lt.assertNodeType)("Expression")
      }
    }
  });
  ur("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, lt.assertValueType)("string")
      }
    }
  });
  ur("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, lt.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, lt.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, lt.chain)((0, lt.assertValueType)("array"), (0, lt.assertEach)((0, lt.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  ur("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  ur("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/types/lib/definitions/placeholders.js
var Op = w((Js) => {
  "use strict";
  Object.defineProperty(Js, "__esModule", {
    value: !0
  });
  Js.PLACEHOLDERS_FLIPPED_ALIAS = Js.PLACEHOLDERS_ALIAS = Js.PLACEHOLDERS = void 0;
  var zM = ds(), GM = Js.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBo\
dy", "Pattern"], Np = Js.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let t of GM) {
    let e = zM.ALIAS_KEYS[t];
    e != null && e.length && (Np[t] = e);
  }
  var wp = Js.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(Np).forEach((t) => {
    Np[t].forEach((e) => {
      hasOwnProperty.call(wp, e) || (wp[e] = []), wp[e].push(t);
    });
  });
});

// ../node_modules/@babel/types/lib/definitions/misc.js
var Dx = w(() => {
  "use strict";
  var xl = ds(), QM = Op(), kp = (0, xl.defineAliasedType)("Miscellaneous");
  kp("Noop", {
    visitor: []
  });
  kp("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, xl.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, xl.assertOneOf)(...QM.PLACEHOLDERS)
      }
    }
  });
  kp("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, xl.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/experimental.js
var _x = w(() => {
  "use strict";
  var st = ds();
  (0, st.default)("ArgumentPlaceholder", {});
  (0, st.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, st.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, st.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, st.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, st.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, st.assertNodeType)("StringLiteral")
      }
    }
  });
  (0, st.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, st.assertNodeType)("Expression")
      }
    }
  });
  (0, st.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, st.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, st.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, st.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, st.assertNodeType)("Identifier")
      }
    }
  });
  (0, st.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, st.chain)((0, st.assertValueType)("array"), (0, st.assertEach)((0, st.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  });
  (0, st.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, st.chain)((0, st.assertValueType)("array"), (0, st.assertEach)((0, st.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, st.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, st.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, st.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, st.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, st.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, st.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, st.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, st.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, st.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, st.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// ../node_modules/@babel/types/lib/definitions/typescript.js
var qx = w(() => {
  "use strict";
  var X = ds(), Lx = Cp(), ZM = cn(), _e = (0, X.defineAliasedType)("TypeScript"), Nr = (0, X.assertValueType)("boolean"), Mx = /* @__PURE__ */ n(
  () => ({
    returnType: {
      validate: (0, X.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, X.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  _e("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, X.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, X.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, X.chain)((0, X.assertValueType)("array"), (0, X.assertEach)((0, X.assertNodeType)("Decorator"))),
        optional: !0
      }
    }
  });
  _e("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, Lx.functionDeclarationCommon)(), Mx())
  });
  _e("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, Lx.classMethodOrDeclareMethodCommon)(), Mx())
  });
  _e("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, X.validateType)("TSEntityName"),
      right: (0, X.validateType)("Identifier")
    }
  });
  var Sl = /* @__PURE__ */ n(() => ({
    typeParameters: (0, X.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, X.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), Bx = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: Sl()
  };
  _e("TSCallSignatureDeclaration", Bx);
  _e("TSConstructSignatureDeclaration", Bx);
  var Fx = /* @__PURE__ */ n(() => ({
    key: (0, X.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, X.validateOptional)(Nr)
  }), "namedTypeElementCommon");
  _e("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, Fx(), {
      readonly: (0, X.validateOptional)(Nr),
      typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        validate: (0, X.assertOneOf)("get", "set")
      }
    })
  });
  _e("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, Sl(), Fx(), {
      kind: {
        validate: (0, X.assertOneOf)("method", "get", "set")
      }
    })
  });
  _e("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, X.validateOptional)(Nr),
      static: (0, X.validateOptional)(Nr),
      parameters: (0, X.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var e3 = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword",
  "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let t of e3)
    _e(t, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  _e("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var jx = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  _e("TSFunctionType", Object.assign({}, jx, {
    fields: Sl()
  }));
  _e("TSConstructorType", Object.assign({}, jx, {
    fields: Object.assign({}, Sl(), {
      abstract: (0, X.validateOptional)(Nr)
    })
  }));
  _e("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, X.validateType)("TSEntityName"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  _e("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, X.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, X.validateOptional)(Nr)
    }
  });
  _e("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, X.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  _e("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, X.validateArrayOfType)("TSTypeElement")
    }
  });
  _e("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, X.validateType)("TSType")
    }
  });
  _e("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, X.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  });
  _e("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  _e("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  _e("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, X.validateType)("Identifier"),
      optional: {
        validate: Nr,
        default: !1
      },
      elementType: (0, X.validateType)("TSType")
    }
  });
  var Rx = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, X.validateArrayOfType)("TSType")
    }
  };
  _e("TSUnionType", Rx);
  _e("TSIntersectionType", Rx);
  _e("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, X.validateType)("TSType"),
      extendsType: (0, X.validateType)("TSType"),
      trueType: (0, X.validateType)("TSType"),
      falseType: (0, X.validateType)("TSType")
    }
  });
  _e("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, X.validateType)("TSTypeParameter")
    }
  });
  _e("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  _e("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, X.validate)((0, X.assertValueType)("string")),
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  _e("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, X.validateType)("TSType"),
      indexType: (0, X.validateType)("TSType")
    }
  });
  _e("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, X.validateOptional)((0, X.assertOneOf)(!0, !1, "+", "-")),
      typeParameter: (0, X.validateType)("TSTypeParameter"),
      optional: (0, X.validateOptional)((0, X.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, X.validateOptionalType)("TSType"),
      nameType: (0, X.validateOptionalType)("TSType")
    }
  });
  _e("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let t = (0, X.assertNodeType)("NumericLiteral", "BigIntLiteral"), e = (0, X.assertOneOf)("-"), r = (0, X.assertNodeType)("NumericL\
iteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function s(i, a, o) {
            (0, ZM.default)("UnaryExpression", o) ? (e(o, "operator", o.operator), t(o, "argument", o.argument)) : r(i, a, o);
          }
          return n(s, "validator"), s.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiter\
al", "UnaryExpression"], s;
        }()
      }
    }
  });
  _e("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, X.validateType)("TSEntityName"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  _e("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, X.validateOptional)(Nr),
      id: (0, X.validateType)("Identifier"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, X.validateOptional)((0, X.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, X.validateType)("TSInterfaceBody")
    }
  });
  _e("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, X.validateArrayOfType)("TSTypeElement")
    }
  });
  _e("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, X.validateOptional)(Nr),
      id: (0, X.validateType)("Identifier"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  _e("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, X.validateType)("Expression"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var Ux = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, X.validateType)("Expression"),
      typeAnnotation: (0, X.validateType)("TSType")
    }
  };
  _e("TSAsExpression", Ux);
  _e("TSSatisfiesExpression", Ux);
  _e("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType"),
      expression: (0, X.validateType)("Expression")
    }
  });
  _e("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, X.validateOptional)(Nr),
      const: (0, X.validateOptional)(Nr),
      id: (0, X.validateType)("Identifier"),
      members: (0, X.validateArrayOfType)("TSEnumMember"),
      initializer: (0, X.validateOptionalType)("Expression")
    }
  });
  _e("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, X.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, X.validateOptionalType)("Expression")
    }
  });
  _e("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, X.validateOptional)(Nr),
      global: (0, X.validateOptional)(Nr),
      id: (0, X.validateType)(["Identifier", "StringLiteral"]),
      body: (0, X.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  _e("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, X.validateArrayOfType)("Statement")
    }
  });
  _e("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, X.validateType)("StringLiteral"),
      qualifier: (0, X.validateOptionalType)("TSEntityName"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, X.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  _e("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, X.validate)(Nr),
      id: (0, X.validateType)("Identifier"),
      moduleReference: (0, X.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, X.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  _e("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, X.validateType)("StringLiteral")
    }
  });
  _e("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, X.validateType)("Expression")
    }
  });
  _e("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, X.validateType)("Expression")
    }
  });
  _e("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, X.validateType)("Identifier")
    }
  });
  _e("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, X.assertNodeType)("TSType")
      }
    }
  });
  _e("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, X.chain)((0, X.assertValueType)("array"), (0, X.assertEach)((0, X.assertNodeType)("TSType")))
      }
    }
  });
  _e("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, X.chain)((0, X.assertValueType)("array"), (0, X.assertEach)((0, X.assertNodeType)("TSTypeParameter")))
      }
    }
  });
  _e("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, X.assertValueType)("string")
      },
      in: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, X.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, X.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var Vx = w((gl) => {
  "use strict";
  Object.defineProperty(gl, "__esModule", {
    value: !0
  });
  gl.DEPRECATED_ALIASES = void 0;
  var dMe = gl.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/types/lib/definitions/index.js
var Br = w((cr) => {
  "use strict";
  Object.defineProperty(cr, "__esModule", {
    value: !0
  });
  Object.defineProperty(cr, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ht.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(cr, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ht.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty(cr, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Dp.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty(cr, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ht.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty(cr, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ht.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(cr, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ht.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty(cr, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ht.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty(cr, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Sa.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty(cr, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Sa.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty(cr, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Sa.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  cr.TYPES = void 0;
  Object.defineProperty(cr, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ht.VISITOR_KEYS;
    }, "get")
  });
  var Xs = lp();
  Cp();
  Ox();
  kx();
  Dx();
  _x();
  qx();
  var Ht = ds(), Sa = Op(), Dp = Vx();
  Object.keys(Dp.DEPRECATED_ALIASES).forEach((t) => {
    Ht.FLIPPED_ALIAS_KEYS[t] = Ht.FLIPPED_ALIAS_KEYS[Dp.DEPRECATED_ALIASES[t]];
  });
  Xs(Ht.VISITOR_KEYS);
  Xs(Ht.ALIAS_KEYS);
  Xs(Ht.FLIPPED_ALIAS_KEYS);
  Xs(Ht.NODE_FIELDS);
  Xs(Ht.BUILDER_KEYS);
  Xs(Ht.DEPRECATED_KEYS);
  Xs(Sa.PLACEHOLDERS_ALIAS);
  Xs(Sa.PLACEHOLDERS_FLIPPED_ALIAS);
  var yMe = cr.TYPES = [].concat(Object.keys(Ht.VISITOR_KEYS), Object.keys(Ht.FLIPPED_ALIAS_KEYS), Object.keys(Ht.DEPRECATED_KEYS));
});

// ../node_modules/@babel/types/lib/validators/validate.js
var Tl = w((ga) => {
  "use strict";
  Object.defineProperty(ga, "__esModule", {
    value: !0
  });
  ga.default = t3;
  ga.validateChild = Yx;
  ga.validateField = Wx;
  var Kx = Br();
  function t3(t, e, r) {
    if (!t) return;
    let s = Kx.NODE_FIELDS[t.type];
    if (!s) return;
    let i = s[e];
    Wx(t, e, r, i), Yx(t, e, r);
  }
  n(t3, "validate");
  function Wx(t, e, r, s) {
    s != null && s.validate && (s.optional && r == null || s.validate(t, e, r));
  }
  n(Wx, "validateField");
  function Yx(t, e, r) {
    if (r == null) return;
    let s = Kx.NODE_PARENT_VALIDATIONS[r.type];
    s && s(t, e, r);
  }
  n(Yx, "validateChild");
});

// ../node_modules/@babel/types/lib/builders/validateNode.js
var Jx = w((_p) => {
  "use strict";
  Object.defineProperty(_p, "__esModule", {
    value: !0
  });
  _p.default = i3;
  var r3 = Tl(), s3 = Ce();
  function i3(t) {
    let e = s3.BUILDER_KEYS[t.type];
    for (let r of e)
      (0, r3.default)(t, r, t[r]);
    return t;
  }
  n(i3, "validateNode");
});

// ../node_modules/@babel/types/lib/builders/generated/index.js
var pr = w((b) => {
  "use strict";
  Object.defineProperty(b, "__esModule", {
    value: !0
  });
  b.anyTypeAnnotation = MB;
  b.argumentPlaceholder = c4;
  b.arrayExpression = n3;
  b.arrayPattern = eB;
  b.arrayTypeAnnotation = BB;
  b.arrowFunctionExpression = tB;
  b.assignmentExpression = a3;
  b.assignmentPattern = Z3;
  b.awaitExpression = EB;
  b.bigIntLiteral = vB;
  b.binaryExpression = o3;
  b.bindExpression = p4;
  b.blockStatement = p3;
  b.booleanLiteral = k3;
  b.booleanLiteralTypeAnnotation = jB;
  b.booleanTypeAnnotation = FB;
  b.breakStatement = f3;
  b.callExpression = h3;
  b.catchClause = d3;
  b.classAccessorProperty = OB;
  b.classBody = rB;
  b.classDeclaration = iB;
  b.classExpression = sB;
  b.classImplements = UB;
  b.classMethod = yB;
  b.classPrivateMethod = DB;
  b.classPrivateProperty = kB;
  b.classProperty = NB;
  b.conditionalExpression = m3;
  b.continueStatement = y3;
  b.debuggerStatement = T3;
  b.decimalLiteral = b4;
  b.declareClass = qB;
  b.declareExportAllDeclaration = zB;
  b.declareExportDeclaration = HB;
  b.declareFunction = VB;
  b.declareInterface = KB;
  b.declareModule = WB;
  b.declareModuleExports = YB;
  b.declareOpaqueType = XB;
  b.declareTypeAlias = JB;
  b.declareVariable = $B;
  b.declaredPredicate = GB;
  b.decorator = h4;
  b.directive = u3;
  b.directiveLiteral = c3;
  b.doExpression = d4;
  b.doWhileStatement = b3;
  b.emptyStatement = x3;
  b.emptyTypeAnnotation = lF;
  b.enumBooleanBody = BF;
  b.enumBooleanMember = UF;
  b.enumDeclaration = MF;
  b.enumDefaultedMember = KF;
  b.enumNumberBody = FF;
  b.enumNumberMember = qF;
  b.enumStringBody = jF;
  b.enumStringMember = VF;
  b.enumSymbolBody = RF;
  b.existsTypeAnnotation = QB;
  b.exportAllDeclaration = nB;
  b.exportDefaultDeclaration = aB;
  b.exportDefaultSpecifier = m4;
  b.exportNamedDeclaration = oB;
  b.exportNamespaceSpecifier = CB;
  b.exportSpecifier = lB;
  b.expressionStatement = S3;
  b.file = g3;
  b.forInStatement = P3;
  b.forOfStatement = uB;
  b.forStatement = E3;
  b.functionDeclaration = A3;
  b.functionExpression = v3;
  b.functionTypeAnnotation = ZB;
  b.functionTypeParam = eF;
  b.genericTypeAnnotation = tF;
  b.identifier = C3;
  b.ifStatement = I3;
  b.import = AB;
  b.importAttribute = f4;
  b.importDeclaration = cB;
  b.importDefaultSpecifier = pB;
  b.importExpression = dB;
  b.importNamespaceSpecifier = fB;
  b.importSpecifier = hB;
  b.indexedAccessType = WF;
  b.inferredPredicate = rF;
  b.interfaceDeclaration = iF;
  b.interfaceExtends = sF;
  b.interfaceTypeAnnotation = nF;
  b.interpreterDirective = l3;
  b.intersectionTypeAnnotation = aF;
  b.jSXAttribute = b.jsxAttribute = JF;
  b.jSXClosingElement = b.jsxClosingElement = XF;
  b.jSXClosingFragment = b.jsxClosingFragment = a4;
  b.jSXElement = b.jsxElement = $F;
  b.jSXEmptyExpression = b.jsxEmptyExpression = HF;
  b.jSXExpressionContainer = b.jsxExpressionContainer = zF;
  b.jSXFragment = b.jsxFragment = i4;
  b.jSXIdentifier = b.jsxIdentifier = QF;
  b.jSXMemberExpression = b.jsxMemberExpression = ZF;
  b.jSXNamespacedName = b.jsxNamespacedName = e4;
  b.jSXOpeningElement = b.jsxOpeningElement = t4;
  b.jSXOpeningFragment = b.jsxOpeningFragment = n4;
  b.jSXSpreadAttribute = b.jsxSpreadAttribute = r4;
  b.jSXSpreadChild = b.jsxSpreadChild = GF;
  b.jSXText = b.jsxText = s4;
  b.labeledStatement = w3;
  b.logicalExpression = D3;
  b.memberExpression = _3;
  b.metaProperty = mB;
  b.mixedTypeAnnotation = oF;
  b.moduleExpression = x4;
  b.newExpression = L3;
  b.noop = o4;
  b.nullLiteral = O3;
  b.nullLiteralTypeAnnotation = RB;
  b.nullableTypeAnnotation = uF;
  b.numberLiteral = M5;
  b.numberLiteralTypeAnnotation = cF;
  b.numberTypeAnnotation = pF;
  b.numericLiteral = Xx;
  b.objectExpression = B3;
  b.objectMethod = F3;
  b.objectPattern = TB;
  b.objectProperty = j3;
  b.objectTypeAnnotation = fF;
  b.objectTypeCallProperty = dF;
  b.objectTypeIndexer = mF;
  b.objectTypeInternalSlot = hF;
  b.objectTypeProperty = yF;
  b.objectTypeSpreadProperty = TF;
  b.opaqueType = bF;
  b.optionalCallExpression = wB;
  b.optionalIndexedAccessType = YF;
  b.optionalMemberExpression = IB;
  b.parenthesizedExpression = q3;
  b.pipelineBareFunction = P4;
  b.pipelinePrimaryTopicReference = E4;
  b.pipelineTopicExpression = g4;
  b.placeholder = l4;
  b.privateName = _B;
  b.program = M3;
  b.qualifiedTypeIdentifier = xF;
  b.recordExpression = y4;
  b.regExpLiteral = $x;
  b.regexLiteral = B5;
  b.restElement = Hx;
  b.restProperty = F5;
  b.returnStatement = R3;
  b.sequenceExpression = U3;
  b.spreadElement = zx;
  b.spreadProperty = j5;
  b.staticBlock = LB;
  b.stringLiteral = N3;
  b.stringLiteralTypeAnnotation = SF;
  b.stringTypeAnnotation = gF;
  b.super = bB;
  b.switchCase = V3;
  b.switchStatement = K3;
  b.symbolTypeAnnotation = PF;
  b.taggedTemplateExpression = xB;
  b.templateElement = SB;
  b.templateLiteral = gB;
  b.thisExpression = W3;
  b.thisTypeAnnotation = EF;
  b.throwStatement = Y3;
  b.topicReference = S4;
  b.tryStatement = J3;
  b.tSAnyKeyword = b.tsAnyKeyword = _4;
  b.tSArrayType = b.tsArrayType = Z4;
  b.tSAsExpression = b.tsAsExpression = b5;
  b.tSBigIntKeyword = b.tsBigIntKeyword = M4;
  b.tSBooleanKeyword = b.tsBooleanKeyword = L4;
  b.tSCallSignatureDeclaration = b.tsCallSignatureDeclaration = w4;
  b.tSConditionalType = b.tsConditionalType = a5;
  b.tSConstructSignatureDeclaration = b.tsConstructSignatureDeclaration = N4;
  b.tSConstructorType = b.tsConstructorType = $4;
  b.tSDeclareFunction = b.tsDeclareFunction = v4;
  b.tSDeclareMethod = b.tsDeclareMethod = C4;
  b.tSEnumDeclaration = b.tsEnumDeclaration = g5;
  b.tSEnumMember = b.tsEnumMember = P5;
  b.tSExportAssignment = b.tsExportAssignment = N5;
  b.tSExpressionWithTypeArguments = b.tsExpressionWithTypeArguments = h5;
  b.tSExternalModuleReference = b.tsExternalModuleReference = I5;
  b.tSFunctionType = b.tsFunctionType = X4;
  b.tSImportEqualsDeclaration = b.tsImportEqualsDeclaration = C5;
  b.tSImportType = b.tsImportType = v5;
  b.tSIndexSignature = b.tsIndexSignature = D4;
  b.tSIndexedAccessType = b.tsIndexedAccessType = c5;
  b.tSInferType = b.tsInferType = o5;
  b.tSInstantiationExpression = b.tsInstantiationExpression = T5;
  b.tSInterfaceBody = b.tsInterfaceBody = m5;
  b.tSInterfaceDeclaration = b.tsInterfaceDeclaration = d5;
  b.tSIntersectionType = b.tsIntersectionType = n5;
  b.tSIntrinsicKeyword = b.tsIntrinsicKeyword = B4;
  b.tSLiteralType = b.tsLiteralType = f5;
  b.tSMappedType = b.tsMappedType = p5;
  b.tSMethodSignature = b.tsMethodSignature = k4;
  b.tSModuleBlock = b.tsModuleBlock = A5;
  b.tSModuleDeclaration = b.tsModuleDeclaration = E5;
  b.tSNamedTupleMember = b.tsNamedTupleMember = s5;
  b.tSNamespaceExportDeclaration = b.tsNamespaceExportDeclaration = O5;
  b.tSNeverKeyword = b.tsNeverKeyword = F4;
  b.tSNonNullExpression = b.tsNonNullExpression = w5;
  b.tSNullKeyword = b.tsNullKeyword = j4;
  b.tSNumberKeyword = b.tsNumberKeyword = R4;
  b.tSObjectKeyword = b.tsObjectKeyword = U4;
  b.tSOptionalType = b.tsOptionalType = t5;
  b.tSParameterProperty = b.tsParameterProperty = A4;
  b.tSParenthesizedType = b.tsParenthesizedType = l5;
  b.tSPropertySignature = b.tsPropertySignature = O4;
  b.tSQualifiedName = b.tsQualifiedName = I4;
  b.tSRestType = b.tsRestType = r5;
  b.tSSatisfiesExpression = b.tsSatisfiesExpression = x5;
  b.tSStringKeyword = b.tsStringKeyword = q4;
  b.tSSymbolKeyword = b.tsSymbolKeyword = V4;
  b.tSThisType = b.tsThisType = J4;
  b.tSTupleType = b.tsTupleType = e5;
  b.tSTypeAliasDeclaration = b.tsTypeAliasDeclaration = y5;
  b.tSTypeAnnotation = b.tsTypeAnnotation = k5;
  b.tSTypeAssertion = b.tsTypeAssertion = S5;
  b.tSTypeLiteral = b.tsTypeLiteral = Q4;
  b.tSTypeOperator = b.tsTypeOperator = u5;
  b.tSTypeParameter = b.tsTypeParameter = L5;
  b.tSTypeParameterDeclaration = b.tsTypeParameterDeclaration = _5;
  b.tSTypeParameterInstantiation = b.tsTypeParameterInstantiation = D5;
  b.tSTypePredicate = b.tsTypePredicate = z4;
  b.tSTypeQuery = b.tsTypeQuery = G4;
  b.tSTypeReference = b.tsTypeReference = H4;
  b.tSUndefinedKeyword = b.tsUndefinedKeyword = K4;
  b.tSUnionType = b.tsUnionType = i5;
  b.tSUnknownKeyword = b.tsUnknownKeyword = W4;
  b.tSVoidKeyword = b.tsVoidKeyword = Y4;
  b.tupleExpression = T4;
  b.tupleTypeAnnotation = AF;
  b.typeAlias = CF;
  b.typeAnnotation = IF;
  b.typeCastExpression = wF;
  b.typeParameter = NF;
  b.typeParameterDeclaration = OF;
  b.typeParameterInstantiation = kF;
  b.typeofTypeAnnotation = vF;
  b.unaryExpression = X3;
  b.unionTypeAnnotation = DF;
  b.updateExpression = $3;
  b.v8IntrinsicIdentifier = u4;
  b.variableDeclaration = H3;
  b.variableDeclarator = z3;
  b.variance = _F;
  b.voidTypeAnnotation = LF;
  b.whileStatement = G3;
  b.withStatement = Q3;
  b.yieldExpression = PB;
  var j = Jx(), Pl = ca();
  function n3(t = []) {
    return (0, j.default)({
      type: "ArrayExpression",
      elements: t
    });
  }
  n(n3, "arrayExpression");
  function a3(t, e, r) {
    return (0, j.default)({
      type: "AssignmentExpression",
      operator: t,
      left: e,
      right: r
    });
  }
  n(a3, "assignmentExpression");
  function o3(t, e, r) {
    return (0, j.default)({
      type: "BinaryExpression",
      operator: t,
      left: e,
      right: r
    });
  }
  n(o3, "binaryExpression");
  function l3(t) {
    return (0, j.default)({
      type: "InterpreterDirective",
      value: t
    });
  }
  n(l3, "interpreterDirective");
  function u3(t) {
    return (0, j.default)({
      type: "Directive",
      value: t
    });
  }
  n(u3, "directive");
  function c3(t) {
    return (0, j.default)({
      type: "DirectiveLiteral",
      value: t
    });
  }
  n(c3, "directiveLiteral");
  function p3(t, e = []) {
    return (0, j.default)({
      type: "BlockStatement",
      body: t,
      directives: e
    });
  }
  n(p3, "blockStatement");
  function f3(t = null) {
    return (0, j.default)({
      type: "BreakStatement",
      label: t
    });
  }
  n(f3, "breakStatement");
  function h3(t, e) {
    return (0, j.default)({
      type: "CallExpression",
      callee: t,
      arguments: e
    });
  }
  n(h3, "callExpression");
  function d3(t = null, e) {
    return (0, j.default)({
      type: "CatchClause",
      param: t,
      body: e
    });
  }
  n(d3, "catchClause");
  function m3(t, e, r) {
    return (0, j.default)({
      type: "ConditionalExpression",
      test: t,
      consequent: e,
      alternate: r
    });
  }
  n(m3, "conditionalExpression");
  function y3(t = null) {
    return (0, j.default)({
      type: "ContinueStatement",
      label: t
    });
  }
  n(y3, "continueStatement");
  function T3() {
    return {
      type: "DebuggerStatement"
    };
  }
  n(T3, "debuggerStatement");
  function b3(t, e) {
    return (0, j.default)({
      type: "DoWhileStatement",
      test: t,
      body: e
    });
  }
  n(b3, "doWhileStatement");
  function x3() {
    return {
      type: "EmptyStatement"
    };
  }
  n(x3, "emptyStatement");
  function S3(t) {
    return (0, j.default)({
      type: "ExpressionStatement",
      expression: t
    });
  }
  n(S3, "expressionStatement");
  function g3(t, e = null, r = null) {
    return (0, j.default)({
      type: "File",
      program: t,
      comments: e,
      tokens: r
    });
  }
  n(g3, "file");
  function P3(t, e, r) {
    return (0, j.default)({
      type: "ForInStatement",
      left: t,
      right: e,
      body: r
    });
  }
  n(P3, "forInStatement");
  function E3(t = null, e = null, r = null, s) {
    return (0, j.default)({
      type: "ForStatement",
      init: t,
      test: e,
      update: r,
      body: s
    });
  }
  n(E3, "forStatement");
  function A3(t = null, e, r, s = !1, i = !1) {
    return (0, j.default)({
      type: "FunctionDeclaration",
      id: t,
      params: e,
      body: r,
      generator: s,
      async: i
    });
  }
  n(A3, "functionDeclaration");
  function v3(t = null, e, r, s = !1, i = !1) {
    return (0, j.default)({
      type: "FunctionExpression",
      id: t,
      params: e,
      body: r,
      generator: s,
      async: i
    });
  }
  n(v3, "functionExpression");
  function C3(t) {
    return (0, j.default)({
      type: "Identifier",
      name: t
    });
  }
  n(C3, "identifier");
  function I3(t, e, r = null) {
    return (0, j.default)({
      type: "IfStatement",
      test: t,
      consequent: e,
      alternate: r
    });
  }
  n(I3, "ifStatement");
  function w3(t, e) {
    return (0, j.default)({
      type: "LabeledStatement",
      label: t,
      body: e
    });
  }
  n(w3, "labeledStatement");
  function N3(t) {
    return (0, j.default)({
      type: "StringLiteral",
      value: t
    });
  }
  n(N3, "stringLiteral");
  function Xx(t) {
    return (0, j.default)({
      type: "NumericLiteral",
      value: t
    });
  }
  n(Xx, "numericLiteral");
  function O3() {
    return {
      type: "NullLiteral"
    };
  }
  n(O3, "nullLiteral");
  function k3(t) {
    return (0, j.default)({
      type: "BooleanLiteral",
      value: t
    });
  }
  n(k3, "booleanLiteral");
  function $x(t, e = "") {
    return (0, j.default)({
      type: "RegExpLiteral",
      pattern: t,
      flags: e
    });
  }
  n($x, "regExpLiteral");
  function D3(t, e, r) {
    return (0, j.default)({
      type: "LogicalExpression",
      operator: t,
      left: e,
      right: r
    });
  }
  n(D3, "logicalExpression");
  function _3(t, e, r = !1, s = null) {
    return (0, j.default)({
      type: "MemberExpression",
      object: t,
      property: e,
      computed: r,
      optional: s
    });
  }
  n(_3, "memberExpression");
  function L3(t, e) {
    return (0, j.default)({
      type: "NewExpression",
      callee: t,
      arguments: e
    });
  }
  n(L3, "newExpression");
  function M3(t, e = [], r = "script", s = null) {
    return (0, j.default)({
      type: "Program",
      body: t,
      directives: e,
      sourceType: r,
      interpreter: s
    });
  }
  n(M3, "program");
  function B3(t) {
    return (0, j.default)({
      type: "ObjectExpression",
      properties: t
    });
  }
  n(B3, "objectExpression");
  function F3(t = "method", e, r, s, i = !1, a = !1, o = !1) {
    return (0, j.default)({
      type: "ObjectMethod",
      kind: t,
      key: e,
      params: r,
      body: s,
      computed: i,
      generator: a,
      async: o
    });
  }
  n(F3, "objectMethod");
  function j3(t, e, r = !1, s = !1, i = null) {
    return (0, j.default)({
      type: "ObjectProperty",
      key: t,
      value: e,
      computed: r,
      shorthand: s,
      decorators: i
    });
  }
  n(j3, "objectProperty");
  function Hx(t) {
    return (0, j.default)({
      type: "RestElement",
      argument: t
    });
  }
  n(Hx, "restElement");
  function R3(t = null) {
    return (0, j.default)({
      type: "ReturnStatement",
      argument: t
    });
  }
  n(R3, "returnStatement");
  function U3(t) {
    return (0, j.default)({
      type: "SequenceExpression",
      expressions: t
    });
  }
  n(U3, "sequenceExpression");
  function q3(t) {
    return (0, j.default)({
      type: "ParenthesizedExpression",
      expression: t
    });
  }
  n(q3, "parenthesizedExpression");
  function V3(t = null, e) {
    return (0, j.default)({
      type: "SwitchCase",
      test: t,
      consequent: e
    });
  }
  n(V3, "switchCase");
  function K3(t, e) {
    return (0, j.default)({
      type: "SwitchStatement",
      discriminant: t,
      cases: e
    });
  }
  n(K3, "switchStatement");
  function W3() {
    return {
      type: "ThisExpression"
    };
  }
  n(W3, "thisExpression");
  function Y3(t) {
    return (0, j.default)({
      type: "ThrowStatement",
      argument: t
    });
  }
  n(Y3, "throwStatement");
  function J3(t, e = null, r = null) {
    return (0, j.default)({
      type: "TryStatement",
      block: t,
      handler: e,
      finalizer: r
    });
  }
  n(J3, "tryStatement");
  function X3(t, e, r = !0) {
    return (0, j.default)({
      type: "UnaryExpression",
      operator: t,
      argument: e,
      prefix: r
    });
  }
  n(X3, "unaryExpression");
  function $3(t, e, r = !1) {
    return (0, j.default)({
      type: "UpdateExpression",
      operator: t,
      argument: e,
      prefix: r
    });
  }
  n($3, "updateExpression");
  function H3(t, e) {
    return (0, j.default)({
      type: "VariableDeclaration",
      kind: t,
      declarations: e
    });
  }
  n(H3, "variableDeclaration");
  function z3(t, e = null) {
    return (0, j.default)({
      type: "VariableDeclarator",
      id: t,
      init: e
    });
  }
  n(z3, "variableDeclarator");
  function G3(t, e) {
    return (0, j.default)({
      type: "WhileStatement",
      test: t,
      body: e
    });
  }
  n(G3, "whileStatement");
  function Q3(t, e) {
    return (0, j.default)({
      type: "WithStatement",
      object: t,
      body: e
    });
  }
  n(Q3, "withStatement");
  function Z3(t, e) {
    return (0, j.default)({
      type: "AssignmentPattern",
      left: t,
      right: e
    });
  }
  n(Z3, "assignmentPattern");
  function eB(t) {
    return (0, j.default)({
      type: "ArrayPattern",
      elements: t
    });
  }
  n(eB, "arrayPattern");
  function tB(t, e, r = !1) {
    return (0, j.default)({
      type: "ArrowFunctionExpression",
      params: t,
      body: e,
      async: r,
      expression: null
    });
  }
  n(tB, "arrowFunctionExpression");
  function rB(t) {
    return (0, j.default)({
      type: "ClassBody",
      body: t
    });
  }
  n(rB, "classBody");
  function sB(t = null, e = null, r, s = null) {
    return (0, j.default)({
      type: "ClassExpression",
      id: t,
      superClass: e,
      body: r,
      decorators: s
    });
  }
  n(sB, "classExpression");
  function iB(t = null, e = null, r, s = null) {
    return (0, j.default)({
      type: "ClassDeclaration",
      id: t,
      superClass: e,
      body: r,
      decorators: s
    });
  }
  n(iB, "classDeclaration");
  function nB(t) {
    return (0, j.default)({
      type: "ExportAllDeclaration",
      source: t
    });
  }
  n(nB, "exportAllDeclaration");
  function aB(t) {
    return (0, j.default)({
      type: "ExportDefaultDeclaration",
      declaration: t
    });
  }
  n(aB, "exportDefaultDeclaration");
  function oB(t = null, e = [], r = null) {
    return (0, j.default)({
      type: "ExportNamedDeclaration",
      declaration: t,
      specifiers: e,
      source: r
    });
  }
  n(oB, "exportNamedDeclaration");
  function lB(t, e) {
    return (0, j.default)({
      type: "ExportSpecifier",
      local: t,
      exported: e
    });
  }
  n(lB, "exportSpecifier");
  function uB(t, e, r, s = !1) {
    return (0, j.default)({
      type: "ForOfStatement",
      left: t,
      right: e,
      body: r,
      await: s
    });
  }
  n(uB, "forOfStatement");
  function cB(t, e) {
    return (0, j.default)({
      type: "ImportDeclaration",
      specifiers: t,
      source: e
    });
  }
  n(cB, "importDeclaration");
  function pB(t) {
    return (0, j.default)({
      type: "ImportDefaultSpecifier",
      local: t
    });
  }
  n(pB, "importDefaultSpecifier");
  function fB(t) {
    return (0, j.default)({
      type: "ImportNamespaceSpecifier",
      local: t
    });
  }
  n(fB, "importNamespaceSpecifier");
  function hB(t, e) {
    return (0, j.default)({
      type: "ImportSpecifier",
      local: t,
      imported: e
    });
  }
  n(hB, "importSpecifier");
  function dB(t, e = null) {
    return (0, j.default)({
      type: "ImportExpression",
      source: t,
      options: e
    });
  }
  n(dB, "importExpression");
  function mB(t, e) {
    return (0, j.default)({
      type: "MetaProperty",
      meta: t,
      property: e
    });
  }
  n(mB, "metaProperty");
  function yB(t = "method", e, r, s, i = !1, a = !1, o = !1, l = !1) {
    return (0, j.default)({
      type: "ClassMethod",
      kind: t,
      key: e,
      params: r,
      body: s,
      computed: i,
      static: a,
      generator: o,
      async: l
    });
  }
  n(yB, "classMethod");
  function TB(t) {
    return (0, j.default)({
      type: "ObjectPattern",
      properties: t
    });
  }
  n(TB, "objectPattern");
  function zx(t) {
    return (0, j.default)({
      type: "SpreadElement",
      argument: t
    });
  }
  n(zx, "spreadElement");
  function bB() {
    return {
      type: "Super"
    };
  }
  n(bB, "_super");
  function xB(t, e) {
    return (0, j.default)({
      type: "TaggedTemplateExpression",
      tag: t,
      quasi: e
    });
  }
  n(xB, "taggedTemplateExpression");
  function SB(t, e = !1) {
    return (0, j.default)({
      type: "TemplateElement",
      value: t,
      tail: e
    });
  }
  n(SB, "templateElement");
  function gB(t, e) {
    return (0, j.default)({
      type: "TemplateLiteral",
      quasis: t,
      expressions: e
    });
  }
  n(gB, "templateLiteral");
  function PB(t = null, e = !1) {
    return (0, j.default)({
      type: "YieldExpression",
      argument: t,
      delegate: e
    });
  }
  n(PB, "yieldExpression");
  function EB(t) {
    return (0, j.default)({
      type: "AwaitExpression",
      argument: t
    });
  }
  n(EB, "awaitExpression");
  function AB() {
    return {
      type: "Import"
    };
  }
  n(AB, "_import");
  function vB(t) {
    return (0, j.default)({
      type: "BigIntLiteral",
      value: t
    });
  }
  n(vB, "bigIntLiteral");
  function CB(t) {
    return (0, j.default)({
      type: "ExportNamespaceSpecifier",
      exported: t
    });
  }
  n(CB, "exportNamespaceSpecifier");
  function IB(t, e, r = !1, s) {
    return (0, j.default)({
      type: "OptionalMemberExpression",
      object: t,
      property: e,
      computed: r,
      optional: s
    });
  }
  n(IB, "optionalMemberExpression");
  function wB(t, e, r) {
    return (0, j.default)({
      type: "OptionalCallExpression",
      callee: t,
      arguments: e,
      optional: r
    });
  }
  n(wB, "optionalCallExpression");
  function NB(t, e = null, r = null, s = null, i = !1, a = !1) {
    return (0, j.default)({
      type: "ClassProperty",
      key: t,
      value: e,
      typeAnnotation: r,
      decorators: s,
      computed: i,
      static: a
    });
  }
  n(NB, "classProperty");
  function OB(t, e = null, r = null, s = null, i = !1, a = !1) {
    return (0, j.default)({
      type: "ClassAccessorProperty",
      key: t,
      value: e,
      typeAnnotation: r,
      decorators: s,
      computed: i,
      static: a
    });
  }
  n(OB, "classAccessorProperty");
  function kB(t, e = null, r = null, s = !1) {
    return (0, j.default)({
      type: "ClassPrivateProperty",
      key: t,
      value: e,
      decorators: r,
      static: s
    });
  }
  n(kB, "classPrivateProperty");
  function DB(t = "method", e, r, s, i = !1) {
    return (0, j.default)({
      type: "ClassPrivateMethod",
      kind: t,
      key: e,
      params: r,
      body: s,
      static: i
    });
  }
  n(DB, "classPrivateMethod");
  function _B(t) {
    return (0, j.default)({
      type: "PrivateName",
      id: t
    });
  }
  n(_B, "privateName");
  function LB(t) {
    return (0, j.default)({
      type: "StaticBlock",
      body: t
    });
  }
  n(LB, "staticBlock");
  function MB() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  n(MB, "anyTypeAnnotation");
  function BB(t) {
    return (0, j.default)({
      type: "ArrayTypeAnnotation",
      elementType: t
    });
  }
  n(BB, "arrayTypeAnnotation");
  function FB() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  n(FB, "booleanTypeAnnotation");
  function jB(t) {
    return (0, j.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: t
    });
  }
  n(jB, "booleanLiteralTypeAnnotation");
  function RB() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  n(RB, "nullLiteralTypeAnnotation");
  function UB(t, e = null) {
    return (0, j.default)({
      type: "ClassImplements",
      id: t,
      typeParameters: e
    });
  }
  n(UB, "classImplements");
  function qB(t, e = null, r = null, s) {
    return (0, j.default)({
      type: "DeclareClass",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(qB, "declareClass");
  function VB(t) {
    return (0, j.default)({
      type: "DeclareFunction",
      id: t
    });
  }
  n(VB, "declareFunction");
  function KB(t, e = null, r = null, s) {
    return (0, j.default)({
      type: "DeclareInterface",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(KB, "declareInterface");
  function WB(t, e, r = null) {
    return (0, j.default)({
      type: "DeclareModule",
      id: t,
      body: e,
      kind: r
    });
  }
  n(WB, "declareModule");
  function YB(t) {
    return (0, j.default)({
      type: "DeclareModuleExports",
      typeAnnotation: t
    });
  }
  n(YB, "declareModuleExports");
  function JB(t, e = null, r) {
    return (0, j.default)({
      type: "DeclareTypeAlias",
      id: t,
      typeParameters: e,
      right: r
    });
  }
  n(JB, "declareTypeAlias");
  function XB(t, e = null, r = null) {
    return (0, j.default)({
      type: "DeclareOpaqueType",
      id: t,
      typeParameters: e,
      supertype: r
    });
  }
  n(XB, "declareOpaqueType");
  function $B(t) {
    return (0, j.default)({
      type: "DeclareVariable",
      id: t
    });
  }
  n($B, "declareVariable");
  function HB(t = null, e = null, r = null) {
    return (0, j.default)({
      type: "DeclareExportDeclaration",
      declaration: t,
      specifiers: e,
      source: r
    });
  }
  n(HB, "declareExportDeclaration");
  function zB(t) {
    return (0, j.default)({
      type: "DeclareExportAllDeclaration",
      source: t
    });
  }
  n(zB, "declareExportAllDeclaration");
  function GB(t) {
    return (0, j.default)({
      type: "DeclaredPredicate",
      value: t
    });
  }
  n(GB, "declaredPredicate");
  function QB() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  n(QB, "existsTypeAnnotation");
  function ZB(t = null, e, r = null, s) {
    return (0, j.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: t,
      params: e,
      rest: r,
      returnType: s
    });
  }
  n(ZB, "functionTypeAnnotation");
  function eF(t = null, e) {
    return (0, j.default)({
      type: "FunctionTypeParam",
      name: t,
      typeAnnotation: e
    });
  }
  n(eF, "functionTypeParam");
  function tF(t, e = null) {
    return (0, j.default)({
      type: "GenericTypeAnnotation",
      id: t,
      typeParameters: e
    });
  }
  n(tF, "genericTypeAnnotation");
  function rF() {
    return {
      type: "InferredPredicate"
    };
  }
  n(rF, "inferredPredicate");
  function sF(t, e = null) {
    return (0, j.default)({
      type: "InterfaceExtends",
      id: t,
      typeParameters: e
    });
  }
  n(sF, "interfaceExtends");
  function iF(t, e = null, r = null, s) {
    return (0, j.default)({
      type: "InterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(iF, "interfaceDeclaration");
  function nF(t = null, e) {
    return (0, j.default)({
      type: "InterfaceTypeAnnotation",
      extends: t,
      body: e
    });
  }
  n(nF, "interfaceTypeAnnotation");
  function aF(t) {
    return (0, j.default)({
      type: "IntersectionTypeAnnotation",
      types: t
    });
  }
  n(aF, "intersectionTypeAnnotation");
  function oF() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  n(oF, "mixedTypeAnnotation");
  function lF() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  n(lF, "emptyTypeAnnotation");
  function uF(t) {
    return (0, j.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: t
    });
  }
  n(uF, "nullableTypeAnnotation");
  function cF(t) {
    return (0, j.default)({
      type: "NumberLiteralTypeAnnotation",
      value: t
    });
  }
  n(cF, "numberLiteralTypeAnnotation");
  function pF() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  n(pF, "numberTypeAnnotation");
  function fF(t, e = [], r = [], s = [], i = !1) {
    return (0, j.default)({
      type: "ObjectTypeAnnotation",
      properties: t,
      indexers: e,
      callProperties: r,
      internalSlots: s,
      exact: i
    });
  }
  n(fF, "objectTypeAnnotation");
  function hF(t, e, r, s, i) {
    return (0, j.default)({
      type: "ObjectTypeInternalSlot",
      id: t,
      value: e,
      optional: r,
      static: s,
      method: i
    });
  }
  n(hF, "objectTypeInternalSlot");
  function dF(t) {
    return (0, j.default)({
      type: "ObjectTypeCallProperty",
      value: t,
      static: null
    });
  }
  n(dF, "objectTypeCallProperty");
  function mF(t = null, e, r, s = null) {
    return (0, j.default)({
      type: "ObjectTypeIndexer",
      id: t,
      key: e,
      value: r,
      variance: s,
      static: null
    });
  }
  n(mF, "objectTypeIndexer");
  function yF(t, e, r = null) {
    return (0, j.default)({
      type: "ObjectTypeProperty",
      key: t,
      value: e,
      variance: r,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  }
  n(yF, "objectTypeProperty");
  function TF(t) {
    return (0, j.default)({
      type: "ObjectTypeSpreadProperty",
      argument: t
    });
  }
  n(TF, "objectTypeSpreadProperty");
  function bF(t, e = null, r = null, s) {
    return (0, j.default)({
      type: "OpaqueType",
      id: t,
      typeParameters: e,
      supertype: r,
      impltype: s
    });
  }
  n(bF, "opaqueType");
  function xF(t, e) {
    return (0, j.default)({
      type: "QualifiedTypeIdentifier",
      id: t,
      qualification: e
    });
  }
  n(xF, "qualifiedTypeIdentifier");
  function SF(t) {
    return (0, j.default)({
      type: "StringLiteralTypeAnnotation",
      value: t
    });
  }
  n(SF, "stringLiteralTypeAnnotation");
  function gF() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  n(gF, "stringTypeAnnotation");
  function PF() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  n(PF, "symbolTypeAnnotation");
  function EF() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  n(EF, "thisTypeAnnotation");
  function AF(t) {
    return (0, j.default)({
      type: "TupleTypeAnnotation",
      types: t
    });
  }
  n(AF, "tupleTypeAnnotation");
  function vF(t) {
    return (0, j.default)({
      type: "TypeofTypeAnnotation",
      argument: t
    });
  }
  n(vF, "typeofTypeAnnotation");
  function CF(t, e = null, r) {
    return (0, j.default)({
      type: "TypeAlias",
      id: t,
      typeParameters: e,
      right: r
    });
  }
  n(CF, "typeAlias");
  function IF(t) {
    return (0, j.default)({
      type: "TypeAnnotation",
      typeAnnotation: t
    });
  }
  n(IF, "typeAnnotation");
  function wF(t, e) {
    return (0, j.default)({
      type: "TypeCastExpression",
      expression: t,
      typeAnnotation: e
    });
  }
  n(wF, "typeCastExpression");
  function NF(t = null, e = null, r = null) {
    return (0, j.default)({
      type: "TypeParameter",
      bound: t,
      default: e,
      variance: r,
      name: null
    });
  }
  n(NF, "typeParameter");
  function OF(t) {
    return (0, j.default)({
      type: "TypeParameterDeclaration",
      params: t
    });
  }
  n(OF, "typeParameterDeclaration");
  function kF(t) {
    return (0, j.default)({
      type: "TypeParameterInstantiation",
      params: t
    });
  }
  n(kF, "typeParameterInstantiation");
  function DF(t) {
    return (0, j.default)({
      type: "UnionTypeAnnotation",
      types: t
    });
  }
  n(DF, "unionTypeAnnotation");
  function _F(t) {
    return (0, j.default)({
      type: "Variance",
      kind: t
    });
  }
  n(_F, "variance");
  function LF() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  n(LF, "voidTypeAnnotation");
  function MF(t, e) {
    return (0, j.default)({
      type: "EnumDeclaration",
      id: t,
      body: e
    });
  }
  n(MF, "enumDeclaration");
  function BF(t) {
    return (0, j.default)({
      type: "EnumBooleanBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  n(BF, "enumBooleanBody");
  function FF(t) {
    return (0, j.default)({
      type: "EnumNumberBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  n(FF, "enumNumberBody");
  function jF(t) {
    return (0, j.default)({
      type: "EnumStringBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  n(jF, "enumStringBody");
  function RF(t) {
    return (0, j.default)({
      type: "EnumSymbolBody",
      members: t,
      hasUnknownMembers: null
    });
  }
  n(RF, "enumSymbolBody");
  function UF(t) {
    return (0, j.default)({
      type: "EnumBooleanMember",
      id: t,
      init: null
    });
  }
  n(UF, "enumBooleanMember");
  function qF(t, e) {
    return (0, j.default)({
      type: "EnumNumberMember",
      id: t,
      init: e
    });
  }
  n(qF, "enumNumberMember");
  function VF(t, e) {
    return (0, j.default)({
      type: "EnumStringMember",
      id: t,
      init: e
    });
  }
  n(VF, "enumStringMember");
  function KF(t) {
    return (0, j.default)({
      type: "EnumDefaultedMember",
      id: t
    });
  }
  n(KF, "enumDefaultedMember");
  function WF(t, e) {
    return (0, j.default)({
      type: "IndexedAccessType",
      objectType: t,
      indexType: e
    });
  }
  n(WF, "indexedAccessType");
  function YF(t, e) {
    return (0, j.default)({
      type: "OptionalIndexedAccessType",
      objectType: t,
      indexType: e,
      optional: null
    });
  }
  n(YF, "optionalIndexedAccessType");
  function JF(t, e = null) {
    return (0, j.default)({
      type: "JSXAttribute",
      name: t,
      value: e
    });
  }
  n(JF, "jsxAttribute");
  function XF(t) {
    return (0, j.default)({
      type: "JSXClosingElement",
      name: t
    });
  }
  n(XF, "jsxClosingElement");
  function $F(t, e = null, r, s = null) {
    return (0, j.default)({
      type: "JSXElement",
      openingElement: t,
      closingElement: e,
      children: r,
      selfClosing: s
    });
  }
  n($F, "jsxElement");
  function HF() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  n(HF, "jsxEmptyExpression");
  function zF(t) {
    return (0, j.default)({
      type: "JSXExpressionContainer",
      expression: t
    });
  }
  n(zF, "jsxExpressionContainer");
  function GF(t) {
    return (0, j.default)({
      type: "JSXSpreadChild",
      expression: t
    });
  }
  n(GF, "jsxSpreadChild");
  function QF(t) {
    return (0, j.default)({
      type: "JSXIdentifier",
      name: t
    });
  }
  n(QF, "jsxIdentifier");
  function ZF(t, e) {
    return (0, j.default)({
      type: "JSXMemberExpression",
      object: t,
      property: e
    });
  }
  n(ZF, "jsxMemberExpression");
  function e4(t, e) {
    return (0, j.default)({
      type: "JSXNamespacedName",
      namespace: t,
      name: e
    });
  }
  n(e4, "jsxNamespacedName");
  function t4(t, e, r = !1) {
    return (0, j.default)({
      type: "JSXOpeningElement",
      name: t,
      attributes: e,
      selfClosing: r
    });
  }
  n(t4, "jsxOpeningElement");
  function r4(t) {
    return (0, j.default)({
      type: "JSXSpreadAttribute",
      argument: t
    });
  }
  n(r4, "jsxSpreadAttribute");
  function s4(t) {
    return (0, j.default)({
      type: "JSXText",
      value: t
    });
  }
  n(s4, "jsxText");
  function i4(t, e, r) {
    return (0, j.default)({
      type: "JSXFragment",
      openingFragment: t,
      closingFragment: e,
      children: r
    });
  }
  n(i4, "jsxFragment");
  function n4() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  n(n4, "jsxOpeningFragment");
  function a4() {
    return {
      type: "JSXClosingFragment"
    };
  }
  n(a4, "jsxClosingFragment");
  function o4() {
    return {
      type: "Noop"
    };
  }
  n(o4, "noop");
  function l4(t, e) {
    return (0, j.default)({
      type: "Placeholder",
      expectedNode: t,
      name: e
    });
  }
  n(l4, "placeholder");
  function u4(t) {
    return (0, j.default)({
      type: "V8IntrinsicIdentifier",
      name: t
    });
  }
  n(u4, "v8IntrinsicIdentifier");
  function c4() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  n(c4, "argumentPlaceholder");
  function p4(t, e) {
    return (0, j.default)({
      type: "BindExpression",
      object: t,
      callee: e
    });
  }
  n(p4, "bindExpression");
  function f4(t, e) {
    return (0, j.default)({
      type: "ImportAttribute",
      key: t,
      value: e
    });
  }
  n(f4, "importAttribute");
  function h4(t) {
    return (0, j.default)({
      type: "Decorator",
      expression: t
    });
  }
  n(h4, "decorator");
  function d4(t, e = !1) {
    return (0, j.default)({
      type: "DoExpression",
      body: t,
      async: e
    });
  }
  n(d4, "doExpression");
  function m4(t) {
    return (0, j.default)({
      type: "ExportDefaultSpecifier",
      exported: t
    });
  }
  n(m4, "exportDefaultSpecifier");
  function y4(t) {
    return (0, j.default)({
      type: "RecordExpression",
      properties: t
    });
  }
  n(y4, "recordExpression");
  function T4(t = []) {
    return (0, j.default)({
      type: "TupleExpression",
      elements: t
    });
  }
  n(T4, "tupleExpression");
  function b4(t) {
    return (0, j.default)({
      type: "DecimalLiteral",
      value: t
    });
  }
  n(b4, "decimalLiteral");
  function x4(t) {
    return (0, j.default)({
      type: "ModuleExpression",
      body: t
    });
  }
  n(x4, "moduleExpression");
  function S4() {
    return {
      type: "TopicReference"
    };
  }
  n(S4, "topicReference");
  function g4(t) {
    return (0, j.default)({
      type: "PipelineTopicExpression",
      expression: t
    });
  }
  n(g4, "pipelineTopicExpression");
  function P4(t) {
    return (0, j.default)({
      type: "PipelineBareFunction",
      callee: t
    });
  }
  n(P4, "pipelineBareFunction");
  function E4() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  n(E4, "pipelinePrimaryTopicReference");
  function A4(t) {
    return (0, j.default)({
      type: "TSParameterProperty",
      parameter: t
    });
  }
  n(A4, "tsParameterProperty");
  function v4(t = null, e = null, r, s = null) {
    return (0, j.default)({
      type: "TSDeclareFunction",
      id: t,
      typeParameters: e,
      params: r,
      returnType: s
    });
  }
  n(v4, "tsDeclareFunction");
  function C4(t = null, e, r = null, s, i = null) {
    return (0, j.default)({
      type: "TSDeclareMethod",
      decorators: t,
      key: e,
      typeParameters: r,
      params: s,
      returnType: i
    });
  }
  n(C4, "tsDeclareMethod");
  function I4(t, e) {
    return (0, j.default)({
      type: "TSQualifiedName",
      left: t,
      right: e
    });
  }
  n(I4, "tsQualifiedName");
  function w4(t = null, e, r = null) {
    return (0, j.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(w4, "tsCallSignatureDeclaration");
  function N4(t = null, e, r = null) {
    return (0, j.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(N4, "tsConstructSignatureDeclaration");
  function O4(t, e = null) {
    return (0, j.default)({
      type: "TSPropertySignature",
      key: t,
      typeAnnotation: e,
      kind: null
    });
  }
  n(O4, "tsPropertySignature");
  function k4(t, e = null, r, s = null) {
    return (0, j.default)({
      type: "TSMethodSignature",
      key: t,
      typeParameters: e,
      parameters: r,
      typeAnnotation: s,
      kind: null
    });
  }
  n(k4, "tsMethodSignature");
  function D4(t, e = null) {
    return (0, j.default)({
      type: "TSIndexSignature",
      parameters: t,
      typeAnnotation: e
    });
  }
  n(D4, "tsIndexSignature");
  function _4() {
    return {
      type: "TSAnyKeyword"
    };
  }
  n(_4, "tsAnyKeyword");
  function L4() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  n(L4, "tsBooleanKeyword");
  function M4() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  n(M4, "tsBigIntKeyword");
  function B4() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  n(B4, "tsIntrinsicKeyword");
  function F4() {
    return {
      type: "TSNeverKeyword"
    };
  }
  n(F4, "tsNeverKeyword");
  function j4() {
    return {
      type: "TSNullKeyword"
    };
  }
  n(j4, "tsNullKeyword");
  function R4() {
    return {
      type: "TSNumberKeyword"
    };
  }
  n(R4, "tsNumberKeyword");
  function U4() {
    return {
      type: "TSObjectKeyword"
    };
  }
  n(U4, "tsObjectKeyword");
  function q4() {
    return {
      type: "TSStringKeyword"
    };
  }
  n(q4, "tsStringKeyword");
  function V4() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  n(V4, "tsSymbolKeyword");
  function K4() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  n(K4, "tsUndefinedKeyword");
  function W4() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  n(W4, "tsUnknownKeyword");
  function Y4() {
    return {
      type: "TSVoidKeyword"
    };
  }
  n(Y4, "tsVoidKeyword");
  function J4() {
    return {
      type: "TSThisType"
    };
  }
  n(J4, "tsThisType");
  function X4(t = null, e, r = null) {
    return (0, j.default)({
      type: "TSFunctionType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(X4, "tsFunctionType");
  function $4(t = null, e, r = null) {
    return (0, j.default)({
      type: "TSConstructorType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n($4, "tsConstructorType");
  function H4(t, e = null) {
    return (0, j.default)({
      type: "TSTypeReference",
      typeName: t,
      typeParameters: e
    });
  }
  n(H4, "tsTypeReference");
  function z4(t, e = null, r = null) {
    return (0, j.default)({
      type: "TSTypePredicate",
      parameterName: t,
      typeAnnotation: e,
      asserts: r
    });
  }
  n(z4, "tsTypePredicate");
  function G4(t, e = null) {
    return (0, j.default)({
      type: "TSTypeQuery",
      exprName: t,
      typeParameters: e
    });
  }
  n(G4, "tsTypeQuery");
  function Q4(t) {
    return (0, j.default)({
      type: "TSTypeLiteral",
      members: t
    });
  }
  n(Q4, "tsTypeLiteral");
  function Z4(t) {
    return (0, j.default)({
      type: "TSArrayType",
      elementType: t
    });
  }
  n(Z4, "tsArrayType");
  function e5(t) {
    return (0, j.default)({
      type: "TSTupleType",
      elementTypes: t
    });
  }
  n(e5, "tsTupleType");
  function t5(t) {
    return (0, j.default)({
      type: "TSOptionalType",
      typeAnnotation: t
    });
  }
  n(t5, "tsOptionalType");
  function r5(t) {
    return (0, j.default)({
      type: "TSRestType",
      typeAnnotation: t
    });
  }
  n(r5, "tsRestType");
  function s5(t, e, r = !1) {
    return (0, j.default)({
      type: "TSNamedTupleMember",
      label: t,
      elementType: e,
      optional: r
    });
  }
  n(s5, "tsNamedTupleMember");
  function i5(t) {
    return (0, j.default)({
      type: "TSUnionType",
      types: t
    });
  }
  n(i5, "tsUnionType");
  function n5(t) {
    return (0, j.default)({
      type: "TSIntersectionType",
      types: t
    });
  }
  n(n5, "tsIntersectionType");
  function a5(t, e, r, s) {
    return (0, j.default)({
      type: "TSConditionalType",
      checkType: t,
      extendsType: e,
      trueType: r,
      falseType: s
    });
  }
  n(a5, "tsConditionalType");
  function o5(t) {
    return (0, j.default)({
      type: "TSInferType",
      typeParameter: t
    });
  }
  n(o5, "tsInferType");
  function l5(t) {
    return (0, j.default)({
      type: "TSParenthesizedType",
      typeAnnotation: t
    });
  }
  n(l5, "tsParenthesizedType");
  function u5(t) {
    return (0, j.default)({
      type: "TSTypeOperator",
      typeAnnotation: t,
      operator: null
    });
  }
  n(u5, "tsTypeOperator");
  function c5(t, e) {
    return (0, j.default)({
      type: "TSIndexedAccessType",
      objectType: t,
      indexType: e
    });
  }
  n(c5, "tsIndexedAccessType");
  function p5(t, e = null, r = null) {
    return (0, j.default)({
      type: "TSMappedType",
      typeParameter: t,
      typeAnnotation: e,
      nameType: r
    });
  }
  n(p5, "tsMappedType");
  function f5(t) {
    return (0, j.default)({
      type: "TSLiteralType",
      literal: t
    });
  }
  n(f5, "tsLiteralType");
  function h5(t, e = null) {
    return (0, j.default)({
      type: "TSExpressionWithTypeArguments",
      expression: t,
      typeParameters: e
    });
  }
  n(h5, "tsExpressionWithTypeArguments");
  function d5(t, e = null, r = null, s) {
    return (0, j.default)({
      type: "TSInterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(d5, "tsInterfaceDeclaration");
  function m5(t) {
    return (0, j.default)({
      type: "TSInterfaceBody",
      body: t
    });
  }
  n(m5, "tsInterfaceBody");
  function y5(t, e = null, r) {
    return (0, j.default)({
      type: "TSTypeAliasDeclaration",
      id: t,
      typeParameters: e,
      typeAnnotation: r
    });
  }
  n(y5, "tsTypeAliasDeclaration");
  function T5(t, e = null) {
    return (0, j.default)({
      type: "TSInstantiationExpression",
      expression: t,
      typeParameters: e
    });
  }
  n(T5, "tsInstantiationExpression");
  function b5(t, e) {
    return (0, j.default)({
      type: "TSAsExpression",
      expression: t,
      typeAnnotation: e
    });
  }
  n(b5, "tsAsExpression");
  function x5(t, e) {
    return (0, j.default)({
      type: "TSSatisfiesExpression",
      expression: t,
      typeAnnotation: e
    });
  }
  n(x5, "tsSatisfiesExpression");
  function S5(t, e) {
    return (0, j.default)({
      type: "TSTypeAssertion",
      typeAnnotation: t,
      expression: e
    });
  }
  n(S5, "tsTypeAssertion");
  function g5(t, e) {
    return (0, j.default)({
      type: "TSEnumDeclaration",
      id: t,
      members: e
    });
  }
  n(g5, "tsEnumDeclaration");
  function P5(t, e = null) {
    return (0, j.default)({
      type: "TSEnumMember",
      id: t,
      initializer: e
    });
  }
  n(P5, "tsEnumMember");
  function E5(t, e) {
    return (0, j.default)({
      type: "TSModuleDeclaration",
      id: t,
      body: e
    });
  }
  n(E5, "tsModuleDeclaration");
  function A5(t) {
    return (0, j.default)({
      type: "TSModuleBlock",
      body: t
    });
  }
  n(A5, "tsModuleBlock");
  function v5(t, e = null, r = null) {
    return (0, j.default)({
      type: "TSImportType",
      argument: t,
      qualifier: e,
      typeParameters: r
    });
  }
  n(v5, "tsImportType");
  function C5(t, e) {
    return (0, j.default)({
      type: "TSImportEqualsDeclaration",
      id: t,
      moduleReference: e,
      isExport: null
    });
  }
  n(C5, "tsImportEqualsDeclaration");
  function I5(t) {
    return (0, j.default)({
      type: "TSExternalModuleReference",
      expression: t
    });
  }
  n(I5, "tsExternalModuleReference");
  function w5(t) {
    return (0, j.default)({
      type: "TSNonNullExpression",
      expression: t
    });
  }
  n(w5, "tsNonNullExpression");
  function N5(t) {
    return (0, j.default)({
      type: "TSExportAssignment",
      expression: t
    });
  }
  n(N5, "tsExportAssignment");
  function O5(t) {
    return (0, j.default)({
      type: "TSNamespaceExportDeclaration",
      id: t
    });
  }
  n(O5, "tsNamespaceExportDeclaration");
  function k5(t) {
    return (0, j.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: t
    });
  }
  n(k5, "tsTypeAnnotation");
  function D5(t) {
    return (0, j.default)({
      type: "TSTypeParameterInstantiation",
      params: t
    });
  }
  n(D5, "tsTypeParameterInstantiation");
  function _5(t) {
    return (0, j.default)({
      type: "TSTypeParameterDeclaration",
      params: t
    });
  }
  n(_5, "tsTypeParameterDeclaration");
  function L5(t = null, e = null, r) {
    return (0, j.default)({
      type: "TSTypeParameter",
      constraint: t,
      default: e,
      name: r
    });
  }
  n(L5, "tsTypeParameter");
  function M5(t) {
    return (0, Pl.default)("NumberLiteral", "NumericLiteral", "The node type "), Xx(t);
  }
  n(M5, "NumberLiteral");
  function B5(t, e = "") {
    return (0, Pl.default)("RegexLiteral", "RegExpLiteral", "The node type "), $x(t, e);
  }
  n(B5, "RegexLiteral");
  function F5(t) {
    return (0, Pl.default)("RestProperty", "RestElement", "The node type "), Hx(t);
  }
  n(F5, "RestProperty");
  function j5(t) {
    return (0, Pl.default)("SpreadProperty", "SpreadElement", "The node type "), zx(t);
  }
  n(j5, "SpreadProperty");
});

// ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var Gx = w((Lp) => {
  "use strict";
  Object.defineProperty(Lp, "__esModule", {
    value: !0
  });
  Lp.default = q5;
  var R5 = pr(), U5 = Ce();
  function q5(t, e) {
    let r = t.value.split(/\r\n|\n|\r/), s = 0;
    for (let a = 0; a < r.length; a++)
      r[a].match(/[^ \t]/) && (s = a);
    let i = "";
    for (let a = 0; a < r.length; a++) {
      let o = r[a], l = a === 0, u = a === r.length - 1, c = a === s, p = o.replace(/\t/g, " ");
      l || (p = p.replace(/^[ ]+/, "")), u || (p = p.replace(/[ ]+$/, "")), p && (c || (p += " "), i += p);
    }
    i && e.push((0, U5.inherits)((0, R5.stringLiteral)(i), t));
  }
  n(q5, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/types/lib/builders/react/buildChildren.js
var Qx = w((Bp) => {
  "use strict";
  Object.defineProperty(Bp, "__esModule", {
    value: !0
  });
  Bp.default = K5;
  var Mp = jt(), V5 = Gx();
  function K5(t) {
    let e = [];
    for (let r = 0; r < t.children.length; r++) {
      let s = t.children[r];
      if ((0, Mp.isJSXText)(s)) {
        (0, V5.default)(s, e);
        continue;
      }
      (0, Mp.isJSXExpressionContainer)(s) && (s = s.expression), !(0, Mp.isJSXEmptyExpression)(s) && e.push(s);
    }
    return e;
  }
  n(K5, "buildChildren");
});

// ../node_modules/@babel/types/lib/validators/isNode.js
var jp = w((Fp) => {
  "use strict";
  Object.defineProperty(Fp, "__esModule", {
    value: !0
  });
  Fp.default = Y5;
  var W5 = Br();
  function Y5(t) {
    return !!(t && W5.VISITOR_KEYS[t.type]);
  }
  n(Y5, "isNode");
});

// ../node_modules/@babel/types/lib/asserts/assertNode.js
var Zx = w((Rp) => {
  "use strict";
  Object.defineProperty(Rp, "__esModule", {
    value: !0
  });
  Rp.default = X5;
  var J5 = jp();
  function X5(t) {
    if (!(0, J5.default)(t)) {
      var e;
      let r = (e = t?.type) != null ? e : JSON.stringify(t);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
  n(X5, "assertNode");
});

// ../node_modules/@babel/types/lib/asserts/generated/index.js
var eS = w((g) => {
  "use strict";
  Object.defineProperty(g, "__esModule", {
    value: !0
  });
  g.assertAccessor = u7;
  g.assertAnyTypeAnnotation = N8;
  g.assertArgumentPlaceholder = iR;
  g.assertArrayExpression = H5;
  g.assertArrayPattern = Xj;
  g.assertArrayTypeAnnotation = O8;
  g.assertArrowFunctionExpression = $j;
  g.assertAssignmentExpression = z5;
  g.assertAssignmentPattern = Jj;
  g.assertAwaitExpression = T8;
  g.assertBigIntLiteral = x8;
  g.assertBinary = k9;
  g.assertBinaryExpression = G5;
  g.assertBindExpression = nR;
  g.assertBlock = L9;
  g.assertBlockParent = _9;
  g.assertBlockStatement = tj;
  g.assertBooleanLiteral = Pj;
  g.assertBooleanLiteralTypeAnnotation = D8;
  g.assertBooleanTypeAnnotation = k8;
  g.assertBreakStatement = rj;
  g.assertCallExpression = sj;
  g.assertCatchClause = ij;
  g.assertClass = n7;
  g.assertClassAccessorProperty = A8;
  g.assertClassBody = Hj;
  g.assertClassDeclaration = Gj;
  g.assertClassExpression = zj;
  g.assertClassImplements = L8;
  g.assertClassMethod = u8;
  g.assertClassPrivateMethod = C8;
  g.assertClassPrivateProperty = v8;
  g.assertClassProperty = E8;
  g.assertCompletionStatement = F9;
  g.assertConditional = j9;
  g.assertConditionalExpression = nj;
  g.assertContinueStatement = aj;
  g.assertDebuggerStatement = oj;
  g.assertDecimalLiteral = fR;
  g.assertDeclaration = X9;
  g.assertDeclareClass = M8;
  g.assertDeclareExportAllDeclaration = W8;
  g.assertDeclareExportDeclaration = K8;
  g.assertDeclareFunction = B8;
  g.assertDeclareInterface = F8;
  g.assertDeclareModule = j8;
  g.assertDeclareModuleExports = R8;
  g.assertDeclareOpaqueType = q8;
  g.assertDeclareTypeAlias = U8;
  g.assertDeclareVariable = V8;
  g.assertDeclaredPredicate = Y8;
  g.assertDecorator = oR;
  g.assertDirective = Z5;
  g.assertDirectiveLiteral = ej;
  g.assertDoExpression = lR;
  g.assertDoWhileStatement = lj;
  g.assertEmptyStatement = uj;
  g.assertEmptyTypeAnnotation = r6;
  g.assertEnumBody = y7;
  g.assertEnumBooleanBody = O6;
  g.assertEnumBooleanMember = L6;
  g.assertEnumDeclaration = N6;
  g.assertEnumDefaultedMember = F6;
  g.assertEnumMember = T7;
  g.assertEnumNumberBody = k6;
  g.assertEnumNumberMember = M6;
  g.assertEnumStringBody = D6;
  g.assertEnumStringMember = B6;
  g.assertEnumSymbolBody = _6;
  g.assertExistsTypeAnnotation = J8;
  g.assertExportAllDeclaration = Qj;
  g.assertExportDeclaration = o7;
  g.assertExportDefaultDeclaration = Zj;
  g.assertExportDefaultSpecifier = uR;
  g.assertExportNamedDeclaration = e8;
  g.assertExportNamespaceSpecifier = S8;
  g.assertExportSpecifier = t8;
  g.assertExpression = O9;
  g.assertExpressionStatement = cj;
  g.assertExpressionWrapper = q9;
  g.assertFile = pj;
  g.assertFlow = p7;
  g.assertFlowBaseAnnotation = h7;
  g.assertFlowDeclaration = d7;
  g.assertFlowPredicate = m7;
  g.assertFlowType = f7;
  g.assertFor = V9;
  g.assertForInStatement = fj;
  g.assertForOfStatement = r8;
  g.assertForStatement = hj;
  g.assertForXStatement = K9;
  g.assertFunction = W9;
  g.assertFunctionDeclaration = dj;
  g.assertFunctionExpression = mj;
  g.assertFunctionParent = Y9;
  g.assertFunctionTypeAnnotation = X8;
  g.assertFunctionTypeParam = $8;
  g.assertGenericTypeAnnotation = H8;
  g.assertIdentifier = yj;
  g.assertIfStatement = Tj;
  g.assertImmutable = Q9;
  g.assertImport = b8;
  g.assertImportAttribute = aR;
  g.assertImportDeclaration = s8;
  g.assertImportDefaultSpecifier = i8;
  g.assertImportExpression = o8;
  g.assertImportNamespaceSpecifier = n8;
  g.assertImportOrExportDeclaration = a7;
  g.assertImportSpecifier = a8;
  g.assertIndexedAccessType = j6;
  g.assertInferredPredicate = z8;
  g.assertInterfaceDeclaration = Q8;
  g.assertInterfaceExtends = G8;
  g.assertInterfaceTypeAnnotation = Z8;
  g.assertInterpreterDirective = Q5;
  g.assertIntersectionTypeAnnotation = e6;
  g.assertJSX = b7;
  g.assertJSXAttribute = U6;
  g.assertJSXClosingElement = q6;
  g.assertJSXClosingFragment = eR;
  g.assertJSXElement = V6;
  g.assertJSXEmptyExpression = K6;
  g.assertJSXExpressionContainer = W6;
  g.assertJSXFragment = Q6;
  g.assertJSXIdentifier = J6;
  g.assertJSXMemberExpression = X6;
  g.assertJSXNamespacedName = $6;
  g.assertJSXOpeningElement = H6;
  g.assertJSXOpeningFragment = Z6;
  g.assertJSXSpreadAttribute = z6;
  g.assertJSXSpreadChild = Y6;
  g.assertJSXText = G6;
  g.assertLVal = H9;
  g.assertLabeledStatement = bj;
  g.assertLiteral = G9;
  g.assertLogicalExpression = Aj;
  g.assertLoop = R9;
  g.assertMemberExpression = vj;
  g.assertMetaProperty = l8;
  g.assertMethod = e7;
  g.assertMiscellaneous = x7;
  g.assertMixedTypeAnnotation = t6;
  g.assertModuleDeclaration = w7;
  g.assertModuleExpression = hR;
  g.assertModuleSpecifier = l7;
  g.assertNewExpression = Cj;
  g.assertNoop = tR;
  g.assertNullLiteral = gj;
  g.assertNullLiteralTypeAnnotation = _8;
  g.assertNullableTypeAnnotation = s6;
  g.assertNumberLiteral = A7;
  g.assertNumberLiteralTypeAnnotation = i6;
  g.assertNumberTypeAnnotation = n6;
  g.assertNumericLiteral = Sj;
  g.assertObjectExpression = wj;
  g.assertObjectMember = t7;
  g.assertObjectMethod = Nj;
  g.assertObjectPattern = c8;
  g.assertObjectProperty = Oj;
  g.assertObjectTypeAnnotation = a6;
  g.assertObjectTypeCallProperty = l6;
  g.assertObjectTypeIndexer = u6;
  g.assertObjectTypeInternalSlot = o6;
  g.assertObjectTypeProperty = c6;
  g.assertObjectTypeSpreadProperty = p6;
  g.assertOpaqueType = f6;
  g.assertOptionalCallExpression = P8;
  g.assertOptionalIndexedAccessType = R6;
  g.assertOptionalMemberExpression = g8;
  g.assertParenthesizedExpression = Lj;
  g.assertPattern = i7;
  g.assertPatternLike = $9;
  g.assertPipelineBareFunction = yR;
  g.assertPipelinePrimaryTopicReference = TR;
  g.assertPipelineTopicExpression = mR;
  g.assertPlaceholder = rR;
  g.assertPrivate = c7;
  g.assertPrivateName = I8;
  g.assertProgram = Ij;
  g.assertProperty = r7;
  g.assertPureish = J9;
  g.assertQualifiedTypeIdentifier = h6;
  g.assertRecordExpression = cR;
  g.assertRegExpLiteral = Ej;
  g.assertRegexLiteral = v7;
  g.assertRestElement = kj;
  g.assertRestProperty = C7;
  g.assertReturnStatement = Dj;
  g.assertScopable = D9;
  g.assertSequenceExpression = _j;
  g.assertSpreadElement = p8;
  g.assertSpreadProperty = I7;
  g.assertStandardized = N9;
  g.assertStatement = M9;
  g.assertStaticBlock = w8;
  g.assertStringLiteral = xj;
  g.assertStringLiteralTypeAnnotation = d6;
  g.assertStringTypeAnnotation = m6;
  g.assertSuper = f8;
  g.assertSwitchCase = Mj;
  g.assertSwitchStatement = Bj;
  g.assertSymbolTypeAnnotation = y6;
  g.assertTSAnyKeyword = IR;
  g.assertTSArrayType = XR;
  g.assertTSAsExpression = f9;
  g.assertTSBaseType = E7;
  g.assertTSBigIntKeyword = NR;
  g.assertTSBooleanKeyword = wR;
  g.assertTSCallSignatureDeclaration = PR;
  g.assertTSConditionalType = e9;
  g.assertTSConstructSignatureDeclaration = ER;
  g.assertTSConstructorType = VR;
  g.assertTSDeclareFunction = xR;
  g.assertTSDeclareMethod = SR;
  g.assertTSEntityName = z9;
  g.assertTSEnumDeclaration = m9;
  g.assertTSEnumMember = y9;
  g.assertTSExportAssignment = E9;
  g.assertTSExpressionWithTypeArguments = o9;
  g.assertTSExternalModuleReference = g9;
  g.assertTSFunctionType = qR;
  g.assertTSImportEqualsDeclaration = S9;
  g.assertTSImportType = x9;
  g.assertTSIndexSignature = CR;
  g.assertTSIndexedAccessType = i9;
  g.assertTSInferType = t9;
  g.assertTSInstantiationExpression = p9;
  g.assertTSInterfaceBody = u9;
  g.assertTSInterfaceDeclaration = l9;
  g.assertTSIntersectionType = ZR;
  g.assertTSIntrinsicKeyword = OR;
  g.assertTSLiteralType = a9;
  g.assertTSMappedType = n9;
  g.assertTSMethodSignature = vR;
  g.assertTSModuleBlock = b9;
  g.assertTSModuleDeclaration = T9;
  g.assertTSNamedTupleMember = GR;
  g.assertTSNamespaceExportDeclaration = A9;
  g.assertTSNeverKeyword = kR;
  g.assertTSNonNullExpression = P9;
  g.assertTSNullKeyword = DR;
  g.assertTSNumberKeyword = _R;
  g.assertTSObjectKeyword = LR;
  g.assertTSOptionalType = HR;
  g.assertTSParameterProperty = bR;
  g.assertTSParenthesizedType = r9;
  g.assertTSPropertySignature = AR;
  g.assertTSQualifiedName = gR;
  g.assertTSRestType = zR;
  g.assertTSSatisfiesExpression = h9;
  g.assertTSStringKeyword = MR;
  g.assertTSSymbolKeyword = BR;
  g.assertTSThisType = UR;
  g.assertTSTupleType = $R;
  g.assertTSType = P7;
  g.assertTSTypeAliasDeclaration = c9;
  g.assertTSTypeAnnotation = v9;
  g.assertTSTypeAssertion = d9;
  g.assertTSTypeElement = g7;
  g.assertTSTypeLiteral = JR;
  g.assertTSTypeOperator = s9;
  g.assertTSTypeParameter = w9;
  g.assertTSTypeParameterDeclaration = I9;
  g.assertTSTypeParameterInstantiation = C9;
  g.assertTSTypePredicate = WR;
  g.assertTSTypeQuery = YR;
  g.assertTSTypeReference = KR;
  g.assertTSUndefinedKeyword = FR;
  g.assertTSUnionType = QR;
  g.assertTSUnknownKeyword = jR;
  g.assertTSVoidKeyword = RR;
  g.assertTaggedTemplateExpression = h8;
  g.assertTemplateElement = d8;
  g.assertTemplateLiteral = m8;
  g.assertTerminatorless = B9;
  g.assertThisExpression = Fj;
  g.assertThisTypeAnnotation = T6;
  g.assertThrowStatement = jj;
  g.assertTopicReference = dR;
  g.assertTryStatement = Rj;
  g.assertTupleExpression = pR;
  g.assertTupleTypeAnnotation = b6;
  g.assertTypeAlias = S6;
  g.assertTypeAnnotation = g6;
  g.assertTypeCastExpression = P6;
  g.assertTypeParameter = E6;
  g.assertTypeParameterDeclaration = A6;
  g.assertTypeParameterInstantiation = v6;
  g.assertTypeScript = S7;
  g.assertTypeofTypeAnnotation = x6;
  g.assertUnaryExpression = Uj;
  g.assertUnaryLike = s7;
  g.assertUnionTypeAnnotation = C6;
  g.assertUpdateExpression = qj;
  g.assertUserWhitespacable = Z9;
  g.assertV8IntrinsicIdentifier = sR;
  g.assertVariableDeclaration = Vj;
  g.assertVariableDeclarator = Kj;
  g.assertVariance = I6;
  g.assertVoidTypeAnnotation = w6;
  g.assertWhile = U9;
  g.assertWhileStatement = Wj;
  g.assertWithStatement = Yj;
  g.assertYieldExpression = y8;
  var $5 = cn(), Pa = ca();
  function A(t, e, r) {
    if (!(0, $5.default)(t, e, r))
      throw new Error(`Expected type "${t}" with option ${JSON.stringify(r)}, but instead got "${e.type}".`);
  }
  n(A, "assert");
  function H5(t, e) {
    A("ArrayExpression", t, e);
  }
  n(H5, "assertArrayExpression");
  function z5(t, e) {
    A("AssignmentExpression", t, e);
  }
  n(z5, "assertAssignmentExpression");
  function G5(t, e) {
    A("BinaryExpression", t, e);
  }
  n(G5, "assertBinaryExpression");
  function Q5(t, e) {
    A("InterpreterDirective", t, e);
  }
  n(Q5, "assertInterpreterDirective");
  function Z5(t, e) {
    A("Directive", t, e);
  }
  n(Z5, "assertDirective");
  function ej(t, e) {
    A("DirectiveLiteral", t, e);
  }
  n(ej, "assertDirectiveLiteral");
  function tj(t, e) {
    A("BlockStatement", t, e);
  }
  n(tj, "assertBlockStatement");
  function rj(t, e) {
    A("BreakStatement", t, e);
  }
  n(rj, "assertBreakStatement");
  function sj(t, e) {
    A("CallExpression", t, e);
  }
  n(sj, "assertCallExpression");
  function ij(t, e) {
    A("CatchClause", t, e);
  }
  n(ij, "assertCatchClause");
  function nj(t, e) {
    A("ConditionalExpression", t, e);
  }
  n(nj, "assertConditionalExpression");
  function aj(t, e) {
    A("ContinueStatement", t, e);
  }
  n(aj, "assertContinueStatement");
  function oj(t, e) {
    A("DebuggerStatement", t, e);
  }
  n(oj, "assertDebuggerStatement");
  function lj(t, e) {
    A("DoWhileStatement", t, e);
  }
  n(lj, "assertDoWhileStatement");
  function uj(t, e) {
    A("EmptyStatement", t, e);
  }
  n(uj, "assertEmptyStatement");
  function cj(t, e) {
    A("ExpressionStatement", t, e);
  }
  n(cj, "assertExpressionStatement");
  function pj(t, e) {
    A("File", t, e);
  }
  n(pj, "assertFile");
  function fj(t, e) {
    A("ForInStatement", t, e);
  }
  n(fj, "assertForInStatement");
  function hj(t, e) {
    A("ForStatement", t, e);
  }
  n(hj, "assertForStatement");
  function dj(t, e) {
    A("FunctionDeclaration", t, e);
  }
  n(dj, "assertFunctionDeclaration");
  function mj(t, e) {
    A("FunctionExpression", t, e);
  }
  n(mj, "assertFunctionExpression");
  function yj(t, e) {
    A("Identifier", t, e);
  }
  n(yj, "assertIdentifier");
  function Tj(t, e) {
    A("IfStatement", t, e);
  }
  n(Tj, "assertIfStatement");
  function bj(t, e) {
    A("LabeledStatement", t, e);
  }
  n(bj, "assertLabeledStatement");
  function xj(t, e) {
    A("StringLiteral", t, e);
  }
  n(xj, "assertStringLiteral");
  function Sj(t, e) {
    A("NumericLiteral", t, e);
  }
  n(Sj, "assertNumericLiteral");
  function gj(t, e) {
    A("NullLiteral", t, e);
  }
  n(gj, "assertNullLiteral");
  function Pj(t, e) {
    A("BooleanLiteral", t, e);
  }
  n(Pj, "assertBooleanLiteral");
  function Ej(t, e) {
    A("RegExpLiteral", t, e);
  }
  n(Ej, "assertRegExpLiteral");
  function Aj(t, e) {
    A("LogicalExpression", t, e);
  }
  n(Aj, "assertLogicalExpression");
  function vj(t, e) {
    A("MemberExpression", t, e);
  }
  n(vj, "assertMemberExpression");
  function Cj(t, e) {
    A("NewExpression", t, e);
  }
  n(Cj, "assertNewExpression");
  function Ij(t, e) {
    A("Program", t, e);
  }
  n(Ij, "assertProgram");
  function wj(t, e) {
    A("ObjectExpression", t, e);
  }
  n(wj, "assertObjectExpression");
  function Nj(t, e) {
    A("ObjectMethod", t, e);
  }
  n(Nj, "assertObjectMethod");
  function Oj(t, e) {
    A("ObjectProperty", t, e);
  }
  n(Oj, "assertObjectProperty");
  function kj(t, e) {
    A("RestElement", t, e);
  }
  n(kj, "assertRestElement");
  function Dj(t, e) {
    A("ReturnStatement", t, e);
  }
  n(Dj, "assertReturnStatement");
  function _j(t, e) {
    A("SequenceExpression", t, e);
  }
  n(_j, "assertSequenceExpression");
  function Lj(t, e) {
    A("ParenthesizedExpression", t, e);
  }
  n(Lj, "assertParenthesizedExpression");
  function Mj(t, e) {
    A("SwitchCase", t, e);
  }
  n(Mj, "assertSwitchCase");
  function Bj(t, e) {
    A("SwitchStatement", t, e);
  }
  n(Bj, "assertSwitchStatement");
  function Fj(t, e) {
    A("ThisExpression", t, e);
  }
  n(Fj, "assertThisExpression");
  function jj(t, e) {
    A("ThrowStatement", t, e);
  }
  n(jj, "assertThrowStatement");
  function Rj(t, e) {
    A("TryStatement", t, e);
  }
  n(Rj, "assertTryStatement");
  function Uj(t, e) {
    A("UnaryExpression", t, e);
  }
  n(Uj, "assertUnaryExpression");
  function qj(t, e) {
    A("UpdateExpression", t, e);
  }
  n(qj, "assertUpdateExpression");
  function Vj(t, e) {
    A("VariableDeclaration", t, e);
  }
  n(Vj, "assertVariableDeclaration");
  function Kj(t, e) {
    A("VariableDeclarator", t, e);
  }
  n(Kj, "assertVariableDeclarator");
  function Wj(t, e) {
    A("WhileStatement", t, e);
  }
  n(Wj, "assertWhileStatement");
  function Yj(t, e) {
    A("WithStatement", t, e);
  }
  n(Yj, "assertWithStatement");
  function Jj(t, e) {
    A("AssignmentPattern", t, e);
  }
  n(Jj, "assertAssignmentPattern");
  function Xj(t, e) {
    A("ArrayPattern", t, e);
  }
  n(Xj, "assertArrayPattern");
  function $j(t, e) {
    A("ArrowFunctionExpression", t, e);
  }
  n($j, "assertArrowFunctionExpression");
  function Hj(t, e) {
    A("ClassBody", t, e);
  }
  n(Hj, "assertClassBody");
  function zj(t, e) {
    A("ClassExpression", t, e);
  }
  n(zj, "assertClassExpression");
  function Gj(t, e) {
    A("ClassDeclaration", t, e);
  }
  n(Gj, "assertClassDeclaration");
  function Qj(t, e) {
    A("ExportAllDeclaration", t, e);
  }
  n(Qj, "assertExportAllDeclaration");
  function Zj(t, e) {
    A("ExportDefaultDeclaration", t, e);
  }
  n(Zj, "assertExportDefaultDeclaration");
  function e8(t, e) {
    A("ExportNamedDeclaration", t, e);
  }
  n(e8, "assertExportNamedDeclaration");
  function t8(t, e) {
    A("ExportSpecifier", t, e);
  }
  n(t8, "assertExportSpecifier");
  function r8(t, e) {
    A("ForOfStatement", t, e);
  }
  n(r8, "assertForOfStatement");
  function s8(t, e) {
    A("ImportDeclaration", t, e);
  }
  n(s8, "assertImportDeclaration");
  function i8(t, e) {
    A("ImportDefaultSpecifier", t, e);
  }
  n(i8, "assertImportDefaultSpecifier");
  function n8(t, e) {
    A("ImportNamespaceSpecifier", t, e);
  }
  n(n8, "assertImportNamespaceSpecifier");
  function a8(t, e) {
    A("ImportSpecifier", t, e);
  }
  n(a8, "assertImportSpecifier");
  function o8(t, e) {
    A("ImportExpression", t, e);
  }
  n(o8, "assertImportExpression");
  function l8(t, e) {
    A("MetaProperty", t, e);
  }
  n(l8, "assertMetaProperty");
  function u8(t, e) {
    A("ClassMethod", t, e);
  }
  n(u8, "assertClassMethod");
  function c8(t, e) {
    A("ObjectPattern", t, e);
  }
  n(c8, "assertObjectPattern");
  function p8(t, e) {
    A("SpreadElement", t, e);
  }
  n(p8, "assertSpreadElement");
  function f8(t, e) {
    A("Super", t, e);
  }
  n(f8, "assertSuper");
  function h8(t, e) {
    A("TaggedTemplateExpression", t, e);
  }
  n(h8, "assertTaggedTemplateExpression");
  function d8(t, e) {
    A("TemplateElement", t, e);
  }
  n(d8, "assertTemplateElement");
  function m8(t, e) {
    A("TemplateLiteral", t, e);
  }
  n(m8, "assertTemplateLiteral");
  function y8(t, e) {
    A("YieldExpression", t, e);
  }
  n(y8, "assertYieldExpression");
  function T8(t, e) {
    A("AwaitExpression", t, e);
  }
  n(T8, "assertAwaitExpression");
  function b8(t, e) {
    A("Import", t, e);
  }
  n(b8, "assertImport");
  function x8(t, e) {
    A("BigIntLiteral", t, e);
  }
  n(x8, "assertBigIntLiteral");
  function S8(t, e) {
    A("ExportNamespaceSpecifier", t, e);
  }
  n(S8, "assertExportNamespaceSpecifier");
  function g8(t, e) {
    A("OptionalMemberExpression", t, e);
  }
  n(g8, "assertOptionalMemberExpression");
  function P8(t, e) {
    A("OptionalCallExpression", t, e);
  }
  n(P8, "assertOptionalCallExpression");
  function E8(t, e) {
    A("ClassProperty", t, e);
  }
  n(E8, "assertClassProperty");
  function A8(t, e) {
    A("ClassAccessorProperty", t, e);
  }
  n(A8, "assertClassAccessorProperty");
  function v8(t, e) {
    A("ClassPrivateProperty", t, e);
  }
  n(v8, "assertClassPrivateProperty");
  function C8(t, e) {
    A("ClassPrivateMethod", t, e);
  }
  n(C8, "assertClassPrivateMethod");
  function I8(t, e) {
    A("PrivateName", t, e);
  }
  n(I8, "assertPrivateName");
  function w8(t, e) {
    A("StaticBlock", t, e);
  }
  n(w8, "assertStaticBlock");
  function N8(t, e) {
    A("AnyTypeAnnotation", t, e);
  }
  n(N8, "assertAnyTypeAnnotation");
  function O8(t, e) {
    A("ArrayTypeAnnotation", t, e);
  }
  n(O8, "assertArrayTypeAnnotation");
  function k8(t, e) {
    A("BooleanTypeAnnotation", t, e);
  }
  n(k8, "assertBooleanTypeAnnotation");
  function D8(t, e) {
    A("BooleanLiteralTypeAnnotation", t, e);
  }
  n(D8, "assertBooleanLiteralTypeAnnotation");
  function _8(t, e) {
    A("NullLiteralTypeAnnotation", t, e);
  }
  n(_8, "assertNullLiteralTypeAnnotation");
  function L8(t, e) {
    A("ClassImplements", t, e);
  }
  n(L8, "assertClassImplements");
  function M8(t, e) {
    A("DeclareClass", t, e);
  }
  n(M8, "assertDeclareClass");
  function B8(t, e) {
    A("DeclareFunction", t, e);
  }
  n(B8, "assertDeclareFunction");
  function F8(t, e) {
    A("DeclareInterface", t, e);
  }
  n(F8, "assertDeclareInterface");
  function j8(t, e) {
    A("DeclareModule", t, e);
  }
  n(j8, "assertDeclareModule");
  function R8(t, e) {
    A("DeclareModuleExports", t, e);
  }
  n(R8, "assertDeclareModuleExports");
  function U8(t, e) {
    A("DeclareTypeAlias", t, e);
  }
  n(U8, "assertDeclareTypeAlias");
  function q8(t, e) {
    A("DeclareOpaqueType", t, e);
  }
  n(q8, "assertDeclareOpaqueType");
  function V8(t, e) {
    A("DeclareVariable", t, e);
  }
  n(V8, "assertDeclareVariable");
  function K8(t, e) {
    A("DeclareExportDeclaration", t, e);
  }
  n(K8, "assertDeclareExportDeclaration");
  function W8(t, e) {
    A("DeclareExportAllDeclaration", t, e);
  }
  n(W8, "assertDeclareExportAllDeclaration");
  function Y8(t, e) {
    A("DeclaredPredicate", t, e);
  }
  n(Y8, "assertDeclaredPredicate");
  function J8(t, e) {
    A("ExistsTypeAnnotation", t, e);
  }
  n(J8, "assertExistsTypeAnnotation");
  function X8(t, e) {
    A("FunctionTypeAnnotation", t, e);
  }
  n(X8, "assertFunctionTypeAnnotation");
  function $8(t, e) {
    A("FunctionTypeParam", t, e);
  }
  n($8, "assertFunctionTypeParam");
  function H8(t, e) {
    A("GenericTypeAnnotation", t, e);
  }
  n(H8, "assertGenericTypeAnnotation");
  function z8(t, e) {
    A("InferredPredicate", t, e);
  }
  n(z8, "assertInferredPredicate");
  function G8(t, e) {
    A("InterfaceExtends", t, e);
  }
  n(G8, "assertInterfaceExtends");
  function Q8(t, e) {
    A("InterfaceDeclaration", t, e);
  }
  n(Q8, "assertInterfaceDeclaration");
  function Z8(t, e) {
    A("InterfaceTypeAnnotation", t, e);
  }
  n(Z8, "assertInterfaceTypeAnnotation");
  function e6(t, e) {
    A("IntersectionTypeAnnotation", t, e);
  }
  n(e6, "assertIntersectionTypeAnnotation");
  function t6(t, e) {
    A("MixedTypeAnnotation", t, e);
  }
  n(t6, "assertMixedTypeAnnotation");
  function r6(t, e) {
    A("EmptyTypeAnnotation", t, e);
  }
  n(r6, "assertEmptyTypeAnnotation");
  function s6(t, e) {
    A("NullableTypeAnnotation", t, e);
  }
  n(s6, "assertNullableTypeAnnotation");
  function i6(t, e) {
    A("NumberLiteralTypeAnnotation", t, e);
  }
  n(i6, "assertNumberLiteralTypeAnnotation");
  function n6(t, e) {
    A("NumberTypeAnnotation", t, e);
  }
  n(n6, "assertNumberTypeAnnotation");
  function a6(t, e) {
    A("ObjectTypeAnnotation", t, e);
  }
  n(a6, "assertObjectTypeAnnotation");
  function o6(t, e) {
    A("ObjectTypeInternalSlot", t, e);
  }
  n(o6, "assertObjectTypeInternalSlot");
  function l6(t, e) {
    A("ObjectTypeCallProperty", t, e);
  }
  n(l6, "assertObjectTypeCallProperty");
  function u6(t, e) {
    A("ObjectTypeIndexer", t, e);
  }
  n(u6, "assertObjectTypeIndexer");
  function c6(t, e) {
    A("ObjectTypeProperty", t, e);
  }
  n(c6, "assertObjectTypeProperty");
  function p6(t, e) {
    A("ObjectTypeSpreadProperty", t, e);
  }
  n(p6, "assertObjectTypeSpreadProperty");
  function f6(t, e) {
    A("OpaqueType", t, e);
  }
  n(f6, "assertOpaqueType");
  function h6(t, e) {
    A("QualifiedTypeIdentifier", t, e);
  }
  n(h6, "assertQualifiedTypeIdentifier");
  function d6(t, e) {
    A("StringLiteralTypeAnnotation", t, e);
  }
  n(d6, "assertStringLiteralTypeAnnotation");
  function m6(t, e) {
    A("StringTypeAnnotation", t, e);
  }
  n(m6, "assertStringTypeAnnotation");
  function y6(t, e) {
    A("SymbolTypeAnnotation", t, e);
  }
  n(y6, "assertSymbolTypeAnnotation");
  function T6(t, e) {
    A("ThisTypeAnnotation", t, e);
  }
  n(T6, "assertThisTypeAnnotation");
  function b6(t, e) {
    A("TupleTypeAnnotation", t, e);
  }
  n(b6, "assertTupleTypeAnnotation");
  function x6(t, e) {
    A("TypeofTypeAnnotation", t, e);
  }
  n(x6, "assertTypeofTypeAnnotation");
  function S6(t, e) {
    A("TypeAlias", t, e);
  }
  n(S6, "assertTypeAlias");
  function g6(t, e) {
    A("TypeAnnotation", t, e);
  }
  n(g6, "assertTypeAnnotation");
  function P6(t, e) {
    A("TypeCastExpression", t, e);
  }
  n(P6, "assertTypeCastExpression");
  function E6(t, e) {
    A("TypeParameter", t, e);
  }
  n(E6, "assertTypeParameter");
  function A6(t, e) {
    A("TypeParameterDeclaration", t, e);
  }
  n(A6, "assertTypeParameterDeclaration");
  function v6(t, e) {
    A("TypeParameterInstantiation", t, e);
  }
  n(v6, "assertTypeParameterInstantiation");
  function C6(t, e) {
    A("UnionTypeAnnotation", t, e);
  }
  n(C6, "assertUnionTypeAnnotation");
  function I6(t, e) {
    A("Variance", t, e);
  }
  n(I6, "assertVariance");
  function w6(t, e) {
    A("VoidTypeAnnotation", t, e);
  }
  n(w6, "assertVoidTypeAnnotation");
  function N6(t, e) {
    A("EnumDeclaration", t, e);
  }
  n(N6, "assertEnumDeclaration");
  function O6(t, e) {
    A("EnumBooleanBody", t, e);
  }
  n(O6, "assertEnumBooleanBody");
  function k6(t, e) {
    A("EnumNumberBody", t, e);
  }
  n(k6, "assertEnumNumberBody");
  function D6(t, e) {
    A("EnumStringBody", t, e);
  }
  n(D6, "assertEnumStringBody");
  function _6(t, e) {
    A("EnumSymbolBody", t, e);
  }
  n(_6, "assertEnumSymbolBody");
  function L6(t, e) {
    A("EnumBooleanMember", t, e);
  }
  n(L6, "assertEnumBooleanMember");
  function M6(t, e) {
    A("EnumNumberMember", t, e);
  }
  n(M6, "assertEnumNumberMember");
  function B6(t, e) {
    A("EnumStringMember", t, e);
  }
  n(B6, "assertEnumStringMember");
  function F6(t, e) {
    A("EnumDefaultedMember", t, e);
  }
  n(F6, "assertEnumDefaultedMember");
  function j6(t, e) {
    A("IndexedAccessType", t, e);
  }
  n(j6, "assertIndexedAccessType");
  function R6(t, e) {
    A("OptionalIndexedAccessType", t, e);
  }
  n(R6, "assertOptionalIndexedAccessType");
  function U6(t, e) {
    A("JSXAttribute", t, e);
  }
  n(U6, "assertJSXAttribute");
  function q6(t, e) {
    A("JSXClosingElement", t, e);
  }
  n(q6, "assertJSXClosingElement");
  function V6(t, e) {
    A("JSXElement", t, e);
  }
  n(V6, "assertJSXElement");
  function K6(t, e) {
    A("JSXEmptyExpression", t, e);
  }
  n(K6, "assertJSXEmptyExpression");
  function W6(t, e) {
    A("JSXExpressionContainer", t, e);
  }
  n(W6, "assertJSXExpressionContainer");
  function Y6(t, e) {
    A("JSXSpreadChild", t, e);
  }
  n(Y6, "assertJSXSpreadChild");
  function J6(t, e) {
    A("JSXIdentifier", t, e);
  }
  n(J6, "assertJSXIdentifier");
  function X6(t, e) {
    A("JSXMemberExpression", t, e);
  }
  n(X6, "assertJSXMemberExpression");
  function $6(t, e) {
    A("JSXNamespacedName", t, e);
  }
  n($6, "assertJSXNamespacedName");
  function H6(t, e) {
    A("JSXOpeningElement", t, e);
  }
  n(H6, "assertJSXOpeningElement");
  function z6(t, e) {
    A("JSXSpreadAttribute", t, e);
  }
  n(z6, "assertJSXSpreadAttribute");
  function G6(t, e) {
    A("JSXText", t, e);
  }
  n(G6, "assertJSXText");
  function Q6(t, e) {
    A("JSXFragment", t, e);
  }
  n(Q6, "assertJSXFragment");
  function Z6(t, e) {
    A("JSXOpeningFragment", t, e);
  }
  n(Z6, "assertJSXOpeningFragment");
  function eR(t, e) {
    A("JSXClosingFragment", t, e);
  }
  n(eR, "assertJSXClosingFragment");
  function tR(t, e) {
    A("Noop", t, e);
  }
  n(tR, "assertNoop");
  function rR(t, e) {
    A("Placeholder", t, e);
  }
  n(rR, "assertPlaceholder");
  function sR(t, e) {
    A("V8IntrinsicIdentifier", t, e);
  }
  n(sR, "assertV8IntrinsicIdentifier");
  function iR(t, e) {
    A("ArgumentPlaceholder", t, e);
  }
  n(iR, "assertArgumentPlaceholder");
  function nR(t, e) {
    A("BindExpression", t, e);
  }
  n(nR, "assertBindExpression");
  function aR(t, e) {
    A("ImportAttribute", t, e);
  }
  n(aR, "assertImportAttribute");
  function oR(t, e) {
    A("Decorator", t, e);
  }
  n(oR, "assertDecorator");
  function lR(t, e) {
    A("DoExpression", t, e);
  }
  n(lR, "assertDoExpression");
  function uR(t, e) {
    A("ExportDefaultSpecifier", t, e);
  }
  n(uR, "assertExportDefaultSpecifier");
  function cR(t, e) {
    A("RecordExpression", t, e);
  }
  n(cR, "assertRecordExpression");
  function pR(t, e) {
    A("TupleExpression", t, e);
  }
  n(pR, "assertTupleExpression");
  function fR(t, e) {
    A("DecimalLiteral", t, e);
  }
  n(fR, "assertDecimalLiteral");
  function hR(t, e) {
    A("ModuleExpression", t, e);
  }
  n(hR, "assertModuleExpression");
  function dR(t, e) {
    A("TopicReference", t, e);
  }
  n(dR, "assertTopicReference");
  function mR(t, e) {
    A("PipelineTopicExpression", t, e);
  }
  n(mR, "assertPipelineTopicExpression");
  function yR(t, e) {
    A("PipelineBareFunction", t, e);
  }
  n(yR, "assertPipelineBareFunction");
  function TR(t, e) {
    A("PipelinePrimaryTopicReference", t, e);
  }
  n(TR, "assertPipelinePrimaryTopicReference");
  function bR(t, e) {
    A("TSParameterProperty", t, e);
  }
  n(bR, "assertTSParameterProperty");
  function xR(t, e) {
    A("TSDeclareFunction", t, e);
  }
  n(xR, "assertTSDeclareFunction");
  function SR(t, e) {
    A("TSDeclareMethod", t, e);
  }
  n(SR, "assertTSDeclareMethod");
  function gR(t, e) {
    A("TSQualifiedName", t, e);
  }
  n(gR, "assertTSQualifiedName");
  function PR(t, e) {
    A("TSCallSignatureDeclaration", t, e);
  }
  n(PR, "assertTSCallSignatureDeclaration");
  function ER(t, e) {
    A("TSConstructSignatureDeclaration", t, e);
  }
  n(ER, "assertTSConstructSignatureDeclaration");
  function AR(t, e) {
    A("TSPropertySignature", t, e);
  }
  n(AR, "assertTSPropertySignature");
  function vR(t, e) {
    A("TSMethodSignature", t, e);
  }
  n(vR, "assertTSMethodSignature");
  function CR(t, e) {
    A("TSIndexSignature", t, e);
  }
  n(CR, "assertTSIndexSignature");
  function IR(t, e) {
    A("TSAnyKeyword", t, e);
  }
  n(IR, "assertTSAnyKeyword");
  function wR(t, e) {
    A("TSBooleanKeyword", t, e);
  }
  n(wR, "assertTSBooleanKeyword");
  function NR(t, e) {
    A("TSBigIntKeyword", t, e);
  }
  n(NR, "assertTSBigIntKeyword");
  function OR(t, e) {
    A("TSIntrinsicKeyword", t, e);
  }
  n(OR, "assertTSIntrinsicKeyword");
  function kR(t, e) {
    A("TSNeverKeyword", t, e);
  }
  n(kR, "assertTSNeverKeyword");
  function DR(t, e) {
    A("TSNullKeyword", t, e);
  }
  n(DR, "assertTSNullKeyword");
  function _R(t, e) {
    A("TSNumberKeyword", t, e);
  }
  n(_R, "assertTSNumberKeyword");
  function LR(t, e) {
    A("TSObjectKeyword", t, e);
  }
  n(LR, "assertTSObjectKeyword");
  function MR(t, e) {
    A("TSStringKeyword", t, e);
  }
  n(MR, "assertTSStringKeyword");
  function BR(t, e) {
    A("TSSymbolKeyword", t, e);
  }
  n(BR, "assertTSSymbolKeyword");
  function FR(t, e) {
    A("TSUndefinedKeyword", t, e);
  }
  n(FR, "assertTSUndefinedKeyword");
  function jR(t, e) {
    A("TSUnknownKeyword", t, e);
  }
  n(jR, "assertTSUnknownKeyword");
  function RR(t, e) {
    A("TSVoidKeyword", t, e);
  }
  n(RR, "assertTSVoidKeyword");
  function UR(t, e) {
    A("TSThisType", t, e);
  }
  n(UR, "assertTSThisType");
  function qR(t, e) {
    A("TSFunctionType", t, e);
  }
  n(qR, "assertTSFunctionType");
  function VR(t, e) {
    A("TSConstructorType", t, e);
  }
  n(VR, "assertTSConstructorType");
  function KR(t, e) {
    A("TSTypeReference", t, e);
  }
  n(KR, "assertTSTypeReference");
  function WR(t, e) {
    A("TSTypePredicate", t, e);
  }
  n(WR, "assertTSTypePredicate");
  function YR(t, e) {
    A("TSTypeQuery", t, e);
  }
  n(YR, "assertTSTypeQuery");
  function JR(t, e) {
    A("TSTypeLiteral", t, e);
  }
  n(JR, "assertTSTypeLiteral");
  function XR(t, e) {
    A("TSArrayType", t, e);
  }
  n(XR, "assertTSArrayType");
  function $R(t, e) {
    A("TSTupleType", t, e);
  }
  n($R, "assertTSTupleType");
  function HR(t, e) {
    A("TSOptionalType", t, e);
  }
  n(HR, "assertTSOptionalType");
  function zR(t, e) {
    A("TSRestType", t, e);
  }
  n(zR, "assertTSRestType");
  function GR(t, e) {
    A("TSNamedTupleMember", t, e);
  }
  n(GR, "assertTSNamedTupleMember");
  function QR(t, e) {
    A("TSUnionType", t, e);
  }
  n(QR, "assertTSUnionType");
  function ZR(t, e) {
    A("TSIntersectionType", t, e);
  }
  n(ZR, "assertTSIntersectionType");
  function e9(t, e) {
    A("TSConditionalType", t, e);
  }
  n(e9, "assertTSConditionalType");
  function t9(t, e) {
    A("TSInferType", t, e);
  }
  n(t9, "assertTSInferType");
  function r9(t, e) {
    A("TSParenthesizedType", t, e);
  }
  n(r9, "assertTSParenthesizedType");
  function s9(t, e) {
    A("TSTypeOperator", t, e);
  }
  n(s9, "assertTSTypeOperator");
  function i9(t, e) {
    A("TSIndexedAccessType", t, e);
  }
  n(i9, "assertTSIndexedAccessType");
  function n9(t, e) {
    A("TSMappedType", t, e);
  }
  n(n9, "assertTSMappedType");
  function a9(t, e) {
    A("TSLiteralType", t, e);
  }
  n(a9, "assertTSLiteralType");
  function o9(t, e) {
    A("TSExpressionWithTypeArguments", t, e);
  }
  n(o9, "assertTSExpressionWithTypeArguments");
  function l9(t, e) {
    A("TSInterfaceDeclaration", t, e);
  }
  n(l9, "assertTSInterfaceDeclaration");
  function u9(t, e) {
    A("TSInterfaceBody", t, e);
  }
  n(u9, "assertTSInterfaceBody");
  function c9(t, e) {
    A("TSTypeAliasDeclaration", t, e);
  }
  n(c9, "assertTSTypeAliasDeclaration");
  function p9(t, e) {
    A("TSInstantiationExpression", t, e);
  }
  n(p9, "assertTSInstantiationExpression");
  function f9(t, e) {
    A("TSAsExpression", t, e);
  }
  n(f9, "assertTSAsExpression");
  function h9(t, e) {
    A("TSSatisfiesExpression", t, e);
  }
  n(h9, "assertTSSatisfiesExpression");
  function d9(t, e) {
    A("TSTypeAssertion", t, e);
  }
  n(d9, "assertTSTypeAssertion");
  function m9(t, e) {
    A("TSEnumDeclaration", t, e);
  }
  n(m9, "assertTSEnumDeclaration");
  function y9(t, e) {
    A("TSEnumMember", t, e);
  }
  n(y9, "assertTSEnumMember");
  function T9(t, e) {
    A("TSModuleDeclaration", t, e);
  }
  n(T9, "assertTSModuleDeclaration");
  function b9(t, e) {
    A("TSModuleBlock", t, e);
  }
  n(b9, "assertTSModuleBlock");
  function x9(t, e) {
    A("TSImportType", t, e);
  }
  n(x9, "assertTSImportType");
  function S9(t, e) {
    A("TSImportEqualsDeclaration", t, e);
  }
  n(S9, "assertTSImportEqualsDeclaration");
  function g9(t, e) {
    A("TSExternalModuleReference", t, e);
  }
  n(g9, "assertTSExternalModuleReference");
  function P9(t, e) {
    A("TSNonNullExpression", t, e);
  }
  n(P9, "assertTSNonNullExpression");
  function E9(t, e) {
    A("TSExportAssignment", t, e);
  }
  n(E9, "assertTSExportAssignment");
  function A9(t, e) {
    A("TSNamespaceExportDeclaration", t, e);
  }
  n(A9, "assertTSNamespaceExportDeclaration");
  function v9(t, e) {
    A("TSTypeAnnotation", t, e);
  }
  n(v9, "assertTSTypeAnnotation");
  function C9(t, e) {
    A("TSTypeParameterInstantiation", t, e);
  }
  n(C9, "assertTSTypeParameterInstantiation");
  function I9(t, e) {
    A("TSTypeParameterDeclaration", t, e);
  }
  n(I9, "assertTSTypeParameterDeclaration");
  function w9(t, e) {
    A("TSTypeParameter", t, e);
  }
  n(w9, "assertTSTypeParameter");
  function N9(t, e) {
    A("Standardized", t, e);
  }
  n(N9, "assertStandardized");
  function O9(t, e) {
    A("Expression", t, e);
  }
  n(O9, "assertExpression");
  function k9(t, e) {
    A("Binary", t, e);
  }
  n(k9, "assertBinary");
  function D9(t, e) {
    A("Scopable", t, e);
  }
  n(D9, "assertScopable");
  function _9(t, e) {
    A("BlockParent", t, e);
  }
  n(_9, "assertBlockParent");
  function L9(t, e) {
    A("Block", t, e);
  }
  n(L9, "assertBlock");
  function M9(t, e) {
    A("Statement", t, e);
  }
  n(M9, "assertStatement");
  function B9(t, e) {
    A("Terminatorless", t, e);
  }
  n(B9, "assertTerminatorless");
  function F9(t, e) {
    A("CompletionStatement", t, e);
  }
  n(F9, "assertCompletionStatement");
  function j9(t, e) {
    A("Conditional", t, e);
  }
  n(j9, "assertConditional");
  function R9(t, e) {
    A("Loop", t, e);
  }
  n(R9, "assertLoop");
  function U9(t, e) {
    A("While", t, e);
  }
  n(U9, "assertWhile");
  function q9(t, e) {
    A("ExpressionWrapper", t, e);
  }
  n(q9, "assertExpressionWrapper");
  function V9(t, e) {
    A("For", t, e);
  }
  n(V9, "assertFor");
  function K9(t, e) {
    A("ForXStatement", t, e);
  }
  n(K9, "assertForXStatement");
  function W9(t, e) {
    A("Function", t, e);
  }
  n(W9, "assertFunction");
  function Y9(t, e) {
    A("FunctionParent", t, e);
  }
  n(Y9, "assertFunctionParent");
  function J9(t, e) {
    A("Pureish", t, e);
  }
  n(J9, "assertPureish");
  function X9(t, e) {
    A("Declaration", t, e);
  }
  n(X9, "assertDeclaration");
  function $9(t, e) {
    A("PatternLike", t, e);
  }
  n($9, "assertPatternLike");
  function H9(t, e) {
    A("LVal", t, e);
  }
  n(H9, "assertLVal");
  function z9(t, e) {
    A("TSEntityName", t, e);
  }
  n(z9, "assertTSEntityName");
  function G9(t, e) {
    A("Literal", t, e);
  }
  n(G9, "assertLiteral");
  function Q9(t, e) {
    A("Immutable", t, e);
  }
  n(Q9, "assertImmutable");
  function Z9(t, e) {
    A("UserWhitespacable", t, e);
  }
  n(Z9, "assertUserWhitespacable");
  function e7(t, e) {
    A("Method", t, e);
  }
  n(e7, "assertMethod");
  function t7(t, e) {
    A("ObjectMember", t, e);
  }
  n(t7, "assertObjectMember");
  function r7(t, e) {
    A("Property", t, e);
  }
  n(r7, "assertProperty");
  function s7(t, e) {
    A("UnaryLike", t, e);
  }
  n(s7, "assertUnaryLike");
  function i7(t, e) {
    A("Pattern", t, e);
  }
  n(i7, "assertPattern");
  function n7(t, e) {
    A("Class", t, e);
  }
  n(n7, "assertClass");
  function a7(t, e) {
    A("ImportOrExportDeclaration", t, e);
  }
  n(a7, "assertImportOrExportDeclaration");
  function o7(t, e) {
    A("ExportDeclaration", t, e);
  }
  n(o7, "assertExportDeclaration");
  function l7(t, e) {
    A("ModuleSpecifier", t, e);
  }
  n(l7, "assertModuleSpecifier");
  function u7(t, e) {
    A("Accessor", t, e);
  }
  n(u7, "assertAccessor");
  function c7(t, e) {
    A("Private", t, e);
  }
  n(c7, "assertPrivate");
  function p7(t, e) {
    A("Flow", t, e);
  }
  n(p7, "assertFlow");
  function f7(t, e) {
    A("FlowType", t, e);
  }
  n(f7, "assertFlowType");
  function h7(t, e) {
    A("FlowBaseAnnotation", t, e);
  }
  n(h7, "assertFlowBaseAnnotation");
  function d7(t, e) {
    A("FlowDeclaration", t, e);
  }
  n(d7, "assertFlowDeclaration");
  function m7(t, e) {
    A("FlowPredicate", t, e);
  }
  n(m7, "assertFlowPredicate");
  function y7(t, e) {
    A("EnumBody", t, e);
  }
  n(y7, "assertEnumBody");
  function T7(t, e) {
    A("EnumMember", t, e);
  }
  n(T7, "assertEnumMember");
  function b7(t, e) {
    A("JSX", t, e);
  }
  n(b7, "assertJSX");
  function x7(t, e) {
    A("Miscellaneous", t, e);
  }
  n(x7, "assertMiscellaneous");
  function S7(t, e) {
    A("TypeScript", t, e);
  }
  n(S7, "assertTypeScript");
  function g7(t, e) {
    A("TSTypeElement", t, e);
  }
  n(g7, "assertTSTypeElement");
  function P7(t, e) {
    A("TSType", t, e);
  }
  n(P7, "assertTSType");
  function E7(t, e) {
    A("TSBaseType", t, e);
  }
  n(E7, "assertTSBaseType");
  function A7(t, e) {
    (0, Pa.default)("assertNumberLiteral", "assertNumericLiteral"), A("NumberLiteral", t, e);
  }
  n(A7, "assertNumberLiteral");
  function v7(t, e) {
    (0, Pa.default)("assertRegexLiteral", "assertRegExpLiteral"), A("RegexLiteral", t, e);
  }
  n(v7, "assertRegexLiteral");
  function C7(t, e) {
    (0, Pa.default)("assertRestProperty", "assertRestElement"), A("RestProperty", t, e);
  }
  n(C7, "assertRestProperty");
  function I7(t, e) {
    (0, Pa.default)("assertSpreadProperty", "assertSpreadElement"), A("SpreadProperty", t, e);
  }
  n(I7, "assertSpreadProperty");
  function w7(t, e) {
    (0, Pa.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), A("ModuleDeclaration", t, e);
  }
  n(w7, "assertModuleDeclaration");
});

// ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var tS = w((El) => {
  "use strict";
  Object.defineProperty(El, "__esModule", {
    value: !0
  });
  El.default = void 0;
  var Yr = pr(), MMe = El.default = N7;
  function N7(t) {
    switch (t) {
      case "string":
        return (0, Yr.stringTypeAnnotation)();
      case "number":
        return (0, Yr.numberTypeAnnotation)();
      case "undefined":
        return (0, Yr.voidTypeAnnotation)();
      case "boolean":
        return (0, Yr.booleanTypeAnnotation)();
      case "function":
        return (0, Yr.genericTypeAnnotation)((0, Yr.identifier)("Function"));
      case "object":
        return (0, Yr.genericTypeAnnotation)((0, Yr.identifier)("Object"));
      case "symbol":
        return (0, Yr.genericTypeAnnotation)((0, Yr.identifier)("Symbol"));
      case "bigint":
        return (0, Yr.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + t);
  }
  n(N7, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var qp = w((Up) => {
  "use strict";
  Object.defineProperty(Up, "__esModule", {
    value: !0
  });
  Up.default = sS;
  var Ea = jt();
  function rS(t) {
    return (0, Ea.isIdentifier)(t) ? t.name : `${t.id.name}.${rS(t.qualification)}`;
  }
  n(rS, "getQualifiedName");
  function sS(t) {
    let e = Array.from(t), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, Ea.isAnyTypeAnnotation)(l))
          return [l];
        if ((0, Ea.isFlowBaseAnnotation)(l)) {
          s.set(l.type, l);
          continue;
        }
        if ((0, Ea.isUnionTypeAnnotation)(l)) {
          i.has(l.types) || (e.push(...l.types), i.add(l.types));
          continue;
        }
        if ((0, Ea.isGenericTypeAnnotation)(l)) {
          let u = rS(l.id);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = sS(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of s)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  n(sS, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var iS = w((Vp) => {
  "use strict";
  Object.defineProperty(Vp, "__esModule", {
    value: !0
  });
  Vp.default = D7;
  var O7 = pr(), k7 = qp();
  function D7(t) {
    let e = (0, k7.default)(t);
    return e.length === 1 ? e[0] : (0, O7.unionTypeAnnotation)(e);
  }
  n(D7, "createFlowUnionType");
});

// ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var oS = w((Kp) => {
  "use strict";
  Object.defineProperty(Kp, "__esModule", {
    value: !0
  });
  Kp.default = aS;
  var Aa = jt();
  function nS(t) {
    return (0, Aa.isIdentifier)(t) ? t.name : `${t.right.name}.${nS(t.left)}`;
  }
  n(nS, "getQualifiedName");
  function aS(t) {
    let e = Array.from(t), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, Aa.isTSAnyKeyword)(l))
          return [l];
        if ((0, Aa.isTSBaseType)(l)) {
          s.set(l.type, l);
          continue;
        }
        if ((0, Aa.isTSUnionType)(l)) {
          i.has(l.types) || (e.push(...l.types), i.add(l.types));
          continue;
        }
        if ((0, Aa.isTSTypeReference)(l) && l.typeParameters) {
          let u = nS(l.typeName);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = aS(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of s)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  n(aS, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var lS = w((Wp) => {
  "use strict";
  Object.defineProperty(Wp, "__esModule", {
    value: !0
  });
  Wp.default = B7;
  var _7 = pr(), L7 = oS(), M7 = jt();
  function B7(t) {
    let e = t.map((s) => (0, M7.isTSTypeAnnotation)(s) ? s.typeAnnotation : s), r = (0, L7.default)(e);
    return r.length === 1 ? r[0] : (0, _7.tsUnionType)(r);
  }
  n(B7, "createTSUnionType");
});

// ../node_modules/@babel/types/lib/builders/generated/uppercase.js
var uS = w((N) => {
  "use strict";
  Object.defineProperty(N, "__esModule", {
    value: !0
  });
  Object.defineProperty(N, "AnyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.anyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "ArgumentPlaceholder", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.argumentPlaceholder;
    }, "get")
  });
  Object.defineProperty(N, "ArrayExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.arrayExpression;
    }, "get")
  });
  Object.defineProperty(N, "ArrayPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.arrayPattern;
    }, "get")
  });
  Object.defineProperty(N, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.arrayTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "ArrowFunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.arrowFunctionExpression;
    }, "get")
  });
  Object.defineProperty(N, "AssignmentExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.assignmentExpression;
    }, "get")
  });
  Object.defineProperty(N, "AssignmentPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.assignmentPattern;
    }, "get")
  });
  Object.defineProperty(N, "AwaitExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.awaitExpression;
    }, "get")
  });
  Object.defineProperty(N, "BigIntLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.bigIntLiteral;
    }, "get")
  });
  Object.defineProperty(N, "BinaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.binaryExpression;
    }, "get")
  });
  Object.defineProperty(N, "BindExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.bindExpression;
    }, "get")
  });
  Object.defineProperty(N, "BlockStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.blockStatement;
    }, "get")
  });
  Object.defineProperty(N, "BooleanLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.booleanLiteral;
    }, "get")
  });
  Object.defineProperty(N, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.booleanLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.booleanTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "BreakStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.breakStatement;
    }, "get")
  });
  Object.defineProperty(N, "CallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.callExpression;
    }, "get")
  });
  Object.defineProperty(N, "CatchClause", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.catchClause;
    }, "get")
  });
  Object.defineProperty(N, "ClassAccessorProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classAccessorProperty;
    }, "get")
  });
  Object.defineProperty(N, "ClassBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classBody;
    }, "get")
  });
  Object.defineProperty(N, "ClassDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "ClassExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classExpression;
    }, "get")
  });
  Object.defineProperty(N, "ClassImplements", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classImplements;
    }, "get")
  });
  Object.defineProperty(N, "ClassMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classMethod;
    }, "get")
  });
  Object.defineProperty(N, "ClassPrivateMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classPrivateMethod;
    }, "get")
  });
  Object.defineProperty(N, "ClassPrivateProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classPrivateProperty;
    }, "get")
  });
  Object.defineProperty(N, "ClassProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classProperty;
    }, "get")
  });
  Object.defineProperty(N, "ConditionalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.conditionalExpression;
    }, "get")
  });
  Object.defineProperty(N, "ContinueStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.continueStatement;
    }, "get")
  });
  Object.defineProperty(N, "DebuggerStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.debuggerStatement;
    }, "get")
  });
  Object.defineProperty(N, "DecimalLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.decimalLiteral;
    }, "get")
  });
  Object.defineProperty(N, "DeclareClass", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareClass;
    }, "get")
  });
  Object.defineProperty(N, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareExportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "DeclareExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareExportDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "DeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareFunction;
    }, "get")
  });
  Object.defineProperty(N, "DeclareInterface", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareInterface;
    }, "get")
  });
  Object.defineProperty(N, "DeclareModule", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareModule;
    }, "get")
  });
  Object.defineProperty(N, "DeclareModuleExports", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareModuleExports;
    }, "get")
  });
  Object.defineProperty(N, "DeclareOpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareOpaqueType;
    }, "get")
  });
  Object.defineProperty(N, "DeclareTypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareTypeAlias;
    }, "get")
  });
  Object.defineProperty(N, "DeclareVariable", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareVariable;
    }, "get")
  });
  Object.defineProperty(N, "DeclaredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declaredPredicate;
    }, "get")
  });
  Object.defineProperty(N, "Decorator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.decorator;
    }, "get")
  });
  Object.defineProperty(N, "Directive", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.directive;
    }, "get")
  });
  Object.defineProperty(N, "DirectiveLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.directiveLiteral;
    }, "get")
  });
  Object.defineProperty(N, "DoExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.doExpression;
    }, "get")
  });
  Object.defineProperty(N, "DoWhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.doWhileStatement;
    }, "get")
  });
  Object.defineProperty(N, "EmptyStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.emptyStatement;
    }, "get")
  });
  Object.defineProperty(N, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.emptyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "EnumBooleanBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumBooleanBody;
    }, "get")
  });
  Object.defineProperty(N, "EnumBooleanMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumBooleanMember;
    }, "get")
  });
  Object.defineProperty(N, "EnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "EnumDefaultedMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumDefaultedMember;
    }, "get")
  });
  Object.defineProperty(N, "EnumNumberBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumNumberBody;
    }, "get")
  });
  Object.defineProperty(N, "EnumNumberMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumNumberMember;
    }, "get")
  });
  Object.defineProperty(N, "EnumStringBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumStringBody;
    }, "get")
  });
  Object.defineProperty(N, "EnumStringMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumStringMember;
    }, "get")
  });
  Object.defineProperty(N, "EnumSymbolBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumSymbolBody;
    }, "get")
  });
  Object.defineProperty(N, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.existsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "ExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.exportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.exportDefaultDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.exportDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(N, "ExportNamedDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.exportNamedDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.exportNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(N, "ExportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.exportSpecifier;
    }, "get")
  });
  Object.defineProperty(N, "ExpressionStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.expressionStatement;
    }, "get")
  });
  Object.defineProperty(N, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.file;
    }, "get")
  });
  Object.defineProperty(N, "ForInStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.forInStatement;
    }, "get")
  });
  Object.defineProperty(N, "ForOfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.forOfStatement;
    }, "get")
  });
  Object.defineProperty(N, "ForStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.forStatement;
    }, "get")
  });
  Object.defineProperty(N, "FunctionDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.functionDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "FunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.functionExpression;
    }, "get")
  });
  Object.defineProperty(N, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.functionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "FunctionTypeParam", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.functionTypeParam;
    }, "get")
  });
  Object.defineProperty(N, "GenericTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.genericTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.identifier;
    }, "get")
  });
  Object.defineProperty(N, "IfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.ifStatement;
    }, "get")
  });
  Object.defineProperty(N, "Import", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.import;
    }, "get")
  });
  Object.defineProperty(N, "ImportAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.importAttribute;
    }, "get")
  });
  Object.defineProperty(N, "ImportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.importDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.importDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(N, "ImportExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.importExpression;
    }, "get")
  });
  Object.defineProperty(N, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.importNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(N, "ImportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.importSpecifier;
    }, "get")
  });
  Object.defineProperty(N, "IndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.indexedAccessType;
    }, "get")
  });
  Object.defineProperty(N, "InferredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.inferredPredicate;
    }, "get")
  });
  Object.defineProperty(N, "InterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.interfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "InterfaceExtends", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.interfaceExtends;
    }, "get")
  });
  Object.defineProperty(N, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.interfaceTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "InterpreterDirective", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.interpreterDirective;
    }, "get")
  });
  Object.defineProperty(N, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.intersectionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "JSXAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxAttribute;
    }, "get")
  });
  Object.defineProperty(N, "JSXClosingElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxClosingElement;
    }, "get")
  });
  Object.defineProperty(N, "JSXClosingFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxClosingFragment;
    }, "get")
  });
  Object.defineProperty(N, "JSXElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxElement;
    }, "get")
  });
  Object.defineProperty(N, "JSXEmptyExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxEmptyExpression;
    }, "get")
  });
  Object.defineProperty(N, "JSXExpressionContainer", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxExpressionContainer;
    }, "get")
  });
  Object.defineProperty(N, "JSXFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxFragment;
    }, "get")
  });
  Object.defineProperty(N, "JSXIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxIdentifier;
    }, "get")
  });
  Object.defineProperty(N, "JSXMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxMemberExpression;
    }, "get")
  });
  Object.defineProperty(N, "JSXNamespacedName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxNamespacedName;
    }, "get")
  });
  Object.defineProperty(N, "JSXOpeningElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxOpeningElement;
    }, "get")
  });
  Object.defineProperty(N, "JSXOpeningFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxOpeningFragment;
    }, "get")
  });
  Object.defineProperty(N, "JSXSpreadAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxSpreadAttribute;
    }, "get")
  });
  Object.defineProperty(N, "JSXSpreadChild", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxSpreadChild;
    }, "get")
  });
  Object.defineProperty(N, "JSXText", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxText;
    }, "get")
  });
  Object.defineProperty(N, "LabeledStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.labeledStatement;
    }, "get")
  });
  Object.defineProperty(N, "LogicalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.logicalExpression;
    }, "get")
  });
  Object.defineProperty(N, "MemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.memberExpression;
    }, "get")
  });
  Object.defineProperty(N, "MetaProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.metaProperty;
    }, "get")
  });
  Object.defineProperty(N, "MixedTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.mixedTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "ModuleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.moduleExpression;
    }, "get")
  });
  Object.defineProperty(N, "NewExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.newExpression;
    }, "get")
  });
  Object.defineProperty(N, "Noop", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.noop;
    }, "get")
  });
  Object.defineProperty(N, "NullLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.nullLiteral;
    }, "get")
  });
  Object.defineProperty(N, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.nullLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "NullableTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.nullableTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "NumberLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.numberLiteral;
    }, "get")
  });
  Object.defineProperty(N, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.numberLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "NumberTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.numberTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "NumericLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.numericLiteral;
    }, "get")
  });
  Object.defineProperty(N, "ObjectExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectExpression;
    }, "get")
  });
  Object.defineProperty(N, "ObjectMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectMethod;
    }, "get")
  });
  Object.defineProperty(N, "ObjectPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectPattern;
    }, "get")
  });
  Object.defineProperty(N, "ObjectProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectProperty;
    }, "get")
  });
  Object.defineProperty(N, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectTypeCallProperty;
    }, "get")
  });
  Object.defineProperty(N, "ObjectTypeIndexer", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectTypeIndexer;
    }, "get")
  });
  Object.defineProperty(N, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectTypeInternalSlot;
    }, "get")
  });
  Object.defineProperty(N, "ObjectTypeProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectTypeProperty;
    }, "get")
  });
  Object.defineProperty(N, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectTypeSpreadProperty;
    }, "get")
  });
  Object.defineProperty(N, "OpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.opaqueType;
    }, "get")
  });
  Object.defineProperty(N, "OptionalCallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.optionalCallExpression;
    }, "get")
  });
  Object.defineProperty(N, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.optionalIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(N, "OptionalMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.optionalMemberExpression;
    }, "get")
  });
  Object.defineProperty(N, "ParenthesizedExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.parenthesizedExpression;
    }, "get")
  });
  Object.defineProperty(N, "PipelineBareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.pipelineBareFunction;
    }, "get")
  });
  Object.defineProperty(N, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.pipelinePrimaryTopicReference;
    }, "get")
  });
  Object.defineProperty(N, "PipelineTopicExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.pipelineTopicExpression;
    }, "get")
  });
  Object.defineProperty(N, "Placeholder", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.placeholder;
    }, "get")
  });
  Object.defineProperty(N, "PrivateName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.privateName;
    }, "get")
  });
  Object.defineProperty(N, "Program", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.program;
    }, "get")
  });
  Object.defineProperty(N, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.qualifiedTypeIdentifier;
    }, "get")
  });
  Object.defineProperty(N, "RecordExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.recordExpression;
    }, "get")
  });
  Object.defineProperty(N, "RegExpLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.regExpLiteral;
    }, "get")
  });
  Object.defineProperty(N, "RegexLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.regexLiteral;
    }, "get")
  });
  Object.defineProperty(N, "RestElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.restElement;
    }, "get")
  });
  Object.defineProperty(N, "RestProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.restProperty;
    }, "get")
  });
  Object.defineProperty(N, "ReturnStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.returnStatement;
    }, "get")
  });
  Object.defineProperty(N, "SequenceExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.sequenceExpression;
    }, "get")
  });
  Object.defineProperty(N, "SpreadElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.spreadElement;
    }, "get")
  });
  Object.defineProperty(N, "SpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.spreadProperty;
    }, "get")
  });
  Object.defineProperty(N, "StaticBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.staticBlock;
    }, "get")
  });
  Object.defineProperty(N, "StringLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.stringLiteral;
    }, "get")
  });
  Object.defineProperty(N, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.stringLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "StringTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.stringTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "Super", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.super;
    }, "get")
  });
  Object.defineProperty(N, "SwitchCase", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.switchCase;
    }, "get")
  });
  Object.defineProperty(N, "SwitchStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.switchStatement;
    }, "get")
  });
  Object.defineProperty(N, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.symbolTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "TSAnyKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsAnyKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSArrayType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsArrayType;
    }, "get")
  });
  Object.defineProperty(N, "TSAsExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsAsExpression;
    }, "get")
  });
  Object.defineProperty(N, "TSBigIntKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsBigIntKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSBooleanKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsBooleanKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsCallSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSConditionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsConditionalType;
    }, "get")
  });
  Object.defineProperty(N, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsConstructSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSConstructorType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsConstructorType;
    }, "get")
  });
  Object.defineProperty(N, "TSDeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsDeclareFunction;
    }, "get")
  });
  Object.defineProperty(N, "TSDeclareMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsDeclareMethod;
    }, "get")
  });
  Object.defineProperty(N, "TSEnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsEnumDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSEnumMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsEnumMember;
    }, "get")
  });
  Object.defineProperty(N, "TSExportAssignment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsExportAssignment;
    }, "get")
  });
  Object.defineProperty(N, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsExpressionWithTypeArguments;
    }, "get")
  });
  Object.defineProperty(N, "TSExternalModuleReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsExternalModuleReference;
    }, "get")
  });
  Object.defineProperty(N, "TSFunctionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsFunctionType;
    }, "get")
  });
  Object.defineProperty(N, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsImportEqualsDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSImportType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsImportType;
    }, "get")
  });
  Object.defineProperty(N, "TSIndexSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsIndexSignature;
    }, "get")
  });
  Object.defineProperty(N, "TSIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(N, "TSInferType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsInferType;
    }, "get")
  });
  Object.defineProperty(N, "TSInstantiationExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsInstantiationExpression;
    }, "get")
  });
  Object.defineProperty(N, "TSInterfaceBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsInterfaceBody;
    }, "get")
  });
  Object.defineProperty(N, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsInterfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSIntersectionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsIntersectionType;
    }, "get")
  });
  Object.defineProperty(N, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsIntrinsicKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsLiteralType;
    }, "get")
  });
  Object.defineProperty(N, "TSMappedType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsMappedType;
    }, "get")
  });
  Object.defineProperty(N, "TSMethodSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsMethodSignature;
    }, "get")
  });
  Object.defineProperty(N, "TSModuleBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsModuleBlock;
    }, "get")
  });
  Object.defineProperty(N, "TSModuleDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsModuleDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSNamedTupleMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsNamedTupleMember;
    }, "get")
  });
  Object.defineProperty(N, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsNamespaceExportDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSNeverKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsNeverKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSNonNullExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsNonNullExpression;
    }, "get")
  });
  Object.defineProperty(N, "TSNullKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsNullKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSNumberKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsNumberKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSObjectKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsObjectKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSOptionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsOptionalType;
    }, "get")
  });
  Object.defineProperty(N, "TSParameterProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsParameterProperty;
    }, "get")
  });
  Object.defineProperty(N, "TSParenthesizedType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsParenthesizedType;
    }, "get")
  });
  Object.defineProperty(N, "TSPropertySignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsPropertySignature;
    }, "get")
  });
  Object.defineProperty(N, "TSQualifiedName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsQualifiedName;
    }, "get")
  });
  Object.defineProperty(N, "TSRestType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsRestType;
    }, "get")
  });
  Object.defineProperty(N, "TSSatisfiesExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsSatisfiesExpression;
    }, "get")
  });
  Object.defineProperty(N, "TSStringKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsStringKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSSymbolKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsSymbolKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSThisType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsThisType;
    }, "get")
  });
  Object.defineProperty(N, "TSTupleType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTupleType;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeAliasDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeAssertion", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeAssertion;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeLiteral;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeOperator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeOperator;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeParameter;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(N, "TSTypePredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypePredicate;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeQuery", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeQuery;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeReference;
    }, "get")
  });
  Object.defineProperty(N, "TSUndefinedKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsUndefinedKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsUnionType;
    }, "get")
  });
  Object.defineProperty(N, "TSUnknownKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsUnknownKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSVoidKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsVoidKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TaggedTemplateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.taggedTemplateExpression;
    }, "get")
  });
  Object.defineProperty(N, "TemplateElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.templateElement;
    }, "get")
  });
  Object.defineProperty(N, "TemplateLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.templateLiteral;
    }, "get")
  });
  Object.defineProperty(N, "ThisExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.thisExpression;
    }, "get")
  });
  Object.defineProperty(N, "ThisTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.thisTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "ThrowStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.throwStatement;
    }, "get")
  });
  Object.defineProperty(N, "TopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.topicReference;
    }, "get")
  });
  Object.defineProperty(N, "TryStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tryStatement;
    }, "get")
  });
  Object.defineProperty(N, "TupleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tupleExpression;
    }, "get")
  });
  Object.defineProperty(N, "TupleTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tupleTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "TypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeAlias;
    }, "get")
  });
  Object.defineProperty(N, "TypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "TypeCastExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeCastExpression;
    }, "get")
  });
  Object.defineProperty(N, "TypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeParameter;
    }, "get")
  });
  Object.defineProperty(N, "TypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(N, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeofTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "UnaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.unaryExpression;
    }, "get")
  });
  Object.defineProperty(N, "UnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.unionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "UpdateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.updateExpression;
    }, "get")
  });
  Object.defineProperty(N, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.v8IntrinsicIdentifier;
    }, "get")
  });
  Object.defineProperty(N, "VariableDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.variableDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "VariableDeclarator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.variableDeclarator;
    }, "get")
  });
  Object.defineProperty(N, "Variance", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.variance;
    }, "get")
  });
  Object.defineProperty(N, "VoidTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.voidTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "WhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.whileStatement;
    }, "get")
  });
  Object.defineProperty(N, "WithStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.withStatement;
    }, "get")
  });
  Object.defineProperty(N, "YieldExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.yieldExpression;
    }, "get")
  });
  var k = pr();
});

// ../node_modules/@babel/types/lib/builders/productions.js
var Jp = w((Yp) => {
  "use strict";
  Object.defineProperty(Yp, "__esModule", {
    value: !0
  });
  Yp.buildUndefinedNode = F7;
  var cS = pr();
  function F7() {
    return (0, cS.unaryExpression)("void", (0, cS.numericLiteral)(0), !0);
  }
  n(F7, "buildUndefinedNode");
});

// ../node_modules/@babel/types/lib/clone/cloneNode.js
var $s = w((Xp) => {
  "use strict";
  Object.defineProperty(Xp, "__esModule", {
    value: !0
  });
  Xp.default = j7;
  var pS = Br(), fS = jt(), {
    hasOwn: ms
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function hS(t, e, r, s) {
    return t && typeof t.type == "string" ? mS(t, e, r, s) : t;
  }
  n(hS, "cloneIfNode");
  function dS(t, e, r, s) {
    return Array.isArray(t) ? t.map((i) => hS(i, e, r, s)) : hS(t, e, r, s);
  }
  n(dS, "cloneIfNodeOrArray");
  function j7(t, e = !0, r = !1) {
    return mS(t, e, r, /* @__PURE__ */ new Map());
  }
  n(j7, "cloneNode");
  function mS(t, e = !0, r = !1, s) {
    if (!t) return t;
    let {
      type: i
    } = t, a = {
      type: t.type
    };
    if ((0, fS.isIdentifier)(t))
      a.name = t.name, ms(t, "optional") && typeof t.optional == "boolean" && (a.optional = t.optional), ms(t, "typeAnnotation") && (a.typeAnnotation =
      e ? dS(t.typeAnnotation, !0, r, s) : t.typeAnnotation);
    else if (ms(pS.NODE_FIELDS, i))
      for (let o of Object.keys(pS.NODE_FIELDS[i]))
        ms(t, o) && (e ? a[o] = (0, fS.isFile)(t) && o === "comments" ? Al(t.comments, e, r, s) : dS(t[o], !0, r, s) : a[o] = t[o]);
    else
      throw new Error(`Unknown node type: "${i}"`);
    return ms(t, "loc") && (r ? a.loc = null : a.loc = t.loc), ms(t, "leadingComments") && (a.leadingComments = Al(t.leadingComments, e, r, s)),
    ms(t, "innerComments") && (a.innerComments = Al(t.innerComments, e, r, s)), ms(t, "trailingComments") && (a.trailingComments = Al(t.trailingComments,
    e, r, s)), ms(t, "extra") && (a.extra = Object.assign({}, t.extra)), a;
  }
  n(mS, "cloneNodeInternal");
  function Al(t, e, r, s) {
    return !t || !e ? t : t.map((i) => {
      let a = s.get(i);
      if (a) return a;
      let {
        type: o,
        value: l,
        loc: u
      } = i, c = {
        type: o,
        value: l,
        loc: u
      };
      return r && (c.loc = null), s.set(i, c), c;
    });
  }
  n(Al, "maybeCloneComments");
});

// ../node_modules/@babel/types/lib/clone/clone.js
var yS = w(($p) => {
  "use strict";
  Object.defineProperty($p, "__esModule", {
    value: !0
  });
  $p.default = U7;
  var R7 = $s();
  function U7(t) {
    return (0, R7.default)(t, !1);
  }
  n(U7, "clone");
});

// ../node_modules/@babel/types/lib/clone/cloneDeep.js
var TS = w((Hp) => {
  "use strict";
  Object.defineProperty(Hp, "__esModule", {
    value: !0
  });
  Hp.default = V7;
  var q7 = $s();
  function V7(t) {
    return (0, q7.default)(t);
  }
  n(V7, "cloneDeep");
});

// ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var bS = w((zp) => {
  "use strict";
  Object.defineProperty(zp, "__esModule", {
    value: !0
  });
  zp.default = W7;
  var K7 = $s();
  function W7(t) {
    return (0, K7.default)(t, !0, !0);
  }
  n(W7, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var xS = w((Gp) => {
  "use strict";
  Object.defineProperty(Gp, "__esModule", {
    value: !0
  });
  Gp.default = J7;
  var Y7 = $s();
  function J7(t) {
    return (0, Y7.default)(t, !1, !0);
  }
  n(J7, "cloneWithoutLoc");
});

// ../node_modules/@babel/types/lib/comments/addComments.js
var Zp = w((Qp) => {
  "use strict";
  Object.defineProperty(Qp, "__esModule", {
    value: !0
  });
  Qp.default = X7;
  function X7(t, e, r) {
    if (!r || !t) return t;
    let s = `${e}Comments`;
    return t[s] ? e === "leading" ? t[s] = r.concat(t[s]) : t[s].push(...r) : t[s] = r, t;
  }
  n(X7, "addComments");
});

// ../node_modules/@babel/types/lib/comments/addComment.js
var SS = w((ef) => {
  "use strict";
  Object.defineProperty(ef, "__esModule", {
    value: !0
  });
  ef.default = H7;
  var $7 = Zp();
  function H7(t, e, r, s) {
    return (0, $7.default)(t, e, [{
      type: s ? "CommentLine" : "CommentBlock",
      value: r
    }]);
  }
  n(H7, "addComment");
});

// ../node_modules/@babel/types/lib/utils/inherit.js
var vl = w((tf) => {
  "use strict";
  Object.defineProperty(tf, "__esModule", {
    value: !0
  });
  tf.default = z7;
  function z7(t, e, r) {
    e && r && (e[t] = Array.from(new Set([].concat(e[t], r[t]).filter(Boolean))));
  }
  n(z7, "inherit");
});

// ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var sf = w((rf) => {
  "use strict";
  Object.defineProperty(rf, "__esModule", {
    value: !0
  });
  rf.default = Q7;
  var G7 = vl();
  function Q7(t, e) {
    (0, G7.default)("innerComments", t, e);
  }
  n(Q7, "inheritInnerComments");
});

// ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var af = w((nf) => {
  "use strict";
  Object.defineProperty(nf, "__esModule", {
    value: !0
  });
  nf.default = eU;
  var Z7 = vl();
  function eU(t, e) {
    (0, Z7.default)("leadingComments", t, e);
  }
  n(eU, "inheritLeadingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var lf = w((of) => {
  "use strict";
  Object.defineProperty(of, "__esModule", {
    value: !0
  });
  of.default = rU;
  var tU = vl();
  function rU(t, e) {
    (0, tU.default)("trailingComments", t, e);
  }
  n(rU, "inheritTrailingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritsComments.js
var cf = w((uf) => {
  "use strict";
  Object.defineProperty(uf, "__esModule", {
    value: !0
  });
  uf.default = aU;
  var sU = lf(), iU = af(), nU = sf();
  function aU(t, e) {
    return (0, sU.default)(t, e), (0, iU.default)(t, e), (0, nU.default)(t, e), t;
  }
  n(aU, "inheritsComments");
});

// ../node_modules/@babel/types/lib/comments/removeComments.js
var gS = w((pf) => {
  "use strict";
  Object.defineProperty(pf, "__esModule", {
    value: !0
  });
  pf.default = lU;
  var oU = Ys();
  function lU(t) {
    return oU.COMMENT_KEYS.forEach((e) => {
      t[e] = null;
    }), t;
  }
  n(lU, "removeComments");
});

// ../node_modules/@babel/types/lib/constants/generated/index.js
var PS = w((H) => {
  "use strict";
  Object.defineProperty(H, "__esModule", {
    value: !0
  });
  H.WHILE_TYPES = H.USERWHITESPACABLE_TYPES = H.UNARYLIKE_TYPES = H.TYPESCRIPT_TYPES = H.TSTYPE_TYPES = H.TSTYPEELEMENT_TYPES = H.TSENTITYNAME_TYPES =
  H.TSBASETYPE_TYPES = H.TERMINATORLESS_TYPES = H.STATEMENT_TYPES = H.STANDARDIZED_TYPES = H.SCOPABLE_TYPES = H.PUREISH_TYPES = H.PROPERTY_TYPES =
  H.PRIVATE_TYPES = H.PATTERN_TYPES = H.PATTERNLIKE_TYPES = H.OBJECTMEMBER_TYPES = H.MODULESPECIFIER_TYPES = H.MODULEDECLARATION_TYPES = H.MISCELLANEOUS_TYPES =
  H.METHOD_TYPES = H.LVAL_TYPES = H.LOOP_TYPES = H.LITERAL_TYPES = H.JSX_TYPES = H.IMPORTOREXPORTDECLARATION_TYPES = H.IMMUTABLE_TYPES = H.FUNCTION_TYPES =
  H.FUNCTIONPARENT_TYPES = H.FOR_TYPES = H.FORXSTATEMENT_TYPES = H.FLOW_TYPES = H.FLOWTYPE_TYPES = H.FLOWPREDICATE_TYPES = H.FLOWDECLARATION_TYPES =
  H.FLOWBASEANNOTATION_TYPES = H.EXPRESSION_TYPES = H.EXPRESSIONWRAPPER_TYPES = H.EXPORTDECLARATION_TYPES = H.ENUMMEMBER_TYPES = H.ENUMBODY_TYPES =
  H.DECLARATION_TYPES = H.CONDITIONAL_TYPES = H.COMPLETIONSTATEMENT_TYPES = H.CLASS_TYPES = H.BLOCK_TYPES = H.BLOCKPARENT_TYPES = H.BINARY_TYPES =
  H.ACCESSOR_TYPES = void 0;
  var Fe = Br(), P3e = H.STANDARDIZED_TYPES = Fe.FLIPPED_ALIAS_KEYS.Standardized, E3e = H.EXPRESSION_TYPES = Fe.FLIPPED_ALIAS_KEYS.Expression,
  A3e = H.BINARY_TYPES = Fe.FLIPPED_ALIAS_KEYS.Binary, v3e = H.SCOPABLE_TYPES = Fe.FLIPPED_ALIAS_KEYS.Scopable, C3e = H.BLOCKPARENT_TYPES = Fe.
  FLIPPED_ALIAS_KEYS.BlockParent, I3e = H.BLOCK_TYPES = Fe.FLIPPED_ALIAS_KEYS.Block, w3e = H.STATEMENT_TYPES = Fe.FLIPPED_ALIAS_KEYS.Statement,
  N3e = H.TERMINATORLESS_TYPES = Fe.FLIPPED_ALIAS_KEYS.Terminatorless, O3e = H.COMPLETIONSTATEMENT_TYPES = Fe.FLIPPED_ALIAS_KEYS.CompletionStatement,
  k3e = H.CONDITIONAL_TYPES = Fe.FLIPPED_ALIAS_KEYS.Conditional, D3e = H.LOOP_TYPES = Fe.FLIPPED_ALIAS_KEYS.Loop, _3e = H.WHILE_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  While, L3e = H.EXPRESSIONWRAPPER_TYPES = Fe.FLIPPED_ALIAS_KEYS.ExpressionWrapper, M3e = H.FOR_TYPES = Fe.FLIPPED_ALIAS_KEYS.For, B3e = H.FORXSTATEMENT_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.ForXStatement, F3e = H.FUNCTION_TYPES = Fe.FLIPPED_ALIAS_KEYS.Function, j3e = H.FUNCTIONPARENT_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  FunctionParent, R3e = H.PUREISH_TYPES = Fe.FLIPPED_ALIAS_KEYS.Pureish, U3e = H.DECLARATION_TYPES = Fe.FLIPPED_ALIAS_KEYS.Declaration, q3e = H.
  PATTERNLIKE_TYPES = Fe.FLIPPED_ALIAS_KEYS.PatternLike, V3e = H.LVAL_TYPES = Fe.FLIPPED_ALIAS_KEYS.LVal, K3e = H.TSENTITYNAME_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  TSEntityName, W3e = H.LITERAL_TYPES = Fe.FLIPPED_ALIAS_KEYS.Literal, Y3e = H.IMMUTABLE_TYPES = Fe.FLIPPED_ALIAS_KEYS.Immutable, J3e = H.USERWHITESPACABLE_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.UserWhitespacable, X3e = H.METHOD_TYPES = Fe.FLIPPED_ALIAS_KEYS.Method, $3e = H.OBJECTMEMBER_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  ObjectMember, H3e = H.PROPERTY_TYPES = Fe.FLIPPED_ALIAS_KEYS.Property, z3e = H.UNARYLIKE_TYPES = Fe.FLIPPED_ALIAS_KEYS.UnaryLike, G3e = H.
  PATTERN_TYPES = Fe.FLIPPED_ALIAS_KEYS.Pattern, Q3e = H.CLASS_TYPES = Fe.FLIPPED_ALIAS_KEYS.Class, uU = H.IMPORTOREXPORTDECLARATION_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration, Z3e = H.EXPORTDECLARATION_TYPES = Fe.FLIPPED_ALIAS_KEYS.ExportDeclaration, eBe = H.MODULESPECIFIER_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.ModuleSpecifier, tBe = H.ACCESSOR_TYPES = Fe.FLIPPED_ALIAS_KEYS.Accessor, rBe = H.PRIVATE_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  Private, sBe = H.FLOW_TYPES = Fe.FLIPPED_ALIAS_KEYS.Flow, iBe = H.FLOWTYPE_TYPES = Fe.FLIPPED_ALIAS_KEYS.FlowType, nBe = H.FLOWBASEANNOTATION_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, aBe = H.FLOWDECLARATION_TYPES = Fe.FLIPPED_ALIAS_KEYS.FlowDeclaration, oBe = H.FLOWPREDICATE_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.FlowPredicate, lBe = H.ENUMBODY_TYPES = Fe.FLIPPED_ALIAS_KEYS.EnumBody, uBe = H.ENUMMEMBER_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  EnumMember, cBe = H.JSX_TYPES = Fe.FLIPPED_ALIAS_KEYS.JSX, pBe = H.MISCELLANEOUS_TYPES = Fe.FLIPPED_ALIAS_KEYS.Miscellaneous, fBe = H.TYPESCRIPT_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.TypeScript, hBe = H.TSTYPEELEMENT_TYPES = Fe.FLIPPED_ALIAS_KEYS.TSTypeElement, dBe = H.TSTYPE_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  TSType, mBe = H.TSBASETYPE_TYPES = Fe.FLIPPED_ALIAS_KEYS.TSBaseType, yBe = H.MODULEDECLARATION_TYPES = uU;
});

// ../node_modules/@babel/types/lib/converters/toBlock.js
var df = w((hf) => {
  "use strict";
  Object.defineProperty(hf, "__esModule", {
    value: !0
  });
  hf.default = cU;
  var Cl = jt(), ff = pr();
  function cU(t, e) {
    if ((0, Cl.isBlockStatement)(t))
      return t;
    let r = [];
    return (0, Cl.isEmptyStatement)(t) ? r = [] : ((0, Cl.isStatement)(t) || ((0, Cl.isFunction)(e) ? t = (0, ff.returnStatement)(t) : t = (0, ff.
    expressionStatement)(t)), r = [t]), (0, ff.blockStatement)(r);
  }
  n(cU, "toBlock");
});

// ../node_modules/@babel/types/lib/converters/ensureBlock.js
var ES = w((mf) => {
  "use strict";
  Object.defineProperty(mf, "__esModule", {
    value: !0
  });
  mf.default = fU;
  var pU = df();
  function fU(t, e = "body") {
    let r = (0, pU.default)(t[e], t);
    return t[e] = r, r;
  }
  n(fU, "ensureBlock");
});

// ../node_modules/@babel/types/lib/converters/toIdentifier.js
var Tf = w((yf) => {
  "use strict";
  Object.defineProperty(yf, "__esModule", {
    value: !0
  });
  yf.default = mU;
  var hU = pn(), dU = Ta();
  function mU(t) {
    t = t + "";
    let e = "";
    for (let r of t)
      e += (0, dU.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return e = e.replace(/^[-0-9]+/, ""), e = e.replace(/[-\s]+(.)?/g, function(r, s) {
      return s ? s.toUpperCase() : "";
    }), (0, hU.default)(e) || (e = `_${e}`), e || "_";
  }
  n(mU, "toIdentifier");
});

// ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var AS = w((bf) => {
  "use strict";
  Object.defineProperty(bf, "__esModule", {
    value: !0
  });
  bf.default = TU;
  var yU = Tf();
  function TU(t) {
    return t = (0, yU.default)(t), (t === "eval" || t === "arguments") && (t = "_" + t), t;
  }
  n(TU, "toBindingIdentifierName");
});

// ../node_modules/@babel/types/lib/converters/toComputedKey.js
var vS = w((xf) => {
  "use strict";
  Object.defineProperty(xf, "__esModule", {
    value: !0
  });
  xf.default = SU;
  var bU = jt(), xU = pr();
  function SU(t, e = t.key || t.property) {
    return !t.computed && (0, bU.isIdentifier)(e) && (e = (0, xU.stringLiteral)(e.name)), e;
  }
  n(SU, "toComputedKey");
});

// ../node_modules/@babel/types/lib/converters/toExpression.js
var CS = w((Il) => {
  "use strict";
  Object.defineProperty(Il, "__esModule", {
    value: !0
  });
  Il.default = void 0;
  var va = jt(), wBe = Il.default = gU;
  function gU(t) {
    if ((0, va.isExpressionStatement)(t) && (t = t.expression), (0, va.isExpression)(t))
      return t;
    if ((0, va.isClass)(t) ? t.type = "ClassExpression" : (0, va.isFunction)(t) && (t.type = "FunctionExpression"), !(0, va.isExpression)(t))
      throw new Error(`cannot turn ${t.type} to an expression`);
    return t;
  }
  n(gU, "toExpression");
});

// ../node_modules/@babel/types/lib/traverse/traverseFast.js
var Pf = w((gf) => {
  "use strict";
  Object.defineProperty(gf, "__esModule", {
    value: !0
  });
  gf.default = Sf;
  var PU = Br();
  function Sf(t, e, r) {
    if (!t) return;
    let s = PU.VISITOR_KEYS[t.type];
    if (s) {
      r = r || {}, e(t, r);
      for (let i of s) {
        let a = t[i];
        if (Array.isArray(a))
          for (let o of a)
            Sf(o, e, r);
        else
          Sf(a, e, r);
      }
    }
  }
  n(Sf, "traverseFast");
});

// ../node_modules/@babel/types/lib/modifications/removeProperties.js
var Af = w((Ef) => {
  "use strict";
  Object.defineProperty(Ef, "__esModule", {
    value: !0
  });
  Ef.default = vU;
  var EU = Ys(), IS = ["tokens", "start", "end", "loc", "raw", "rawValue"], AU = [...EU.COMMENT_KEYS, "comments", ...IS];
  function vU(t, e = {}) {
    let r = e.preserveComments ? IS : AU;
    for (let i of r)
      t[i] != null && (t[i] = void 0);
    for (let i of Object.keys(t))
      i[0] === "_" && t[i] != null && (t[i] = void 0);
    let s = Object.getOwnPropertySymbols(t);
    for (let i of s)
      t[i] = null;
  }
  n(vU, "removeProperties");
});

// ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var Cf = w((vf) => {
  "use strict";
  Object.defineProperty(vf, "__esModule", {
    value: !0
  });
  vf.default = wU;
  var CU = Pf(), IU = Af();
  function wU(t, e) {
    return (0, CU.default)(t, IU.default, e), t;
  }
  n(wU, "removePropertiesDeep");
});

// ../node_modules/@babel/types/lib/converters/toKeyAlias.js
var NS = w((If) => {
  "use strict";
  Object.defineProperty(If, "__esModule", {
    value: !0
  });
  If.default = Oi;
  var wS = jt(), NU = $s(), OU = Cf();
  function Oi(t, e = t.key) {
    let r;
    return t.kind === "method" ? Oi.increment() + "" : ((0, wS.isIdentifier)(e) ? r = e.name : (0, wS.isStringLiteral)(e) ? r = JSON.stringify(
    e.value) : r = JSON.stringify((0, OU.default)((0, NU.default)(e))), t.computed && (r = `[${r}]`), t.static && (r = `static:${r}`), r);
  }
  n(Oi, "toKeyAlias");
  Oi.uid = 0;
  Oi.increment = function() {
    return Oi.uid >= Number.MAX_SAFE_INTEGER ? Oi.uid = 0 : Oi.uid++;
  };
});

// ../node_modules/@babel/types/lib/converters/toStatement.js
var OS = w((Nl) => {
  "use strict";
  Object.defineProperty(Nl, "__esModule", {
    value: !0
  });
  Nl.default = void 0;
  var wl = jt(), kU = pr(), RBe = Nl.default = DU;
  function DU(t, e) {
    if ((0, wl.isStatement)(t))
      return t;
    let r = !1, s;
    if ((0, wl.isClass)(t))
      r = !0, s = "ClassDeclaration";
    else if ((0, wl.isFunction)(t))
      r = !0, s = "FunctionDeclaration";
    else if ((0, wl.isAssignmentExpression)(t))
      return (0, kU.expressionStatement)(t);
    if (r && !t.id && (s = !1), !s) {
      if (e)
        return !1;
      throw new Error(`cannot turn ${t.type} to a statement`);
    }
    return t.type = s, t;
  }
  n(DU, "toStatement");
});

// ../node_modules/@babel/types/lib/converters/valueToNode.js
var kS = w((Ol) => {
  "use strict";
  Object.defineProperty(Ol, "__esModule", {
    value: !0
  });
  Ol.default = void 0;
  var _U = pn(), rr = pr(), VBe = Ol.default = wf, LU = Function.call.bind(Object.prototype.toString);
  function MU(t) {
    return LU(t) === "[object RegExp]";
  }
  n(MU, "isRegExp");
  function BU(t) {
    if (typeof t != "object" || t === null || Object.prototype.toString.call(t) !== "[object Object]")
      return !1;
    let e = Object.getPrototypeOf(t);
    return e === null || Object.getPrototypeOf(e) === null;
  }
  n(BU, "isPlainObject");
  function wf(t) {
    if (t === void 0)
      return (0, rr.identifier)("undefined");
    if (t === !0 || t === !1)
      return (0, rr.booleanLiteral)(t);
    if (t === null)
      return (0, rr.nullLiteral)();
    if (typeof t == "string")
      return (0, rr.stringLiteral)(t);
    if (typeof t == "number") {
      let e;
      if (Number.isFinite(t))
        e = (0, rr.numericLiteral)(Math.abs(t));
      else {
        let r;
        Number.isNaN(t) ? r = (0, rr.numericLiteral)(0) : r = (0, rr.numericLiteral)(1), e = (0, rr.binaryExpression)("/", r, (0, rr.numericLiteral)(
        0));
      }
      return (t < 0 || Object.is(t, -0)) && (e = (0, rr.unaryExpression)("-", e)), e;
    }
    if (MU(t)) {
      let e = t.source, r = t.toString().match(/\/([a-z]+|)$/)[1];
      return (0, rr.regExpLiteral)(e, r);
    }
    if (Array.isArray(t))
      return (0, rr.arrayExpression)(t.map(wf));
    if (BU(t)) {
      let e = [];
      for (let r of Object.keys(t)) {
        let s;
        (0, _U.default)(r) ? s = (0, rr.identifier)(r) : s = (0, rr.stringLiteral)(r), e.push((0, rr.objectProperty)(s, wf(t[r])));
      }
      return (0, rr.objectExpression)(e);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  n(wf, "valueToNode");
});

// ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var DS = w((Nf) => {
  "use strict";
  Object.defineProperty(Nf, "__esModule", {
    value: !0
  });
  Nf.default = jU;
  var FU = pr();
  function jU(t, e, r = !1) {
    return t.object = (0, FU.memberExpression)(t.object, t.property, t.computed), t.property = e, t.computed = !!r, t;
  }
  n(jU, "appendToMemberExpression");
});

// ../node_modules/@babel/types/lib/modifications/inherits.js
var LS = w((Of) => {
  "use strict";
  Object.defineProperty(Of, "__esModule", {
    value: !0
  });
  Of.default = UU;
  var _S = Ys(), RU = cf();
  function UU(t, e) {
    if (!t || !e) return t;
    for (let r of _S.INHERIT_KEYS.optional)
      t[r] == null && (t[r] = e[r]);
    for (let r of Object.keys(e))
      r[0] === "_" && r !== "__clone" && (t[r] = e[r]);
    for (let r of _S.INHERIT_KEYS.force)
      t[r] = e[r];
    return (0, RU.default)(t, e), t;
  }
  n(UU, "inherits");
});

// ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var MS = w((kf) => {
  "use strict";
  Object.defineProperty(kf, "__esModule", {
    value: !0
  });
  kf.default = KU;
  var qU = pr(), VU = Ce();
  function KU(t, e) {
    if ((0, VU.isSuper)(t.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return t.object = (0, qU.memberExpression)(e, t.object), t;
  }
  n(KU, "prependToMemberExpression");
});

// ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var Ca = w((_f) => {
  "use strict";
  Object.defineProperty(_f, "__esModule", {
    value: !0
  });
  _f.default = Df;
  var ys = jt();
  function Df(t, e, r, s) {
    let i = [].concat(t), a = /* @__PURE__ */ Object.create(null);
    for (; i.length; ) {
      let o = i.shift();
      if (!o || s && ((0, ys.isAssignmentExpression)(o) || (0, ys.isUnaryExpression)(o) || (0, ys.isUpdateExpression)(o)))
        continue;
      if ((0, ys.isIdentifier)(o)) {
        e ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, ys.isExportDeclaration)(o) && !(0, ys.isExportAllDeclaration)(o)) {
        (0, ys.isDeclaration)(o.declaration) && i.push(o.declaration);
        continue;
      }
      if (r) {
        if ((0, ys.isFunctionDeclaration)(o)) {
          i.push(o.id);
          continue;
        }
        if ((0, ys.isFunctionExpression)(o))
          continue;
      }
      let l = Df.keys[o.type];
      if (l)
        for (let u = 0; u < l.length; u++) {
          let c = l[u], p = o[c];
          p && (Array.isArray(p) ? i.push(...p) : i.push(p));
        }
    }
    return a;
  }
  n(Df, "getBindingIdentifiers");
  Df.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
});

// ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var BS = w((kl) => {
  "use strict";
  Object.defineProperty(kl, "__esModule", {
    value: !0
  });
  kl.default = void 0;
  var WU = Ca(), ZBe = kl.default = YU;
  function YU(t, e) {
    return (0, WU.default)(t, e, !0);
  }
  n(YU, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/types/lib/traverse/traverse.js
var FS = w((Mf) => {
  "use strict";
  Object.defineProperty(Mf, "__esModule", {
    value: !0
  });
  Mf.default = XU;
  var JU = Br();
  function XU(t, e, r) {
    typeof e == "function" && (e = {
      enter: e
    });
    let {
      enter: s,
      exit: i
    } = e;
    Lf(t, s, i, r, []);
  }
  n(XU, "traverse");
  function Lf(t, e, r, s, i) {
    let a = JU.VISITOR_KEYS[t.type];
    if (a) {
      e && e(t, i, s);
      for (let o of a) {
        let l = t[o];
        if (Array.isArray(l))
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c && (i.push({
              node: t,
              key: o,
              index: u
            }), Lf(c, e, r, s, i), i.pop());
          }
        else l && (i.push({
          node: t,
          key: o
        }), Lf(l, e, r, s, i), i.pop());
      }
      r && r(t, i, s);
    }
  }
  n(Lf, "traverseSimpleImpl");
});

// ../node_modules/@babel/types/lib/validators/isBinding.js
var jS = w((Bf) => {
  "use strict";
  Object.defineProperty(Bf, "__esModule", {
    value: !0
  });
  Bf.default = HU;
  var $U = Ca();
  function HU(t, e, r) {
    if (r && t.type === "Identifier" && e.type === "ObjectProperty" && r.type === "ObjectExpression")
      return !1;
    let s = $U.default.keys[e.type];
    if (s)
      for (let i = 0; i < s.length; i++) {
        let a = s[i], o = e[a];
        if (Array.isArray(o)) {
          if (o.indexOf(t) >= 0) return !0;
        } else if (o === t) return !0;
      }
    return !1;
  }
  n(HU, "isBinding");
});

// ../node_modules/@babel/types/lib/validators/isLet.js
var jf = w((Ff) => {
  "use strict";
  Object.defineProperty(Ff, "__esModule", {
    value: !0
  });
  Ff.default = QU;
  var zU = jt(), GU = Ys();
  function QU(t) {
    return (0, zU.isVariableDeclaration)(t) && (t.kind !== "var" || t[GU.BLOCK_SCOPED_SYMBOL]);
  }
  n(QU, "isLet");
});

// ../node_modules/@babel/types/lib/validators/isBlockScoped.js
var US = w((Rf) => {
  "use strict";
  Object.defineProperty(Rf, "__esModule", {
    value: !0
  });
  Rf.default = eq;
  var RS = jt(), ZU = jf();
  function eq(t) {
    return (0, RS.isFunctionDeclaration)(t) || (0, RS.isClassDeclaration)(t) || (0, ZU.default)(t);
  }
  n(eq, "isBlockScoped");
});

// ../node_modules/@babel/types/lib/validators/isImmutable.js
var qS = w((Uf) => {
  "use strict";
  Object.defineProperty(Uf, "__esModule", {
    value: !0
  });
  Uf.default = sq;
  var tq = fl(), rq = jt();
  function sq(t) {
    return (0, tq.default)(t.type, "Immutable") ? !0 : (0, rq.isIdentifier)(t) ? t.name === "undefined" : !1;
  }
  n(sq, "isImmutable");
});

// ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var KS = w((Vf) => {
  "use strict";
  Object.defineProperty(Vf, "__esModule", {
    value: !0
  });
  Vf.default = qf;
  var VS = Br();
  function qf(t, e) {
    if (typeof t != "object" || typeof e != "object" || t == null || e == null)
      return t === e;
    if (t.type !== e.type)
      return !1;
    let r = Object.keys(VS.NODE_FIELDS[t.type] || t.type), s = VS.VISITOR_KEYS[t.type];
    for (let i of r) {
      let a = t[i], o = e[i];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let l = 0; l < a.length; l++)
            if (!qf(a[l], o[l]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(s != null && s.includes(i))) {
          for (let l of Object.keys(a))
            if (a[l] !== o[l])
              return !1;
          continue;
        }
        if (!qf(a, o))
          return !1;
      }
    }
    return !0;
  }
  n(qf, "isNodesEquivalent");
});

// ../node_modules/@babel/types/lib/validators/isReferenced.js
var WS = w((Kf) => {
  "use strict";
  Object.defineProperty(Kf, "__esModule", {
    value: !0
  });
  Kf.default = iq;
  function iq(t, e, r) {
    switch (e.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return e.property === t ? !!e.computed : e.object === t;
      case "JSXMemberExpression":
        return e.object === t;
      case "VariableDeclarator":
        return e.init === t;
      case "ArrowFunctionExpression":
        return e.body === t;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return e.key === t ? !!e.computed : !1;
      case "ObjectProperty":
        return e.key === t ? !!e.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return e.key === t ? !!e.computed : !0;
      case "ClassPrivateProperty":
        return e.key !== t;
      case "ClassDeclaration":
      case "ClassExpression":
        return e.superClass === t;
      case "AssignmentExpression":
        return e.right === t;
      case "AssignmentPattern":
        return e.right === t;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return r != null && r.source ? !1 : e.local === t;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return e.key !== t;
      case "TSEnumMember":
        return e.id !== t;
      case "TSPropertySignature":
        return e.key === t ? !!e.computed : !0;
    }
    return !0;
  }
  n(iq, "isReferenced");
});

// ../node_modules/@babel/types/lib/validators/isScope.js
var YS = w((Wf) => {
  "use strict";
  Object.defineProperty(Wf, "__esModule", {
    value: !0
  });
  Wf.default = nq;
  var ki = jt();
  function nq(t, e) {
    return (0, ki.isBlockStatement)(t) && ((0, ki.isFunction)(e) || (0, ki.isCatchClause)(e)) ? !1 : (0, ki.isPattern)(t) && ((0, ki.isFunction)(
    e) || (0, ki.isCatchClause)(e)) ? !0 : (0, ki.isScopable)(t);
  }
  n(nq, "isScope");
});

// ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var XS = w((Yf) => {
  "use strict";
  Object.defineProperty(Yf, "__esModule", {
    value: !0
  });
  Yf.default = aq;
  var JS = jt();
  function aq(t) {
    return (0, JS.isImportDefaultSpecifier)(t) || (0, JS.isIdentifier)(t.imported || t.exported, {
      name: "default"
    });
  }
  n(aq, "isSpecifierDefault");
});

// ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var $S = w((Jf) => {
  "use strict";
  Object.defineProperty(Jf, "__esModule", {
    value: !0
  });
  Jf.default = uq;
  var oq = pn(), lq = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implement\
s", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transie\
nt", "volatile"]);
  function uq(t) {
    return (0, oq.default)(t) && !lq.has(t);
  }
  n(uq, "isValidES3Identifier");
});

// ../node_modules/@babel/types/lib/validators/isVar.js
var HS = w((Xf) => {
  "use strict";
  Object.defineProperty(Xf, "__esModule", {
    value: !0
  });
  Xf.default = fq;
  var cq = jt(), pq = Ys();
  function fq(t) {
    return (0, cq.isVariableDeclaration)(t, {
      kind: "var"
    }) && !t[pq.BLOCK_SCOPED_SYMBOL];
  }
  n(fq, "isVar");
});

// ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var zS = w((zf) => {
  "use strict";
  Object.defineProperty(zf, "__esModule", {
    value: !0
  });
  zf.default = Dl;
  var hq = Ca(), Di = jt(), $f = pr(), Hf = Jp(), dq = $s();
  function Dl(t, e) {
    let r = [], s = !0;
    for (let i of t)
      if ((0, Di.isEmptyStatement)(i) || (s = !1), (0, Di.isExpression)(i))
        r.push(i);
      else if ((0, Di.isExpressionStatement)(i))
        r.push(i.expression);
      else if ((0, Di.isVariableDeclaration)(i)) {
        if (i.kind !== "var") return;
        for (let a of i.declarations) {
          let o = (0, hq.default)(a);
          for (let l of Object.keys(o))
            e.push({
              kind: i.kind,
              id: (0, dq.default)(o[l])
            });
          a.init && r.push((0, $f.assignmentExpression)("=", a.id, a.init));
        }
        s = !0;
      } else if ((0, Di.isIfStatement)(i)) {
        let a = i.consequent ? Dl([i.consequent], e) : (0, Hf.buildUndefinedNode)(), o = i.alternate ? Dl([i.alternate], e) : (0, Hf.buildUndefinedNode)();
        if (!a || !o) return;
        r.push((0, $f.conditionalExpression)(i.test, a, o));
      } else if ((0, Di.isBlockStatement)(i)) {
        let a = Dl(i.body, e);
        if (!a) return;
        r.push(a);
      } else if ((0, Di.isEmptyStatement)(i))
        t.indexOf(i) === 0 && (s = !0);
      else
        return;
    return s && r.push((0, Hf.buildUndefinedNode)()), r.length === 1 ? r[0] : (0, $f.sequenceExpression)(r);
  }
  n(Dl, "gatherSequenceExpressions");
});

// ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var GS = w((Gf) => {
  "use strict";
  Object.defineProperty(Gf, "__esModule", {
    value: !0
  });
  Gf.default = yq;
  var mq = zS();
  function yq(t, e) {
    if (!(t != null && t.length)) return;
    let r = [], s = (0, mq.default)(t, r);
    if (s) {
      for (let i of r)
        e.push(i);
      return s;
    }
  }
  n(yq, "toSequenceExpression");
});

// ../node_modules/@babel/types/lib/index.js
var Ce = w((te) => {
  "use strict";
  Object.defineProperty(te, "__esModule", {
    value: !0
  });
  var Ts = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(te, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return bV.default;
    }, "get")
  });
  Object.defineProperty(te, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return wq.default;
    }, "get")
  });
  Object.defineProperty(te, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Nq.default;
    }, "get")
  });
  Object.defineProperty(te, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Wq.default;
    }, "get")
  });
  Object.defineProperty(te, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Sq.default;
    }, "get")
  });
  Object.defineProperty(te, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return TV.default;
    }, "get")
  });
  Object.defineProperty(te, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Aq.default;
    }, "get")
  });
  Object.defineProperty(te, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return vq.default;
    }, "get")
  });
  Object.defineProperty(te, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Cq.default;
    }, "get")
  });
  Object.defineProperty(te, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Eq.default;
    }, "get")
  });
  Object.defineProperty(te, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Iq.default;
    }, "get")
  });
  Object.defineProperty(te, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return QS.default;
    }, "get")
  });
  Object.defineProperty(te, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Pq.default;
    }, "get")
  });
  Object.defineProperty(te, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return gq.default;
    }, "get")
  });
  Object.defineProperty(te, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return QS.default;
    }, "get")
  });
  Object.defineProperty(te, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Mq.default;
    }, "get")
  });
  Object.defineProperty(te, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return zq.default;
    }, "get")
  });
  Object.defineProperty(te, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Gq.default;
    }, "get")
  });
  Object.defineProperty(te, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Oq.default;
    }, "get")
  });
  Object.defineProperty(te, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return kq.default;
    }, "get")
  });
  Object.defineProperty(te, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return _q.default;
    }, "get")
  });
  Object.defineProperty(te, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Yq.default;
    }, "get")
  });
  Object.defineProperty(te, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Dq.default;
    }, "get")
  });
  Object.defineProperty(te, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return eV.default;
    }, "get")
  });
  Object.defineProperty(te, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return tV.default;
    }, "get")
  });
  Object.defineProperty(te, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return rV.default;
    }, "get")
  });
  Object.defineProperty(te, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return sV.default;
    }, "get")
  });
  Object.defineProperty(te, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return iV.default;
    }, "get")
  });
  Object.defineProperty(te, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return nV.default;
    }, "get")
  });
  Object.defineProperty(te, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return aV.default;
    }, "get")
  });
  Object.defineProperty(te, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return oV.default;
    }, "get")
  });
  Object.defineProperty(te, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return lV.default;
    }, "get")
  });
  Object.defineProperty(te, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return uV.default;
    }, "get")
  });
  Object.defineProperty(te, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return cV.default;
    }, "get")
  });
  Object.defineProperty(te, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return pV.default;
    }, "get")
  });
  Object.defineProperty(te, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return fV.default;
    }, "get")
  });
  Object.defineProperty(te, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return hV.default;
    }, "get")
  });
  Object.defineProperty(te, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return dV.default;
    }, "get")
  });
  Object.defineProperty(te, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return mV.default;
    }, "get")
  });
  Object.defineProperty(te, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Jq.default;
    }, "get")
  });
  te.react = void 0;
  Object.defineProperty(te, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Lq.default;
    }, "get")
  });
  Object.defineProperty(te, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Xq.default;
    }, "get")
  });
  Object.defineProperty(te, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $q.default;
    }, "get")
  });
  Object.defineProperty(te, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Hq.default;
    }, "get")
  });
  Object.defineProperty(te, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Zq.default;
    }, "get")
  });
  Object.defineProperty(te, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Bq.default;
    }, "get")
  });
  Object.defineProperty(te, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Fq.default;
    }, "get")
  });
  Object.defineProperty(te, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return jq.default;
    }, "get")
  });
  Object.defineProperty(te, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Rq.default;
    }, "get")
  });
  Object.defineProperty(te, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Uq.default;
    }, "get")
  });
  Object.defineProperty(te, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return qq.default;
    }, "get")
  });
  Object.defineProperty(te, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Vq.default;
    }, "get")
  });
  Object.defineProperty(te, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return _l.default;
    }, "get")
  });
  Object.defineProperty(te, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qq.default;
    }, "get")
  });
  Object.defineProperty(te, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return yV.default;
    }, "get")
  });
  Object.defineProperty(te, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Kq.default;
    }, "get")
  });
  var Tq = ix(), bq = nx(), xq = Qx(), Sq = Zx(), Qf = eS();
  Object.keys(Qf).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ts, t) || t in te && te[t] === Qf[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Qf[t];
      }, "get")
    });
  });
  var gq = tS(), QS = iS(), Pq = lS(), Zf = pr();
  Object.keys(Zf).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ts, t) || t in te && te[t] === Zf[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Zf[t];
      }, "get")
    });
  });
  var eh = uS();
  Object.keys(eh).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ts, t) || t in te && te[t] === eh[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return eh[t];
      }, "get")
    });
  });
  var th = Jp();
  Object.keys(th).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ts, t) || t in te && te[t] === th[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return th[t];
      }, "get")
    });
  });
  var Eq = $s(), Aq = yS(), vq = TS(), Cq = bS(), Iq = xS(), wq = SS(), Nq = Zp(), Oq = sf(), kq = af(), Dq = cf(), _q = lf(), Lq = gS(), rh = PS();
  Object.keys(rh).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ts, t) || t in te && te[t] === rh[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return rh[t];
      }, "get")
    });
  });
  var sh = Ys();
  Object.keys(sh).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ts, t) || t in te && te[t] === sh[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return sh[t];
      }, "get")
    });
  });
  var Mq = ES(), Bq = AS(), Fq = df(), jq = vS(), Rq = CS(), Uq = Tf(), qq = NS(), Vq = OS(), Kq = kS(), ih = Br();
  Object.keys(ih).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ts, t) || t in te && te[t] === ih[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return ih[t];
      }, "get")
    });
  });
  var Wq = DS(), Yq = LS(), Jq = MS(), Xq = Af(), $q = Cf(), Hq = qp(), zq = Ca(), Gq = BS(), _l = FS();
  Object.keys(_l).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ts, t) || t in te && te[t] === _l[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return _l[t];
      }, "get")
    });
  });
  var Qq = Pf(), Zq = cl(), eV = cn(), tV = jS(), rV = US(), sV = qS(), iV = jf(), nV = jp(), aV = KS(), oV = pp(), lV = WS(), uV = YS(), cV = XS(),
  pV = fl(), fV = $S(), hV = pn(), dV = HS(), mV = ip(), yV = Tl(), TV = ap(), nh = jt();
  Object.keys(nh).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ts, t) || t in te && te[t] === nh[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return nh[t];
      }, "get")
    });
  });
  var bV = ca(), wFe = te.react = {
    isReactComponent: Tq.default,
    isCompatTag: bq.default,
    buildChildren: xq.default
  };
  te.toSequenceExpression = GS().default;
});

// ../node_modules/@jridgewell/set-array/dist/set-array.umd.js
var eg = w((Ll, ZS) => {
  (function(t, e) {
    typeof Ll == "object" && typeof ZS < "u" ? e(Ll) : typeof define == "function" && define.amd ? define(["exports"], e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, e(t.setArray = {}));
  })(Ll, function(t) {
    "use strict";
    class e {
      static {
        n(this, "SetArray");
      }
      constructor() {
        this._indexes = { __proto__: null }, this.array = [];
      }
    }
    function r(l) {
      return l;
    }
    n(r, "cast");
    function s(l, u) {
      return l._indexes[u];
    }
    n(s, "get");
    function i(l, u) {
      let c = s(l, u);
      if (c !== void 0)
        return c;
      let { array: p, _indexes: f } = l, m = p.push(u);
      return f[u] = m - 1;
    }
    n(i, "put");
    function a(l) {
      let { array: u, _indexes: c } = l;
      if (u.length === 0)
        return;
      let p = u.pop();
      c[p] = void 0;
    }
    n(a, "pop");
    function o(l, u) {
      let c = s(l, u);
      if (c === void 0)
        return;
      let { array: p, _indexes: f } = l;
      for (let m = c + 1; m < p.length; m++) {
        let y = p[m];
        p[m - 1] = y, f[y]--;
      }
      f[u] = void 0, p.pop();
    }
    n(o, "remove"), t.SetArray = e, t.get = s, t.pop = a, t.put = i, t.remove = o, Object.defineProperty(t, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var ah = w((Ml, tg) => {
  (function(t, e) {
    typeof Ml == "object" && typeof tg < "u" ? e(Ml) : typeof define == "function" && define.amd ? define(["exports"], e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, e(t.sourcemapCodec = {}));
  })(Ml, function(t) {
    "use strict";
    let s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = new Uint8Array(64), a = new Uint8Array(128);
    for (let L = 0; L < s.length; L++) {
      let q = s.charCodeAt(L);
      i[L] = q, a[q] = L;
    }
    let o = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
      decode(L) {
        return Buffer.from(L.buffer, L.byteOffset, L.byteLength).toString();
      }
    } : {
      decode(L) {
        let q = "";
        for (let _ = 0; _ < L.length; _++)
          q += String.fromCharCode(L[_]);
        return q;
      }
    };
    function l(L) {
      let q = new Int32Array(5), _ = [], U = 0;
      do {
        let J = u(L, U), ie = [], de = !0, ne = 0;
        q[0] = 0;
        for (let Be = U; Be < J; Be++) {
          let bt;
          Be = c(L, Be, q, 0);
          let Et = q[0];
          Et < ne && (de = !1), ne = Et, p(L, Be, J) ? (Be = c(L, Be, q, 1), Be = c(L, Be, q, 2), Be = c(L, Be, q, 3), p(L, Be, J) ? (Be = c(
          L, Be, q, 4), bt = [Et, q[1], q[2], q[3], q[4]]) : bt = [Et, q[1], q[2], q[3]]) : bt = [Et], ie.push(bt);
        }
        de || f(ie), _.push(ie), U = J + 1;
      } while (U <= L.length);
      return _;
    }
    n(l, "decode");
    function u(L, q) {
      let _ = L.indexOf(";", q);
      return _ === -1 ? L.length : _;
    }
    n(u, "indexOf");
    function c(L, q, _, U) {
      let J = 0, ie = 0, de = 0;
      do {
        let Be = L.charCodeAt(q++);
        de = a[Be], J |= (de & 31) << ie, ie += 5;
      } while (de & 32);
      let ne = J & 1;
      return J >>>= 1, ne && (J = -2147483648 | -J), _[U] += J, q;
    }
    n(c, "decodeInteger");
    function p(L, q, _) {
      return q >= _ ? !1 : L.charCodeAt(q) !== 44;
    }
    n(p, "hasMoreVlq");
    function f(L) {
      L.sort(m);
    }
    n(f, "sort");
    function m(L, q) {
      return L[0] - q[0];
    }
    n(m, "sortComparator");
    function y(L) {
      let q = new Int32Array(5), _ = 1024 * 16, U = _ - 36, J = new Uint8Array(_), ie = J.subarray(0, U), de = 0, ne = "";
      for (let Be = 0; Be < L.length; Be++) {
        let bt = L[Be];
        if (Be > 0 && (de === _ && (ne += o.decode(J), de = 0), J[de++] = 59), bt.length !== 0) {
          q[0] = 0;
          for (let Et = 0; Et < bt.length; Et++) {
            let Jt = bt[Et];
            de > U && (ne += o.decode(ie), J.copyWithin(0, U, de), de -= U), Et > 0 && (J[de++] = 44), de = T(J, de, q, Jt, 0), Jt.length !==
            1 && (de = T(J, de, q, Jt, 1), de = T(J, de, q, Jt, 2), de = T(J, de, q, Jt, 3), Jt.length !== 4 && (de = T(J, de, q, Jt, 4)));
          }
        }
      }
      return ne + o.decode(J.subarray(0, de));
    }
    n(y, "encode");
    function T(L, q, _, U, J) {
      let ie = U[J], de = ie - _[J];
      _[J] = ie, de = de < 0 ? -de << 1 | 1 : de << 1;
      do {
        let ne = de & 31;
        de >>>= 5, de > 0 && (ne |= 32), L[q++] = i[ne];
      } while (de > 0);
      return q;
    }
    n(T, "encodeInteger"), t.decode = l, t.encode = y, Object.defineProperty(t, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var rg = w((oh, lh) => {
  (function(t, e) {
    typeof oh == "object" && typeof lh < "u" ? lh.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, t.resolveURI = e());
  })(oh, function() {
    "use strict";
    let t = /^[\w+.-]+:\/\//, e = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    var s;
    (function(_) {
      _[_.Empty = 1] = "Empty", _[_.Hash = 2] = "Hash", _[_.Query = 3] = "Query", _[_.RelativePath = 4] = "RelativePath", _[_.AbsolutePath =
      5] = "AbsolutePath", _[_.SchemeRelative = 6] = "SchemeRelative", _[_.Absolute = 7] = "Absolute";
    })(s || (s = {}));
    function i(_) {
      return t.test(_);
    }
    n(i, "isAbsoluteUrl");
    function a(_) {
      return _.startsWith("//");
    }
    n(a, "isSchemeRelativeUrl");
    function o(_) {
      return _.startsWith("/");
    }
    n(o, "isAbsolutePath");
    function l(_) {
      return _.startsWith("file:");
    }
    n(l, "isFileUrl");
    function u(_) {
      return /^[.?#]/.test(_);
    }
    n(u, "isRelative");
    function c(_) {
      let U = e.exec(_);
      return f(U[1], U[2] || "", U[3], U[4] || "", U[5] || "/", U[6] || "", U[7] || "");
    }
    n(c, "parseAbsoluteUrl");
    function p(_) {
      let U = r.exec(_), J = U[2];
      return f("file:", "", U[1] || "", "", o(J) ? J : "/" + J, U[3] || "", U[4] || "");
    }
    n(p, "parseFileUrl");
    function f(_, U, J, ie, de, ne, Be) {
      return {
        scheme: _,
        user: U,
        host: J,
        port: ie,
        path: de,
        query: ne,
        hash: Be,
        type: s.Absolute
      };
    }
    n(f, "makeUrl");
    function m(_) {
      if (a(_)) {
        let J = c("http:" + _);
        return J.scheme = "", J.type = s.SchemeRelative, J;
      }
      if (o(_)) {
        let J = c("http://foo.com" + _);
        return J.scheme = "", J.host = "", J.type = s.AbsolutePath, J;
      }
      if (l(_))
        return p(_);
      if (i(_))
        return c(_);
      let U = c("http://foo.com/" + _);
      return U.scheme = "", U.host = "", U.type = _ ? _.startsWith("?") ? s.Query : _.startsWith("#") ? s.Hash : s.RelativePath : s.Empty, U;
    }
    n(m, "parseUrl");
    function y(_) {
      if (_.endsWith("/.."))
        return _;
      let U = _.lastIndexOf("/");
      return _.slice(0, U + 1);
    }
    n(y, "stripPathFilename");
    function T(_, U) {
      L(U, U.type), _.path === "/" ? _.path = U.path : _.path = y(U.path) + _.path;
    }
    n(T, "mergePaths");
    function L(_, U) {
      let J = U <= s.RelativePath, ie = _.path.split("/"), de = 1, ne = 0, Be = !1;
      for (let Et = 1; Et < ie.length; Et++) {
        let Jt = ie[Et];
        if (!Jt) {
          Be = !0;
          continue;
        }
        if (Be = !1, Jt !== ".") {
          if (Jt === "..") {
            ne ? (Be = !0, ne--, de--) : J && (ie[de++] = Jt);
            continue;
          }
          ie[de++] = Jt, ne++;
        }
      }
      let bt = "";
      for (let Et = 1; Et < de; Et++)
        bt += "/" + ie[Et];
      (!bt || Be && !bt.endsWith("/..")) && (bt += "/"), _.path = bt;
    }
    n(L, "normalizePath");
    function q(_, U) {
      if (!_ && !U)
        return "";
      let J = m(_), ie = J.type;
      if (U && ie !== s.Absolute) {
        let ne = m(U), Be = ne.type;
        switch (ie) {
          case s.Empty:
            J.hash = ne.hash;
          case s.Hash:
            J.query = ne.query;
          case s.Query:
          case s.RelativePath:
            T(J, ne);
          case s.AbsolutePath:
            J.user = ne.user, J.host = ne.host, J.port = ne.port;
          case s.SchemeRelative:
            J.scheme = ne.scheme;
        }
        Be > ie && (ie = Be);
      }
      L(J, ie);
      let de = J.query + J.hash;
      switch (ie) {
        case s.Hash:
        case s.Query:
          return de;
        case s.RelativePath: {
          let ne = J.path.slice(1);
          return ne ? u(U || _) && !u(ne) ? "./" + ne + de : ne + de : de || ".";
        }
        case s.AbsolutePath:
          return J.path + de;
        default:
          return J.scheme + "//" + J.user + J.host + J.port + J.path + de;
      }
    }
    return n(q, "resolve"), q;
  });
});

// ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var Fl = w((Bl, sg) => {
  (function(t, e) {
    typeof Bl == "object" && typeof sg < "u" ? e(Bl, ah(), rg()) : typeof define == "function" && define.amd ? define(["exports", "@jridgewe\
ll/sourcemap-codec", "@jridgewell/resolve-uri"], e) : (t = typeof globalThis < "u" ? globalThis : t || self, e(t.traceMapping = {}, t.sourcemapCodec,
    t.resolveURI));
  })(Bl, function(t, e, r) {
    "use strict";
    function s(Y, Q) {
      return Q && !Q.endsWith("/") && (Q += "/"), r(Y, Q);
    }
    n(s, "resolve");
    function i(Y) {
      if (!Y)
        return "";
      let Q = Y.lastIndexOf("/");
      return Y.slice(0, Q + 1);
    }
    n(i, "stripFilename");
    let a = 0, o = 1, l = 2, u = 3, c = 4, p = 1, f = 2;
    function m(Y, Q) {
      let Z = y(Y, 0);
      if (Z === Y.length)
        return Y;
      Q || (Y = Y.slice());
      for (let ue = Z; ue < Y.length; ue = y(Y, ue + 1))
        Y[ue] = L(Y[ue], Q);
      return Y;
    }
    n(m, "maybeSort");
    function y(Y, Q) {
      for (let Z = Q; Z < Y.length; Z++)
        if (!T(Y[Z]))
          return Z;
      return Y.length;
    }
    n(y, "nextUnsortedSegmentLine");
    function T(Y) {
      for (let Q = 1; Q < Y.length; Q++)
        if (Y[Q][a] < Y[Q - 1][a])
          return !1;
      return !0;
    }
    n(T, "isSorted");
    function L(Y, Q) {
      return Q || (Y = Y.slice()), Y.sort(q);
    }
    n(L, "sortSegments");
    function q(Y, Q) {
      return Y[a] - Q[a];
    }
    n(q, "sortComparator");
    let _ = !1;
    function U(Y, Q, Z, ue) {
      for (; Z <= ue; ) {
        let Re = Z + (ue - Z >> 1), we = Y[Re][a] - Q;
        if (we === 0)
          return _ = !0, Re;
        we < 0 ? Z = Re + 1 : ue = Re - 1;
      }
      return _ = !1, Z - 1;
    }
    n(U, "binarySearch");
    function J(Y, Q, Z) {
      for (let ue = Z + 1; ue < Y.length && Y[ue][a] === Q; Z = ue++)
        ;
      return Z;
    }
    n(J, "upperBound");
    function ie(Y, Q, Z) {
      for (let ue = Z - 1; ue >= 0 && Y[ue][a] === Q; Z = ue--)
        ;
      return Z;
    }
    n(ie, "lowerBound");
    function de() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    n(de, "memoizedState");
    function ne(Y, Q, Z, ue) {
      let { lastKey: Re, lastNeedle: we, lastIndex: at } = Z, vt = 0, ze = Y.length - 1;
      if (ue === Re) {
        if (Q === we)
          return _ = at !== -1 && Y[at][a] === Q, at;
        Q >= we ? vt = at === -1 ? 0 : at : ze = at;
      }
      return Z.lastKey = ue, Z.lastNeedle = Q, Z.lastIndex = U(Y, Q, vt, ze);
    }
    n(ne, "memoizedBinarySearch");
    function Be(Y, Q) {
      let Z = Q.map(Et);
      for (let ue = 0; ue < Y.length; ue++) {
        let Re = Y[ue];
        for (let we = 0; we < Re.length; we++) {
          let at = Re[we];
          if (at.length === 1)
            continue;
          let vt = at[o], ze = at[l], Ct = at[u], Ir = Z[vt], Ft = Ir[ze] || (Ir[ze] = []), Mt = Q[vt], or = J(Ft, Ct, ne(Ft, Ct, Mt, ze));
          Mt.lastIndex = ++or, bt(Ft, or, [Ct, ue, at[a]]);
        }
      }
      return Z;
    }
    n(Be, "buildBySources");
    function bt(Y, Q, Z) {
      for (let ue = Y.length; ue > Q; ue--)
        Y[ue] = Y[ue - 1];
      Y[Q] = Z;
    }
    n(bt, "insert");
    function Et() {
      return { __proto__: null };
    }
    n(Et, "buildNullArray");
    let Jt = /* @__PURE__ */ n(function(Y, Q) {
      let Z = ts(Y);
      if (!("sections" in Z))
        return new xt(Z, Q);
      let ue = [], Re = [], we = [], at = [], vt = [];
      Ws(Z, Q, ue, Re, we, at, vt, 0, 0, 1 / 0, 1 / 0);
      let ze = {
        version: 3,
        file: Z.file,
        names: at,
        sources: Re,
        sourcesContent: we,
        mappings: ue,
        ignoreList: vt
      };
      return Xb(ze);
    }, "AnyMap");
    function ts(Y) {
      return typeof Y == "string" ? JSON.parse(Y) : Y;
    }
    n(ts, "parse");
    function Ws(Y, Q, Z, ue, Re, we, at, vt, ze, Ct, Ir) {
      let { sections: Ft } = Y;
      for (let Mt = 0; Mt < Ft.length; Mt++) {
        let { map: or, offset: ss } = Ft[Mt], Ci = Ct, ln = Ir;
        if (Mt + 1 < Ft.length) {
          let un = Ft[Mt + 1].offset;
          Ci = Math.min(Ct, vt + un.line), Ci === Ct ? ln = Math.min(Ir, ze + un.column) : Ci < Ct && (ln = ze + un.column);
        }
        il(or, Q, Z, ue, Re, we, at, vt + ss.line, ze + ss.column, Ci, ln);
      }
    }
    n(Ws, "recurse");
    function il(Y, Q, Z, ue, Re, we, at, vt, ze, Ct, Ir) {
      let Ft = ts(Y);
      if ("sections" in Ft)
        return Ws(...arguments);
      let Mt = new xt(Ft, Q), or = ue.length, ss = we.length, Ci = Xt(Mt), { resolvedSources: ln, sourcesContent: un, ignoreList: Qc } = Mt;
      if (rs(ue, ln), rs(we, Mt.names), un)
        rs(Re, un);
      else
        for (let Mr = 0; Mr < ln.length; Mr++)
          Re.push(null);
      if (Qc)
        for (let Mr = 0; Mr < Qc.length; Mr++)
          at.push(Qc[Mr] + or);
      for (let Mr = 0; Mr < Ci.length; Mr++) {
        let Zc = vt + Mr;
        if (Zc > Ct)
          return;
        let Hb = De(Z, Zc), n2 = Mr === 0 ? ze : 0, zb = Ci[Mr];
        for (let ep = 0; ep < zb.length; ep++) {
          let Ii = zb[ep], ll = n2 + Ii[a];
          if (Zc === Ct && ll >= Ir)
            return;
          if (Ii.length === 1) {
            Hb.push([ll]);
            continue;
          }
          let Gb = or + Ii[o], Qb = Ii[l], Zb = Ii[u];
          Hb.push(Ii.length === 4 ? [ll, Gb, Qb, Zb] : [ll, Gb, Qb, Zb, ss + Ii[c]]);
        }
      }
    }
    n(il, "addSection");
    function rs(Y, Q) {
      for (let Z = 0; Z < Q.length; Z++)
        Y.push(Q[Z]);
    }
    n(rs, "append");
    function De(Y, Q) {
      for (let Z = Y.length; Z <= Q; Z++)
        Y[Z] = [];
      return Y[Q];
    }
    n(De, "getLine");
    let Pe = "`line` must be greater than 0 (lines start at line 1)", Me = "`column` must be greater than or equal to 0 (columns start at co\
lumn 0)", Ue = -1, At = 1;
    class xt {
      static {
        n(this, "TraceMap");
      }
      constructor(Q, Z) {
        let ue = typeof Q == "string";
        if (!ue && Q._decodedMemo)
          return Q;
        let Re = ue ? JSON.parse(Q) : Q, { version: we, file: at, names: vt, sourceRoot: ze, sources: Ct, sourcesContent: Ir } = Re;
        this.version = we, this.file = at, this.names = vt || [], this.sourceRoot = ze, this.sources = Ct, this.sourcesContent = Ir, this.ignoreList =
        Re.ignoreList || Re.x_google_ignoreList || void 0;
        let Ft = s(ze || "", i(Z));
        this.resolvedSources = Ct.map((or) => s(or || "", Ft));
        let { mappings: Mt } = Re;
        typeof Mt == "string" ? (this._encoded = Mt, this._decoded = void 0) : (this._encoded = void 0, this._decoded = m(Mt, ue)), this._decodedMemo =
        de(), this._bySources = void 0, this._bySourceMemos = void 0;
      }
    }
    function wt(Y) {
      return Y;
    }
    n(wt, "cast");
    function tr(Y) {
      var Q, Z;
      return (Q = (Z = Y)._encoded) !== null && Q !== void 0 ? Q : Z._encoded = e.encode(Y._decoded);
    }
    n(tr, "encodedMappings");
    function Xt(Y) {
      var Q;
      return (Q = Y)._decoded || (Q._decoded = e.decode(Y._encoded));
    }
    n(Xt, "decodedMappings");
    function aa(Y, Q, Z) {
      let ue = Xt(Y);
      if (Q >= ue.length)
        return null;
      let Re = ue[Q], we = ol(Re, Y._decodedMemo, Q, Z, At);
      return we === -1 ? null : Re[we];
    }
    n(aa, "traceSegment");
    function an(Y, Q) {
      let { line: Z, column: ue, bias: Re } = Q;
      if (Z--, Z < 0)
        throw new Error(Pe);
      if (ue < 0)
        throw new Error(Me);
      let we = Xt(Y);
      if (Z >= we.length)
        return al(null, null, null, null);
      let at = we[Z], vt = ol(at, Y._decodedMemo, Z, ue, Re || At);
      if (vt === -1)
        return al(null, null, null, null);
      let ze = at[vt];
      if (ze.length === 1)
        return al(null, null, null, null);
      let { names: Ct, resolvedSources: Ir } = Y;
      return al(Ir[ze[o]], ze[l] + 1, ze[u], ze.length === 5 ? Ct[ze[c]] : null);
    }
    n(an, "originalPositionFor");
    function Pi(Y, Q) {
      let { source: Z, line: ue, column: Re, bias: we } = Q;
      return $b(Y, Z, ue, Re, we || At, !1);
    }
    n(Pi, "generatedPositionFor");
    function on(Y, Q) {
      let { source: Z, line: ue, column: Re, bias: we } = Q;
      return $b(Y, Z, ue, Re, we || Ue, !0);
    }
    n(on, "allGeneratedPositionsFor");
    function Ei(Y, Q) {
      let Z = Xt(Y), { names: ue, resolvedSources: Re } = Y;
      for (let we = 0; we < Z.length; we++) {
        let at = Z[we];
        for (let vt = 0; vt < at.length; vt++) {
          let ze = at[vt], Ct = we + 1, Ir = ze[0], Ft = null, Mt = null, or = null, ss = null;
          ze.length !== 1 && (Ft = Re[ze[1]], Mt = ze[2] + 1, or = ze[3]), ze.length === 5 && (ss = ue[ze[4]]), Q({
            generatedLine: Ct,
            generatedColumn: Ir,
            source: Ft,
            originalLine: Mt,
            originalColumn: or,
            name: ss
          });
        }
      }
    }
    n(Ei, "eachMapping");
    function Ai(Y, Q) {
      let { sources: Z, resolvedSources: ue } = Y, Re = Z.indexOf(Q);
      return Re === -1 && (Re = ue.indexOf(Q)), Re;
    }
    n(Ai, "sourceIndex");
    function vi(Y, Q) {
      let { sourcesContent: Z } = Y;
      if (Z == null)
        return null;
      let ue = Ai(Y, Q);
      return ue === -1 ? null : Z[ue];
    }
    n(vi, "sourceContentFor");
    function nl(Y, Q) {
      let { ignoreList: Z } = Y;
      if (Z == null)
        return !1;
      let ue = Ai(Y, Q);
      return ue === -1 ? !1 : Z.includes(ue);
    }
    n(nl, "isIgnored");
    function Xb(Y, Q) {
      let Z = new xt(Gc(Y, []), Q);
      return Z._decoded = Y.mappings, Z;
    }
    n(Xb, "presortedDecodedMap");
    function r2(Y) {
      return Gc(Y, Xt(Y));
    }
    n(r2, "decodedMap");
    function s2(Y) {
      return Gc(Y, tr(Y));
    }
    n(s2, "encodedMap");
    function Gc(Y, Q) {
      return {
        version: Y.version,
        file: Y.file,
        names: Y.names,
        sourceRoot: Y.sourceRoot,
        sources: Y.sources,
        sourcesContent: Y.sourcesContent,
        mappings: Q,
        ignoreList: Y.ignoreList || Y.x_google_ignoreList
      };
    }
    n(Gc, "clone");
    function al(Y, Q, Z, ue) {
      return { source: Y, line: Q, column: Z, name: ue };
    }
    n(al, "OMapping");
    function oa(Y, Q) {
      return { line: Y, column: Q };
    }
    n(oa, "GMapping");
    function ol(Y, Q, Z, ue, Re) {
      let we = ne(Y, ue, Q, Z);
      return _ ? we = (Re === Ue ? J : ie)(Y, ue, we) : Re === Ue && we++, we === -1 || we === Y.length ? -1 : we;
    }
    n(ol, "traceSegmentInternal");
    function i2(Y, Q, Z, ue, Re) {
      let we = ol(Y, Q, Z, ue, At);
      if (!_ && Re === Ue && we++, we === -1 || we === Y.length)
        return [];
      let at = _ ? ue : Y[we][a];
      _ || (we = ie(Y, at, we));
      let vt = J(Y, at, we), ze = [];
      for (; we <= vt; we++) {
        let Ct = Y[we];
        ze.push(oa(Ct[p] + 1, Ct[f]));
      }
      return ze;
    }
    n(i2, "sliceGeneratedPositions");
    function $b(Y, Q, Z, ue, Re, we) {
      var at;
      if (Z--, Z < 0)
        throw new Error(Pe);
      if (ue < 0)
        throw new Error(Me);
      let { sources: vt, resolvedSources: ze } = Y, Ct = vt.indexOf(Q);
      if (Ct === -1 && (Ct = ze.indexOf(Q)), Ct === -1)
        return we ? [] : oa(null, null);
      let Ft = ((at = Y)._bySources || (at._bySources = Be(Xt(Y), Y._bySourceMemos = vt.map(de))))[Ct][Z];
      if (Ft == null)
        return we ? [] : oa(null, null);
      let Mt = Y._bySourceMemos[Ct];
      if (we)
        return i2(Ft, Mt, Z, ue, Re);
      let or = ol(Ft, Mt, Z, ue, Re);
      if (or === -1)
        return oa(null, null);
      let ss = Ft[or];
      return oa(ss[p] + 1, ss[f]);
    }
    n($b, "generatedPosition"), t.AnyMap = Jt, t.GREATEST_LOWER_BOUND = At, t.LEAST_UPPER_BOUND = Ue, t.TraceMap = xt, t.allGeneratedPositionsFor =
    on, t.decodedMap = r2, t.decodedMappings = Xt, t.eachMapping = Ei, t.encodedMap = s2, t.encodedMappings = tr, t.generatedPositionFor = Pi,
    t.isIgnored = nl, t.originalPositionFor = an, t.presortedDecodedMap = Xb, t.sourceContentFor = vi, t.traceSegment = aa;
  });
});

// ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var uh = w((jl, ig) => {
  (function(t, e) {
    typeof jl == "object" && typeof ig < "u" ? e(jl, eg(), ah(), Fl()) : typeof define == "function" && define.amd ? define(["exports", "@jr\
idgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], e) : (t = typeof globalThis < "u" ? globalThis : t || self,
    e(t.genMapping = {}, t.setArray, t.sourcemapCodec, t.traceMapping));
  })(jl, function(t, e, r, s) {
    "use strict";
    class p {
      static {
        n(this, "GenMapping");
      }
      constructor({ file: Pe, sourceRoot: Me } = {}) {
        this._names = new e.SetArray(), this._sources = new e.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = Pe, this.
        sourceRoot = Me, this._ignoreList = new e.SetArray();
      }
    }
    function f(De) {
      return De;
    }
    n(f, "cast");
    function m(De, Pe, Me, Ue, At, xt, wt, tr) {
      return ne(!1, De, Pe, Me, Ue, At, xt, wt, tr);
    }
    n(m, "addSegment");
    function y(De, Pe) {
      return rs(!1, De, Pe);
    }
    n(y, "addMapping");
    let T = /* @__PURE__ */ n((De, Pe, Me, Ue, At, xt, wt, tr) => ne(!0, De, Pe, Me, Ue, At, xt, wt, tr), "maybeAddSegment"), L = /* @__PURE__ */ n(
    (De, Pe) => rs(!0, De, Pe), "maybeAddMapping");
    function q(De, Pe, Me) {
      let { _sources: Ue, _sourcesContent: At } = De, xt = e.put(Ue, Pe);
      At[xt] = Me;
    }
    n(q, "setSourceContent");
    function _(De, Pe, Me = !0) {
      let { _sources: Ue, _sourcesContent: At, _ignoreList: xt } = De, wt = e.put(Ue, Pe);
      wt === At.length && (At[wt] = null), Me ? e.put(xt, wt) : e.remove(xt, wt);
    }
    n(_, "setIgnore");
    function U(De) {
      let { _mappings: Pe, _sources: Me, _sourcesContent: Ue, _names: At, _ignoreList: xt } = De;
      return Jt(Pe), {
        version: 3,
        file: De.file || void 0,
        names: At.array,
        sourceRoot: De.sourceRoot || void 0,
        sources: Me.array,
        sourcesContent: Ue,
        mappings: Pe,
        ignoreList: xt.array
      };
    }
    n(U, "toDecodedMap");
    function J(De) {
      let Pe = U(De);
      return Object.assign(Object.assign({}, Pe), { mappings: r.encode(Pe.mappings) });
    }
    n(J, "toEncodedMap");
    function ie(De) {
      let Pe = new s.TraceMap(De), Me = new p({ file: Pe.file, sourceRoot: Pe.sourceRoot });
      return ts(Me._names, Pe.names), ts(Me._sources, Pe.sources), Me._sourcesContent = Pe.sourcesContent || Pe.sources.map(() => null), Me.
      _mappings = s.decodedMappings(Pe), Pe.ignoreList && ts(Me._ignoreList, Pe.ignoreList), Me;
    }
    n(ie, "fromMap");
    function de(De) {
      let Pe = [], { _mappings: Me, _sources: Ue, _names: At } = De;
      for (let xt = 0; xt < Me.length; xt++) {
        let wt = Me[xt];
        for (let tr = 0; tr < wt.length; tr++) {
          let Xt = wt[tr], aa = { line: xt + 1, column: Xt[0] }, an, Pi, on;
          Xt.length !== 1 && (an = Ue.array[Xt[1]], Pi = { line: Xt[2] + 1, column: Xt[3] }, Xt.length === 5 && (on = At.array[Xt[4]])), Pe.
          push({ generated: aa, source: an, original: Pi, name: on });
        }
      }
      return Pe;
    }
    n(de, "allMappings");
    function ne(De, Pe, Me, Ue, At, xt, wt, tr, Xt) {
      let { _mappings: aa, _sources: an, _sourcesContent: Pi, _names: on } = Pe, Ei = Be(aa, Me), Ai = bt(Ei, Ue);
      if (!At)
        return De && Ws(Ei, Ai) ? void 0 : Et(Ei, Ai, [Ue]);
      let vi = e.put(an, At), nl = tr ? e.put(on, tr) : -1;
      if (vi === Pi.length && (Pi[vi] = Xt ?? null), !(De && il(Ei, Ai, vi, xt, wt, nl)))
        return Et(Ei, Ai, tr ? [Ue, vi, xt, wt, nl] : [Ue, vi, xt, wt]);
    }
    n(ne, "addSegmentInternal");
    function Be(De, Pe) {
      for (let Me = De.length; Me <= Pe; Me++)
        De[Me] = [];
      return De[Pe];
    }
    n(Be, "getLine");
    function bt(De, Pe) {
      let Me = De.length;
      for (let Ue = Me - 1; Ue >= 0; Me = Ue--) {
        let At = De[Ue];
        if (Pe >= At[0])
          break;
      }
      return Me;
    }
    n(bt, "getColumnIndex");
    function Et(De, Pe, Me) {
      for (let Ue = De.length; Ue > Pe; Ue--)
        De[Ue] = De[Ue - 1];
      De[Pe] = Me;
    }
    n(Et, "insert");
    function Jt(De) {
      let { length: Pe } = De, Me = Pe;
      for (let Ue = Me - 1; Ue >= 0 && !(De[Ue].length > 0); Me = Ue, Ue--)
        ;
      Me < Pe && (De.length = Me);
    }
    n(Jt, "removeEmptyFinalLines");
    function ts(De, Pe) {
      for (let Me = 0; Me < Pe.length; Me++)
        e.put(De, Pe[Me]);
    }
    n(ts, "putAll");
    function Ws(De, Pe) {
      return Pe === 0 ? !0 : De[Pe - 1].length === 1;
    }
    n(Ws, "skipSourceless");
    function il(De, Pe, Me, Ue, At, xt) {
      if (Pe === 0)
        return !1;
      let wt = De[Pe - 1];
      return wt.length === 1 ? !1 : Me === wt[1] && Ue === wt[2] && At === wt[3] && xt === (wt.length === 5 ? wt[4] : -1);
    }
    n(il, "skipSource");
    function rs(De, Pe, Me) {
      let { generated: Ue, source: At, original: xt, name: wt, content: tr } = Me;
      return At ? ne(De, Pe, Ue.line - 1, Ue.column, At, xt.line - 1, xt.column, wt, tr) : ne(De, Pe, Ue.line - 1, Ue.column, null, null, null,
      null, null);
    }
    n(rs, "addMappingInternal"), t.GenMapping = p, t.addMapping = y, t.addSegment = m, t.allMappings = de, t.fromMap = ie, t.maybeAddMapping =
    L, t.maybeAddSegment = T, t.setIgnore = _, t.setSourceContent = q, t.toDecodedMap = U, t.toEncodedMap = J, Object.defineProperty(t, "__e\
sModule", { value: !0 });
  });
});

// ../node_modules/@babel/generator/lib/source-map.js
var ng = w((Rl) => {
  "use strict";
  Object.defineProperty(Rl, "__esModule", {
    value: !0
  });
  Rl.default = void 0;
  var Hs = uh(), ch = Fl(), ph = class {
    static {
      n(this, "SourceMap");
    }
    constructor(e, r) {
      var s;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let i = this._map = new Hs.GenMapping({
        sourceRoot: e.sourceRoot
      });
      if (this._sourceFileName = (s = e.sourceFileName) == null ? void 0 : s.replace(/\\/g, "/"), this._rawMappings = void 0, e.inputSourceMap) {
        this._inputMap = new ch.TraceMap(e.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, Hs.setSourceContent)(i, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof r == "string" && !e.inputSourceMap)
        (0, Hs.setSourceContent)(i, this._sourceFileName, r);
      else if (typeof r == "object")
        for (let o of Object.keys(r))
          (0, Hs.setSourceContent)(i, o.replace(/\\/g, "/"), r[o]);
    }
    get() {
      return (0, Hs.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, Hs.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, Hs.allMappings)(this._map));
    }
    mark(e, r, s, i, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (r != null)
        if (this._inputMap) {
          if (u = (0, ch.originalPositionFor)(this._inputMap, {
            line: r,
            column: s
          }), !u.name && a) {
            let c = (0, ch.originalPositionFor)(this._inputMap, a);
            c.name && (i = c.name);
          }
        } else
          u = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: r,
            column: s
          };
      (0, Hs.maybeAddMapping)(this._map, {
        name: i,
        generated: e,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  Rl.default = ph;
});

// ../node_modules/@babel/generator/lib/buffer.js
var ag = w((Ul) => {
  "use strict";
  Object.defineProperty(Ul, "__esModule", {
    value: !0
  });
  Ul.default = void 0;
  var fh = class {
    static {
      n(this, "Buffer");
    }
    constructor(e, r) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = e, this._indentChar = r;
      for (let s = 0; s < 64; s++)
        this._fastIndentations.push(r.repeat(s));
      this._allocQueue();
    }
    _allocQueue() {
      let e = this._queue;
      for (let r = 0; r < 16; r++)
        e.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(e, r, s, i, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = e, l.repeat = r, l.line = s, l.column = i, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let e = this._map, r = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: e?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let s = e ? e.get() : null;
          return r.map = s, s;
        },
        set map(s) {
          Object.defineProperty(r, "map", {
            value: s,
            writable: !0
          });
        },
        get rawMappings() {
          let s = e?.getRawMappings();
          return r.rawMappings = s, s;
        },
        set rawMappings(s) {
          Object.defineProperty(r, "rawMappings", {
            value: s,
            writable: !0
          });
        }
      };
      return r;
    }
    append(e, r) {
      this._flush(), this._append(e, this._sourcePosition, r);
    }
    appendChar(e) {
      this._flush(), this._appendChar(e, 1, this._sourcePosition);
    }
    queue(e) {
      if (e === 10)
        for (; this._queueCursor !== 0; ) {
          let s = this._queue[this._queueCursor - 1].char;
          if (s !== 32 && s !== 9)
            break;
          this._queueCursor--;
        }
      let r = this._sourcePosition;
      this._pushQueue(e, 1, r.line, r.column, r.filename);
    }
    queueIndentation(e) {
      e !== 0 && this._pushQueue(-1, e, void 0, void 0, void 0);
    }
    _flush() {
      let e = this._queueCursor, r = this._queue;
      for (let s = 0; s < e; s++) {
        let i = r[s];
        this._appendChar(i.char, i.repeat, i);
      }
      this._queueCursor = 0;
    }
    _appendChar(e, r, s) {
      if (this._last = e, e === -1) {
        let i = this._fastIndentations[r];
        i !== void 0 ? this._str += i : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
      } else
        this._str += r > 1 ? String.fromCharCode(e).repeat(r) : String.fromCharCode(e);
      e !== 10 ? (this._mark(s.line, s.column, s.identifierName, s.identifierNamePos, s.filename), this._position.column += r) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (s.identifierName = void 0, s.identifierNamePos = void 0);
    }
    _append(e, r, s) {
      let i = e.length, a = this._position;
      if (this._last = e.charCodeAt(i - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = e, this._appendCount =
      0) : this._str += e, !s && !this._map) {
        a.column += i;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: c
      } = r, p = r.line;
      (l != null || u != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
      let f = e.indexOf(`
`), m = 0;
      for (f !== 0 && this._mark(p, o, l, u, c); f !== -1; )
        a.line++, a.column = 0, m = f + 1, m < i && p !== void 0 && this._mark(++p, 0, null, null, c), f = e.indexOf(`
`, m);
      a.column += i - m;
    }
    _mark(e, r, s, i, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, e, r, s, i, a);
    }
    removeTrailingNewline() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let e = this._queueCursor;
      return e !== 0 ? this._queue[e - 1].char : this._last;
    }
    getNewlineCount() {
      let e = this._queueCursor, r = 0;
      if (e === 0) return this._last === 10 ? 1 : 0;
      for (let s = e - 1; s >= 0 && this._queue[s].char === 10; s--)
        r++;
      return r === e && this._last === 10 ? r + 1 : r;
    }
    endsWithCharAndNewline() {
      let e = this._queue, r = this._queueCursor;
      if (r !== 0)
        return e[r - 1].char !== 10 ? void 0 : r > 1 ? e[r - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(e, r) {
      if (!this._map) {
        r();
        return;
      }
      this.source("start", e);
      let s = e.identifierName, i = this._sourcePosition;
      s && (this._canMarkIdName = !1, i.identifierName = s), r(), s && (this._canMarkIdName = !0, i.identifierName = void 0, i.identifierNamePos =
      void 0), this.source("end", e);
    }
    source(e, r) {
      this._map && this._normalizePosition(e, r, 0);
    }
    sourceWithOffset(e, r, s) {
      this._map && this._normalizePosition(e, r, s);
    }
    withSource(e, r, s) {
      this._map && this.source(e, r), s();
    }
    _normalizePosition(e, r, s) {
      let i = r[e], a = this._sourcePosition;
      i && (a.line = i.line, a.column = Math.max(i.column + s, 0), a.filename = r.filename);
    }
    getCurrentColumn() {
      let e = this._queue, r = this._queueCursor, s = -1, i = 0;
      for (let a = 0; a < r; a++) {
        let o = e[a];
        o.char === 10 && (s = i), i += o.repeat;
      }
      return s === -1 ? this._position.column + i : i - 1 - s;
    }
    getCurrentLine() {
      let e = 0, r = this._queue;
      for (let s = 0; s < this._queueCursor; s++)
        r[s].char === 10 && e++;
      return this._position.line + e;
    }
  };
  Ul.default = fh;
});

// ../node_modules/@babel/generator/lib/node/whitespace.js
var pg = w((Vl) => {
  "use strict";
  Object.defineProperty(Vl, "__esModule", {
    value: !0
  });
  Vl.nodes = void 0;
  var xV = Ce(), {
    FLIPPED_ALIAS_KEYS: SV,
    isArrayExpression: gV,
    isAssignmentExpression: lg,
    isBinary: ug,
    isBlockStatement: PV,
    isCallExpression: cg,
    isFunction: Ia,
    isIdentifier: ql,
    isLiteral: EV,
    isMemberExpression: hh,
    isObjectExpression: AV,
    isOptionalCallExpression: vV,
    isOptionalMemberExpression: CV,
    isStringLiteral: IV
  } = xV;
  function dn(t, e) {
    return t && (hh(t) || CV(t) ? (dn(t.object, e), t.computed && dn(t.property, e)) : ug(t) || lg(t) ? (dn(t.left, e), dn(t.right, e)) : cg(
    t) || vV(t) ? (e.hasCall = !0, dn(t.callee, e)) : Ia(t) ? e.hasFunction = !0 : ql(t) && (e.hasHelper = e.hasHelper || t.callee && bs(t.callee))),
    e;
  }
  n(dn, "crawlInternal");
  function og(t) {
    return dn(t, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  n(og, "crawl");
  function bs(t) {
    return t ? hh(t) ? bs(t.object) || bs(t.property) : ql(t) ? t.name === "require" || t.name.charCodeAt(0) === 95 : cg(t) ? bs(t.callee) :
    ug(t) || lg(t) ? ql(t.left) && bs(t.left) || bs(t.right) : !1 : !1;
  }
  n(bs, "isHelper");
  function wV(t) {
    return EV(t) || AV(t) || gV(t) || ql(t) || hh(t);
  }
  n(wV, "isType");
  var _i = Vl.nodes = {
    AssignmentExpression(t) {
      let e = og(t.right);
      if (e.hasCall && e.hasHelper || e.hasFunction)
        return e.hasFunction ? 3 : 2;
    },
    SwitchCase(t, e) {
      return (t.consequent.length || e.cases[0] === t ? 1 : 0) | (!t.consequent.length && e.cases[e.cases.length - 1] === t ? 2 : 0);
    },
    LogicalExpression(t) {
      if (Ia(t.left) || Ia(t.right))
        return 2;
    },
    Literal(t) {
      if (IV(t) && t.value === "use strict")
        return 2;
    },
    CallExpression(t) {
      if (Ia(t.callee) || bs(t))
        return 3;
    },
    OptionalCallExpression(t) {
      if (Ia(t.callee))
        return 3;
    },
    VariableDeclaration(t) {
      for (let e = 0; e < t.declarations.length; e++) {
        let r = t.declarations[e], s = bs(r.id) && !wV(r.init);
        if (!s && r.init) {
          let i = og(r.init);
          s = bs(r.init) && i.hasCall || i.hasFunction;
        }
        if (s)
          return 3;
      }
    },
    IfStatement(t) {
      if (PV(t.consequent))
        return 3;
    }
  };
  _i.ObjectProperty = _i.ObjectTypeProperty = _i.ObjectMethod = function(t, e) {
    if (e.properties[0] === t)
      return 1;
  };
  _i.ObjectTypeCallProperty = function(t, e) {
    var r;
    if (e.callProperties[0] === t && !((r = e.properties) != null && r.length))
      return 1;
  };
  _i.ObjectTypeIndexer = function(t, e) {
    var r, s;
    if (e.indexers[0] === t && !((r = e.properties) != null && r.length) && !((s = e.callProperties) != null && s.length))
      return 1;
  };
  _i.ObjectTypeInternalSlot = function(t, e) {
    var r, s, i;
    if (e.internalSlots[0] === t && !((r = e.properties) != null && r.length) && !((s = e.callProperties) != null && s.length) && !((i = e.indexers) !=
    null && i.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  t, e]) {
    [t].concat(SV[t] || []).forEach(function(r) {
      let s = e ? 3 : 0;
      _i[r] = () => s;
    });
  });
});

// ../node_modules/@babel/generator/lib/node/parentheses.js
var yg = w((ut) => {
  "use strict";
  Object.defineProperty(ut, "__esModule", {
    value: !0
  });
  ut.ArrowFunctionExpression = sK;
  ut.AssignmentExpression = nK;
  ut.Binary = YV;
  ut.BinaryExpression = QV;
  ut.ClassExpression = tK;
  ut.ConditionalExpression = dh;
  ut.DoExpression = WV;
  ut.FunctionExpression = rK;
  ut.FunctionTypeAnnotation = qV;
  ut.Identifier = oK;
  ut.LogicalExpression = aK;
  ut.NullableTypeAnnotation = UV;
  ut.ObjectExpression = KV;
  ut.OptionalIndexedAccessType = XV;
  ut.OptionalCallExpression = ut.OptionalMemberExpression = iK;
  ut.SequenceExpression = ZV;
  ut.TSTypeAssertion = ut.TSSatisfiesExpression = ut.TSAsExpression = $V;
  ut.TSInferType = zV;
  ut.TSInstantiationExpression = GV;
  ut.TSIntersectionType = ut.TSUnionType = HV;
  ut.UnaryLike = mg;
  ut.IntersectionTypeAnnotation = ut.UnionTypeAnnotation = JV;
  ut.UpdateExpression = VV;
  ut.AwaitExpression = ut.YieldExpression = eK;
  var NV = Ce(), {
    isArrayTypeAnnotation: OV,
    isArrowFunctionExpression: kV,
    isBinaryExpression: DV,
    isCallExpression: _V,
    isExportDeclaration: LV,
    isForOfStatement: MV,
    isIndexedAccessType: BV,
    isMemberExpression: hg,
    isObjectPattern: FV,
    isOptionalMemberExpression: jV,
    isYieldExpression: RV
  } = NV, fg = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!\
=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function dg(t) {
    return t === "TSAsExpression" || t === "TSSatisfiesExpression" || t === "TSTypeAssertion";
  }
  n(dg, "isTSTypeExpression");
  var Kl = /* @__PURE__ */ n((t, e) => {
    let r = e.type;
    return (r === "ClassDeclaration" || r === "ClassExpression") && e.superClass === t;
  }, "isClassExtendsClause"), wa = /* @__PURE__ */ n((t, e) => {
    let r = e.type;
    return (r === "MemberExpression" || r === "OptionalMemberExpression") && e.object === t || (r === "CallExpression" || r === "OptionalCal\
lExpression" || r === "NewExpression") && e.callee === t || r === "TaggedTemplateExpression" && e.tag === t || r === "TSNonNullExpression";
  }, "hasPostfixPart");
  function UV(t, e) {
    return OV(e);
  }
  n(UV, "NullableTypeAnnotation");
  function qV(t, e, r) {
    if (r.length < 3) return;
    let s = e.type;
    return s === "UnionTypeAnnotation" || s === "IntersectionTypeAnnotation" || s === "ArrayTypeAnnotation" || s === "TypeAnnotation" && kV(
    r[r.length - 3]);
  }
  n(qV, "FunctionTypeAnnotation");
  function VV(t, e) {
    return wa(t, e) || Kl(t, e);
  }
  n(VV, "UpdateExpression");
  function KV(t, e, r) {
    return Na(r, 3);
  }
  n(KV, "ObjectExpression");
  function WV(t, e, r) {
    return !t.async && Na(r, 1);
  }
  n(WV, "DoExpression");
  function YV(t, e) {
    let r = e.type;
    if (t.operator === "**" && r === "BinaryExpression" && e.operator === "**")
      return e.left === t;
    if (Kl(t, e) || wa(t, e) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
      return !0;
    if (r === "BinaryExpression" || r === "LogicalExpression") {
      let s = fg.get(e.operator), i = fg.get(t.operator);
      if (s === i && e.right === t && r !== "LogicalExpression" || s > i)
        return !0;
    }
  }
  n(YV, "Binary");
  function JV(t, e) {
    let r = e.type;
    return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
  }
  n(JV, "UnionTypeAnnotation");
  function XV(t, e) {
    return BV(e) && e.objectType === t;
  }
  n(XV, "OptionalIndexedAccessType");
  function $V() {
    return !0;
  }
  n($V, "TSAsExpression");
  function HV(t, e) {
    let r = e.type;
    return r === "TSArrayType" || r === "TSOptionalType" || r === "TSIntersectionType" || r === "TSUnionType" || r === "TSRestType";
  }
  n(HV, "TSUnionType");
  function zV(t, e) {
    let r = e.type;
    return r === "TSArrayType" || r === "TSOptionalType";
  }
  n(zV, "TSInferType");
  function GV(t, e) {
    let r = e.type;
    return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!e.typeParameters;
  }
  n(GV, "TSInstantiationExpression");
  function QV(t, e) {
    if (t.operator === "in") {
      let r = e.type;
      return r === "VariableDeclarator" || r === "ForStatement" || r === "ForInStatement" || r === "ForOfStatement";
    }
    return !1;
  }
  n(QV, "BinaryExpression");
  function ZV(t, e) {
    let r = e.type;
    return !(r === "ForStatement" || r === "ThrowStatement" || r === "ReturnStatement" || r === "IfStatement" && e.test === t || r === "Whil\
eStatement" && e.test === t || r === "ForInStatement" && e.right === t || r === "SwitchStatement" && e.discriminant === t || r === "Expressi\
onStatement" && e.expression === t);
  }
  n(ZV, "SequenceExpression");
  function eK(t, e) {
    let r = e.type;
    return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || wa(t, e) || r === "A\
waitExpression" && RV(t) || r === "ConditionalExpression" && t === e.test || Kl(t, e);
  }
  n(eK, "YieldExpression");
  function tK(t, e, r) {
    return Na(r, 5);
  }
  n(tK, "ClassExpression");
  function mg(t, e) {
    return wa(t, e) || DV(e) && e.operator === "**" && e.left === t || Kl(t, e);
  }
  n(mg, "UnaryLike");
  function rK(t, e, r) {
    return Na(r, 5);
  }
  n(rK, "FunctionExpression");
  function sK(t, e) {
    return LV(e) || dh(t, e);
  }
  n(sK, "ArrowFunctionExpression");
  function dh(t, e) {
    let r = e.type;
    return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalEx\
pression" && e.test === t || r === "AwaitExpression" || dg(r) ? !0 : mg(t, e);
  }
  n(dh, "ConditionalExpression");
  function iK(t, e) {
    return _V(e) && e.callee === t || hg(e) && e.object === t;
  }
  n(iK, "OptionalMemberExpression");
  function nK(t, e) {
    return FV(t.left) ? !0 : dh(t, e);
  }
  n(nK, "AssignmentExpression");
  function aK(t, e) {
    let r = e.type;
    if (dg(r)) return !0;
    if (r !== "LogicalExpression") return !1;
    switch (t.operator) {
      case "||":
        return e.operator === "??" || e.operator === "&&";
      case "&&":
        return e.operator === "??";
      case "??":
        return e.operator !== "??";
    }
  }
  n(aK, "LogicalExpression");
  function oK(t, e, r) {
    var s;
    let i = e.type;
    if ((s = t.extra) != null && s.parenthesized && i === "AssignmentExpression" && e.left === t) {
      let a = e.right.type;
      if ((a === "FunctionExpression" || a === "ClassExpression") && e.right.id == null)
        return !0;
    }
    if (t.name === "let") {
      let a = hg(e, {
        object: t,
        computed: !0
      }) || jV(e, {
        object: t,
        computed: !0,
        optional: !1
      });
      return Na(r, a ? 57 : 32);
    }
    return t.name === "async" && MV(e) && t === e.left;
  }
  n(oK, "Identifier");
  function Na(t, e) {
    let r = e & 1, s = e & 2, i = e & 4, a = e & 8, o = e & 16, l = e & 32, u = t.length - 1;
    if (u <= 0) return;
    let c = t[u];
    u--;
    let p = t[u];
    for (; u >= 0; ) {
      let f = p.type;
      if (r && f === "ExpressionStatement" && p.expression === c || i && f === "ExportDefaultDeclaration" && c === p.declaration || s && f ===
      "ArrowFunctionExpression" && p.body === c || a && f === "ForStatement" && p.init === c || o && f === "ForInStatement" && p.left === c ||
      l && f === "ForOfStatement" && p.left === c)
        return !0;
      if (u > 0 && (wa(c, p) && f !== "NewExpression" || f === "SequenceExpression" && p.expressions[0] === c || f === "UpdateExpression" &&
      !p.prefix || f === "ConditionalExpression" && p.test === c || (f === "BinaryExpression" || f === "LogicalExpression") && p.left === c ||
      f === "AssignmentExpression" && p.left === c))
        c = p, u--, p = t[u];
      else
        return !1;
    }
    return !1;
  }
  n(Na, "isFirstInContext");
});

// ../node_modules/@babel/generator/lib/node/index.js
var yh = w((mn) => {
  "use strict";
  Object.defineProperty(mn, "__esModule", {
    value: !0
  });
  mn.needsParens = SK;
  mn.needsWhitespace = mh;
  mn.needsWhitespaceAfter = xK;
  mn.needsWhitespaceBefore = bK;
  var lK = pg(), uK = yg(), cK = Ce(), {
    FLIPPED_ALIAS_KEYS: pK,
    isCallExpression: fK,
    isExpressionStatement: hK,
    isMemberExpression: dK,
    isNewExpression: mK
  } = cK;
  function Tg(t) {
    let e = /* @__PURE__ */ new Map();
    function r(s, i) {
      let a = e.get(s);
      e.set(s, a ? function(o, l, u) {
        var c;
        return (c = a(o, l, u)) != null ? c : i(o, l, u);
      } : i);
    }
    n(r, "add");
    for (let s of Object.keys(t)) {
      let i = pK[s];
      if (i)
        for (let a of i)
          r(a, t[s]);
      else
        r(s, t[s]);
    }
    return e;
  }
  n(Tg, "expandAliases");
  var yK = Tg(uK), TK = Tg(lK.nodes);
  function bg(t) {
    return fK(t) ? !0 : dK(t) && bg(t.object);
  }
  n(bg, "isOrHasCallExpression");
  function mh(t, e, r) {
    var s;
    if (!t) return !1;
    hK(t) && (t = t.expression);
    let i = (s = TK.get(t.type)) == null ? void 0 : s(t, e);
    return typeof i == "number" ? (i & r) !== 0 : !1;
  }
  n(mh, "needsWhitespace");
  function bK(t, e) {
    return mh(t, e, 1);
  }
  n(bK, "needsWhitespaceBefore");
  function xK(t, e) {
    return mh(t, e, 2);
  }
  n(xK, "needsWhitespaceAfter");
  function SK(t, e, r) {
    var s;
    return e ? mK(e) && e.callee === t && bg(t) ? !0 : (s = yK.get(t.type)) == null ? void 0 : s(t, e, r) : !1;
  }
  n(SK, "needsParens");
});

// ../node_modules/@babel/generator/lib/generators/template-literals.js
var xg = w((Oa) => {
  "use strict";
  Object.defineProperty(Oa, "__esModule", {
    value: !0
  });
  Oa.TaggedTemplateExpression = gK;
  Oa.TemplateElement = PK;
  Oa.TemplateLiteral = EK;
  function gK(t) {
    this.print(t.tag, t), this.print(t.typeParameters, t), this.print(t.quasi, t);
  }
  n(gK, "TaggedTemplateExpression");
  function PK() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  n(PK, "TemplateElement");
  function EK(t) {
    let e = t.quasis, r = "`";
    for (let s = 0; s < e.length; s++)
      r += e[s].value.raw, s + 1 < e.length && (this.token(r + "${", !0), this.print(t.expressions[s], t), r = "}");
    this.token(r + "`", !0);
  }
  n(EK, "TemplateLiteral");
});

// ../node_modules/@babel/generator/lib/generators/expressions.js
var Pg = w((yt) => {
  "use strict";
  Object.defineProperty(yt, "__esModule", {
    value: !0
  });
  yt.LogicalExpression = yt.BinaryExpression = yt.AssignmentExpression = HK;
  yt.AssignmentPattern = $K;
  yt.AwaitExpression = WK;
  yt.BindExpression = zK;
  yt.CallExpression = VK;
  yt.ConditionalExpression = DK;
  yt.Decorator = RK;
  yt.DoExpression = NK;
  yt.EmptyStatement = JK;
  yt.ExpressionStatement = XK;
  yt.Import = KK;
  yt.MemberExpression = GK;
  yt.MetaProperty = QK;
  yt.ModuleExpression = tW;
  yt.NewExpression = _K;
  yt.OptionalCallExpression = qK;
  yt.OptionalMemberExpression = UK;
  yt.ParenthesizedExpression = OK;
  yt.PrivateName = ZK;
  yt.SequenceExpression = LK;
  yt.Super = BK;
  yt.ThisExpression = MK;
  yt.UnaryExpression = wK;
  yt.UpdateExpression = kK;
  yt.V8IntrinsicIdentifier = eW;
  yt.YieldExpression = YK;
  yt._shouldPrintDecoratorsBeforeExport = jK;
  var AK = Ce(), vK = yh(), {
    isCallExpression: CK,
    isLiteral: Sg,
    isMemberExpression: Th,
    isNewExpression: IK
  } = AK;
  function wK(t) {
    let {
      operator: e
    } = t;
    e === "void" || e === "delete" || e === "typeof" || e === "throw" ? (this.word(e), this.space()) : this.token(e), this.print(t.argument,
    t);
  }
  n(wK, "UnaryExpression");
  function NK(t) {
    t.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(t.body, t);
  }
  n(NK, "DoExpression");
  function OK(t) {
    this.tokenChar(40), this.print(t.expression, t), this.rightParens(t);
  }
  n(OK, "ParenthesizedExpression");
  function kK(t) {
    t.prefix ? (this.token(t.operator), this.print(t.argument, t)) : (this.printTerminatorless(t.argument, t, !0), this.token(t.operator));
  }
  n(kK, "UpdateExpression");
  function DK(t) {
    this.print(t.test, t), this.space(), this.tokenChar(63), this.space(), this.print(t.consequent, t), this.space(), this.tokenChar(58), this.
    space(), this.print(t.alternate, t);
  }
  n(DK, "ConditionalExpression");
  function _K(t, e) {
    this.word("new"), this.space(), this.print(t.callee, t), !(this.format.minified && t.arguments.length === 0 && !t.optional && !CK(e, {
      callee: t
    }) && !Th(e) && !IK(e)) && (this.print(t.typeArguments, t), this.print(t.typeParameters, t), t.optional && this.token("?."), this.tokenChar(
    40), this.printList(t.arguments, t), this.rightParens(t));
  }
  n(_K, "NewExpression");
  function LK(t) {
    this.printList(t.expressions, t);
  }
  n(LK, "SequenceExpression");
  function MK() {
    this.word("this");
  }
  n(MK, "ThisExpression");
  function BK() {
    this.word("super");
  }
  n(BK, "Super");
  function gg(t) {
    switch (t.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !t.computed && t.property.type === "Identifier" && gg(t.object);
      default:
        return !1;
    }
  }
  n(gg, "isDecoratorMemberExpression");
  function FK(t) {
    return t.type === "ParenthesizedExpression" ? !1 : !gg(t.type === "CallExpression" ? t.callee : t);
  }
  n(FK, "shouldParenthesizeDecoratorExpression");
  function jK(t) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof t.start == "number" && t.start ===
    t.declaration.start;
  }
  n(jK, "_shouldPrintDecoratorsBeforeExport");
  function RK(t) {
    this.tokenChar(64);
    let {
      expression: e
    } = t;
    FK(e) ? (this.tokenChar(40), this.print(e, t), this.tokenChar(41)) : this.print(e, t), this.newline();
  }
  n(RK, "Decorator");
  function UK(t) {
    let {
      computed: e
    } = t, {
      optional: r,
      property: s
    } = t;
    if (this.print(t.object, t), !e && Th(s))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    Sg(s) && typeof s.value == "number" && (e = !0), r && this.token("?."), e ? (this.tokenChar(91), this.print(s, t), this.tokenChar(93)) :
    (r || this.tokenChar(46), this.print(s, t));
  }
  n(UK, "OptionalMemberExpression");
  function qK(t) {
    this.print(t.callee, t), this.print(t.typeParameters, t), t.optional && this.token("?."), this.print(t.typeArguments, t), this.tokenChar(
    40), this.printList(t.arguments, t), this.rightParens(t);
  }
  n(qK, "OptionalCallExpression");
  function VK(t) {
    this.print(t.callee, t), this.print(t.typeArguments, t), this.print(t.typeParameters, t), this.tokenChar(40), this.printList(t.arguments,
    t), this.rightParens(t);
  }
  n(VK, "CallExpression");
  function KK() {
    this.word("import");
  }
  n(KK, "Import");
  function WK(t) {
    this.word("await"), t.argument && (this.space(), this.printTerminatorless(t.argument, t, !1));
  }
  n(WK, "AwaitExpression");
  function YK(t) {
    this.word("yield", !0), t.delegate ? (this.tokenChar(42), t.argument && (this.space(), this.print(t.argument, t))) : t.argument && (this.
    space(), this.printTerminatorless(t.argument, t, !1));
  }
  n(YK, "YieldExpression");
  function JK() {
    this.semicolon(!0);
  }
  n(JK, "EmptyStatement");
  function XK(t) {
    this.print(t.expression, t), this.semicolon();
  }
  n(XK, "ExpressionStatement");
  function $K(t) {
    this.print(t.left, t), t.left.optional && this.tokenChar(63), this.print(t.left.typeAnnotation, t), this.space(), this.tokenChar(61), this.
    space(), this.print(t.right, t);
  }
  n($K, "AssignmentPattern");
  function HK(t, e) {
    let r = this.inForStatementInitCounter && t.operator === "in" && !vK.needsParens(t, e);
    r && this.tokenChar(40), this.print(t.left, t), this.space(), t.operator === "in" || t.operator === "instanceof" ? this.word(t.operator) :
    this.token(t.operator), this.space(), this.print(t.right, t), r && this.tokenChar(41);
  }
  n(HK, "AssignmentExpression");
  function zK(t) {
    this.print(t.object, t), this.token("::"), this.print(t.callee, t);
  }
  n(zK, "BindExpression");
  function GK(t) {
    if (this.print(t.object, t), !t.computed && Th(t.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let e = t.computed;
    Sg(t.property) && typeof t.property.value == "number" && (e = !0), e ? (this.tokenChar(91), this.print(t.property, t), this.tokenChar(93)) :
    (this.tokenChar(46), this.print(t.property, t));
  }
  n(GK, "MemberExpression");
  function QK(t) {
    this.print(t.meta, t), this.tokenChar(46), this.print(t.property, t);
  }
  n(QK, "MetaProperty");
  function ZK(t) {
    this.tokenChar(35), this.print(t.id, t);
  }
  n(ZK, "PrivateName");
  function eW(t) {
    this.tokenChar(37), this.word(t.name);
  }
  n(eW, "V8IntrinsicIdentifier");
  function tW(t) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: e
    } = t;
    (e.body.length || e.directives.length) && this.newline(), this.print(e, t), this.dedent(), this.rightBrace(t);
  }
  n(tW, "ModuleExpression");
});

// ../node_modules/@babel/generator/lib/generators/statements.js
var Cg = w((Dt) => {
  "use strict";
  Object.defineProperty(Dt, "__esModule", {
    value: !0
  });
  Dt.BreakStatement = pW;
  Dt.CatchClause = TW;
  Dt.ContinueStatement = fW;
  Dt.DebuggerStatement = SW;
  Dt.DoWhileStatement = cW;
  Dt.ForOfStatement = Dt.ForInStatement = void 0;
  Dt.ForStatement = lW;
  Dt.IfStatement = oW;
  Dt.LabeledStatement = mW;
  Dt.ReturnStatement = hW;
  Dt.SwitchCase = xW;
  Dt.SwitchStatement = bW;
  Dt.ThrowStatement = dW;
  Dt.TryStatement = yW;
  Dt.VariableDeclaration = gW;
  Dt.VariableDeclarator = PW;
  Dt.WhileStatement = uW;
  Dt.WithStatement = aW;
  var rW = Ce(), {
    isFor: Eg,
    isForStatement: sW,
    isIfStatement: iW,
    isStatement: nW
  } = rW;
  function aW(t) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(t.object, t), this.tokenChar(41), this.printBlock(t);
  }
  n(aW, "WithStatement");
  function oW(t) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(t.test, t), this.tokenChar(41), this.space();
    let e = t.alternate && iW(Ag(t.consequent));
    e && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(t.consequent, t), e && (this.dedent(), this.newline(),
    this.tokenChar(125)), t.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    t.alternate, t));
  }
  n(oW, "IfStatement");
  function Ag(t) {
    let {
      body: e
    } = t;
    return nW(e) === !1 ? t : Ag(e);
  }
  n(Ag, "getLastStatement");
  function lW(t) {
    this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(t.init, t), this.inForStatementInitCounter--,
    this.tokenChar(59), t.test && (this.space(), this.print(t.test, t)), this.tokenChar(59), t.update && (this.space(), this.print(t.update,
    t)), this.tokenChar(41), this.printBlock(t);
  }
  n(lW, "ForStatement");
  function uW(t) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(t.test, t), this.tokenChar(41), this.printBlock(t);
  }
  n(uW, "WhileStatement");
  function vg(t) {
    this.word("for"), this.space();
    let e = t.type === "ForOfStatement";
    e && t.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(t.left, t), this.space(),
    this.word(e ? "of" : "in"), this.space(), this.print(t.right, t), this.tokenChar(41), this.printBlock(t);
  }
  n(vg, "ForXStatement");
  var zFe = Dt.ForInStatement = vg, GFe = Dt.ForOfStatement = vg;
  function cW(t) {
    this.word("do"), this.space(), this.print(t.body, t), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(t.test,
    t), this.tokenChar(41), this.semicolon();
  }
  n(cW, "DoWhileStatement");
  function Wl(t, e, r, s) {
    e && (t.space(), t.printTerminatorless(e, r, s)), t.semicolon();
  }
  n(Wl, "printStatementAfterKeyword");
  function pW(t) {
    this.word("break"), Wl(this, t.label, t, !0);
  }
  n(pW, "BreakStatement");
  function fW(t) {
    this.word("continue"), Wl(this, t.label, t, !0);
  }
  n(fW, "ContinueStatement");
  function hW(t) {
    this.word("return"), Wl(this, t.argument, t, !1);
  }
  n(hW, "ReturnStatement");
  function dW(t) {
    this.word("throw"), Wl(this, t.argument, t, !1);
  }
  n(dW, "ThrowStatement");
  function mW(t) {
    this.print(t.label, t), this.tokenChar(58), this.space(), this.print(t.body, t);
  }
  n(mW, "LabeledStatement");
  function yW(t) {
    this.word("try"), this.space(), this.print(t.block, t), this.space(), t.handlers ? this.print(t.handlers[0], t) : this.print(t.handler, t),
    t.finalizer && (this.space(), this.word("finally"), this.space(), this.print(t.finalizer, t));
  }
  n(yW, "TryStatement");
  function TW(t) {
    this.word("catch"), this.space(), t.param && (this.tokenChar(40), this.print(t.param, t), this.print(t.param.typeAnnotation, t), this.tokenChar(
    41), this.space()), this.print(t.body, t);
  }
  n(TW, "CatchClause");
  function bW(t) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(t.discriminant, t), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(t.cases, t, {
      indent: !0,
      addNewlines(e, r) {
        if (!e && t.cases[t.cases.length - 1] === r) return -1;
      }
    }), this.rightBrace(t);
  }
  n(bW, "SwitchStatement");
  function xW(t) {
    t.test ? (this.word("case"), this.space(), this.print(t.test, t), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), t.consequent.
    length && (this.newline(), this.printSequence(t.consequent, t, {
      indent: !0
    }));
  }
  n(xW, "SwitchCase");
  function SW() {
    this.word("debugger"), this.semicolon();
  }
  n(SW, "DebuggerStatement");
  function gW(t, e) {
    t.declare && (this.word("declare"), this.space());
    let {
      kind: r
    } = t;
    this.word(r, r === "using" || r === "await using"), this.space();
    let s = !1;
    if (!Eg(e))
      for (let i of t.declarations)
        i.init && (s = !0);
    if (this.printList(t.declarations, t, {
      separator: s ? function() {
        this.tokenChar(44), this.newline();
      } : void 0,
      indent: t.declarations.length > 1
    }), Eg(e)) {
      if (sW(e)) {
        if (e.init === t) return;
      } else if (e.left === t) return;
    }
    this.semicolon();
  }
  n(gW, "VariableDeclaration");
  function PW(t) {
    this.print(t.id, t), t.definite && this.tokenChar(33), this.print(t.id.typeAnnotation, t), t.init && (this.space(), this.tokenChar(61), this.
    space(), this.print(t.init, t));
  }
  n(PW, "VariableDeclarator");
});

// ../node_modules/@babel/generator/lib/generators/classes.js
var Ig = w((Fr) => {
  "use strict";
  Object.defineProperty(Fr, "__esModule", {
    value: !0
  });
  Fr.ClassAccessorProperty = NW;
  Fr.ClassBody = IW;
  Fr.ClassExpression = Fr.ClassDeclaration = CW;
  Fr.ClassMethod = kW;
  Fr.ClassPrivateMethod = DW;
  Fr.ClassPrivateProperty = OW;
  Fr.ClassProperty = wW;
  Fr.StaticBlock = LW;
  Fr._classMethodHead = _W;
  var EW = Ce(), {
    isExportDefaultDeclaration: AW,
    isExportNamedDeclaration: vW
  } = EW;
  function CW(t, e) {
    (!(AW(e) || vW(e)) || !this._shouldPrintDecoratorsBeforeExport(e)) && this.printJoin(t.decorators, t), t.declare && (this.word("declare"),
    this.space()), t.abstract && (this.word("abstract"), this.space()), this.word("class"), t.id && (this.space(), this.print(t.id, t)), this.
    print(t.typeParameters, t), t.superClass && (this.space(), this.word("extends"), this.space(), this.print(t.superClass, t), this.print(t.
    superTypeParameters, t)), t.implements && (this.space(), this.word("implements"), this.space(), this.printList(t.implements, t)), this.space(),
    this.print(t.body, t);
  }
  n(CW, "ClassDeclaration");
  function IW(t) {
    this.tokenChar(123), t.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(t.body, t, {
      indent: !0
    }), this.endsWith(10) || this.newline(), this.rightBrace(t));
  }
  n(IW, "ClassBody");
  function wW(t) {
    var e;
    this.printJoin(t.decorators, t);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), t.computed ? (this.tokenChar(91), this.print(t.key, t), this.tokenChar(93)) :
    (this._variance(t), this.print(t.key, t)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(33), this.print(t.typeAnnotation,
    t), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value, t)), this.semicolon();
  }
  n(wW, "ClassProperty");
  function NW(t) {
    var e;
    this.printJoin(t.decorators, t);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), this.word("accessor", !0), this.space(), t.computed ? (this.tokenChar(91), this.
    print(t.key, t), this.tokenChar(93)) : (this._variance(t), this.print(t.key, t)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(
    33), this.print(t.typeAnnotation, t), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value, t)), this.semicolon();
  }
  n(NW, "ClassAccessorProperty");
  function OW(t) {
    this.printJoin(t.decorators, t), t.static && (this.word("static"), this.space()), this.print(t.key, t), this.print(t.typeAnnotation, t),
    t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value, t)), this.semicolon();
  }
  n(OW, "ClassPrivateProperty");
  function kW(t) {
    this._classMethodHead(t), this.space(), this.print(t.body, t);
  }
  n(kW, "ClassMethod");
  function DW(t) {
    this._classMethodHead(t), this.space(), this.print(t.body, t);
  }
  n(DW, "ClassPrivateMethod");
  function _W(t) {
    var e;
    this.printJoin(t.decorators, t);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), this._methodHead(t);
  }
  n(_W, "_classMethodHead");
  function LW(t) {
    this.word("static"), this.space(), this.tokenChar(123), t.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    t.body, t, {
      indent: !0
    }), this.rightBrace(t));
  }
  n(LW, "StaticBlock");
});

// ../node_modules/@babel/generator/lib/generators/methods.js
var wg = w((Jr) => {
  "use strict";
  Object.defineProperty(Jr, "__esModule", {
    value: !0
  });
  Jr.ArrowFunctionExpression = WW;
  Jr.FunctionDeclaration = Jr.FunctionExpression = KW;
  Jr._functionHead = VW;
  Jr._methodHead = UW;
  Jr._param = RW;
  Jr._parameters = jW;
  Jr._params = FW;
  Jr._predicate = qW;
  var MW = Ce(), {
    isIdentifier: BW
  } = MW;
  function FW(t, e, r) {
    this.print(t.typeParameters, t);
    let s = JW.call(this, e, r);
    s && this.sourceIdentifierName(s.name, s.pos), this.tokenChar(40), this._parameters(t.params, t), this.tokenChar(41);
    let i = t.type === "ArrowFunctionExpression";
    this.print(t.returnType, t, i), this._noLineTerminator = i;
  }
  n(FW, "_params");
  function jW(t, e) {
    let r = t.length;
    for (let s = 0; s < r; s++)
      this._param(t[s], e), s < t.length - 1 && (this.tokenChar(44), this.space());
  }
  n(jW, "_parameters");
  function RW(t, e) {
    this.printJoin(t.decorators, t), this.print(t, e), t.optional && this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(RW, "_param");
  function UW(t) {
    let e = t.kind, r = t.key;
    (e === "get" || e === "set") && (this.word(e), this.space()), t.async && (this.word("async", !0), this.space()), (e === "method" || e ===
    "init") && t.generator && this.tokenChar(42), t.computed ? (this.tokenChar(91), this.print(r, t), this.tokenChar(93)) : this.print(r, t),
    t.optional && this.tokenChar(63), this._params(t, t.computed && t.key.type !== "StringLiteral" ? void 0 : t.key, void 0);
  }
  n(UW, "_methodHead");
  function qW(t, e) {
    t.predicate && (t.returnType || this.tokenChar(58), this.space(), this.print(t.predicate, t, e));
  }
  n(qW, "_predicate");
  function VW(t, e) {
    t.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), t.generator && (this._endsWithInnerRaw =
    !1, this.tokenChar(42)), this.space(), t.id && this.print(t.id, t), this._params(t, t.id, e), t.type !== "TSDeclareFunction" && this._predicate(
    t);
  }
  n(VW, "_functionHead");
  function KW(t, e) {
    this._functionHead(t, e), this.space(), this.print(t.body, t);
  }
  n(KW, "FunctionExpression");
  function WW(t, e) {
    t.async && (this.word("async", !0), this.space());
    let r;
    !this.format.retainLines && t.params.length === 1 && BW(r = t.params[0]) && !YW(t, r) ? this.print(r, t, !0) : this._params(t, void 0, e),
    this._predicate(t, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(t.body, t);
  }
  n(WW, "ArrowFunctionExpression");
  function YW(t, e) {
    var r, s;
    return !!(t.typeParameters || t.returnType || t.predicate || e.typeAnnotation || e.optional || (r = e.leadingComments) != null && r.length ||
    (s = e.trailingComments) != null && s.length);
  }
  n(YW, "hasTypesOrComments");
  function JW(t, e) {
    let r = t;
    if (!r && e) {
      let u = e.type;
      u === "VariableDeclarator" ? r = e.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? r = e.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!e.computed || e.key.type === "StringLiteral") && (r = e.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (r = e.key);
    }
    if (!r) return;
    let s;
    if (r.type === "Identifier") {
      var i, a;
      s = {
        pos: (i = r.loc) == null ? void 0 : i.start,
        name: ((a = r.loc) == null ? void 0 : a.identifierName) || r.name
      };
    } else if (r.type === "PrivateName") {
      var o;
      s = {
        pos: (o = r.loc) == null ? void 0 : o.start,
        name: "#" + r.id.name
      };
    } else if (r.type === "StringLiteral") {
      var l;
      s = {
        pos: (l = r.loc) == null ? void 0 : l.start,
        name: r.value
      };
    }
    return s;
  }
  n(JW, "_getFuncIdName");
});

// ../node_modules/@babel/generator/lib/generators/modules.js
var bh = w((fr) => {
  "use strict";
  Object.defineProperty(fr, "__esModule", {
    value: !0
  });
  fr.ExportAllDeclaration = nY;
  fr.ExportDefaultDeclaration = oY;
  fr.ExportDefaultSpecifier = tY;
  fr.ExportNamedDeclaration = aY;
  fr.ExportNamespaceSpecifier = sY;
  fr.ExportSpecifier = rY;
  fr.ImportAttribute = uY;
  fr.ImportDeclaration = lY;
  fr.ImportDefaultSpecifier = eY;
  fr.ImportExpression = pY;
  fr.ImportNamespaceSpecifier = cY;
  fr.ImportSpecifier = ZW;
  fr._printAttributes = iY;
  var XW = Ce(), {
    isClassDeclaration: $W,
    isExportDefaultSpecifier: HW,
    isExportNamespaceSpecifier: zW,
    isImportDefaultSpecifier: GW,
    isImportNamespaceSpecifier: QW,
    isStatement: Og
  } = XW;
  function ZW(t) {
    (t.importKind === "type" || t.importKind === "typeof") && (this.word(t.importKind), this.space()), this.print(t.imported, t), t.local &&
    t.local.name !== t.imported.name && (this.space(), this.word("as"), this.space(), this.print(t.local, t));
  }
  n(ZW, "ImportSpecifier");
  function eY(t) {
    this.print(t.local, t);
  }
  n(eY, "ImportDefaultSpecifier");
  function tY(t) {
    this.print(t.exported, t);
  }
  n(tY, "ExportDefaultSpecifier");
  function rY(t) {
    t.exportKind === "type" && (this.word("type"), this.space()), this.print(t.local, t), t.exported && t.local.name !== t.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(t.exported, t));
  }
  n(rY, "ExportSpecifier");
  function sY(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.exported, t);
  }
  n(sY, "ExportNamespaceSpecifier");
  var Ng = !1;
  function iY(t) {
    let {
      importAttributesKeyword: e
    } = this.format, {
      attributes: r,
      assertions: s
    } = t;
    r && !e && !Ng && (Ng = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify \
the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\
\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let i = e === "assert" || !e && s;
    if (this.word(i ? "assert" : "with"), this.space(), !i && e !== "with") {
      this.printList(r || s, t);
      return;
    }
    this.tokenChar(123), this.space(), this.printList(r || s, t), this.space(), this.tokenChar(125);
  }
  n(iY, "_printAttributes");
  function nY(t) {
    var e, r;
    this.word("export"), this.space(), t.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (e = t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.print(t.source, t, !0),
    this.space(), this._printAttributes(t)) : this.print(t.source, t), this.semicolon();
  }
  n(nY, "ExportAllDeclaration");
  function kg(t, e) {
    $W(e.declaration) && t._shouldPrintDecoratorsBeforeExport(e) && t.printJoin(e.declaration.decorators, e);
  }
  n(kg, "maybePrintDecoratorsBeforeExport");
  function aY(t) {
    if (kg(this, t), this.word("export"), this.space(), t.declaration) {
      let s = t.declaration;
      this.print(s, t), Og(s) || this.semicolon();
    } else {
      t.exportKind === "type" && (this.word("type"), this.space());
      let s = t.specifiers.slice(0), i = !1;
      for (; ; ) {
        let a = s[0];
        if (HW(a) || zW(a))
          i = !0, this.print(s.shift(), t), s.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      if ((s.length || !s.length && !i) && (this.tokenChar(123), s.length && (this.space(), this.printList(s, t), this.space()), this.tokenChar(
      125)), t.source) {
        var e, r;
        this.space(), this.word("from"), this.space(), (e = t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.
        print(t.source, t, !0), this.space(), this._printAttributes(t)) : this.print(t.source, t);
      }
      this.semicolon();
    }
  }
  n(aY, "ExportNamedDeclaration");
  function oY(t) {
    kg(this, t), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
    let e = t.declaration;
    this.print(e, t), Og(e) || this.semicolon();
  }
  n(oY, "ExportDefaultDeclaration");
  function lY(t) {
    var e, r;
    this.word("import"), this.space();
    let s = t.importKind === "type" || t.importKind === "typeof";
    s ? (this.noIndentInnerCommentsHere(), this.word(t.importKind), this.space()) : t.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : t.phase && (this.noIndentInnerCommentsHere(), this.word(t.phase), this.space());
    let i = t.specifiers.slice(0), a = !!i.length;
    for (; a; ) {
      let o = i[0];
      if (GW(o) || QW(o))
        this.print(i.shift(), t), i.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    i.length ? (this.tokenChar(123), this.space(), this.printList(i, t), this.space(), this.tokenChar(125)) : s && !a && (this.tokenChar(123),
    this.tokenChar(125)), (a || s) && (this.space(), this.word("from"), this.space()), (e = t.attributes) != null && e.length || (r = t.assertions) !=
    null && r.length ? (this.print(t.source, t, !0), this.space(), this._printAttributes(t)) : this.print(t.source, t), this.semicolon();
  }
  n(lY, "ImportDeclaration");
  function uY(t) {
    this.print(t.key), this.tokenChar(58), this.space(), this.print(t.value);
  }
  n(uY, "ImportAttribute");
  function cY(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.local, t);
  }
  n(cY, "ImportNamespaceSpecifier");
  function pY(t) {
    this.word("import"), t.phase && (this.tokenChar(46), this.word(t.phase)), this.tokenChar(40), this.print(t.source, t), t.options != null &&
    (this.tokenChar(44), this.space(), this.print(t.options, t)), this.tokenChar(41);
  }
  n(pY, "ImportExpression");
});

// ../node_modules/jsesc/jsesc.js
var xh = w((a4e, Lg) => {
  "use strict";
  var Dg = {}, fY = Dg.hasOwnProperty, _g = /* @__PURE__ */ n((t, e) => {
    for (let r in t)
      fY.call(t, r) && e(r, t[r]);
  }, "forOwn"), hY = /* @__PURE__ */ n((t, e) => (e && _g(e, (r, s) => {
    t[r] = s;
  }), t), "extend"), dY = /* @__PURE__ */ n((t, e) => {
    let r = t.length, s = -1;
    for (; ++s < r; )
      e(t[s]);
  }, "forEach"), ka = Dg.toString, mY = Array.isArray, yY = Buffer.isBuffer, TY = /* @__PURE__ */ n((t) => ka.call(t) == "[object Object]", "\
isObject"), bY = /* @__PURE__ */ n((t) => typeof t == "string" || ka.call(t) == "[object String]", "isString"), xY = /* @__PURE__ */ n((t) => typeof t ==
  "number" || ka.call(t) == "[object Number]", "isNumber"), SY = /* @__PURE__ */ n((t) => typeof t == "function", "isFunction"), gY = /* @__PURE__ */ n(
  (t) => ka.call(t) == "[object Map]", "isMap"), PY = /* @__PURE__ */ n((t) => ka.call(t) == "[object Set]", "isSet"), EY = {
    '"': '\\"',
    "'": "\\'",
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, AY = /["'\\\b\f\n\r\t]/, vY = /[0-9]/, CY = /[ !#-&\(-\[\]-_a-~]/, zs = /* @__PURE__ */ n((t, e) => {
    let r = /* @__PURE__ */ n(() => {
      c = u, ++e.indentLevel, u = e.indent.repeat(e.indentLevel);
    }, "increaseIndentation"), s = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, i = e && e.json;
    i && (s.quotes = "double", s.wrap = !0), e = hY(s, e), e.quotes != "single" && e.quotes != "double" && e.quotes != "backtick" && (e.quotes =
    "single");
    let a = e.quotes == "double" ? '"' : e.quotes == "backtick" ? "`" : "'", o = e.compact, l = e.lowercaseHex, u = e.indent.repeat(e.indentLevel),
    c = "", p = e.__inline1__, f = e.__inline2__, m = o ? "" : `
`, y, T = !0, L = e.numbers == "binary", q = e.numbers == "octal", _ = e.numbers == "decimal", U = e.numbers == "hexadecimal";
    if (i && t && SY(t.toJSON) && (t = t.toJSON()), !bY(t)) {
      if (gY(t))
        return t.size == 0 ? "new Map()" : (o || (e.__inline1__ = !0, e.__inline2__ = !1), "new Map(" + zs(Array.from(t), e) + ")");
      if (PY(t))
        return t.size == 0 ? "new Set()" : "new Set(" + zs(Array.from(t), e) + ")";
      if (yY(t))
        return t.length == 0 ? "Buffer.from([])" : "Buffer.from(" + zs(Array.from(t), e) + ")";
      if (mY(t))
        return y = [], e.wrap = !0, p && (e.__inline1__ = !1, e.__inline2__ = !0), f || r(), dY(t, (ne) => {
          T = !1, f && (e.__inline2__ = !1), y.push(
            (o || f ? "" : u) + zs(ne, e)
          );
        }), T ? "[]" : f ? "[" + y.join(", ") + "]" : "[" + m + y.join("," + m) + m + (o ? "" : c) + "]";
      if (xY(t)) {
        if (i)
          return JSON.stringify(t);
        if (_)
          return String(t);
        if (U) {
          let ne = t.toString(16);
          return l || (ne = ne.toUpperCase()), "0x" + ne;
        }
        if (L)
          return "0b" + t.toString(2);
        if (q)
          return "0o" + t.toString(8);
      } else return TY(t) ? (y = [], e.wrap = !0, r(), _g(t, (ne, Be) => {
        T = !1, y.push(
          (o ? "" : u) + zs(ne, e) + ":" + (o ? "" : " ") + zs(Be, e)
        );
      }), T ? "{}" : "{" + m + y.join("," + m) + m + (o ? "" : c) + "}") : i ? JSON.stringify(t) || "null" : String(t);
    }
    let J = t, ie = -1, de = J.length;
    for (y = ""; ++ie < de; ) {
      let ne = J.charAt(ie);
      if (e.es6) {
        let ts = J.charCodeAt(ie);
        if (
          // check if it’s the start of a surrogate pair
          ts >= 55296 && ts <= 56319 && // high surrogate
          de > ie + 1
        ) {
          let Ws = J.charCodeAt(ie + 1);
          if (Ws >= 56320 && Ws <= 57343) {
            let rs = ((ts - 55296) * 1024 + Ws - 56320 + 65536).toString(16);
            l || (rs = rs.toUpperCase()), y += "\\u{" + rs + "}", ++ie;
            continue;
          }
        }
      }
      if (!e.escapeEverything) {
        if (CY.test(ne)) {
          y += ne;
          continue;
        }
        if (ne == '"') {
          y += a == ne ? '\\"' : ne;
          continue;
        }
        if (ne == "`") {
          y += a == ne ? "\\`" : ne;
          continue;
        }
        if (ne == "'") {
          y += a == ne ? "\\'" : ne;
          continue;
        }
      }
      if (ne == "\0" && !i && !vY.test(J.charAt(ie + 1))) {
        y += "\\0";
        continue;
      }
      if (AY.test(ne)) {
        y += EY[ne];
        continue;
      }
      let Be = ne.charCodeAt(0);
      if (e.minimal && Be != 8232 && Be != 8233) {
        y += ne;
        continue;
      }
      let bt = Be.toString(16);
      l || (bt = bt.toUpperCase());
      let Et = bt.length > 2 || i, Jt = "\\" + (Et ? "u" : "x") + ("0000" + bt).slice(Et ? -4 : -2);
      y += Jt;
    }
    return e.wrap && (y = a + y + a), a == "`" && (y = y.replace(/\$\{/g, "\\${")), e.isScriptContext ? y.replace(/<\/(script|style)/gi, "<\\\
/$1").replace(/<!--/g, i ? "\\u003C!--" : "\\x3C!--") : y;
  }, "jsesc");
  zs.version = "2.5.2";
  Lg.exports = zs;
});

// ../node_modules/@babel/generator/lib/generators/types.js
var gh = w((Nt) => {
  "use strict";
  Object.defineProperty(Nt, "__esModule", {
    value: !0
  });
  Nt.ArgumentPlaceholder = OY;
  Nt.ArrayPattern = Nt.ArrayExpression = MY;
  Nt.BigIntLiteral = KY;
  Nt.BooleanLiteral = RY;
  Nt.DecimalLiteral = WY;
  Nt.Identifier = NY;
  Nt.NullLiteral = UY;
  Nt.NumericLiteral = qY;
  Nt.ObjectPattern = Nt.ObjectExpression = DY;
  Nt.ObjectMethod = _Y;
  Nt.ObjectProperty = LY;
  Nt.PipelineBareFunction = XY;
  Nt.PipelinePrimaryTopicReference = $Y;
  Nt.PipelineTopicExpression = JY;
  Nt.RecordExpression = BY;
  Nt.RegExpLiteral = jY;
  Nt.SpreadElement = Nt.RestElement = kY;
  Nt.StringLiteral = VY;
  Nt.TopicReference = YY;
  Nt.TupleExpression = FY;
  var IY = Ce(), Bg = xh(), {
    isAssignmentPattern: wY,
    isIdentifier: Sh
  } = IY;
  function NY(t) {
    var e;
    this.sourceIdentifierName(((e = t.loc) == null ? void 0 : e.identifierName) || t.name), this.word(t.name);
  }
  n(NY, "Identifier");
  function OY() {
    this.tokenChar(63);
  }
  n(OY, "ArgumentPlaceholder");
  function kY(t) {
    this.token("..."), this.print(t.argument, t);
  }
  n(kY, "RestElement");
  function DY(t) {
    let e = t.properties;
    this.tokenChar(123), e.length && (this.space(), this.printList(e, t, {
      indent: !0,
      statement: !0
    }), this.space()), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
  }
  n(DY, "ObjectExpression");
  function _Y(t) {
    this.printJoin(t.decorators, t), this._methodHead(t), this.space(), this.print(t.body, t);
  }
  n(_Y, "ObjectMethod");
  function LY(t) {
    if (this.printJoin(t.decorators, t), t.computed)
      this.tokenChar(91), this.print(t.key, t), this.tokenChar(93);
    else {
      if (wY(t.value) && Sh(t.key) && t.key.name === t.value.left.name) {
        this.print(t.value, t);
        return;
      }
      if (this.print(t.key, t), t.shorthand && Sh(t.key) && Sh(t.value) && t.key.name === t.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(t.value, t);
  }
  n(LY, "ObjectProperty");
  function MY(t) {
    let e = t.elements, r = e.length;
    this.tokenChar(91);
    for (let s = 0; s < e.length; s++) {
      let i = e[s];
      i ? (s > 0 && this.space(), this.print(i, t), s < r - 1 && this.tokenChar(44)) : this.tokenChar(44);
    }
    this.tokenChar(93);
  }
  n(MY, "ArrayExpression");
  function BY(t) {
    let e = t.properties, r, s;
    if (this.format.recordAndTupleSyntaxType === "bar")
      r = "{|", s = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      r = "#{", s = "}";
    }
    this.token(r), e.length && (this.space(), this.printList(e, t, {
      indent: !0,
      statement: !0
    }), this.space()), this.token(s);
  }
  n(BY, "RecordExpression");
  function FY(t) {
    let e = t.elements, r = e.length, s, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      s = "[|", i = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      s = "#[", i = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(s);
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      o && (a > 0 && this.space(), this.print(o, t), a < r - 1 && this.tokenChar(44));
    }
    this.token(i);
  }
  n(FY, "TupleExpression");
  function jY(t) {
    this.word(`/${t.pattern}/${t.flags}`);
  }
  n(jY, "RegExpLiteral");
  function RY(t) {
    this.word(t.value ? "true" : "false");
  }
  n(RY, "BooleanLiteral");
  function UY() {
    this.word("null");
  }
  n(UY, "NullLiteral");
  function qY(t) {
    let e = this.getPossibleRaw(t), r = this.format.jsescOption, s = t.value, i = s + "";
    r.numbers ? this.number(Bg(s, r), s) : e == null ? this.number(i, s) : this.format.minified ? this.number(e.length < i.length ? e : i, s) :
    this.number(e, s);
  }
  n(qY, "NumericLiteral");
  function VY(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let r = Bg(t.value, this.format.jsescOption);
    this.token(r);
  }
  n(VY, "StringLiteral");
  function KY(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.word(e);
      return;
    }
    this.word(t.value + "n");
  }
  n(KY, "BigIntLiteral");
  function WY(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.word(e);
      return;
    }
    this.word(t.value + "m");
  }
  n(WY, "DecimalLiteral");
  var Mg = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function YY() {
    let {
      topicToken: t
    } = this.format;
    if (Mg.has(t))
      this.token(t);
    else {
      let e = JSON.stringify(t), r = Array.from(Mg, (s) => JSON.stringify(s));
      throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${e} received instead).`);
    }
  }
  n(YY, "TopicReference");
  function JY(t) {
    this.print(t.expression, t);
  }
  n(JY, "PipelineTopicExpression");
  function XY(t) {
    this.print(t.callee, t);
  }
  n(XY, "PipelineBareFunction");
  function $Y() {
    this.tokenChar(35);
  }
  n($Y, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/generator/lib/generators/flow.js
var jg = w((fe) => {
  "use strict";
  Object.defineProperty(fe, "__esModule", {
    value: !0
  });
  fe.AnyTypeAnnotation = QY;
  fe.ArrayTypeAnnotation = ZY;
  fe.BooleanLiteralTypeAnnotation = tJ;
  fe.BooleanTypeAnnotation = eJ;
  fe.DeclareClass = sJ;
  fe.DeclareExportAllDeclaration = dJ;
  fe.DeclareExportDeclaration = hJ;
  fe.DeclareFunction = iJ;
  fe.DeclareInterface = oJ;
  fe.DeclareModule = lJ;
  fe.DeclareModuleExports = uJ;
  fe.DeclareOpaqueType = pJ;
  fe.DeclareTypeAlias = cJ;
  fe.DeclareVariable = fJ;
  fe.DeclaredPredicate = aJ;
  fe.EmptyTypeAnnotation = BJ;
  fe.EnumBooleanBody = yJ;
  fe.EnumBooleanMember = gJ;
  fe.EnumDeclaration = mJ;
  fe.EnumDefaultedMember = SJ;
  fe.EnumNumberBody = TJ;
  fe.EnumNumberMember = PJ;
  fe.EnumStringBody = bJ;
  fe.EnumStringMember = EJ;
  fe.EnumSymbolBody = xJ;
  fe.ExistsTypeAnnotation = vJ;
  fe.FunctionTypeAnnotation = CJ;
  fe.FunctionTypeParam = IJ;
  fe.IndexedAccessType = oX;
  fe.InferredPredicate = nJ;
  fe.InterfaceDeclaration = kJ;
  fe.GenericTypeAnnotation = fe.ClassImplements = fe.InterfaceExtends = wJ;
  fe.InterfaceTypeAnnotation = _J;
  fe.IntersectionTypeAnnotation = LJ;
  fe.MixedTypeAnnotation = MJ;
  fe.NullLiteralTypeAnnotation = rJ;
  fe.NullableTypeAnnotation = FJ;
  Object.defineProperty(fe, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Fg.NumericLiteral;
    }, "get")
  });
  fe.NumberTypeAnnotation = jJ;
  fe.ObjectTypeAnnotation = $J;
  fe.ObjectTypeCallProperty = zJ;
  fe.ObjectTypeIndexer = GJ;
  fe.ObjectTypeInternalSlot = HJ;
  fe.ObjectTypeProperty = QJ;
  fe.ObjectTypeSpreadProperty = ZJ;
  fe.OpaqueType = XJ;
  fe.OptionalIndexedAccessType = lX;
  fe.QualifiedTypeIdentifier = eX;
  Object.defineProperty(fe, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Fg.StringLiteral;
    }, "get")
  });
  fe.StringTypeAnnotation = RJ;
  fe.SymbolTypeAnnotation = tX;
  fe.ThisTypeAnnotation = UJ;
  fe.TupleTypeAnnotation = qJ;
  fe.TypeAlias = KJ;
  fe.TypeAnnotation = WJ;
  fe.TypeCastExpression = iX;
  fe.TypeParameter = JJ;
  fe.TypeParameterDeclaration = fe.TypeParameterInstantiation = YJ;
  fe.TypeofTypeAnnotation = VJ;
  fe.UnionTypeAnnotation = sX;
  fe.Variance = nX;
  fe.VoidTypeAnnotation = aX;
  fe._interfaceish = NJ;
  fe._variance = OJ;
  var HY = Ce(), zY = bh(), Fg = gh(), {
    isDeclareExportDeclaration: Yl,
    isStatement: GY
  } = HY;
  function QY() {
    this.word("any");
  }
  n(QY, "AnyTypeAnnotation");
  function ZY(t) {
    this.print(t.elementType, t, !0), this.tokenChar(91), this.tokenChar(93);
  }
  n(ZY, "ArrayTypeAnnotation");
  function eJ() {
    this.word("boolean");
  }
  n(eJ, "BooleanTypeAnnotation");
  function tJ(t) {
    this.word(t.value ? "true" : "false");
  }
  n(tJ, "BooleanLiteralTypeAnnotation");
  function rJ() {
    this.word("null");
  }
  n(rJ, "NullLiteralTypeAnnotation");
  function sJ(t, e) {
    Yl(e) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(t);
  }
  n(sJ, "DeclareClass");
  function iJ(t, e) {
    Yl(e) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(t.id, t), this.print(t.id.typeAnnotation.
    typeAnnotation, t), t.predicate && (this.space(), this.print(t.predicate, t)), this.semicolon();
  }
  n(iJ, "DeclareFunction");
  function nJ() {
    this.tokenChar(37), this.word("checks");
  }
  n(nJ, "InferredPredicate");
  function aJ(t) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(t.value, t), this.tokenChar(41);
  }
  n(aJ, "DeclaredPredicate");
  function oJ(t) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(t);
  }
  n(oJ, "DeclareInterface");
  function lJ(t) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(t.id, t), this.space(), this.print(t.body, t);
  }
  n(lJ, "DeclareModule");
  function uJ(t) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(t.typeAnnotation, t);
  }
  n(uJ, "DeclareModuleExports");
  function cJ(t) {
    this.word("declare"), this.space(), this.TypeAlias(t);
  }
  n(cJ, "DeclareTypeAlias");
  function pJ(t, e) {
    Yl(e) || (this.word("declare"), this.space()), this.OpaqueType(t);
  }
  n(pJ, "DeclareOpaqueType");
  function fJ(t, e) {
    Yl(e) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(t.id, t), this.print(t.id.typeAnnotation, t), this.
    semicolon();
  }
  n(fJ, "DeclareVariable");
  function hJ(t) {
    this.word("declare"), this.space(), this.word("export"), this.space(), t.default && (this.word("default"), this.space()), AJ.call(this, t);
  }
  n(hJ, "DeclareExportDeclaration");
  function dJ(t) {
    this.word("declare"), this.space(), zY.ExportAllDeclaration.call(this, t);
  }
  n(dJ, "DeclareExportAllDeclaration");
  function mJ(t) {
    let {
      id: e,
      body: r
    } = t;
    this.word("enum"), this.space(), this.print(e, t), this.print(r, t);
  }
  n(mJ, "EnumDeclaration");
  function Jl(t, e, r) {
    r && (t.space(), t.word("of"), t.space(), t.word(e)), t.space();
  }
  n(Jl, "enumExplicitType");
  function Xl(t, e) {
    let {
      members: r
    } = e;
    t.token("{"), t.indent(), t.newline();
    for (let s of r)
      t.print(s, e), t.newline();
    e.hasUnknownMembers && (t.token("..."), t.newline()), t.dedent(), t.token("}");
  }
  n(Xl, "enumBody");
  function yJ(t) {
    let {
      explicitType: e
    } = t;
    Jl(this, "boolean", e), Xl(this, t);
  }
  n(yJ, "EnumBooleanBody");
  function TJ(t) {
    let {
      explicitType: e
    } = t;
    Jl(this, "number", e), Xl(this, t);
  }
  n(TJ, "EnumNumberBody");
  function bJ(t) {
    let {
      explicitType: e
    } = t;
    Jl(this, "string", e), Xl(this, t);
  }
  n(bJ, "EnumStringBody");
  function xJ(t) {
    Jl(this, "symbol", !0), Xl(this, t);
  }
  n(xJ, "EnumSymbolBody");
  function SJ(t) {
    let {
      id: e
    } = t;
    this.print(e, t), this.tokenChar(44);
  }
  n(SJ, "EnumDefaultedMember");
  function Ph(t, e) {
    let {
      id: r,
      init: s
    } = e;
    t.print(r, e), t.space(), t.token("="), t.space(), t.print(s, e), t.token(",");
  }
  n(Ph, "enumInitializedMember");
  function gJ(t) {
    Ph(this, t);
  }
  n(gJ, "EnumBooleanMember");
  function PJ(t) {
    Ph(this, t);
  }
  n(PJ, "EnumNumberMember");
  function EJ(t) {
    Ph(this, t);
  }
  n(EJ, "EnumStringMember");
  function AJ(t) {
    if (t.declaration) {
      let e = t.declaration;
      this.print(e, t), GY(e) || this.semicolon();
    } else
      this.tokenChar(123), t.specifiers.length && (this.space(), this.printList(t.specifiers, t), this.space()), this.tokenChar(125), t.source &&
      (this.space(), this.word("from"), this.space(), this.print(t.source, t)), this.semicolon();
  }
  n(AJ, "FlowExportDeclaration");
  function vJ() {
    this.tokenChar(42);
  }
  n(vJ, "ExistsTypeAnnotation");
  function CJ(t, e) {
    this.print(t.typeParameters, t), this.tokenChar(40), t.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(t.this.typeAnnotation,
    t), (t.params.length || t.rest) && (this.tokenChar(44), this.space())), this.printList(t.params, t), t.rest && (t.params.length && (this.
    tokenChar(44), this.space()), this.token("..."), this.print(t.rest, t)), this.tokenChar(41);
    let r = e?.type;
    r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" &&
    e.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(t.returnType, t);
  }
  n(CJ, "FunctionTypeAnnotation");
  function IJ(t) {
    this.print(t.name, t), t.optional && this.tokenChar(63), t.name && (this.tokenChar(58), this.space()), this.print(t.typeAnnotation, t);
  }
  n(IJ, "FunctionTypeParam");
  function wJ(t) {
    this.print(t.id, t), this.print(t.typeParameters, t, !0);
  }
  n(wJ, "InterfaceExtends");
  function NJ(t) {
    var e;
    if (this.print(t.id, t), this.print(t.typeParameters, t), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.
    space(), this.printList(t.extends, t)), t.type === "DeclareClass") {
      var r, s;
      (r = t.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(t.mixins, t)), (s = t.implements) !=
      null && s.length && (this.space(), this.word("implements"), this.space(), this.printList(t.implements, t));
    }
    this.space(), this.print(t.body, t);
  }
  n(NJ, "_interfaceish");
  function OJ(t) {
    var e;
    let r = (e = t.variance) == null ? void 0 : e.kind;
    r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
  }
  n(OJ, "_variance");
  function kJ(t) {
    this.word("interface"), this.space(), this._interfaceish(t);
  }
  n(kJ, "InterfaceDeclaration");
  function DJ() {
    this.space(), this.tokenChar(38), this.space();
  }
  n(DJ, "andSeparator");
  function _J(t) {
    var e;
    this.word("interface"), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(), this.printList(t.extends,
    t)), this.space(), this.print(t.body, t);
  }
  n(_J, "InterfaceTypeAnnotation");
  function LJ(t) {
    this.printJoin(t.types, t, {
      separator: DJ
    });
  }
  n(LJ, "IntersectionTypeAnnotation");
  function MJ() {
    this.word("mixed");
  }
  n(MJ, "MixedTypeAnnotation");
  function BJ() {
    this.word("empty");
  }
  n(BJ, "EmptyTypeAnnotation");
  function FJ(t) {
    this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(FJ, "NullableTypeAnnotation");
  function jJ() {
    this.word("number");
  }
  n(jJ, "NumberTypeAnnotation");
  function RJ() {
    this.word("string");
  }
  n(RJ, "StringTypeAnnotation");
  function UJ() {
    this.word("this");
  }
  n(UJ, "ThisTypeAnnotation");
  function qJ(t) {
    this.tokenChar(91), this.printList(t.types, t), this.tokenChar(93);
  }
  n(qJ, "TupleTypeAnnotation");
  function VJ(t) {
    this.word("typeof"), this.space(), this.print(t.argument, t);
  }
  n(VJ, "TypeofTypeAnnotation");
  function KJ(t) {
    this.word("type"), this.space(), this.print(t.id, t), this.print(t.typeParameters, t), this.space(), this.tokenChar(61), this.space(), this.
    print(t.right, t), this.semicolon();
  }
  n(KJ, "TypeAlias");
  function WJ(t) {
    this.tokenChar(58), this.space(), t.optional && this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(WJ, "TypeAnnotation");
  function YJ(t) {
    this.tokenChar(60), this.printList(t.params, t, {}), this.tokenChar(62);
  }
  n(YJ, "TypeParameterInstantiation");
  function JJ(t) {
    this._variance(t), this.word(t.name), t.bound && this.print(t.bound, t), t.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(t.default, t));
  }
  n(JJ, "TypeParameter");
  function XJ(t) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(t.id, t), this.print(t.typeParameters, t), t.supertype &&
    (this.tokenChar(58), this.space(), this.print(t.supertype, t)), t.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(
    t.impltype, t)), this.semicolon();
  }
  n(XJ, "OpaqueType");
  function $J(t) {
    t.exact ? this.token("{|") : this.tokenChar(123);
    let e = [...t.properties, ...t.callProperties || [], ...t.indexers || [], ...t.internalSlots || []];
    e.length && (this.newline(), this.space(), this.printJoin(e, t, {
      addNewlines(r) {
        if (r && !e[0]) return 1;
      },
      indent: !0,
      statement: !0,
      iterator: /* @__PURE__ */ n(() => {
        (e.length !== 1 || t.inexact) && (this.tokenChar(44), this.space());
      }, "iterator")
    }), this.space()), t.inexact && (this.indent(), this.token("..."), e.length && this.newline(), this.dedent()), t.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  n($J, "ObjectTypeAnnotation");
  function HJ(t) {
    t.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(t.id, t), this.tokenChar(93), this.tokenChar(
    93), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58), this.space()), this.print(t.value, t);
  }
  n(HJ, "ObjectTypeInternalSlot");
  function zJ(t) {
    t.static && (this.word("static"), this.space()), this.print(t.value, t);
  }
  n(zJ, "ObjectTypeCallProperty");
  function GJ(t) {
    t.static && (this.word("static"), this.space()), this._variance(t), this.tokenChar(91), t.id && (this.print(t.id, t), this.tokenChar(58),
    this.space()), this.print(t.key, t), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(t.value, t);
  }
  n(GJ, "ObjectTypeIndexer");
  function QJ(t) {
    t.proto && (this.word("proto"), this.space()), t.static && (this.word("static"), this.space()), (t.kind === "get" || t.kind === "set") &&
    (this.word(t.kind), this.space()), this._variance(t), this.print(t.key, t), t.optional && this.tokenChar(63), t.method || (this.tokenChar(
    58), this.space()), this.print(t.value, t);
  }
  n(QJ, "ObjectTypeProperty");
  function ZJ(t) {
    this.token("..."), this.print(t.argument, t);
  }
  n(ZJ, "ObjectTypeSpreadProperty");
  function eX(t) {
    this.print(t.qualification, t), this.tokenChar(46), this.print(t.id, t);
  }
  n(eX, "QualifiedTypeIdentifier");
  function tX() {
    this.word("symbol");
  }
  n(tX, "SymbolTypeAnnotation");
  function rX() {
    this.space(), this.tokenChar(124), this.space();
  }
  n(rX, "orSeparator");
  function sX(t) {
    this.printJoin(t.types, t, {
      separator: rX
    });
  }
  n(sX, "UnionTypeAnnotation");
  function iX(t) {
    this.tokenChar(40), this.print(t.expression, t), this.print(t.typeAnnotation, t), this.tokenChar(41);
  }
  n(iX, "TypeCastExpression");
  function nX(t) {
    t.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  n(nX, "Variance");
  function aX() {
    this.word("void");
  }
  n(aX, "VoidTypeAnnotation");
  function oX(t) {
    this.print(t.objectType, t, !0), this.tokenChar(91), this.print(t.indexType, t), this.tokenChar(93);
  }
  n(oX, "IndexedAccessType");
  function lX(t) {
    this.print(t.objectType, t), t.optional && this.token("?."), this.tokenChar(91), this.print(t.indexType, t), this.tokenChar(93);
  }
  n(lX, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/generator/lib/generators/base.js
var Rg = w((xs) => {
  "use strict";
  Object.defineProperty(xs, "__esModule", {
    value: !0
  });
  xs.BlockStatement = pX;
  xs.Directive = fX;
  xs.DirectiveLiteral = mX;
  xs.File = uX;
  xs.InterpreterDirective = yX;
  xs.Placeholder = TX;
  xs.Program = cX;
  function uX(t) {
    t.program && this.print(t.program.interpreter, t), this.print(t.program, t);
  }
  n(uX, "File");
  function cX(t) {
    var e;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let r = (e = t.directives) == null ? void 0 : e.length;
    if (r) {
      var s;
      let i = t.body.length ? 2 : 1;
      this.printSequence(t.directives, t, {
        trailingCommentsLineOffset: i
      }), (s = t.directives[r - 1].trailingComments) != null && s.length || this.newline(i);
    }
    this.printSequence(t.body, t);
  }
  n(cX, "Program");
  function pX(t) {
    var e;
    this.tokenChar(123);
    let r = (e = t.directives) == null ? void 0 : e.length;
    if (r) {
      var s;
      let i = t.body.length ? 2 : 1;
      this.printSequence(t.directives, t, {
        indent: !0,
        trailingCommentsLineOffset: i
      }), (s = t.directives[r - 1].trailingComments) != null && s.length || this.newline(i);
    }
    this.printSequence(t.body, t, {
      indent: !0
    }), this.rightBrace(t);
  }
  n(pX, "BlockStatement");
  function fX(t) {
    this.print(t.value, t), this.semicolon();
  }
  n(fX, "Directive");
  var hX = /(?:^|[^\\])(?:\\\\)*'/, dX = /(?:^|[^\\])(?:\\\\)*"/;
  function mX(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let {
      value: r
    } = t;
    if (!dX.test(r))
      this.token(`"${r}"`);
    else if (!hX.test(r))
      this.token(`'${r}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  n(mX, "DirectiveLiteral");
  function yX(t) {
    this.token(`#!${t.value}`), this.newline(1, !0);
  }
  n(yX, "InterpreterDirective");
  function TX(t) {
    this.token("%%"), this.print(t.name), this.token("%%"), t.expectedNode === "Statement" && this.semicolon();
  }
  n(TX, "Placeholder");
});

// ../node_modules/@babel/generator/lib/generators/jsx.js
var Ug = w((Zt) => {
  "use strict";
  Object.defineProperty(Zt, "__esModule", {
    value: !0
  });
  Zt.JSXAttribute = bX;
  Zt.JSXClosingElement = NX;
  Zt.JSXClosingFragment = _X;
  Zt.JSXElement = CX;
  Zt.JSXEmptyExpression = OX;
  Zt.JSXExpressionContainer = EX;
  Zt.JSXFragment = kX;
  Zt.JSXIdentifier = xX;
  Zt.JSXMemberExpression = gX;
  Zt.JSXNamespacedName = SX;
  Zt.JSXOpeningElement = wX;
  Zt.JSXOpeningFragment = DX;
  Zt.JSXSpreadAttribute = PX;
  Zt.JSXSpreadChild = AX;
  Zt.JSXText = vX;
  function bX(t) {
    this.print(t.name, t), t.value && (this.tokenChar(61), this.print(t.value, t));
  }
  n(bX, "JSXAttribute");
  function xX(t) {
    this.word(t.name);
  }
  n(xX, "JSXIdentifier");
  function SX(t) {
    this.print(t.namespace, t), this.tokenChar(58), this.print(t.name, t);
  }
  n(SX, "JSXNamespacedName");
  function gX(t) {
    this.print(t.object, t), this.tokenChar(46), this.print(t.property, t);
  }
  n(gX, "JSXMemberExpression");
  function PX(t) {
    this.tokenChar(123), this.token("..."), this.print(t.argument, t), this.tokenChar(125);
  }
  n(PX, "JSXSpreadAttribute");
  function EX(t) {
    this.tokenChar(123), this.print(t.expression, t), this.tokenChar(125);
  }
  n(EX, "JSXExpressionContainer");
  function AX(t) {
    this.tokenChar(123), this.token("..."), this.print(t.expression, t), this.tokenChar(125);
  }
  n(AX, "JSXSpreadChild");
  function vX(t) {
    let e = this.getPossibleRaw(t);
    e !== void 0 ? this.token(e, !0) : this.token(t.value, !0);
  }
  n(vX, "JSXText");
  function CX(t) {
    let e = t.openingElement;
    if (this.print(e, t), !e.selfClosing) {
      this.indent();
      for (let r of t.children)
        this.print(r, t);
      this.dedent(), this.print(t.closingElement, t);
    }
  }
  n(CX, "JSXElement");
  function IX() {
    this.space();
  }
  n(IX, "spaceSeparator");
  function wX(t) {
    this.tokenChar(60), this.print(t.name, t), this.print(t.typeParameters, t), t.attributes.length > 0 && (this.space(), this.printJoin(t.attributes,
    t, {
      separator: IX
    })), t.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
  }
  n(wX, "JSXOpeningElement");
  function NX(t) {
    this.token("</"), this.print(t.name, t), this.tokenChar(62);
  }
  n(NX, "JSXClosingElement");
  function OX() {
    this.printInnerComments();
  }
  n(OX, "JSXEmptyExpression");
  function kX(t) {
    this.print(t.openingFragment, t), this.indent();
    for (let e of t.children)
      this.print(e, t);
    this.dedent(), this.print(t.closingFragment, t);
  }
  n(kX, "JSXFragment");
  function DX() {
    this.tokenChar(60), this.tokenChar(62);
  }
  n(DX, "JSXOpeningFragment");
  function _X() {
    this.token("</"), this.tokenChar(62);
  }
  n(_X, "JSXClosingFragment");
});

// ../node_modules/@babel/generator/lib/generators/typescript.js
var Kg = w((ce) => {
  "use strict";
  Object.defineProperty(ce, "__esModule", {
    value: !0
  });
  ce.TSAnyKeyword = XX;
  ce.TSArrayType = m$;
  ce.TSSatisfiesExpression = ce.TSAsExpression = _$;
  ce.TSBigIntKeyword = $X;
  ce.TSBooleanKeyword = QX;
  ce.TSCallSignatureDeclaration = qX;
  ce.TSConditionalType = P$;
  ce.TSConstructSignatureDeclaration = VX;
  ce.TSConstructorType = l$;
  ce.TSDeclareFunction = jX;
  ce.TSDeclareMethod = RX;
  ce.TSEnumDeclaration = B$;
  ce.TSEnumMember = F$;
  ce.TSExportAssignment = W$;
  ce.TSExpressionWithTypeArguments = N$;
  ce.TSExternalModuleReference = V$;
  ce.TSFunctionType = o$;
  ce.TSImportEqualsDeclaration = q$;
  ce.TSImportType = U$;
  ce.TSIndexSignature = JX;
  ce.TSIndexedAccessType = C$;
  ce.TSInferType = E$;
  ce.TSInstantiationExpression = M$;
  ce.TSInterfaceBody = k$;
  ce.TSInterfaceDeclaration = O$;
  ce.TSIntersectionType = g$;
  ce.TSIntrinsicKeyword = n$;
  ce.TSLiteralType = w$;
  ce.TSMappedType = I$;
  ce.TSMethodSignature = YX;
  ce.TSModuleBlock = R$;
  ce.TSModuleDeclaration = j$;
  ce.TSNamedTupleMember = x$;
  ce.TSNamespaceExportDeclaration = Y$;
  ce.TSNeverKeyword = i$;
  ce.TSNonNullExpression = K$;
  ce.TSNullKeyword = s$;
  ce.TSNumberKeyword = zX;
  ce.TSObjectKeyword = GX;
  ce.TSOptionalType = T$;
  ce.TSParameterProperty = FX;
  ce.TSParenthesizedType = A$;
  ce.TSPropertySignature = KX;
  ce.TSQualifiedName = UX;
  ce.TSRestType = b$;
  ce.TSStringKeyword = ZX;
  ce.TSSymbolKeyword = e$;
  ce.TSThisType = a$;
  ce.TSTupleType = y$;
  ce.TSTypeAliasDeclaration = D$;
  ce.TSTypeAnnotation = LX;
  ce.TSTypeAssertion = L$;
  ce.TSTypeLiteral = h$;
  ce.TSTypeOperator = v$;
  ce.TSTypeParameter = BX;
  ce.TSTypeParameterDeclaration = ce.TSTypeParameterInstantiation = MX;
  ce.TSTypePredicate = p$;
  ce.TSTypeQuery = f$;
  ce.TSTypeReference = c$;
  ce.TSUndefinedKeyword = r$;
  ce.TSUnionType = S$;
  ce.TSUnknownKeyword = HX;
  ce.TSVoidKeyword = t$;
  ce.tsPrintClassMemberModifiers = X$;
  ce.tsPrintFunctionOrConstructorType = u$;
  ce.tsPrintPropertyOrMethodName = WX;
  ce.tsPrintSignatureDeclarationBase = J$;
  ce.tsPrintTypeLiteralOrInterfaceBody = d$;
  function LX(t) {
    this.tokenChar(58), this.space(), t.optional && this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(LX, "TSTypeAnnotation");
  function MX(t, e) {
    this.tokenChar(60), this.printList(t.params, t, {}), e.type === "ArrowFunctionExpression" && t.params.length === 1 && this.tokenChar(44),
    this.tokenChar(62);
  }
  n(MX, "TSTypeParameterInstantiation");
  function BX(t) {
    t.in && (this.word("in"), this.space()), t.out && (this.word("out"), this.space()), this.word(t.name), t.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(t.constraint, t)), t.default && (this.space(), this.tokenChar(61), this.space(), this.print(t.
    default, t));
  }
  n(BX, "TSTypeParameter");
  function FX(t) {
    t.accessibility && (this.word(t.accessibility), this.space()), t.readonly && (this.word("readonly"), this.space()), this._param(t.parameter);
  }
  n(FX, "TSParameterProperty");
  function jX(t, e) {
    t.declare && (this.word("declare"), this.space()), this._functionHead(t, e), this.tokenChar(59);
  }
  n(jX, "TSDeclareFunction");
  function RX(t) {
    this._classMethodHead(t), this.tokenChar(59);
  }
  n(RX, "TSDeclareMethod");
  function UX(t) {
    this.print(t.left, t), this.tokenChar(46), this.print(t.right, t);
  }
  n(UX, "TSQualifiedName");
  function qX(t) {
    this.tsPrintSignatureDeclarationBase(t), this.tokenChar(59);
  }
  n(qX, "TSCallSignatureDeclaration");
  function VX(t) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(t), this.tokenChar(59);
  }
  n(VX, "TSConstructSignatureDeclaration");
  function KX(t) {
    let {
      readonly: e
    } = t;
    e && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(t), this.print(t.typeAnnotation, t), this.tokenChar(59);
  }
  n(KX, "TSPropertySignature");
  function WX(t) {
    t.computed && this.tokenChar(91), this.print(t.key, t), t.computed && this.tokenChar(93), t.optional && this.tokenChar(63);
  }
  n(WX, "tsPrintPropertyOrMethodName");
  function YX(t) {
    let {
      kind: e
    } = t;
    (e === "set" || e === "get") && (this.word(e), this.space()), this.tsPrintPropertyOrMethodName(t), this.tsPrintSignatureDeclarationBase(
    t), this.tokenChar(59);
  }
  n(YX, "TSMethodSignature");
  function JX(t) {
    let {
      readonly: e,
      static: r
    } = t;
    r && (this.word("static"), this.space()), e && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(t.parameters,
    t), this.tokenChar(93), this.print(t.typeAnnotation, t), this.tokenChar(59);
  }
  n(JX, "TSIndexSignature");
  function XX() {
    this.word("any");
  }
  n(XX, "TSAnyKeyword");
  function $X() {
    this.word("bigint");
  }
  n($X, "TSBigIntKeyword");
  function HX() {
    this.word("unknown");
  }
  n(HX, "TSUnknownKeyword");
  function zX() {
    this.word("number");
  }
  n(zX, "TSNumberKeyword");
  function GX() {
    this.word("object");
  }
  n(GX, "TSObjectKeyword");
  function QX() {
    this.word("boolean");
  }
  n(QX, "TSBooleanKeyword");
  function ZX() {
    this.word("string");
  }
  n(ZX, "TSStringKeyword");
  function e$() {
    this.word("symbol");
  }
  n(e$, "TSSymbolKeyword");
  function t$() {
    this.word("void");
  }
  n(t$, "TSVoidKeyword");
  function r$() {
    this.word("undefined");
  }
  n(r$, "TSUndefinedKeyword");
  function s$() {
    this.word("null");
  }
  n(s$, "TSNullKeyword");
  function i$() {
    this.word("never");
  }
  n(i$, "TSNeverKeyword");
  function n$() {
    this.word("intrinsic");
  }
  n(n$, "TSIntrinsicKeyword");
  function a$() {
    this.word("this");
  }
  n(a$, "TSThisType");
  function o$(t) {
    this.tsPrintFunctionOrConstructorType(t);
  }
  n(o$, "TSFunctionType");
  function l$(t) {
    t.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(t);
  }
  n(l$, "TSConstructorType");
  function u$(t) {
    let {
      typeParameters: e
    } = t, r = t.parameters;
    this.print(e, t), this.tokenChar(40), this._parameters(r, t), this.tokenChar(41), this.space(), this.token("=>"), this.space();
    let s = t.typeAnnotation;
    this.print(s.typeAnnotation, t);
  }
  n(u$, "tsPrintFunctionOrConstructorType");
  function c$(t) {
    this.print(t.typeName, t, !0), this.print(t.typeParameters, t, !0);
  }
  n(c$, "TSTypeReference");
  function p$(t) {
    t.asserts && (this.word("asserts"), this.space()), this.print(t.parameterName), t.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(t.typeAnnotation.typeAnnotation));
  }
  n(p$, "TSTypePredicate");
  function f$(t) {
    this.word("typeof"), this.space(), this.print(t.exprName), t.typeParameters && this.print(t.typeParameters, t);
  }
  n(f$, "TSTypeQuery");
  function h$(t) {
    this.tsPrintTypeLiteralOrInterfaceBody(t.members, t);
  }
  n(h$, "TSTypeLiteral");
  function d$(t, e) {
    Eh(this, t, e);
  }
  n(d$, "tsPrintTypeLiteralOrInterfaceBody");
  function Eh(t, e, r) {
    if (t.token("{"), e.length) {
      t.indent(), t.newline();
      for (let s of e)
        t.print(s, r), t.newline();
      t.dedent();
    }
    t.rightBrace(r);
  }
  n(Eh, "tsPrintBraced");
  function m$(t) {
    this.print(t.elementType, t, !0), this.token("[]");
  }
  n(m$, "TSArrayType");
  function y$(t) {
    this.tokenChar(91), this.printList(t.elementTypes, t), this.tokenChar(93);
  }
  n(y$, "TSTupleType");
  function T$(t) {
    this.print(t.typeAnnotation, t), this.tokenChar(63);
  }
  n(T$, "TSOptionalType");
  function b$(t) {
    this.token("..."), this.print(t.typeAnnotation, t);
  }
  n(b$, "TSRestType");
  function x$(t) {
    this.print(t.label, t), t.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(t.elementType, t);
  }
  n(x$, "TSNamedTupleMember");
  function S$(t) {
    Vg(this, t, "|");
  }
  n(S$, "TSUnionType");
  function g$(t) {
    Vg(this, t, "&");
  }
  n(g$, "TSIntersectionType");
  function Vg(t, e, r) {
    t.printJoin(e.types, e, {
      separator() {
        this.space(), this.token(r), this.space();
      }
    });
  }
  n(Vg, "tsPrintUnionOrIntersectionType");
  function P$(t) {
    this.print(t.checkType), this.space(), this.word("extends"), this.space(), this.print(t.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(t.trueType), this.space(), this.tokenChar(58), this.space(), this.print(t.falseType);
  }
  n(P$, "TSConditionalType");
  function E$(t) {
    this.token("infer"), this.space(), this.print(t.typeParameter);
  }
  n(E$, "TSInferType");
  function A$(t) {
    this.tokenChar(40), this.print(t.typeAnnotation, t), this.tokenChar(41);
  }
  n(A$, "TSParenthesizedType");
  function v$(t) {
    this.word(t.operator), this.space(), this.print(t.typeAnnotation, t);
  }
  n(v$, "TSTypeOperator");
  function C$(t) {
    this.print(t.objectType, t, !0), this.tokenChar(91), this.print(t.indexType, t), this.tokenChar(93);
  }
  n(C$, "TSIndexedAccessType");
  function I$(t) {
    let {
      nameType: e,
      optional: r,
      readonly: s,
      typeParameter: i,
      typeAnnotation: a
    } = t;
    this.tokenChar(123), this.space(), s && (qg(this, s), this.word("readonly"), this.space()), this.tokenChar(91), this.word(i.name), this.
    space(), this.word("in"), this.space(), this.print(i.constraint, i), e && (this.space(), this.word("as"), this.space(), this.print(e, t)),
    this.tokenChar(93), r && (qg(this, r), this.tokenChar(63)), a && (this.tokenChar(58), this.space(), this.print(a, t)), this.space(), this.
    tokenChar(125);
  }
  n(I$, "TSMappedType");
  function qg(t, e) {
    e !== !0 && t.token(e);
  }
  n(qg, "tokenIfPlusMinus");
  function w$(t) {
    this.print(t.literal, t);
  }
  n(w$, "TSLiteralType");
  function N$(t) {
    this.print(t.expression, t), this.print(t.typeParameters, t);
  }
  n(N$, "TSExpressionWithTypeArguments");
  function O$(t) {
    let {
      declare: e,
      id: r,
      typeParameters: s,
      extends: i,
      body: a
    } = t;
    e && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r, t), this.print(s, t), i != null && i.length &&
    (this.space(), this.word("extends"), this.space(), this.printList(i, t)), this.space(), this.print(a, t);
  }
  n(O$, "TSInterfaceDeclaration");
  function k$(t) {
    this.tsPrintTypeLiteralOrInterfaceBody(t.body, t);
  }
  n(k$, "TSInterfaceBody");
  function D$(t) {
    let {
      declare: e,
      id: r,
      typeParameters: s,
      typeAnnotation: i
    } = t;
    e && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r, t), this.print(s, t), this.space(), this.tokenChar(
    61), this.space(), this.print(i, t), this.tokenChar(59);
  }
  n(D$, "TSTypeAliasDeclaration");
  function _$(t) {
    var e;
    let {
      type: r,
      expression: s,
      typeAnnotation: i
    } = t, a = !!((e = s.trailingComments) != null && e.length);
    this.print(s, t, !0, void 0, a), this.space(), this.word(r === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(i, t);
  }
  n(_$, "TSTypeExpression");
  function L$(t) {
    let {
      typeAnnotation: e,
      expression: r
    } = t;
    this.tokenChar(60), this.print(e, t), this.tokenChar(62), this.space(), this.print(r, t);
  }
  n(L$, "TSTypeAssertion");
  function M$(t) {
    this.print(t.expression, t), this.print(t.typeParameters, t);
  }
  n(M$, "TSInstantiationExpression");
  function B$(t) {
    let {
      declare: e,
      const: r,
      id: s,
      members: i
    } = t;
    e && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(s, t), this.
    space(), Eh(this, i, t);
  }
  n(B$, "TSEnumDeclaration");
  function F$(t) {
    let {
      id: e,
      initializer: r
    } = t;
    this.print(e, t), r && (this.space(), this.tokenChar(61), this.space(), this.print(r, t)), this.tokenChar(44);
  }
  n(F$, "TSEnumMember");
  function j$(t) {
    let {
      declare: e,
      id: r
    } = t;
    if (e && (this.word("declare"), this.space()), t.global || (this.word(r.type === "Identifier" ? "namespace" : "module"), this.space()), this.
    print(r, t), !t.body) {
      this.tokenChar(59);
      return;
    }
    let s = t.body;
    for (; s.type === "TSModuleDeclaration"; )
      this.tokenChar(46), this.print(s.id, s), s = s.body;
    this.space(), this.print(s, t);
  }
  n(j$, "TSModuleDeclaration");
  function R$(t) {
    Eh(this, t.body, t);
  }
  n(R$, "TSModuleBlock");
  function U$(t) {
    let {
      argument: e,
      qualifier: r,
      typeParameters: s
    } = t;
    this.word("import"), this.tokenChar(40), this.print(e, t), this.tokenChar(41), r && (this.tokenChar(46), this.print(r, t)), s && this.print(
    s, t);
  }
  n(U$, "TSImportType");
  function q$(t) {
    let {
      isExport: e,
      id: r,
      moduleReference: s
    } = t;
    e && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r, t), this.space(), this.tokenChar(61), this.space(),
    this.print(s, t), this.tokenChar(59);
  }
  n(q$, "TSImportEqualsDeclaration");
  function V$(t) {
    this.token("require("), this.print(t.expression, t), this.tokenChar(41);
  }
  n(V$, "TSExternalModuleReference");
  function K$(t) {
    this.print(t.expression, t), this.tokenChar(33);
  }
  n(K$, "TSNonNullExpression");
  function W$(t) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(t.expression, t), this.tokenChar(59);
  }
  n(W$, "TSExportAssignment");
  function Y$(t) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(t.id, t);
  }
  n(Y$, "TSNamespaceExportDeclaration");
  function J$(t) {
    let {
      typeParameters: e
    } = t, r = t.parameters;
    this.print(e, t), this.tokenChar(40), this._parameters(r, t), this.tokenChar(41);
    let s = t.typeAnnotation;
    this.print(s, t);
  }
  n(J$, "tsPrintSignatureDeclarationBase");
  function X$(t) {
    let e = t.type === "ClassAccessorProperty" || t.type === "ClassProperty";
    e && t.declare && (this.word("declare"), this.space()), t.accessibility && (this.word(t.accessibility), this.space()), t.static && (this.
    word("static"), this.space()), t.override && (this.word("override"), this.space()), t.abstract && (this.word("abstract"), this.space()),
    e && t.readonly && (this.word("readonly"), this.space());
  }
  n(X$, "tsPrintClassMemberModifiers");
});

// ../node_modules/@babel/generator/lib/generators/index.js
var Wg = w((Ge) => {
  "use strict";
  Object.defineProperty(Ge, "__esModule", {
    value: !0
  });
  var Ah = xg();
  Object.keys(Ah).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Ah[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Ah[t];
      }, "get")
    });
  });
  var vh = Pg();
  Object.keys(vh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === vh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return vh[t];
      }, "get")
    });
  });
  var Ch = Cg();
  Object.keys(Ch).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Ch[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Ch[t];
      }, "get")
    });
  });
  var Ih = Ig();
  Object.keys(Ih).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Ih[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Ih[t];
      }, "get")
    });
  });
  var wh = wg();
  Object.keys(wh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === wh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return wh[t];
      }, "get")
    });
  });
  var Nh = bh();
  Object.keys(Nh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Nh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Nh[t];
      }, "get")
    });
  });
  var Oh = gh();
  Object.keys(Oh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Oh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Oh[t];
      }, "get")
    });
  });
  var kh = jg();
  Object.keys(kh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === kh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return kh[t];
      }, "get")
    });
  });
  var Dh = Rg();
  Object.keys(Dh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Dh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Dh[t];
      }, "get")
    });
  });
  var _h = Ug();
  Object.keys(_h).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === _h[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return _h[t];
      }, "get")
    });
  });
  var Lh = Kg();
  Object.keys(Lh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Lh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Lh[t];
      }, "get")
    });
  });
});

// ../node_modules/@babel/generator/lib/printer.js
var Jg = w(($l) => {
  "use strict";
  Object.defineProperty($l, "__esModule", {
    value: !0
  });
  $l.default = void 0;
  var $$ = ag(), H$ = yh(), z$ = Ce(), G$ = Wg(), {
    isFunction: Q$,
    isStatement: Z$,
    isClassBody: eH,
    isTSInterfaceBody: tH,
    isTSEnumDeclaration: rH
  } = z$, sH = /e/i, iH = /\.0+$/, Yg = /[\n\r\u2028\u2029]/, nH = /[\n\r\u2028\u2029]|\*\//, {
    needsParens: aH
  } = H$, Da = class {
    static {
      n(this, "Printer");
    }
    constructor(e, r) {
      this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState =
      null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger =
      !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = e, this.
      _indentRepeat = e.indent.style.length, this._inputMap = r?._inputMap, this._buf = new $$.default(r, e.indent.style[0]);
    }
    generate(e) {
      return this.print(e), this._maybeAddAuxComment(), this._buf.get();
    }
    indent() {
      this.format.compact || this.format.concise || this._indent++;
    }
    dedent() {
      this.format.compact || this.format.concise || this._indent--;
    }
    semicolon(e = !1) {
      this._maybeAddAuxComment(), e ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(e) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
    }
    rightParens(e) {
      this.sourceWithOffset("end", e.loc, -1), this.tokenChar(41);
    }
    space(e = !1) {
      if (!this.format.compact) {
        if (e)
          this._space();
        else if (this._buf.hasContent()) {
          let r = this.getLastChar();
          r !== 32 && r !== 10 && this._space();
        }
      }
    }
    word(e, r = !1) {
      this._maybePrintInnerComments(), (this._endsWithWord || e.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(),
      this._append(e, !1), this._endsWithWord = !0, this._noLineTerminator = r;
    }
    number(e, r) {
      function s(i) {
        if (i.length > 2 && i.charCodeAt(0) === 48) {
          let a = i.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      n(s, "isNonDecimalLiteral"), this.word(e), this._endsWithInteger = Number.isInteger(r) && !s(e) && !sH.test(e) && !iH.test(e) && e.charCodeAt(
      e.length - 1) !== 46;
    }
    token(e, r = !1) {
      this._maybePrintInnerComments();
      let s = this.getLastChar(), i = e.charCodeAt(0);
      (s === 33 && (e === "--" || i === 61) || i === 43 && s === 43 || i === 45 && s === 45 || i === 46 && this._endsWithInteger) && this._space(),
      this._maybeAddAuxComment(), this._append(e, r), this._noLineTerminator = !1;
    }
    tokenChar(e) {
      this._maybePrintInnerComments();
      let r = this.getLastChar();
      (e === 43 && r === 43 || e === 45 && r === 45 || e === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this.
      _appendChar(e), this._noLineTerminator = !1;
    }
    newline(e = 1, r) {
      if (!(e <= 0)) {
        if (!r) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        e > 2 && (e = 2), e -= this._buf.getNewlineCount();
        for (let s = 0; s < e; s++)
          this._newline();
      }
    }
    endsWith(e) {
      return this.getLastChar() === e;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(e, r) {
      if (!e) {
        r();
        return;
      }
      this._catchUp("start", e), this._buf.exactSource(e, r);
    }
    source(e, r) {
      r && (this._catchUp(e, r), this._buf.source(e, r));
    }
    sourceWithOffset(e, r, s) {
      r && (this._catchUp(e, r), this._buf.sourceWithOffset(e, r, s));
    }
    withSource(e, r, s) {
      if (!r) {
        s();
        return;
      }
      this._catchUp(e, r), this._buf.withSource(e, r, s);
    }
    sourceIdentifierName(e, r) {
      if (!this._buf._canMarkIdName) return;
      let s = this._buf._sourcePosition;
      s.identifierNamePos = r, s.identifierName = e;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _append(e, r) {
      this._maybeAddParen(e), this._maybeIndent(e.charCodeAt(0)), this._buf.append(e, r), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _appendChar(e) {
      this._maybeAddParenChar(e), this._maybeIndent(e), this._buf.appendChar(e), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _queue(e) {
      this._maybeAddParenChar(e), this._maybeIndent(e), this._buf.queue(e), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(e) {
      this._indent && e !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(e) {
      if (this._indent && e !== 10 && this.endsWith(10))
        return !0;
    }
    _maybeAddParenChar(e) {
      let r = this._parenPushNewlineState;
      if (r && e !== 32) {
        if (e !== 10) {
          this._parenPushNewlineState = null;
          return;
        }
        this.tokenChar(40), this.indent(), r.printed = !0;
      }
    }
    _maybeAddParen(e) {
      let r = this._parenPushNewlineState;
      if (!r) return;
      let s = e.length, i;
      for (i = 0; i < s && e.charCodeAt(i) === 32; i++) ;
      if (i === s)
        return;
      let a = e.charCodeAt(i);
      if (a !== 10) {
        if (a !== 47 || i + 1 === s) {
          this._parenPushNewlineState = null;
          return;
        }
        let o = e.charCodeAt(i + 1);
        if (o === 42)
          return;
        if (o !== 47) {
          this._parenPushNewlineState = null;
          return;
        }
      }
      this.tokenChar(40), this.indent(), r.printed = !0;
    }
    catchUp(e) {
      if (!this.format.retainLines) return;
      let r = e - this._buf.getCurrentLine();
      for (let s = 0; s < r; s++)
        this._newline();
    }
    _catchUp(e, r) {
      var s;
      if (!this.format.retainLines) return;
      let i = r == null || (s = r[e]) == null ? void 0 : s.line;
      if (i != null) {
        let a = i - this._buf.getCurrentLine();
        for (let o = 0; o < a; o++)
          this._newline();
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(e, r, s) {
      if (s)
        this._noLineTerminator = !0, this.print(e, r);
      else {
        let i = {
          printed: !1
        };
        this._parenPushNewlineState = i, this.print(e, r), i.printed && (this.dedent(), this.newline(), this.tokenChar(41));
      }
    }
    print(e, r, s, i, a) {
      var o, l;
      if (!e) return;
      this._endsWithInnerRaw = !1;
      let u = e.type, c = this.format, p = c.concise;
      e._compact && (c.concise = !0);
      let f = this[u];
      if (f === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(u)} with constructor ${JSON.stringify(e.constructor.name)}`);
      this._printStack.push(e);
      let m = this._insideAux;
      this._insideAux = e.loc == null, this._maybeAddAuxComment(this._insideAux && !m);
      let y = (o = e.extra) == null ? void 0 : o.parenthesized, T = a || y && c.retainFunctionParens && u === "FunctionExpression" || aH(e, r,
      this._printStack);
      if (!T && y && (l = e.leadingComments) != null && l.length && e.leadingComments[0].type === "CommentBlock")
        switch (r?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (r.callee !== e) break;
          default:
            T = !0;
        }
      T && (this.tokenChar(40), this._endsWithInnerRaw = !1), this._lastCommentLine = 0, this._printLeadingComments(e, r);
      let L = u === "Program" || u === "File" ? null : e.loc;
      this.exactSource(L, f.bind(this, e, r)), T ? (this._printTrailingComments(e, r), this.tokenChar(41), this._noLineTerminator = s) : s &&
      !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(e, r)) : this._printTrailingComments(e, r, i), this.
      _printStack.pop(), c.concise = p, this._insideAux = m, this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(e) {
      e && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let e = this.format.auxiliaryCommentBefore;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let e = this.format.auxiliaryCommentAfter;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    getPossibleRaw(e) {
      let r = e.extra;
      if (r?.raw != null && r.rawValue != null && e.value === r.rawValue)
        return r.raw;
    }
    printJoin(e, r, s = {}) {
      if (!(e != null && e.length)) return;
      let {
        indent: i
      } = s;
      if (i == null && this.format.retainLines) {
        var a;
        let f = (a = e[0].loc) == null ? void 0 : a.start.line;
        f != null && f !== this._buf.getCurrentLine() && (i = !0);
      }
      i && this.indent();
      let o = {
        addNewlines: s.addNewlines,
        nextNodeStartLine: 0
      }, l = s.separator ? s.separator.bind(this) : null, u = e.length;
      for (let f = 0; f < u; f++) {
        let m = e[f];
        if (m && (s.statement && this._printNewline(f === 0, o), this.print(m, r, void 0, s.trailingCommentsLineOffset || 0), s.iterator == null ||
        s.iterator(m, f), f < u - 1 && l?.(), s.statement)) {
          var c;
          if ((c = m.trailingComments) != null && c.length || (this._lastCommentLine = 0), f + 1 === u)
            this.newline(1);
          else {
            var p;
            let y = e[f + 1];
            o.nextNodeStartLine = ((p = y.loc) == null ? void 0 : p.start.line) || 0, this._printNewline(!0, o);
          }
        }
      }
      i && this.dedent();
    }
    printAndIndentOnComments(e, r) {
      let s = e.leadingComments && e.leadingComments.length > 0;
      s && this.indent(), this.print(e, r), s && this.dedent();
    }
    printBlock(e) {
      let r = e.body;
      r.type !== "EmptyStatement" && this.space(), this.print(r, e);
    }
    _printTrailingComments(e, r, s) {
      let {
        innerComments: i,
        trailingComments: a
      } = e;
      i != null && i.length && this._printComments(2, i, e, r, s), a != null && a.length && this._printComments(2, a, e, r, s);
    }
    _printLeadingComments(e, r) {
      let s = e.leadingComments;
      s != null && s.length && this._printComments(0, s, e, r);
    }
    _maybePrintInnerComments() {
      this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments() {
      let e = this._printStack[this._printStack.length - 1], r = e.innerComments;
      if (!(r != null && r.length)) return;
      let s = this.endsWith(32), i = this._indentInnerComments, a = this._printedComments.size;
      i && this.indent(), this._printComments(1, r, e), s && a !== this._printedComments.size && this.space(), i && this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(e, r, s = {}) {
      var i;
      s.statement = !0, (i = s.indent) != null || (s.indent = !1), this.printJoin(e, r, s);
    }
    printList(e, r, s = {}) {
      s.separator == null && (s.separator = oH), this.printJoin(e, r, s);
    }
    _printNewline(e, r) {
      let s = this.format;
      if (s.retainLines || s.compact) return;
      if (s.concise) {
        this.space();
        return;
      }
      if (!e)
        return;
      let i = r.nextNodeStartLine, a = this._lastCommentLine;
      if (i > 0 && a > 0) {
        let o = i - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(e) {
      return e.ignore || this._printedComments.has(e) ? 0 : this._noLineTerminator && nH.test(e.value) ? 2 : (this._printedComments.add(e), this.
      format.shouldPrintComment(e.value) ? 1 : 0);
    }
    _printComment(e, r) {
      let s = this._noLineTerminator, i = e.type === "CommentBlock", a = i && r !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && r !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && this.space();
      let l;
      if (i) {
        let {
          _parenPushNewlineState: c
        } = this;
        if (c?.printed === !1 && Yg.test(e.value) && (this.tokenChar(40), this.indent(), c.printed = !0), l = `/*${e.value}*/`, this.format.
        indent.adjustMultilineComment) {
          var u;
          let p = (u = e.loc) == null ? void 0 : u.start.column;
          if (p) {
            let f = new RegExp("\\n\\s{1," + p + "}", "g");
            l = l.replace(f, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let f = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (f += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(f)}`);
          }
        }
      } else s ? l = `/*${e.value}*/` : l = `//${e.value}`;
      this.endsWith(47) && this._space(), this.source("start", e.loc), this._append(l, i), !i && !s && this.newline(1, !0), a && r !== 3 && this.
      newline(1);
    }
    _printComments(e, r, s, i, a = 0) {
      let o = s.loc, l = r.length, u = !!o, c = u ? o.start.line : 0, p = u ? o.end.line : 0, f = 0, m = 0, y = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let T = 0; T < l; T++) {
        let L = r[T], q = this._shouldPrintComment(L);
        if (q === 2) {
          u = !1;
          break;
        }
        if (u && L.loc && q === 1) {
          let _ = L.loc.start.line, U = L.loc.end.line;
          if (e === 0) {
            let J = 0;
            T === 0 ? this._buf.hasContent() && (L.type === "CommentLine" || _ !== U) && (J = m = 1) : J = _ - f, f = U, y(J), this._printComment(
            L, 1), T + 1 === l && (y(Math.max(c - f, m)), f = c);
          } else if (e === 1) {
            let J = _ - (T === 0 ? c : f);
            f = U, y(J), this._printComment(L, 1), T + 1 === l && (y(Math.min(1, p - f)), f = p);
          } else {
            let J = _ - (T === 0 ? p - a : f);
            f = U, y(J), this._printComment(L, 1);
          }
        } else {
          if (u = !1, q !== 1)
            continue;
          if (l === 1) {
            let _ = L.loc ? L.loc.start.line === L.loc.end.line : !Yg.test(L.value), U = _ && !Z$(s) && !eH(i) && !tH(i) && !rH(i);
            e === 0 ? this._printComment(L, U && s.type !== "ObjectExpression" || _ && Q$(i, {
              body: s
            }) ? 1 : 0) : U && e === 2 ? this._printComment(L, 1) : this._printComment(L, 0);
          } else e === 1 && !(s.type === "ObjectExpression" && s.properties.length > 1) && s.type !== "ClassBody" && s.type !== "TSInterface\
Body" ? this._printComment(L, T === 0 ? 2 : T === l - 1 ? 3 : 0) : this._printComment(L, 0);
        }
      }
      e === 2 && u && f && (this._lastCommentLine = f);
    }
  };
  Object.assign(Da.prototype, G$);
  Da.prototype.Noop = /* @__PURE__ */ n(function() {
  }, "Noop");
  var S4e = $l.default = Da;
  function oH() {
    this.tokenChar(44), this.space();
  }
  n(oH, "commaSeparator");
});

// ../node_modules/@babel/generator/lib/index.js
var _a = w((Hl) => {
  "use strict";
  Object.defineProperty(Hl, "__esModule", {
    value: !0
  });
  Hl.default = lH;
  var Xg = ng(), $g = Jg();
  function Hg(t, e) {
    let r = {
      auxiliaryCommentBefore: e.auxiliaryCommentBefore,
      auxiliaryCommentAfter: e.auxiliaryCommentAfter,
      shouldPrintComment: e.shouldPrintComment,
      retainLines: e.retainLines,
      retainFunctionParens: e.retainFunctionParens,
      comments: e.comments == null || e.comments,
      compact: e.compact,
      minified: e.minified,
      concise: e.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, e.jsescOption),
      topicToken: e.topicToken,
      importAttributesKeyword: e.importAttributesKeyword
    };
    {
      var s;
      r.decoratorsBeforeExport = e.decoratorsBeforeExport, r.jsescOption.json = e.jsonCompatibleStrings, r.recordAndTupleSyntaxType = (s = e.
      recordAndTupleSyntaxType) != null ? s : "hash";
    }
    r.minified ? (r.compact = !0, r.shouldPrintComment = r.shouldPrintComment || (() => r.comments)) : r.shouldPrintComment = r.shouldPrintComment ||
    ((l) => r.comments || l.includes("@license") || l.includes("@preserve")), r.compact === "auto" && (r.compact = typeof t == "string" && t.
    length > 5e5, r.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${e.filename} as it exceeds th\
e max of 500KB.`)), r.compact && (r.indent.adjustMultilineComment = !1);
    let {
      auxiliaryCommentBefore: i,
      auxiliaryCommentAfter: a,
      shouldPrintComment: o
    } = r;
    return i && !o(i) && (r.auxiliaryCommentBefore = void 0), a && !o(a) && (r.auxiliaryCommentAfter = void 0), r;
  }
  n(Hg, "normalizeOptions");
  Hl.CodeGenerator = class {
    static {
      n(this, "CodeGenerator");
    }
    constructor(e, r = {}, s) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = e, this._format = Hg(s, r), this._map = r.sourceMaps ? new Xg.
      default(r, s) : null;
    }
    generate() {
      return new $g.default(this._format, this._map).generate(this._ast);
    }
  };
  function lH(t, e = {}, r) {
    let s = Hg(r, e), i = e.sourceMaps ? new Xg.default(e, r) : null;
    return new $g.default(s, i).generate(t);
  }
  n(lH, "generate");
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var Mh = w((He) => {
  "use strict";
  Object.defineProperty(He, "__esModule", {
    value: !0
  });
  He.Var = He.User = He.Statement = He.SpreadProperty = He.Scope = He.RestProperty = He.ReferencedMemberExpression = He.ReferencedIdentifier =
  He.Referenced = He.Pure = He.NumericLiteralTypeAnnotation = He.Generated = He.ForAwaitStatement = He.Flow = He.Expression = He.ExistentialTypeParam =
  He.BlockScoped = He.BindingIdentifier = void 0;
  var C4e = He.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], I4e = He.ReferencedMemberExpression = ["MemberExpression"], w4e = He.
  BindingIdentifier = ["Identifier"], N4e = He.Statement = ["Statement"], O4e = He.Expression = ["Expression"], k4e = He.Scope = ["Scopable",
  "Pattern"], D4e = He.Referenced = null, _4e = He.BlockScoped = null, L4e = He.Var = ["VariableDeclaration"], M4e = He.User = null, B4e = He.
  Generated = null, F4e = He.Pure = null, j4e = He.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], R4e = He.RestProperty =
  ["RestElement"], U4e = He.SpreadProperty = ["RestElement"], q4e = He.ExistentialTypeParam = ["ExistsTypeAnnotation"], V4e = He.NumericLiteralTypeAnnotation =
  ["NumberLiteralTypeAnnotation"], K4e = He.ForAwaitStatement = ["ForOfStatement"];
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var Fh = w((Ut) => {
  "use strict";
  Object.defineProperty(Ut, "__esModule", {
    value: !0
  });
  Ut.isBindingIdentifier = kH;
  Ut.isBlockScoped = BH;
  Ut.isExpression = _H;
  Ut.isFlow = qH;
  Ut.isForAwaitStatement = WH;
  Ut.isGenerated = RH;
  Ut.isPure = UH;
  Ut.isReferenced = MH;
  Ut.isReferencedIdentifier = NH;
  Ut.isReferencedMemberExpression = OH;
  Ut.isRestProperty = VH;
  Ut.isScope = LH;
  Ut.isSpreadProperty = KH;
  Ut.isStatement = DH;
  Ut.isUser = jH;
  Ut.isVar = FH;
  var uH = Ce(), {
    isBinding: cH,
    isBlockScoped: pH,
    isExportDeclaration: fH,
    isExpression: hH,
    isFlow: dH,
    isForStatement: mH,
    isForXStatement: yH,
    isIdentifier: zg,
    isImportDeclaration: TH,
    isImportSpecifier: bH,
    isJSXIdentifier: xH,
    isJSXMemberExpression: SH,
    isMemberExpression: gH,
    isRestElement: Gg,
    isReferenced: Bh,
    isScope: PH,
    isStatement: EH,
    isVar: AH,
    isVariableDeclaration: vH,
    react: CH,
    isForOfStatement: IH
  } = uH, {
    isCompatTag: wH
  } = CH;
  function NH(t) {
    let {
      node: e,
      parent: r
    } = this;
    if (!zg(e, t) && !SH(r, t))
      if (xH(e, t)) {
        if (wH(e.name)) return !1;
      } else
        return !1;
    return Bh(e, r, this.parentPath.parent);
  }
  n(NH, "isReferencedIdentifier");
  function OH() {
    let {
      node: t,
      parent: e
    } = this;
    return gH(t) && Bh(t, e);
  }
  n(OH, "isReferencedMemberExpression");
  function kH() {
    let {
      node: t,
      parent: e
    } = this, r = this.parentPath.parent;
    return zg(t) && cH(t, e, r);
  }
  n(kH, "isBindingIdentifier");
  function DH() {
    let {
      node: t,
      parent: e
    } = this;
    return EH(t) ? !(vH(t) && (yH(e, {
      left: t
    }) || mH(e, {
      init: t
    }))) : !1;
  }
  n(DH, "isStatement");
  function _H() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : hH(this.node);
  }
  n(_H, "isExpression");
  function LH() {
    return PH(this.node, this.parent);
  }
  n(LH, "isScope");
  function MH() {
    return Bh(this.node, this.parent);
  }
  n(MH, "isReferenced");
  function BH() {
    return pH(this.node);
  }
  n(BH, "isBlockScoped");
  function FH() {
    return AH(this.node);
  }
  n(FH, "isVar");
  function jH() {
    return this.node && !!this.node.loc;
  }
  n(jH, "isUser");
  function RH() {
    return !this.isUser();
  }
  n(RH, "isGenerated");
  function UH(t) {
    return this.scope.isPure(this.node, t);
  }
  n(UH, "isPure");
  function qH() {
    let {
      node: t
    } = this;
    return dH(t) ? !0 : TH(t) ? t.importKind === "type" || t.importKind === "typeof" : fH(t) ? t.exportKind === "type" : bH(t) ? t.importKind ===
    "type" || t.importKind === "typeof" : !1;
  }
  n(qH, "isFlow");
  function VH() {
    return Gg(this.node) && this.parentPath && this.parentPath.isObjectPattern();
  }
  n(VH, "isRestProperty");
  function KH() {
    return Gg(this.node) && this.parentPath && this.parentPath.isObjectExpression();
  }
  n(KH, "isSpreadProperty");
  function WH() {
    return IH(this.node, {
      await: !0
    });
  }
  n(WH, "isForAwaitStatement");
  Ut.isExistentialTypeParam = /* @__PURE__ */ n(function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, "isExistentialTypeParam"), Ut.isNumericLiteralTypeAnnotation = /* @__PURE__ */ n(function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  }, "isNumericLiteralTypeAnnotation");
});

// ../node_modules/@babel/traverse/lib/visitors.js
var Ma = w((yn) => {
  "use strict";
  Object.defineProperty(yn, "__esModule", {
    value: !0
  });
  yn.explode = oP;
  yn.isExplodedVisitor = aP;
  yn.merge = HH;
  yn.verify = lP;
  var nP = Mh(), YH = Fh(), JH = Ce(), {
    DEPRECATED_KEYS: Qg,
    DEPRECATED_ALIASES: Zg,
    FLIPPED_ALIAS_KEYS: eP,
    TYPES: XH,
    __internal__deprecationWarning: tP
  } = JH;
  function $H(t) {
    return t in nP;
  }
  n($H, "isVirtualType");
  function aP(t) {
    return t?._exploded;
  }
  n(aP, "isExplodedVisitor");
  function oP(t) {
    if (aP(t)) return t;
    t._exploded = !0;
    for (let e of Object.keys(t)) {
      if (Li(e)) continue;
      let r = e.split("|");
      if (r.length === 1) continue;
      let s = t[e];
      delete t[e];
      for (let i of r)
        t[i] = s;
    }
    lP(t), delete t.__esModule, zH(t), iP(t);
    for (let e of Object.keys(t)) {
      if (Li(e) || !$H(e)) continue;
      let r = t[e];
      for (let i of Object.keys(r))
        r[i] = GH(e, r[i]);
      delete t[e];
      let s = nP[e];
      if (s !== null)
        for (let i of s)
          t[i] ? La(t[i], r) : t[i] = r;
      else
        La(t, r);
    }
    for (let e of Object.keys(t)) {
      if (Li(e)) continue;
      let r = eP[e];
      if (e in Qg) {
        let i = Qg[e];
        tP(e, i, "Visitor "), r = [i];
      } else if (e in Zg) {
        let i = Zg[e];
        tP(e, i, "Visitor "), r = eP[i];
      }
      if (!r) continue;
      let s = t[e];
      delete t[e];
      for (let i of r) {
        let a = t[i];
        a ? La(a, s) : t[i] = Object.assign({}, s);
      }
    }
    for (let e of Object.keys(t))
      Li(e) || iP(t[e]);
    return t;
  }
  n(oP, "explode");
  function lP(t) {
    if (!t._verified) {
      if (typeof t == "function")
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Functi\
on }`?");
      for (let e of Object.keys(t)) {
        if ((e === "enter" || e === "exit") && rP(e, t[e]), Li(e)) continue;
        if (XH.indexOf(e) < 0)
          throw new Error(`You gave us a visitor for the node type ${e} but it's not a valid type`);
        let r = t[e];
        if (typeof r == "object")
          for (let s of Object.keys(r))
            if (s === "enter" || s === "exit")
              rP(`${e}.${s}`, r[s]);
            else
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${e} that has the invalid property ${s}`);
      }
      t._verified = !0;
    }
  }
  n(lP, "verify");
  function rP(t, e) {
    let r = [].concat(e);
    for (let s of r)
      if (typeof s != "function")
        throw new TypeError(`Non-function found defined in ${t} with type ${typeof s}`);
  }
  n(rP, "validateVisitorMethods");
  function HH(t, e = [], r) {
    let s = {};
    for (let i = 0; i < t.length; i++) {
      let a = oP(t[i]), o = e[i], l = a;
      (o || r) && (l = sP(l, o, r)), La(s, l);
      for (let u of Object.keys(a)) {
        if (Li(u)) continue;
        let c = a[u];
        (o || r) && (c = sP(c, o, r));
        let p = s[u] || (s[u] = {});
        La(p, c);
      }
    }
    return s;
  }
  n(HH, "merge");
  function sP(t, e, r) {
    let s = {};
    for (let i of ["enter", "exit"]) {
      let a = t[i];
      Array.isArray(a) && (a = a.map(function(o) {
        let l = o;
        return e && (l = /* @__PURE__ */ n(function(u) {
          o.call(e, u, e);
        }, "newFn")), r && (l = r(e?.key, i, l)), l !== o && (l.toString = () => o.toString()), l;
      }), s[i] = a);
    }
    return s;
  }
  n(sP, "wrapWithStateOrWrapper");
  function zH(t) {
    for (let e of Object.keys(t)) {
      if (Li(e)) continue;
      let r = t[e];
      typeof r == "function" && (t[e] = {
        enter: r
      });
    }
  }
  n(zH, "ensureEntranceObjects");
  function iP(t) {
    t.enter && !Array.isArray(t.enter) && (t.enter = [t.enter]), t.exit && !Array.isArray(t.exit) && (t.exit = [t.exit]);
  }
  n(iP, "ensureCallbackArrays");
  function GH(t, e) {
    let r = `is${t}`, s = YH[r], i = /* @__PURE__ */ n(function(a) {
      if (s.call(a))
        return e.apply(this, arguments);
    }, "newFn");
    return i.toString = () => e.toString(), i;
  }
  n(GH, "wrapCheck");
  function Li(t) {
    return t[0] === "_" || t === "enter" || t === "exit" || t === "shouldSkip" || t === "denylist" || t === "noScope" || t === "skipKeys" ||
    t === "blacklist";
  }
  n(Li, "shouldIgnoreKey");
  function La(t, e) {
    for (let r of ["enter", "exit"])
      e[r] && (t[r] = [].concat(t[r] || [], e[r]));
  }
  n(La, "mergePair");
});

// ../node_modules/@babel/traverse/lib/cache.js
var Mi = w((_r) => {
  "use strict";
  Object.defineProperty(_r, "__esModule", {
    value: !0
  });
  _r.clear = ZH;
  _r.clearPath = uP;
  _r.clearScope = cP;
  _r.getCachedPaths = ez;
  _r.getOrCreateCachedPaths = tz;
  _r.scope = _r.path = void 0;
  var zl = _r.path = /* @__PURE__ */ new WeakMap(), QH = _r.scope = /* @__PURE__ */ new WeakMap();
  function ZH() {
    uP(), cP();
  }
  n(ZH, "clear");
  function uP() {
    _r.path = zl = /* @__PURE__ */ new WeakMap();
  }
  n(uP, "clearPath");
  function cP() {
    _r.scope = QH = /* @__PURE__ */ new WeakMap();
  }
  n(cP, "clearScope");
  var jh = Object.freeze({});
  function ez(t, e) {
    var r, s;
    return t = null, (r = zl.get((s = t) != null ? s : jh)) == null ? void 0 : r.get(e);
  }
  n(ez, "getCachedPaths");
  function tz(t, e) {
    var r, s;
    t = null;
    let i = zl.get((r = t) != null ? r : jh);
    i || zl.set((s = t) != null ? s : jh, i = /* @__PURE__ */ new WeakMap());
    let a = i.get(e);
    return a || i.set(e, a = /* @__PURE__ */ new Map()), a;
  }
  n(tz, "getOrCreateCachedPaths");
});

// ../node_modules/debug/node_modules/ms/index.js
var fP = w((G4e, pP) => {
  var Tn = 1e3, bn = Tn * 60, xn = bn * 60, Bi = xn * 24, rz = Bi * 7, sz = Bi * 365.25;
  pP.exports = function(t, e) {
    e = e || {};
    var r = typeof t;
    if (r === "string" && t.length > 0)
      return iz(t);
    if (r === "number" && isFinite(t))
      return e.long ? az(t) : nz(t);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(t)
    );
  };
  function iz(t) {
    if (t = String(t), !(t.length > 100)) {
      var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.
      exec(
        t
      );
      if (e) {
        var r = parseFloat(e[1]), s = (e[2] || "ms").toLowerCase();
        switch (s) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return r * sz;
          case "weeks":
          case "week":
          case "w":
            return r * rz;
          case "days":
          case "day":
          case "d":
            return r * Bi;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return r * xn;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return r * bn;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return r * Tn;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return r;
          default:
            return;
        }
      }
    }
  }
  n(iz, "parse");
  function nz(t) {
    var e = Math.abs(t);
    return e >= Bi ? Math.round(t / Bi) + "d" : e >= xn ? Math.round(t / xn) + "h" : e >= bn ? Math.round(t / bn) + "m" : e >= Tn ? Math.round(
    t / Tn) + "s" : t + "ms";
  }
  n(nz, "fmtShort");
  function az(t) {
    var e = Math.abs(t);
    return e >= Bi ? Gl(t, e, Bi, "day") : e >= xn ? Gl(t, e, xn, "hour") : e >= bn ? Gl(t, e, bn, "minute") : e >= Tn ? Gl(t, e, Tn, "secon\
d") : t + " ms";
  }
  n(az, "fmtLong");
  function Gl(t, e, r, s) {
    var i = e >= r * 1.5;
    return Math.round(t / r) + " " + s + (i ? "s" : "");
  }
  n(Gl, "plural");
});

// ../node_modules/debug/src/common.js
var Rh = w((Z4e, hP) => {
  function oz(t) {
    r.debug = r, r.default = r, r.coerce = u, r.disable = a, r.enable = i, r.enabled = o, r.humanize = fP(), r.destroy = c, Object.keys(t).forEach(
    (p) => {
      r[p] = t[p];
    }), r.names = [], r.skips = [], r.formatters = {};
    function e(p) {
      let f = 0;
      for (let m = 0; m < p.length; m++)
        f = (f << 5) - f + p.charCodeAt(m), f |= 0;
      return r.colors[Math.abs(f) % r.colors.length];
    }
    n(e, "selectColor"), r.selectColor = e;
    function r(p) {
      let f, m = null, y, T;
      function L(...q) {
        if (!L.enabled)
          return;
        let _ = L, U = Number(/* @__PURE__ */ new Date()), J = U - (f || U);
        _.diff = J, _.prev = f, _.curr = U, f = U, q[0] = r.coerce(q[0]), typeof q[0] != "string" && q.unshift("%O");
        let ie = 0;
        q[0] = q[0].replace(/%([a-zA-Z%])/g, (ne, Be) => {
          if (ne === "%%")
            return "%";
          ie++;
          let bt = r.formatters[Be];
          if (typeof bt == "function") {
            let Et = q[ie];
            ne = bt.call(_, Et), q.splice(ie, 1), ie--;
          }
          return ne;
        }), r.formatArgs.call(_, q), (_.log || r.log).apply(_, q);
      }
      return n(L, "debug"), L.namespace = p, L.useColors = r.useColors(), L.color = r.selectColor(p), L.extend = s, L.destroy = r.destroy, Object.
      defineProperty(L, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: /* @__PURE__ */ n(() => m !== null ? m : (y !== r.namespaces && (y = r.namespaces, T = r.enabled(p)), T), "get"),
        set: /* @__PURE__ */ n((q) => {
          m = q;
        }, "set")
      }), typeof r.init == "function" && r.init(L), L;
    }
    n(r, "createDebug");
    function s(p, f) {
      let m = r(this.namespace + (typeof f > "u" ? ":" : f) + p);
      return m.log = this.log, m;
    }
    n(s, "extend");
    function i(p) {
      r.save(p), r.namespaces = p, r.names = [], r.skips = [];
      let f, m = (typeof p == "string" ? p : "").split(/[\s,]+/), y = m.length;
      for (f = 0; f < y; f++)
        m[f] && (p = m[f].replace(/\*/g, ".*?"), p[0] === "-" ? r.skips.push(new RegExp("^" + p.slice(1) + "$")) : r.names.push(new RegExp("\
^" + p + "$")));
    }
    n(i, "enable");
    function a() {
      let p = [
        ...r.names.map(l),
        ...r.skips.map(l).map((f) => "-" + f)
      ].join(",");
      return r.enable(""), p;
    }
    n(a, "disable");
    function o(p) {
      if (p[p.length - 1] === "*")
        return !0;
      let f, m;
      for (f = 0, m = r.skips.length; f < m; f++)
        if (r.skips[f].test(p))
          return !1;
      for (f = 0, m = r.names.length; f < m; f++)
        if (r.names[f].test(p))
          return !0;
      return !1;
    }
    n(o, "enabled");
    function l(p) {
      return p.toString().substring(2, p.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    n(l, "toNamespace");
    function u(p) {
      return p instanceof Error ? p.stack || p.message : p;
    }
    n(u, "coerce");
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major versio\
n of `debug`.");
    }
    return n(c, "destroy"), r.enable(r.load()), r;
  }
  n(oz, "setup");
  hP.exports = oz;
});

// ../node_modules/debug/src/browser.js
var dP = w((Lr, Ql) => {
  Lr.formatArgs = uz;
  Lr.save = cz;
  Lr.load = pz;
  Lr.useColors = lz;
  Lr.storage = fz();
  Lr.destroy = /* @__PURE__ */ (() => {
    let t = !1;
    return () => {
      t || (t = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the nex\
t major version of `debug`."));
    };
  })();
  Lr.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function lz() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "\
u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement &&
    document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >=
    31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  n(lz, "useColors");
  function uz(t) {
    if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" +
    Ql.exports.humanize(this.diff), !this.useColors)
      return;
    let e = "color: " + this.color;
    t.splice(1, 0, e, "color: inherit");
    let r = 0, s = 0;
    t[0].replace(/%[a-zA-Z%]/g, (i) => {
      i !== "%%" && (r++, i === "%c" && (s = r));
    }), t.splice(s, 0, e);
  }
  n(uz, "formatArgs");
  Lr.log = console.debug || console.log || (() => {
  });
  function cz(t) {
    try {
      t ? Lr.storage.setItem("debug", t) : Lr.storage.removeItem("debug");
    } catch {
    }
  }
  n(cz, "save");
  function pz() {
    let t;
    try {
      t = Lr.storage.getItem("debug");
    } catch {
    }
    return !t && typeof process < "u" && "env" in process && (t = process.env.DEBUG), t;
  }
  n(pz, "load");
  function fz() {
    try {
      return localStorage;
    } catch {
    }
  }
  n(fz, "localstorage");
  Ql.exports = Rh()(Lr);
  var { formatters: hz } = Ql.exports;
  hz.j = function(t) {
    try {
      return JSON.stringify(t);
    } catch (e) {
      return "[UnexpectedJSONParseError]: " + e.message;
    }
  };
});

// ../node_modules/has-flag/index.js
var yP = w((r5e, mP) => {
  "use strict";
  mP.exports = (t, e = process.argv) => {
    let r = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", s = e.indexOf(r + t), i = e.indexOf("--");
    return s !== -1 && (i === -1 || s < i);
  };
});

// ../node_modules/supports-color/index.js
var xP = w((s5e, bP) => {
  "use strict";
  var dz = require("os"), TP = require("tty"), jr = yP(), { env: zt } = process, Gs;
  jr("no-color") || jr("no-colors") || jr("color=false") || jr("color=never") ? Gs = 0 : (jr("color") || jr("colors") || jr("color=true") ||
  jr("color=always")) && (Gs = 1);
  "FORCE_COLOR" in zt && (zt.FORCE_COLOR === "true" ? Gs = 1 : zt.FORCE_COLOR === "false" ? Gs = 0 : Gs = zt.FORCE_COLOR.length === 0 ? 1 : Math.
  min(parseInt(zt.FORCE_COLOR, 10), 3));
  function Uh(t) {
    return t === 0 ? !1 : {
      level: t,
      hasBasic: !0,
      has256: t >= 2,
      has16m: t >= 3
    };
  }
  n(Uh, "translateLevel");
  function qh(t, e) {
    if (Gs === 0)
      return 0;
    if (jr("color=16m") || jr("color=full") || jr("color=truecolor"))
      return 3;
    if (jr("color=256"))
      return 2;
    if (t && !e && Gs === void 0)
      return 0;
    let r = Gs || 0;
    if (zt.TERM === "dumb")
      return r;
    if (process.platform === "win32") {
      let s = dz.release().split(".");
      return Number(s[0]) >= 10 && Number(s[2]) >= 10586 ? Number(s[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in zt)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((s) => s in zt) || zt.CI_NAME === "codeship" ?
      1 : r;
    if ("TEAMCITY_VERSION" in zt)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(zt.TEAMCITY_VERSION) ? 1 : 0;
    if (zt.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in zt) {
      let s = parseInt((zt.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (zt.TERM_PROGRAM) {
        case "iTerm.app":
          return s >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(zt.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(zt.TERM) || "COLORTERM" in
    zt ? 1 : r;
  }
  n(qh, "supportsColor");
  function mz(t) {
    let e = qh(t, t && t.isTTY);
    return Uh(e);
  }
  n(mz, "getSupportLevel");
  bP.exports = {
    supportsColor: mz,
    stdout: Uh(qh(!0, TP.isatty(1))),
    stderr: Uh(qh(!0, TP.isatty(2)))
  };
});

// ../node_modules/debug/src/node.js
var gP = w((Gt, eu) => {
  var yz = require("tty"), Zl = require("util");
  Gt.init = Ez;
  Gt.log = Sz;
  Gt.formatArgs = bz;
  Gt.save = gz;
  Gt.load = Pz;
  Gt.useColors = Tz;
  Gt.destroy = Zl.deprecate(
    () => {
    },
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
  );
  Gt.colors = [6, 2, 3, 4, 5, 1];
  try {
    let t = xP();
    t && (t.stderr || t).level >= 2 && (Gt.colors = [
      20,
      21,
      26,
      27,
      32,
      33,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      56,
      57,
      62,
      63,
      68,
      69,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      92,
      93,
      98,
      99,
      112,
      113,
      128,
      129,
      134,
      135,
      148,
      149,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      178,
      179,
      184,
      185,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      214,
      215,
      220,
      221
    ]);
  } catch {
  }
  Gt.inspectOpts = Object.keys(process.env).filter((t) => /^debug_/i.test(t)).reduce((t, e) => {
    let r = e.substring(6).toLowerCase().replace(/_([a-z])/g, (i, a) => a.toUpperCase()), s = process.env[e];
    return /^(yes|on|true|enabled)$/i.test(s) ? s = !0 : /^(no|off|false|disabled)$/i.test(s) ? s = !1 : s === "null" ? s = null : s = Number(
    s), t[r] = s, t;
  }, {});
  function Tz() {
    return "colors" in Gt.inspectOpts ? !!Gt.inspectOpts.colors : yz.isatty(process.stderr.fd);
  }
  n(Tz, "useColors");
  function bz(t) {
    let { namespace: e, useColors: r } = this;
    if (r) {
      let s = this.color, i = "\x1B[3" + (s < 8 ? s : "8;5;" + s), a = `  ${i};1m${e} \x1B[0m`;
      t[0] = a + t[0].split(`
`).join(`
` + a), t.push(i + "m+" + eu.exports.humanize(this.diff) + "\x1B[0m");
    } else
      t[0] = xz() + e + " " + t[0];
  }
  n(bz, "formatArgs");
  function xz() {
    return Gt.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  n(xz, "getDate");
  function Sz(...t) {
    return process.stderr.write(Zl.formatWithOptions(Gt.inspectOpts, ...t) + `
`);
  }
  n(Sz, "log");
  function gz(t) {
    t ? process.env.DEBUG = t : delete process.env.DEBUG;
  }
  n(gz, "save");
  function Pz() {
    return process.env.DEBUG;
  }
  n(Pz, "load");
  function Ez(t) {
    t.inspectOpts = {};
    let e = Object.keys(Gt.inspectOpts);
    for (let r = 0; r < e.length; r++)
      t.inspectOpts[e[r]] = Gt.inspectOpts[e[r]];
  }
  n(Ez, "init");
  eu.exports = Rh()(Gt);
  var { formatters: SP } = eu.exports;
  SP.o = function(t) {
    return this.inspectOpts.colors = this.useColors, Zl.inspect(t, this.inspectOpts).split(`
`).map((e) => e.trim()).join(" ");
  };
  SP.O = function(t) {
    return this.inspectOpts.colors = this.useColors, Zl.inspect(t, this.inspectOpts);
  };
});

// ../node_modules/debug/src/index.js
var PP = w((a5e, Vh) => {
  typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? Vh.exports = dP() : Vh.exports = gP();
});

// ../node_modules/@babel/helper-split-export-declaration/lib/index.js
var vP = w((Yh) => {
  "use strict";
  Object.defineProperty(Yh, "__esModule", {
    value: !0
  });
  Yh.default = Iz;
  var Az = Ce(), {
    cloneNode: Kh,
    exportNamedDeclaration: EP,
    exportSpecifier: AP,
    identifier: Wh,
    variableDeclaration: vz,
    variableDeclarator: Cz
  } = Az;
  function Iz(t) {
    if (!t.isExportDeclaration() || t.isExportAllDeclaration())
      throw new Error("Only default and named export declarations can be split.");
    if (t.isExportDefaultDeclaration()) {
      let a = t.get("declaration"), o = a.isFunctionDeclaration() || a.isClassDeclaration(), l = a.isFunctionExpression() || a.isClassExpression(),
      u = a.isScope() ? a.scope.parent : a.scope, c = a.node.id, p = !1;
      c ? l && u.hasBinding(c.name) && (p = !0, c = u.generateUidIdentifier(c.name)) : (p = !0, c = u.generateUidIdentifier("default"), (o ||
      l) && (a.node.id = Kh(c)));
      let f = o ? a.node : vz("var", [Cz(Kh(c), a.node)]), m = EP(null, [AP(Kh(c), Wh("default"))]);
      return t.insertAfter(m), t.replaceWith(f), p && u.registerDeclaration(t), t;
    } else if (t.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let e = t.get("declaration"), r = e.getOuterBindingIdentifiers(), s = Object.keys(r).map((a) => AP(Wh(a), Wh(a))), i = EP(null, s);
    return t.insertAfter(i), t.replaceWith(e.node), t;
  }
  n(Iz, "splitExportDeclaration");
});

// ../node_modules/@babel/helper-environment-visitor/lib/index.js
var Xh = w((Sn) => {
  "use strict";
  Object.defineProperty(Sn, "__esModule", {
    value: !0
  });
  Sn.default = void 0;
  Sn.requeueComputedKeyAndDecorators = Jh;
  Sn.skipAllButComputedKey = /* @__PURE__ */ n(function(e) {
    e.skip(), e.node.computed && e.context.maybeQueue(e.get("key"));
  }, "skipAllButComputedKey");
  function Jh(t) {
    let {
      context: e,
      node: r
    } = t;
    if (r.computed && e.maybeQueue(t.get("key")), r.decorators)
      for (let s of t.get("decorators"))
        e.maybeQueue(s);
  }
  n(Jh, "requeueComputedKeyAndDecorators");
  var wz = {
    FunctionParent(t) {
      t.isArrowFunctionExpression() || (t.skip(), t.isMethod() && Jh(t));
    },
    Property(t) {
      t.isObjectProperty() || (t.skip(), Jh(t));
    }
  }, u5e = Sn.default = wz;
});

// ../node_modules/@babel/traverse/lib/scope/lib/renamer.js
var CP = w((tu) => {
  "use strict";
  Object.defineProperty(tu, "__esModule", {
    value: !0
  });
  tu.default = void 0;
  var Nz = vP(), Oz = Ce(), kz = Xh(), Dz = ru(), _z = Ma(), Lz = {
    ReferencedIdentifier({
      node: t
    }, e) {
      t.name === e.oldName && (t.name = e.newName);
    },
    Scope(t, e) {
      t.scope.bindingIdentifierEquals(e.oldName, e.binding.identifier) || (t.skip(), t.isMethod() && (0, kz.requeueComputedKeyAndDecorators)(
      t));
    },
    ObjectProperty({
      node: t,
      scope: e
    }, r) {
      let {
        name: s
      } = t.key;
      if (t.shorthand && (s === r.oldName || s === r.newName) && e.getBindingIdentifier(s) === r.binding.identifier) {
        var i;
        t.shorthand = !1, (i = t.extra) != null && i.shorthand && (t.extra.shorthand = !1);
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(t, e) {
      if (t.isVariableDeclaration()) return;
      let r = t.getOuterBindingIdentifiers();
      for (let s in r)
        s === e.oldName && (r[s].name = e.newName);
    }
  }, $h = class {
    static {
      n(this, "Renamer");
    }
    constructor(e, r, s) {
      this.newName = s, this.oldName = r, this.binding = e;
    }
    maybeConvertFromExportDeclaration(e) {
      let r = e.parentPath;
      if (r.isExportDeclaration()) {
        if (r.isExportDefaultDeclaration()) {
          let {
            declaration: s
          } = r.node;
          if (Oz.isDeclaration(s) && !s.id)
            return;
        }
        r.isExportAllDeclaration() || (0, Nz.default)(r);
      }
    }
    maybeConvertFromClassFunctionDeclaration(e) {
      return e;
    }
    maybeConvertFromClassFunctionExpression(e) {
      return e;
    }
    rename() {
      let {
        binding: e,
        oldName: r,
        newName: s
      } = this, {
        scope: i,
        path: a
      } = e, o = a.find((u) => u.isDeclaration() || u.isFunctionExpression() || u.isClassExpression());
      o && o.getOuterBindingIdentifiers()[r] === e.identifier && this.maybeConvertFromExportDeclaration(o);
      let l = arguments[0] || i.block;
      (0, Dz.traverseNode)(l, (0, _z.explode)(Lz), i, this, i.path, {
        discriminant: !0
      }), arguments[0] || (i.removeOwnBinding(r), i.bindings[s] = e, this.binding.identifier.name = s), o && (this.maybeConvertFromClassFunctionDeclaration(
      a), this.maybeConvertFromClassFunctionExpression(a));
    }
  };
  tu.default = $h;
});

// ../node_modules/@babel/traverse/lib/scope/binding.js
var IP = w((su) => {
  "use strict";
  Object.defineProperty(su, "__esModule", {
    value: !0
  });
  su.default = void 0;
  var Hh = class {
    static {
      n(this, "Binding");
    }
    constructor({
      identifier: e,
      scope: r,
      path: s,
      kind: i
    }) {
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0,
      this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = e, this.scope = r, this.path = s, this.kind = i,
      (i === "var" || i === "hoisted") && Mz(s) && this.reassign(s), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = !0;
    }
    setValue(e) {
      this.hasDeoptedValue || (this.hasValue = !0, this.value = e);
    }
    clearValue() {
      this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
    }
    reassign(e) {
      this.constant = !1, this.constantViolations.indexOf(e) === -1 && this.constantViolations.push(e);
    }
    reference(e) {
      this.referencePaths.indexOf(e) === -1 && (this.referenced = !0, this.references++, this.referencePaths.push(e));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
  su.default = Hh;
  function Mz(t) {
    for (let {
      parentPath: e,
      key: r
    } = t; e; {
      parentPath: e,
      key: r
    } = e) {
      if (e.isFunctionParent()) return !1;
      if (e.isWhile() || e.isForXStatement() || e.isForStatement() && r === "body")
        return !0;
    }
    return !1;
  }
  n(Mz, "isDeclaredInLoop");
});

// ../node_modules/@babel/traverse/node_modules/globals/globals.json
var wP = w((y5e, Bz) => {
  Bz.exports = {
    builtin: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      BigInt: !1,
      BigInt64Array: !1,
      BigUint64Array: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      globalThis: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es5: {
      Array: !1,
      Boolean: !1,
      constructor: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      propertyIsEnumerable: !1,
      RangeError: !1,
      ReferenceError: !1,
      RegExp: !1,
      String: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1
    },
    es2015: {
      Array: !1,
      ArrayBuffer: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es2017: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    browser: {
      AbortController: !1,
      AbortSignal: !1,
      addEventListener: !1,
      alert: !1,
      AnalyserNode: !1,
      Animation: !1,
      AnimationEffectReadOnly: !1,
      AnimationEffectTiming: !1,
      AnimationEffectTimingReadOnly: !1,
      AnimationEvent: !1,
      AnimationPlaybackEvent: !1,
      AnimationTimeline: !1,
      applicationCache: !1,
      ApplicationCache: !1,
      ApplicationCacheErrorEvent: !1,
      atob: !1,
      Attr: !1,
      Audio: !1,
      AudioBuffer: !1,
      AudioBufferSourceNode: !1,
      AudioContext: !1,
      AudioDestinationNode: !1,
      AudioListener: !1,
      AudioNode: !1,
      AudioParam: !1,
      AudioProcessingEvent: !1,
      AudioScheduledSourceNode: !1,
      "AudioWorkletGlobalScope ": !1,
      AudioWorkletNode: !1,
      AudioWorkletProcessor: !1,
      BarProp: !1,
      BaseAudioContext: !1,
      BatteryManager: !1,
      BeforeUnloadEvent: !1,
      BiquadFilterNode: !1,
      Blob: !1,
      BlobEvent: !1,
      blur: !1,
      BroadcastChannel: !1,
      btoa: !1,
      BudgetService: !1,
      ByteLengthQueuingStrategy: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      cancelAnimationFrame: !1,
      cancelIdleCallback: !1,
      CanvasCaptureMediaStreamTrack: !1,
      CanvasGradient: !1,
      CanvasPattern: !1,
      CanvasRenderingContext2D: !1,
      ChannelMergerNode: !1,
      ChannelSplitterNode: !1,
      CharacterData: !1,
      clearInterval: !1,
      clearTimeout: !1,
      clientInformation: !1,
      ClipboardEvent: !1,
      close: !1,
      closed: !1,
      CloseEvent: !1,
      Comment: !1,
      CompositionEvent: !1,
      confirm: !1,
      console: !1,
      ConstantSourceNode: !1,
      ConvolverNode: !1,
      CountQueuingStrategy: !1,
      createImageBitmap: !1,
      Credential: !1,
      CredentialsContainer: !1,
      crypto: !1,
      Crypto: !1,
      CryptoKey: !1,
      CSS: !1,
      CSSConditionRule: !1,
      CSSFontFaceRule: !1,
      CSSGroupingRule: !1,
      CSSImportRule: !1,
      CSSKeyframeRule: !1,
      CSSKeyframesRule: !1,
      CSSMediaRule: !1,
      CSSNamespaceRule: !1,
      CSSPageRule: !1,
      CSSRule: !1,
      CSSRuleList: !1,
      CSSStyleDeclaration: !1,
      CSSStyleRule: !1,
      CSSStyleSheet: !1,
      CSSSupportsRule: !1,
      CustomElementRegistry: !1,
      customElements: !1,
      CustomEvent: !1,
      DataTransfer: !1,
      DataTransferItem: !1,
      DataTransferItemList: !1,
      defaultstatus: !1,
      defaultStatus: !1,
      DelayNode: !1,
      DeviceMotionEvent: !1,
      DeviceOrientationEvent: !1,
      devicePixelRatio: !1,
      dispatchEvent: !1,
      document: !1,
      Document: !1,
      DocumentFragment: !1,
      DocumentType: !1,
      DOMError: !1,
      DOMException: !1,
      DOMImplementation: !1,
      DOMMatrix: !1,
      DOMMatrixReadOnly: !1,
      DOMParser: !1,
      DOMPoint: !1,
      DOMPointReadOnly: !1,
      DOMQuad: !1,
      DOMRect: !1,
      DOMRectReadOnly: !1,
      DOMStringList: !1,
      DOMStringMap: !1,
      DOMTokenList: !1,
      DragEvent: !1,
      DynamicsCompressorNode: !1,
      Element: !1,
      ErrorEvent: !1,
      event: !1,
      Event: !1,
      EventSource: !1,
      EventTarget: !1,
      external: !1,
      fetch: !1,
      File: !1,
      FileList: !1,
      FileReader: !1,
      find: !1,
      focus: !1,
      FocusEvent: !1,
      FontFace: !1,
      FontFaceSetLoadEvent: !1,
      FormData: !1,
      frameElement: !1,
      frames: !1,
      GainNode: !1,
      Gamepad: !1,
      GamepadButton: !1,
      GamepadEvent: !1,
      getComputedStyle: !1,
      getSelection: !1,
      HashChangeEvent: !1,
      Headers: !1,
      history: !1,
      History: !1,
      HTMLAllCollection: !1,
      HTMLAnchorElement: !1,
      HTMLAreaElement: !1,
      HTMLAudioElement: !1,
      HTMLBaseElement: !1,
      HTMLBodyElement: !1,
      HTMLBRElement: !1,
      HTMLButtonElement: !1,
      HTMLCanvasElement: !1,
      HTMLCollection: !1,
      HTMLContentElement: !1,
      HTMLDataElement: !1,
      HTMLDataListElement: !1,
      HTMLDetailsElement: !1,
      HTMLDialogElement: !1,
      HTMLDirectoryElement: !1,
      HTMLDivElement: !1,
      HTMLDListElement: !1,
      HTMLDocument: !1,
      HTMLElement: !1,
      HTMLEmbedElement: !1,
      HTMLFieldSetElement: !1,
      HTMLFontElement: !1,
      HTMLFormControlsCollection: !1,
      HTMLFormElement: !1,
      HTMLFrameElement: !1,
      HTMLFrameSetElement: !1,
      HTMLHeadElement: !1,
      HTMLHeadingElement: !1,
      HTMLHRElement: !1,
      HTMLHtmlElement: !1,
      HTMLIFrameElement: !1,
      HTMLImageElement: !1,
      HTMLInputElement: !1,
      HTMLLabelElement: !1,
      HTMLLegendElement: !1,
      HTMLLIElement: !1,
      HTMLLinkElement: !1,
      HTMLMapElement: !1,
      HTMLMarqueeElement: !1,
      HTMLMediaElement: !1,
      HTMLMenuElement: !1,
      HTMLMetaElement: !1,
      HTMLMeterElement: !1,
      HTMLModElement: !1,
      HTMLObjectElement: !1,
      HTMLOListElement: !1,
      HTMLOptGroupElement: !1,
      HTMLOptionElement: !1,
      HTMLOptionsCollection: !1,
      HTMLOutputElement: !1,
      HTMLParagraphElement: !1,
      HTMLParamElement: !1,
      HTMLPictureElement: !1,
      HTMLPreElement: !1,
      HTMLProgressElement: !1,
      HTMLQuoteElement: !1,
      HTMLScriptElement: !1,
      HTMLSelectElement: !1,
      HTMLShadowElement: !1,
      HTMLSlotElement: !1,
      HTMLSourceElement: !1,
      HTMLSpanElement: !1,
      HTMLStyleElement: !1,
      HTMLTableCaptionElement: !1,
      HTMLTableCellElement: !1,
      HTMLTableColElement: !1,
      HTMLTableElement: !1,
      HTMLTableRowElement: !1,
      HTMLTableSectionElement: !1,
      HTMLTemplateElement: !1,
      HTMLTextAreaElement: !1,
      HTMLTimeElement: !1,
      HTMLTitleElement: !1,
      HTMLTrackElement: !1,
      HTMLUListElement: !1,
      HTMLUnknownElement: !1,
      HTMLVideoElement: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      IdleDeadline: !1,
      IIRFilterNode: !1,
      Image: !1,
      ImageBitmap: !1,
      ImageBitmapRenderingContext: !1,
      ImageCapture: !1,
      ImageData: !1,
      indexedDB: !1,
      innerHeight: !1,
      innerWidth: !1,
      InputEvent: !1,
      IntersectionObserver: !1,
      IntersectionObserverEntry: !1,
      Intl: !1,
      isSecureContext: !1,
      KeyboardEvent: !1,
      KeyframeEffect: !1,
      KeyframeEffectReadOnly: !1,
      length: !1,
      localStorage: !1,
      location: !0,
      Location: !1,
      locationbar: !1,
      matchMedia: !1,
      MediaDeviceInfo: !1,
      MediaDevices: !1,
      MediaElementAudioSourceNode: !1,
      MediaEncryptedEvent: !1,
      MediaError: !1,
      MediaKeyMessageEvent: !1,
      MediaKeySession: !1,
      MediaKeyStatusMap: !1,
      MediaKeySystemAccess: !1,
      MediaList: !1,
      MediaQueryList: !1,
      MediaQueryListEvent: !1,
      MediaRecorder: !1,
      MediaSettingsRange: !1,
      MediaSource: !1,
      MediaStream: !1,
      MediaStreamAudioDestinationNode: !1,
      MediaStreamAudioSourceNode: !1,
      MediaStreamEvent: !1,
      MediaStreamTrack: !1,
      MediaStreamTrackEvent: !1,
      menubar: !1,
      MessageChannel: !1,
      MessageEvent: !1,
      MessagePort: !1,
      MIDIAccess: !1,
      MIDIConnectionEvent: !1,
      MIDIInput: !1,
      MIDIInputMap: !1,
      MIDIMessageEvent: !1,
      MIDIOutput: !1,
      MIDIOutputMap: !1,
      MIDIPort: !1,
      MimeType: !1,
      MimeTypeArray: !1,
      MouseEvent: !1,
      moveBy: !1,
      moveTo: !1,
      MutationEvent: !1,
      MutationObserver: !1,
      MutationRecord: !1,
      name: !1,
      NamedNodeMap: !1,
      NavigationPreloadManager: !1,
      navigator: !1,
      Navigator: !1,
      NetworkInformation: !1,
      Node: !1,
      NodeFilter: !1,
      NodeIterator: !1,
      NodeList: !1,
      Notification: !1,
      OfflineAudioCompletionEvent: !1,
      OfflineAudioContext: !1,
      offscreenBuffering: !1,
      OffscreenCanvas: !0,
      onabort: !0,
      onafterprint: !0,
      onanimationend: !0,
      onanimationiteration: !0,
      onanimationstart: !0,
      onappinstalled: !0,
      onauxclick: !0,
      onbeforeinstallprompt: !0,
      onbeforeprint: !0,
      onbeforeunload: !0,
      onblur: !0,
      oncancel: !0,
      oncanplay: !0,
      oncanplaythrough: !0,
      onchange: !0,
      onclick: !0,
      onclose: !0,
      oncontextmenu: !0,
      oncuechange: !0,
      ondblclick: !0,
      ondevicemotion: !0,
      ondeviceorientation: !0,
      ondeviceorientationabsolute: !0,
      ondrag: !0,
      ondragend: !0,
      ondragenter: !0,
      ondragleave: !0,
      ondragover: !0,
      ondragstart: !0,
      ondrop: !0,
      ondurationchange: !0,
      onemptied: !0,
      onended: !0,
      onerror: !0,
      onfocus: !0,
      ongotpointercapture: !0,
      onhashchange: !0,
      oninput: !0,
      oninvalid: !0,
      onkeydown: !0,
      onkeypress: !0,
      onkeyup: !0,
      onlanguagechange: !0,
      onload: !0,
      onloadeddata: !0,
      onloadedmetadata: !0,
      onloadstart: !0,
      onlostpointercapture: !0,
      onmessage: !0,
      onmessageerror: !0,
      onmousedown: !0,
      onmouseenter: !0,
      onmouseleave: !0,
      onmousemove: !0,
      onmouseout: !0,
      onmouseover: !0,
      onmouseup: !0,
      onmousewheel: !0,
      onoffline: !0,
      ononline: !0,
      onpagehide: !0,
      onpageshow: !0,
      onpause: !0,
      onplay: !0,
      onplaying: !0,
      onpointercancel: !0,
      onpointerdown: !0,
      onpointerenter: !0,
      onpointerleave: !0,
      onpointermove: !0,
      onpointerout: !0,
      onpointerover: !0,
      onpointerup: !0,
      onpopstate: !0,
      onprogress: !0,
      onratechange: !0,
      onrejectionhandled: !0,
      onreset: !0,
      onresize: !0,
      onscroll: !0,
      onsearch: !0,
      onseeked: !0,
      onseeking: !0,
      onselect: !0,
      onstalled: !0,
      onstorage: !0,
      onsubmit: !0,
      onsuspend: !0,
      ontimeupdate: !0,
      ontoggle: !0,
      ontransitionend: !0,
      onunhandledrejection: !0,
      onunload: !0,
      onvolumechange: !0,
      onwaiting: !0,
      onwheel: !0,
      open: !1,
      openDatabase: !1,
      opener: !1,
      Option: !1,
      origin: !1,
      OscillatorNode: !1,
      outerHeight: !1,
      outerWidth: !1,
      PageTransitionEvent: !1,
      pageXOffset: !1,
      pageYOffset: !1,
      PannerNode: !1,
      parent: !1,
      Path2D: !1,
      PaymentAddress: !1,
      PaymentRequest: !1,
      PaymentRequestUpdateEvent: !1,
      PaymentResponse: !1,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceLongTaskTiming: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceNavigationTiming: !1,
      PerformanceObserver: !1,
      PerformanceObserverEntryList: !1,
      PerformancePaintTiming: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      PeriodicWave: !1,
      Permissions: !1,
      PermissionStatus: !1,
      personalbar: !1,
      PhotoCapabilities: !1,
      Plugin: !1,
      PluginArray: !1,
      PointerEvent: !1,
      PopStateEvent: !1,
      postMessage: !1,
      Presentation: !1,
      PresentationAvailability: !1,
      PresentationConnection: !1,
      PresentationConnectionAvailableEvent: !1,
      PresentationConnectionCloseEvent: !1,
      PresentationConnectionList: !1,
      PresentationReceiver: !1,
      PresentationRequest: !1,
      print: !1,
      ProcessingInstruction: !1,
      ProgressEvent: !1,
      PromiseRejectionEvent: !1,
      prompt: !1,
      PushManager: !1,
      PushSubscription: !1,
      PushSubscriptionOptions: !1,
      queueMicrotask: !1,
      RadioNodeList: !1,
      Range: !1,
      ReadableStream: !1,
      registerProcessor: !1,
      RemotePlayback: !1,
      removeEventListener: !1,
      Request: !1,
      requestAnimationFrame: !1,
      requestIdleCallback: !1,
      resizeBy: !1,
      ResizeObserver: !1,
      ResizeObserverEntry: !1,
      resizeTo: !1,
      Response: !1,
      RTCCertificate: !1,
      RTCDataChannel: !1,
      RTCDataChannelEvent: !1,
      RTCDtlsTransport: !1,
      RTCIceCandidate: !1,
      RTCIceGatherer: !1,
      RTCIceTransport: !1,
      RTCPeerConnection: !1,
      RTCPeerConnectionIceEvent: !1,
      RTCRtpContributingSource: !1,
      RTCRtpReceiver: !1,
      RTCRtpSender: !1,
      RTCSctpTransport: !1,
      RTCSessionDescription: !1,
      RTCStatsReport: !1,
      RTCTrackEvent: !1,
      screen: !1,
      Screen: !1,
      screenLeft: !1,
      ScreenOrientation: !1,
      screenTop: !1,
      screenX: !1,
      screenY: !1,
      ScriptProcessorNode: !1,
      scroll: !1,
      scrollbars: !1,
      scrollBy: !1,
      scrollTo: !1,
      scrollX: !1,
      scrollY: !1,
      SecurityPolicyViolationEvent: !1,
      Selection: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerRegistration: !1,
      sessionStorage: !1,
      setInterval: !1,
      setTimeout: !1,
      ShadowRoot: !1,
      SharedWorker: !1,
      SourceBuffer: !1,
      SourceBufferList: !1,
      speechSynthesis: !1,
      SpeechSynthesisEvent: !1,
      SpeechSynthesisUtterance: !1,
      StaticRange: !1,
      status: !1,
      statusbar: !1,
      StereoPannerNode: !1,
      stop: !1,
      Storage: !1,
      StorageEvent: !1,
      StorageManager: !1,
      styleMedia: !1,
      StyleSheet: !1,
      StyleSheetList: !1,
      SubtleCrypto: !1,
      SVGAElement: !1,
      SVGAngle: !1,
      SVGAnimatedAngle: !1,
      SVGAnimatedBoolean: !1,
      SVGAnimatedEnumeration: !1,
      SVGAnimatedInteger: !1,
      SVGAnimatedLength: !1,
      SVGAnimatedLengthList: !1,
      SVGAnimatedNumber: !1,
      SVGAnimatedNumberList: !1,
      SVGAnimatedPreserveAspectRatio: !1,
      SVGAnimatedRect: !1,
      SVGAnimatedString: !1,
      SVGAnimatedTransformList: !1,
      SVGAnimateElement: !1,
      SVGAnimateMotionElement: !1,
      SVGAnimateTransformElement: !1,
      SVGAnimationElement: !1,
      SVGCircleElement: !1,
      SVGClipPathElement: !1,
      SVGComponentTransferFunctionElement: !1,
      SVGDefsElement: !1,
      SVGDescElement: !1,
      SVGDiscardElement: !1,
      SVGElement: !1,
      SVGEllipseElement: !1,
      SVGFEBlendElement: !1,
      SVGFEColorMatrixElement: !1,
      SVGFEComponentTransferElement: !1,
      SVGFECompositeElement: !1,
      SVGFEConvolveMatrixElement: !1,
      SVGFEDiffuseLightingElement: !1,
      SVGFEDisplacementMapElement: !1,
      SVGFEDistantLightElement: !1,
      SVGFEDropShadowElement: !1,
      SVGFEFloodElement: !1,
      SVGFEFuncAElement: !1,
      SVGFEFuncBElement: !1,
      SVGFEFuncGElement: !1,
      SVGFEFuncRElement: !1,
      SVGFEGaussianBlurElement: !1,
      SVGFEImageElement: !1,
      SVGFEMergeElement: !1,
      SVGFEMergeNodeElement: !1,
      SVGFEMorphologyElement: !1,
      SVGFEOffsetElement: !1,
      SVGFEPointLightElement: !1,
      SVGFESpecularLightingElement: !1,
      SVGFESpotLightElement: !1,
      SVGFETileElement: !1,
      SVGFETurbulenceElement: !1,
      SVGFilterElement: !1,
      SVGForeignObjectElement: !1,
      SVGGElement: !1,
      SVGGeometryElement: !1,
      SVGGradientElement: !1,
      SVGGraphicsElement: !1,
      SVGImageElement: !1,
      SVGLength: !1,
      SVGLengthList: !1,
      SVGLinearGradientElement: !1,
      SVGLineElement: !1,
      SVGMarkerElement: !1,
      SVGMaskElement: !1,
      SVGMatrix: !1,
      SVGMetadataElement: !1,
      SVGMPathElement: !1,
      SVGNumber: !1,
      SVGNumberList: !1,
      SVGPathElement: !1,
      SVGPatternElement: !1,
      SVGPoint: !1,
      SVGPointList: !1,
      SVGPolygonElement: !1,
      SVGPolylineElement: !1,
      SVGPreserveAspectRatio: !1,
      SVGRadialGradientElement: !1,
      SVGRect: !1,
      SVGRectElement: !1,
      SVGScriptElement: !1,
      SVGSetElement: !1,
      SVGStopElement: !1,
      SVGStringList: !1,
      SVGStyleElement: !1,
      SVGSVGElement: !1,
      SVGSwitchElement: !1,
      SVGSymbolElement: !1,
      SVGTextContentElement: !1,
      SVGTextElement: !1,
      SVGTextPathElement: !1,
      SVGTextPositioningElement: !1,
      SVGTitleElement: !1,
      SVGTransform: !1,
      SVGTransformList: !1,
      SVGTSpanElement: !1,
      SVGUnitTypes: !1,
      SVGUseElement: !1,
      SVGViewElement: !1,
      TaskAttributionTiming: !1,
      Text: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      TextEvent: !1,
      TextMetrics: !1,
      TextTrack: !1,
      TextTrackCue: !1,
      TextTrackCueList: !1,
      TextTrackList: !1,
      TimeRanges: !1,
      toolbar: !1,
      top: !1,
      Touch: !1,
      TouchEvent: !1,
      TouchList: !1,
      TrackEvent: !1,
      TransitionEvent: !1,
      TreeWalker: !1,
      UIEvent: !1,
      URL: !1,
      URLSearchParams: !1,
      ValidityState: !1,
      visualViewport: !1,
      VisualViewport: !1,
      VTTCue: !1,
      WaveShaperNode: !1,
      WebAssembly: !1,
      WebGL2RenderingContext: !1,
      WebGLActiveInfo: !1,
      WebGLBuffer: !1,
      WebGLContextEvent: !1,
      WebGLFramebuffer: !1,
      WebGLProgram: !1,
      WebGLQuery: !1,
      WebGLRenderbuffer: !1,
      WebGLRenderingContext: !1,
      WebGLSampler: !1,
      WebGLShader: !1,
      WebGLShaderPrecisionFormat: !1,
      WebGLSync: !1,
      WebGLTexture: !1,
      WebGLTransformFeedback: !1,
      WebGLUniformLocation: !1,
      WebGLVertexArrayObject: !1,
      WebSocket: !1,
      WheelEvent: !1,
      window: !1,
      Window: !1,
      Worker: !1,
      WritableStream: !1,
      XMLDocument: !1,
      XMLHttpRequest: !1,
      XMLHttpRequestEventTarget: !1,
      XMLHttpRequestUpload: !1,
      XMLSerializer: !1,
      XPathEvaluator: !1,
      XPathExpression: !1,
      XPathResult: !1,
      XSLTProcessor: !1
    },
    worker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      clearInterval: !1,
      clearTimeout: !1,
      close: !0,
      console: !1,
      fetch: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !0,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onoffline: !0,
      ononline: !0,
      onrejectionhandled: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !0,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    node: {
      __dirname: !1,
      __filename: !1,
      Buffer: !1,
      clearImmediate: !1,
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      exports: !0,
      global: !1,
      Intl: !1,
      module: !1,
      process: !1,
      queueMicrotask: !1,
      require: !1,
      setImmediate: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1
    },
    commonjs: {
      exports: !0,
      global: !1,
      module: !1,
      require: !1
    },
    amd: {
      define: !1,
      require: !1
    },
    mocha: {
      after: !1,
      afterEach: !1,
      before: !1,
      beforeEach: !1,
      context: !1,
      describe: !1,
      it: !1,
      mocha: !1,
      run: !1,
      setup: !1,
      specify: !1,
      suite: !1,
      suiteSetup: !1,
      suiteTeardown: !1,
      teardown: !1,
      test: !1,
      xcontext: !1,
      xdescribe: !1,
      xit: !1,
      xspecify: !1
    },
    jasmine: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fail: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jasmine: !1,
      pending: !1,
      runs: !1,
      spyOn: !1,
      spyOnProperty: !1,
      waits: !1,
      waitsFor: !1,
      xdescribe: !1,
      xit: !1
    },
    jest: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jest: !1,
      pit: !1,
      require: !1,
      test: !1,
      xdescribe: !1,
      xit: !1,
      xtest: !1
    },
    qunit: {
      asyncTest: !1,
      deepEqual: !1,
      equal: !1,
      expect: !1,
      module: !1,
      notDeepEqual: !1,
      notEqual: !1,
      notOk: !1,
      notPropEqual: !1,
      notStrictEqual: !1,
      ok: !1,
      propEqual: !1,
      QUnit: !1,
      raises: !1,
      start: !1,
      stop: !1,
      strictEqual: !1,
      test: !1,
      throws: !1
    },
    phantomjs: {
      console: !0,
      exports: !0,
      phantom: !0,
      require: !0,
      WebPage: !0
    },
    couch: {
      emit: !1,
      exports: !1,
      getRow: !1,
      log: !1,
      module: !1,
      provides: !1,
      require: !1,
      respond: !1,
      send: !1,
      start: !1,
      sum: !1
    },
    rhino: {
      defineClass: !1,
      deserialize: !1,
      gc: !1,
      help: !1,
      importClass: !1,
      importPackage: !1,
      java: !1,
      load: !1,
      loadClass: !1,
      Packages: !1,
      print: !1,
      quit: !1,
      readFile: !1,
      readUrl: !1,
      runCommand: !1,
      seal: !1,
      serialize: !1,
      spawn: !1,
      sync: !1,
      toint32: !1,
      version: !1
    },
    nashorn: {
      __DIR__: !1,
      __FILE__: !1,
      __LINE__: !1,
      com: !1,
      edu: !1,
      exit: !1,
      java: !1,
      Java: !1,
      javafx: !1,
      JavaImporter: !1,
      javax: !1,
      JSAdapter: !1,
      load: !1,
      loadWithNewGlobal: !1,
      org: !1,
      Packages: !1,
      print: !1,
      quit: !1
    },
    wsh: {
      ActiveXObject: !0,
      Enumerator: !0,
      GetObject: !0,
      ScriptEngine: !0,
      ScriptEngineBuildVersion: !0,
      ScriptEngineMajorVersion: !0,
      ScriptEngineMinorVersion: !0,
      VBArray: !0,
      WScript: !0,
      WSH: !0,
      XDomainRequest: !0
    },
    jquery: {
      $: !1,
      jQuery: !1
    },
    yui: {
      YAHOO: !1,
      YAHOO_config: !1,
      YUI: !1,
      YUI_config: !1
    },
    shelljs: {
      cat: !1,
      cd: !1,
      chmod: !1,
      config: !1,
      cp: !1,
      dirs: !1,
      echo: !1,
      env: !1,
      error: !1,
      exec: !1,
      exit: !1,
      find: !1,
      grep: !1,
      ln: !1,
      ls: !1,
      mkdir: !1,
      mv: !1,
      popd: !1,
      pushd: !1,
      pwd: !1,
      rm: !1,
      sed: !1,
      set: !1,
      target: !1,
      tempdir: !1,
      test: !1,
      touch: !1,
      which: !1
    },
    prototypejs: {
      $: !1,
      $$: !1,
      $A: !1,
      $break: !1,
      $continue: !1,
      $F: !1,
      $H: !1,
      $R: !1,
      $w: !1,
      Abstract: !1,
      Ajax: !1,
      Autocompleter: !1,
      Builder: !1,
      Class: !1,
      Control: !1,
      Draggable: !1,
      Draggables: !1,
      Droppables: !1,
      Effect: !1,
      Element: !1,
      Enumerable: !1,
      Event: !1,
      Field: !1,
      Form: !1,
      Hash: !1,
      Insertion: !1,
      ObjectRange: !1,
      PeriodicalExecuter: !1,
      Position: !1,
      Prototype: !1,
      Scriptaculous: !1,
      Selector: !1,
      Sortable: !1,
      SortableObserver: !1,
      Sound: !1,
      Template: !1,
      Toggle: !1,
      Try: !1
    },
    meteor: {
      _: !1,
      $: !1,
      Accounts: !1,
      AccountsClient: !1,
      AccountsCommon: !1,
      AccountsServer: !1,
      App: !1,
      Assets: !1,
      Blaze: !1,
      check: !1,
      Cordova: !1,
      DDP: !1,
      DDPRateLimiter: !1,
      DDPServer: !1,
      Deps: !1,
      EJSON: !1,
      Email: !1,
      HTTP: !1,
      Log: !1,
      Match: !1,
      Meteor: !1,
      Mongo: !1,
      MongoInternals: !1,
      Npm: !1,
      Package: !1,
      Plugin: !1,
      process: !1,
      Random: !1,
      ReactiveDict: !1,
      ReactiveVar: !1,
      Router: !1,
      ServiceConfiguration: !1,
      Session: !1,
      share: !1,
      Spacebars: !1,
      Template: !1,
      Tinytest: !1,
      Tracker: !1,
      UI: !1,
      Utils: !1,
      WebApp: !1,
      WebAppInternals: !1
    },
    mongo: {
      _isWindows: !1,
      _rand: !1,
      BulkWriteResult: !1,
      cat: !1,
      cd: !1,
      connect: !1,
      db: !1,
      getHostName: !1,
      getMemInfo: !1,
      hostname: !1,
      ISODate: !1,
      listFiles: !1,
      load: !1,
      ls: !1,
      md5sumFile: !1,
      mkdir: !1,
      Mongo: !1,
      NumberInt: !1,
      NumberLong: !1,
      ObjectId: !1,
      PlanCache: !1,
      print: !1,
      printjson: !1,
      pwd: !1,
      quit: !1,
      removeFile: !1,
      rs: !1,
      sh: !1,
      UUID: !1,
      version: !1,
      WriteResult: !1
    },
    applescript: {
      $: !1,
      Application: !1,
      Automation: !1,
      console: !1,
      delay: !1,
      Library: !1,
      ObjC: !1,
      ObjectSpecifier: !1,
      Path: !1,
      Progress: !1,
      Ref: !1
    },
    serviceworker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      clearInterval: !1,
      clearTimeout: !1,
      Client: !1,
      clients: !1,
      Clients: !1,
      close: !0,
      console: !1,
      ExtendableEvent: !1,
      ExtendableMessageEvent: !1,
      fetch: !1,
      FetchEvent: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !1,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onfetch: !0,
      oninstall: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onmessageerror: !0,
      onnotificationclick: !0,
      onnotificationclose: !0,
      onoffline: !0,
      ononline: !0,
      onpush: !0,
      onpushsubscriptionchange: !0,
      onrejectionhandled: !0,
      onsync: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      registration: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerGlobalScope: !1,
      ServiceWorkerMessageEvent: !1,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      skipWaiting: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      WindowClient: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    atomtest: {
      advanceClock: !1,
      fakeClearInterval: !1,
      fakeClearTimeout: !1,
      fakeSetInterval: !1,
      fakeSetTimeout: !1,
      resetTimeouts: !1,
      waitsForPromise: !1
    },
    embertest: {
      andThen: !1,
      click: !1,
      currentPath: !1,
      currentRouteName: !1,
      currentURL: !1,
      fillIn: !1,
      find: !1,
      findAll: !1,
      findWithAssert: !1,
      keyEvent: !1,
      pauseTest: !1,
      resumeTest: !1,
      triggerEvent: !1,
      visit: !1,
      wait: !1
    },
    protractor: {
      $: !1,
      $$: !1,
      browser: !1,
      by: !1,
      By: !1,
      DartObject: !1,
      element: !1,
      protractor: !1
    },
    "shared-node-browser": {
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      setInterval: !1,
      setTimeout: !1,
      URL: !1,
      URLSearchParams: !1
    },
    webextensions: {
      browser: !1,
      chrome: !1,
      opr: !1
    },
    greasemonkey: {
      cloneInto: !1,
      createObjectIn: !1,
      exportFunction: !1,
      GM: !1,
      GM_addStyle: !1,
      GM_deleteValue: !1,
      GM_getResourceText: !1,
      GM_getResourceURL: !1,
      GM_getValue: !1,
      GM_info: !1,
      GM_listValues: !1,
      GM_log: !1,
      GM_openInTab: !1,
      GM_registerMenuCommand: !1,
      GM_setClipboard: !1,
      GM_setValue: !1,
      GM_xmlhttpRequest: !1,
      unsafeWindow: !1
    },
    devtools: {
      $: !1,
      $_: !1,
      $$: !1,
      $0: !1,
      $1: !1,
      $2: !1,
      $3: !1,
      $4: !1,
      $x: !1,
      chrome: !1,
      clear: !1,
      copy: !1,
      debug: !1,
      dir: !1,
      dirxml: !1,
      getEventListeners: !1,
      inspect: !1,
      keys: !1,
      monitor: !1,
      monitorEvents: !1,
      profile: !1,
      profileEnd: !1,
      queryObjects: !1,
      table: !1,
      undebug: !1,
      unmonitor: !1,
      unmonitorEvents: !1,
      values: !1
    }
  };
});

// ../node_modules/@babel/traverse/node_modules/globals/index.js
var OP = w((T5e, NP) => {
  "use strict";
  NP.exports = wP();
});

// ../node_modules/@babel/traverse/lib/scope/index.js
var Zh = w((nu) => {
  "use strict";
  Object.defineProperty(nu, "__esModule", {
    value: !0
  });
  nu.default = void 0;
  var Fz = CP(), jz = ji(), Rz = IP(), Uz = OP(), UP = Ce(), qz = UP, kP = Mi(), Vz = Ma(), {
    NOT_LOCAL_BINDING: DP,
    callExpression: _P,
    cloneNode: LP,
    getBindingIdentifiers: Kz,
    identifier: gn,
    isArrayExpression: MP,
    isBinary: Wz,
    isCallExpression: BP,
    isClass: Yz,
    isClassBody: Jz,
    isClassDeclaration: Xz,
    isExportAllDeclaration: qP,
    isExportDefaultDeclaration: $z,
    isExportNamedDeclaration: zh,
    isFunctionDeclaration: Hz,
    isIdentifier: Fi,
    isImportDeclaration: Gh,
    isLiteral: zz,
    isMemberExpression: Gz,
    isMethod: Qz,
    isModuleSpecifier: Zz,
    isNullLiteral: eG,
    isObjectExpression: tG,
    isProperty: rG,
    isPureish: sG,
    isRegExpLiteral: iG,
    isSuper: nG,
    isTaggedTemplateExpression: aG,
    isTemplateLiteral: VP,
    isThisExpression: FP,
    isUnaryExpression: oG,
    isVariableDeclaration: lG,
    matchesPattern: jP,
    memberExpression: Qh,
    numericLiteral: uG,
    toIdentifier: cG,
    variableDeclaration: pG,
    variableDeclarator: fG,
    isRecordExpression: hG,
    isTupleExpression: dG,
    isObjectProperty: mG,
    isTopicReference: RP,
    isMetaProperty: yG,
    isPrivateName: TG,
    isExportDeclaration: bG,
    buildUndefinedNode: xG
  } = UP;
  function It(t, e) {
    switch (t?.type) {
      default:
        if (Gh(t) || bG(t)) {
          var r;
          if ((qP(t) || zh(t) || Gh(t)) && t.source)
            It(t.source, e);
          else if ((zh(t) || Gh(t)) && (r = t.specifiers) != null && r.length)
            for (let s of t.specifiers) It(s, e);
          else ($z(t) || zh(t)) && t.declaration && It(t.declaration, e);
        } else Zz(t) ? It(t.local, e) : zz(t) && !eG(t) && !iG(t) && !VP(t) && e.push(t.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        It(t.object, e), It(t.property, e);
        break;
      case "Identifier":
      case "JSXIdentifier":
        e.push(t.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        It(t.callee, e);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (let s of t.properties)
          It(s, e);
        break;
      case "SpreadElement":
      case "RestElement":
        It(t.argument, e);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        It(t.key, e);
        break;
      case "ThisExpression":
        e.push("this");
        break;
      case "Super":
        e.push("super");
        break;
      case "Import":
        e.push("import");
        break;
      case "DoExpression":
        e.push("do");
        break;
      case "YieldExpression":
        e.push("yield"), It(t.argument, e);
        break;
      case "AwaitExpression":
        e.push("await"), It(t.argument, e);
        break;
      case "AssignmentExpression":
        It(t.left, e);
        break;
      case "VariableDeclarator":
        It(t.id, e);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        It(t.id, e);
        break;
      case "PrivateName":
        It(t.id, e);
        break;
      case "ParenthesizedExpression":
        It(t.expression, e);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        It(t.argument, e);
        break;
      case "MetaProperty":
        It(t.meta, e), It(t.property, e);
        break;
      case "JSXElement":
        It(t.openingElement, e);
        break;
      case "JSXOpeningElement":
        It(t.name, e);
        break;
      case "JSXFragment":
        It(t.openingFragment, e);
        break;
      case "JSXOpeningFragment":
        e.push("Fragment");
        break;
      case "JSXNamespacedName":
        It(t.namespace, e), It(t.name, e);
        break;
    }
  }
  n(It, "gatherNodeParts");
  var iu = {
    ForStatement(t) {
      let e = t.get("init");
      if (e.isVar()) {
        let {
          scope: r
        } = t;
        (r.getFunctionParent() || r.getProgramParent()).registerBinding("var", e);
      }
    },
    Declaration(t) {
      if (t.isBlockScoped() || t.isImportDeclaration() || t.isExportDeclaration()) return;
      (t.scope.getFunctionParent() || t.scope.getProgramParent()).registerDeclaration(t);
    },
    ImportDeclaration(t) {
      t.scope.getBlockParent().registerDeclaration(t);
    },
    ReferencedIdentifier(t, e) {
      e.references.push(t);
    },
    ForXStatement(t, e) {
      let r = t.get("left");
      if (r.isPattern() || r.isIdentifier())
        e.constantViolations.push(t);
      else if (r.isVar()) {
        let {
          scope: s
        } = t;
        (s.getFunctionParent() || s.getProgramParent()).registerBinding("var", r);
      }
    },
    ExportDeclaration: {
      exit(t) {
        let {
          node: e,
          scope: r
        } = t;
        if (qP(e)) return;
        let s = e.declaration;
        if (Xz(s) || Hz(s)) {
          let i = s.id;
          if (!i) return;
          let a = r.getBinding(i.name);
          a?.reference(t);
        } else if (lG(s))
          for (let i of s.declarations)
            for (let a of Object.keys(Kz(i))) {
              let o = r.getBinding(a);
              o?.reference(t);
            }
      }
    },
    LabeledStatement(t) {
      t.scope.getBlockParent().registerDeclaration(t);
    },
    AssignmentExpression(t, e) {
      e.assignments.push(t);
    },
    UpdateExpression(t, e) {
      e.constantViolations.push(t);
    },
    UnaryExpression(t, e) {
      t.node.operator === "delete" && e.constantViolations.push(t);
    },
    BlockScoped(t) {
      let e = t.scope;
      if (e.path === t && (e = e.parent), e.getBlockParent().registerDeclaration(t), t.isClassDeclaration() && t.node.id) {
        let i = t.node.id.name;
        t.scope.bindings[i] = t.scope.parent.getBinding(i);
      }
    },
    CatchClause(t) {
      t.scope.registerBinding("let", t);
    },
    Function(t) {
      let e = t.get("params");
      for (let r of e)
        t.scope.registerBinding("param", r);
      t.isFunctionExpression() && t.has("id") && !t.get("id").node[DP] && t.scope.registerBinding("local", t.get("id"), t);
    },
    ClassExpression(t) {
      t.has("id") && !t.get("id").node[DP] && t.scope.registerBinding("local", t);
    }
  }, SG = 0, Ba = class t {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references =
      void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      let {
        node: r
      } = e, s = kP.scope.get(r);
      if (s?.path === e)
        return s;
      kP.scope.set(r, this), this.uid = SG++, this.block = r, this.path = e, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
    }
    get parent() {
      var e;
      let r, s = this.path;
      do {
        let i = s.key === "key" || s.listKey === "decorators";
        s = s.parentPath, i && s.isMethod() && (s = s.parentPath), s && s.isScope() && (r = s);
      } while (s && !r);
      return (e = r) == null ? void 0 : e.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(e, r, s) {
      (0, jz.default)(e, r, this, s, this.path);
    }
    generateDeclaredUidIdentifier(e) {
      let r = this.generateUidIdentifier(e);
      return this.push({
        id: r
      }), LP(r);
    }
    generateUidIdentifier(e) {
      return gn(this.generateUid(e));
    }
    generateUid(e = "temp") {
      e = cG(e).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let r, s = 1;
      do
        r = this._generateUid(e, s), s++;
      while (this.hasLabel(r) || this.hasBinding(r) || this.hasGlobal(r) || this.hasReference(r));
      let i = this.getProgramParent();
      return i.references[r] = !0, i.uids[r] = !0, r;
    }
    _generateUid(e, r) {
      let s = e;
      return r > 1 && (s += r), `_${s}`;
    }
    generateUidBasedOnNode(e, r) {
      let s = [];
      It(e, s);
      let i = s.join("$");
      return i = i.replace(/^_/, "") || r || "ref", this.generateUid(i.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(e, r) {
      return gn(this.generateUidBasedOnNode(e, r));
    }
    isStatic(e) {
      if (FP(e) || nG(e) || RP(e))
        return !0;
      if (Fi(e)) {
        let r = this.getBinding(e.name);
        return r ? r.constant : this.hasBinding(e.name);
      }
      return !1;
    }
    maybeGenerateMemoised(e, r) {
      if (this.isStatic(e))
        return null;
      {
        let s = this.generateUidIdentifierBasedOnNode(e);
        return r ? s : (this.push({
          id: s
        }), LP(s));
      }
    }
    checkBlockScopedCollisions(e, r, s, i) {
      if (r === "param" || e.kind === "local") return;
      if (r === "let" || e.kind === "let" || e.kind === "const" || e.kind === "module" || e.kind === "param" && r === "const")
        throw this.hub.buildError(i, `Duplicate declaration "${s}"`, TypeError);
    }
    rename(e, r) {
      let s = this.getBinding(e);
      s && (r || (r = this.generateUidIdentifier(e).name), new Fz.default(s, e, r).rename(arguments[2]));
    }
    _renameFromMap(e, r, s, i) {
      e[r] && (e[s] = i, e[r] = null);
    }
    dump() {
      let e = "-".repeat(60);
      console.log(e);
      let r = this;
      do {
        console.log("#", r.block.type);
        for (let s of Object.keys(r.bindings)) {
          let i = r.bindings[s];
          console.log(" -", s, {
            constant: i.constant,
            references: i.references,
            violations: i.constantViolations.length,
            kind: i.kind
          });
        }
      } while (r = r.parent);
      console.log(e);
    }
    toArray(e, r, s) {
      if (Fi(e)) {
        let o = this.getBinding(e.name);
        if (o != null && o.constant && o.path.isGenericType("Array"))
          return e;
      }
      if (MP(e))
        return e;
      if (Fi(e, {
        name: "arguments"
      }))
        return _P(Qh(Qh(Qh(gn("Array"), gn("prototype")), gn("slice")), gn("call")), [e]);
      let i, a = [e];
      return r === !0 ? i = "toConsumableArray" : typeof r == "number" ? (a.push(uG(r)), i = "slicedToArray") : i = "toArray", s && (a.unshift(
      this.hub.addHelper(i)), i = "maybeArrayLike"), _P(this.hub.addHelper(i), a);
    }
    hasLabel(e) {
      return !!this.getLabel(e);
    }
    getLabel(e) {
      return this.labels.get(e);
    }
    registerLabel(e) {
      this.labels.set(e.node.label.name, e);
    }
    registerDeclaration(e) {
      if (e.isLabeledStatement())
        this.registerLabel(e);
      else if (e.isFunctionDeclaration())
        this.registerBinding("hoisted", e.get("id"), e);
      else if (e.isVariableDeclaration()) {
        let r = e.get("declarations"), {
          kind: s
        } = e.node;
        for (let i of r)
          this.registerBinding(s === "using" || s === "await using" ? "const" : s, i);
      } else if (e.isClassDeclaration()) {
        if (e.node.declare) return;
        this.registerBinding("let", e);
      } else if (e.isImportDeclaration()) {
        let r = e.node.importKind === "type" || e.node.importKind === "typeof", s = e.get("specifiers");
        for (let i of s) {
          let a = r || i.isImportSpecifier() && (i.node.importKind === "type" || i.node.importKind === "typeof");
          this.registerBinding(a ? "unknown" : "module", i);
        }
      } else if (e.isExportDeclaration()) {
        let r = e.get("declaration");
        (r.isClassDeclaration() || r.isFunctionDeclaration() || r.isVariableDeclaration()) && this.registerDeclaration(r);
      } else
        this.registerBinding("unknown", e);
    }
    buildUndefinedNode() {
      return xG();
    }
    registerConstantViolation(e) {
      let r = e.getBindingIdentifiers();
      for (let i of Object.keys(r)) {
        var s;
        (s = this.getBinding(i)) == null || s.reassign(e);
      }
    }
    registerBinding(e, r, s = r) {
      if (!e) throw new ReferenceError("no `kind`");
      if (r.isVariableDeclaration()) {
        let o = r.get("declarations");
        for (let l of o)
          this.registerBinding(e, l);
        return;
      }
      let i = this.getProgramParent(), a = r.getOuterBindingIdentifiers(!0);
      for (let o of Object.keys(a)) {
        i.references[o] = !0;
        for (let l of a[o]) {
          let u = this.getOwnBinding(o);
          if (u) {
            if (u.identifier === l) continue;
            this.checkBlockScopedCollisions(u, e, o, l);
          }
          u ? this.registerConstantViolation(s) : this.bindings[o] = new Rz.default({
            identifier: l,
            scope: this,
            path: s,
            kind: e
          });
        }
      }
    }
    addGlobal(e) {
      this.globals[e.name] = e;
    }
    hasUid(e) {
      let r = this;
      do
        if (r.uids[e]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasGlobal(e) {
      let r = this;
      do
        if (r.globals[e]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasReference(e) {
      return !!this.getProgramParent().references[e];
    }
    isPure(e, r) {
      if (Fi(e)) {
        let o = this.getBinding(e.name);
        return o ? r ? o.constant : !0 : !1;
      } else {
        if (FP(e) || yG(e) || RP(e) || TG(e))
          return !0;
        if (Yz(e)) {
          var s;
          return e.superClass && !this.isPure(e.superClass, r) || ((s = e.decorators) == null ? void 0 : s.length) > 0 ? !1 : this.isPure(e.
          body, r);
        } else if (Jz(e)) {
          for (let o of e.body)
            if (!this.isPure(o, r)) return !1;
          return !0;
        } else {
          if (Wz(e))
            return this.isPure(e.left, r) && this.isPure(e.right, r);
          if (MP(e) || dG(e)) {
            for (let o of e.elements)
              if (o !== null && !this.isPure(o, r)) return !1;
            return !0;
          } else if (tG(e) || hG(e)) {
            for (let o of e.properties)
              if (!this.isPure(o, r)) return !1;
            return !0;
          } else if (Qz(e)) {
            var i;
            return !(e.computed && !this.isPure(e.key, r) || ((i = e.decorators) == null ? void 0 : i.length) > 0);
          } else if (rG(e)) {
            var a;
            return !(e.computed && !this.isPure(e.key, r) || ((a = e.decorators) == null ? void 0 : a.length) > 0 || (mG(e) || e.static) && e.
            value !== null && !this.isPure(e.value, r));
          } else {
            if (oG(e))
              return this.isPure(e.argument, r);
            if (VP(e)) {
              for (let o of e.expressions)
                if (!this.isPure(o, r)) return !1;
              return !0;
            } else return aG(e) ? jP(e.tag, "String.raw") && !this.hasBinding("String", {
              noGlobals: !0
            }) && this.isPure(e.quasi, r) : Gz(e) ? !e.computed && Fi(e.object) && e.object.name === "Symbol" && Fi(e.property) && e.property.
            name !== "for" && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) : BP(e) ? jP(e.callee, "Symbol.for") && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) && e.arguments.length === 1 && qz.isStringLiteral(e.arguments[0]) : sG(e);
          }
        }
      }
    }
    setData(e, r) {
      return this.data[e] = r;
    }
    getData(e) {
      let r = this;
      do {
        let s = r.data[e];
        if (s != null) return s;
      } while (r = r.parent);
    }
    removeData(e) {
      let r = this;
      do
        r.data[e] != null && (r.data[e] = null);
      while (r = r.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      let e = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.
      create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      let r = this.getProgramParent();
      if (r.crawling) return;
      let s = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, e.type !== "Program" && (0, Vz.isExplodedVisitor)(iu)) {
        for (let a of iu.enter)
          a.call(s, e, s);
        let i = iu[e.type];
        if (i)
          for (let a of i.enter)
            a.call(s, e, s);
      }
      e.traverse(iu, s), this.crawling = !1;
      for (let i of s.assignments) {
        let a = i.getBindingIdentifiers();
        for (let o of Object.keys(a))
          i.scope.getBinding(o) || r.addGlobal(a[o]);
        i.scope.registerConstantViolation(i);
      }
      for (let i of s.references) {
        let a = i.scope.getBinding(i.node.name);
        a ? a.reference(i) : r.addGlobal(i.node);
      }
      for (let i of s.constantViolations)
        i.scope.registerConstantViolation(i);
    }
    push(e) {
      let r = this.path;
      r.isPattern() ? r = this.getPatternParent().path : !r.isBlockStatement() && !r.isProgram() && (r = this.getBlockParent().path), r.isSwitchStatement() &&
      (r = (this.getFunctionParent() || this.getProgramParent()).path);
      let {
        init: s,
        unique: i,
        kind: a = "var",
        id: o
      } = e;
      if (!s && !i && (a === "var" || a === "let") && r.isFunction() && !r.node.name && BP(r.parent, {
        callee: r.node
      }) && r.parent.arguments.length <= r.node.params.length && Fi(o)) {
        r.pushContainer("params", o), r.scope.registerBinding("param", r.get("params")[r.node.params.length - 1]);
        return;
      }
      (r.isLoop() || r.isCatchClause() || r.isFunction()) && (r.ensureBlock(), r = r.get("body"));
      let l = e._blockHoist == null ? 2 : e._blockHoist, u = `declaration:${a}:${l}`, c = !i && r.getData(u);
      if (!c) {
        let m = pG(a, []);
        m._blockHoist = l, [c] = r.unshiftContainer("body", [m]), i || r.setData(u, c);
      }
      let p = fG(o, s), f = c.node.declarations.push(p);
      r.scope.registerBinding(a, c.get("declarations")[f - 1]);
    }
    getProgramParent() {
      let e = this;
      do
        if (e.path.isProgram())
          return e;
      while (e = e.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let e = this;
      do
        if (e.path.isFunctionParent())
          return e;
      while (e = e.parent);
      return null;
    }
    getBlockParent() {
      let e = this;
      do
        if (e.path.isBlockParent())
          return e;
      while (e = e.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let e = this;
      do
        if (!e.path.isPattern())
          return e.getBlockParent();
      while (e = e.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      let e = /* @__PURE__ */ Object.create(null), r = this;
      do {
        for (let s of Object.keys(r.bindings))
          s in e || (e[s] = r.bindings[s]);
        r = r.parent;
      } while (r);
      return e;
    }
    getAllBindingsOfKind(...e) {
      let r = /* @__PURE__ */ Object.create(null);
      for (let s of e) {
        let i = this;
        do {
          for (let a of Object.keys(i.bindings)) {
            let o = i.bindings[a];
            o.kind === s && (r[a] = o);
          }
          i = i.parent;
        } while (i);
      }
      return r;
    }
    bindingIdentifierEquals(e, r) {
      return this.getBindingIdentifier(e) === r;
    }
    getBinding(e) {
      let r = this, s;
      do {
        let a = r.getOwnBinding(e);
        if (a) {
          var i;
          if (!((i = s) != null && i.isPattern() && a.kind !== "param" && a.kind !== "local"))
            return a;
        } else if (!a && e === "arguments" && r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
        s = r.path;
      } while (r = r.parent);
    }
    getOwnBinding(e) {
      return this.bindings[e];
    }
    getBindingIdentifier(e) {
      var r;
      return (r = this.getBinding(e)) == null ? void 0 : r.identifier;
    }
    getOwnBindingIdentifier(e) {
      let r = this.bindings[e];
      return r?.identifier;
    }
    hasOwnBinding(e) {
      return !!this.getOwnBinding(e);
    }
    hasBinding(e, r) {
      var s, i, a;
      return e ? !!(this.hasOwnBinding(e) || (typeof r == "boolean" && (r = {
        noGlobals: r
      }), this.parentHasBinding(e, r)) || !((s = r) != null && s.noUids) && this.hasUid(e) || !((i = r) != null && i.noGlobals) && t.globals.
      includes(e) || !((a = r) != null && a.noGlobals) && t.contextVariables.includes(e)) : !1;
    }
    parentHasBinding(e, r) {
      var s;
      return (s = this.parent) == null ? void 0 : s.hasBinding(e, r);
    }
    moveBindingTo(e, r) {
      let s = this.getBinding(e);
      s && (s.scope.removeOwnBinding(e), s.scope = r, r.bindings[e] = s);
    }
    removeOwnBinding(e) {
      delete this.bindings[e];
    }
    removeBinding(e) {
      var r;
      (r = this.getBinding(e)) == null || r.scope.removeOwnBinding(e);
      let s = this;
      do
        s.uids[e] && (s.uids[e] = !1);
      while (s = s.parent);
    }
  };
  nu.default = Ba;
  Ba.globals = Object.keys(Uz.builtin);
  Ba.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/source-map.js
var KP = w((au) => {
  "use strict";
  Object.defineProperty(au, "__esModule", {
    value: !0
  });
  au.default = void 0;
  var Qs = uh(), ed = Fl(), td = class {
    static {
      n(this, "SourceMap");
    }
    constructor(e, r) {
      var s;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let i = this._map = new Qs.GenMapping({
        sourceRoot: e.sourceRoot
      });
      if (this._sourceFileName = (s = e.sourceFileName) == null ? void 0 : s.replace(/\\/g, "/"), this._rawMappings = void 0, e.inputSourceMap) {
        this._inputMap = new ed.TraceMap(e.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, Qs.setSourceContent)(i, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof r == "string" && !e.inputSourceMap)
        (0, Qs.setSourceContent)(i, this._sourceFileName, r);
      else if (typeof r == "object")
        for (let o of Object.keys(r))
          (0, Qs.setSourceContent)(i, o.replace(/\\/g, "/"), r[o]);
    }
    get() {
      return (0, Qs.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, Qs.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, Qs.allMappings)(this._map));
    }
    mark(e, r, s, i, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (r != null)
        if (this._inputMap) {
          if (u = (0, ed.originalPositionFor)(this._inputMap, {
            line: r,
            column: s
          }), !u.name && a) {
            let c = (0, ed.originalPositionFor)(this._inputMap, a);
            c.name && (i = c.name);
          }
        } else
          u = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: r,
            column: s
          };
      (0, Qs.maybeAddMapping)(this._map, {
        name: i,
        generated: e,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  au.default = td;
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/buffer.js
var WP = w((ou) => {
  "use strict";
  Object.defineProperty(ou, "__esModule", {
    value: !0
  });
  ou.default = void 0;
  var rd = class {
    static {
      n(this, "Buffer");
    }
    constructor(e, r) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = e, this._indentChar = r;
      for (let s = 0; s < 64; s++)
        this._fastIndentations.push(r.repeat(s));
      this._allocQueue();
    }
    _allocQueue() {
      let e = this._queue;
      for (let r = 0; r < 16; r++)
        e.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(e, r, s, i, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = e, l.repeat = r, l.line = s, l.column = i, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let e = this._map, r = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: e?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let s = e ? e.get() : null;
          return r.map = s, s;
        },
        set map(s) {
          Object.defineProperty(r, "map", {
            value: s,
            writable: !0
          });
        },
        get rawMappings() {
          let s = e?.getRawMappings();
          return r.rawMappings = s, s;
        },
        set rawMappings(s) {
          Object.defineProperty(r, "rawMappings", {
            value: s,
            writable: !0
          });
        }
      };
      return r;
    }
    append(e, r) {
      this._flush(), this._append(e, this._sourcePosition, r);
    }
    appendChar(e) {
      this._flush(), this._appendChar(e, 1, this._sourcePosition);
    }
    queue(e) {
      if (e === 10)
        for (; this._queueCursor !== 0; ) {
          let s = this._queue[this._queueCursor - 1].char;
          if (s !== 32 && s !== 9)
            break;
          this._queueCursor--;
        }
      let r = this._sourcePosition;
      this._pushQueue(e, 1, r.line, r.column, r.filename);
    }
    queueIndentation(e) {
      e !== 0 && this._pushQueue(-1, e, void 0, void 0, void 0);
    }
    _flush() {
      let e = this._queueCursor, r = this._queue;
      for (let s = 0; s < e; s++) {
        let i = r[s];
        this._appendChar(i.char, i.repeat, i);
      }
      this._queueCursor = 0;
    }
    _appendChar(e, r, s) {
      if (this._last = e, e === -1) {
        let i = this._fastIndentations[r];
        i !== void 0 ? this._str += i : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
      } else
        this._str += r > 1 ? String.fromCharCode(e).repeat(r) : String.fromCharCode(e);
      e !== 10 ? (this._mark(s.line, s.column, s.identifierName, s.identifierNamePos, s.filename), this._position.column += r) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (s.identifierName = void 0, s.identifierNamePos = void 0);
    }
    _append(e, r, s) {
      let i = e.length, a = this._position;
      if (this._last = e.charCodeAt(i - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = e, this._appendCount =
      0) : this._str += e, !s && !this._map) {
        a.column += i;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: c
      } = r, p = r.line;
      (l != null || u != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
      let f = e.indexOf(`
`), m = 0;
      for (f !== 0 && this._mark(p, o, l, u, c); f !== -1; )
        a.line++, a.column = 0, m = f + 1, m < i && p !== void 0 && this._mark(++p, 0, null, null, c), f = e.indexOf(`
`, m);
      a.column += i - m;
    }
    _mark(e, r, s, i, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, e, r, s, i, a);
    }
    removeTrailingNewline() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let e = this._queueCursor;
      return e !== 0 ? this._queue[e - 1].char : this._last;
    }
    getNewlineCount() {
      let e = this._queueCursor, r = 0;
      if (e === 0) return this._last === 10 ? 1 : 0;
      for (let s = e - 1; s >= 0 && this._queue[s].char === 10; s--)
        r++;
      return r === e && this._last === 10 ? r + 1 : r;
    }
    endsWithCharAndNewline() {
      let e = this._queue, r = this._queueCursor;
      if (r !== 0)
        return e[r - 1].char !== 10 ? void 0 : r > 1 ? e[r - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(e, r) {
      if (!this._map) {
        r();
        return;
      }
      this.source("start", e);
      let s = e.identifierName, i = this._sourcePosition;
      s && (this._canMarkIdName = !1, i.identifierName = s), r(), s && (this._canMarkIdName = !0, i.identifierName = void 0, i.identifierNamePos =
      void 0), this.source("end", e);
    }
    source(e, r) {
      this._map && this._normalizePosition(e, r, 0);
    }
    sourceWithOffset(e, r, s) {
      this._map && this._normalizePosition(e, r, s);
    }
    withSource(e, r, s) {
      this._map && this.source(e, r), s();
    }
    _normalizePosition(e, r, s) {
      let i = r[e], a = this._sourcePosition;
      i && (a.line = i.line, a.column = Math.max(i.column + s, 0), a.filename = r.filename);
    }
    getCurrentColumn() {
      let e = this._queue, r = this._queueCursor, s = -1, i = 0;
      for (let a = 0; a < r; a++) {
        let o = e[a];
        o.char === 10 && (s = i), i += o.repeat;
      }
      return s === -1 ? this._position.column + i : i - 1 - s;
    }
    getCurrentLine() {
      let e = 0, r = this._queue;
      for (let s = 0; s < this._queueCursor; s++)
        r[s].char === 10 && e++;
      return this._position.line + e;
    }
  };
  ou.default = rd;
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/node/whitespace.js
var HP = w((uu) => {
  "use strict";
  Object.defineProperty(uu, "__esModule", {
    value: !0
  });
  uu.nodes = void 0;
  var gG = Ce(), {
    FLIPPED_ALIAS_KEYS: PG,
    isArrayExpression: EG,
    isAssignmentExpression: JP,
    isBinary: XP,
    isBlockStatement: AG,
    isCallExpression: $P,
    isFunction: Fa,
    isIdentifier: lu,
    isLiteral: vG,
    isMemberExpression: sd,
    isObjectExpression: CG,
    isOptionalCallExpression: IG,
    isOptionalMemberExpression: wG,
    isStringLiteral: NG
  } = gG;
  function Pn(t, e) {
    return t && (sd(t) || wG(t) ? (Pn(t.object, e), t.computed && Pn(t.property, e)) : XP(t) || JP(t) ? (Pn(t.left, e), Pn(t.right, e)) : $P(
    t) || IG(t) ? (e.hasCall = !0, Pn(t.callee, e)) : Fa(t) ? e.hasFunction = !0 : lu(t) && (e.hasHelper = e.hasHelper || t.callee && Ss(t.callee))),
    e;
  }
  n(Pn, "crawlInternal");
  function YP(t) {
    return Pn(t, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  n(YP, "crawl");
  function Ss(t) {
    return t ? sd(t) ? Ss(t.object) || Ss(t.property) : lu(t) ? t.name === "require" || t.name.charCodeAt(0) === 95 : $P(t) ? Ss(t.callee) :
    XP(t) || JP(t) ? lu(t.left) && Ss(t.left) || Ss(t.right) : !1 : !1;
  }
  n(Ss, "isHelper");
  function OG(t) {
    return vG(t) || CG(t) || EG(t) || lu(t) || sd(t);
  }
  n(OG, "isType");
  var Ri = uu.nodes = {
    AssignmentExpression(t) {
      let e = YP(t.right);
      if (e.hasCall && e.hasHelper || e.hasFunction)
        return e.hasFunction ? 3 : 2;
    },
    SwitchCase(t, e) {
      return (t.consequent.length || e.cases[0] === t ? 1 : 0) | (!t.consequent.length && e.cases[e.cases.length - 1] === t ? 2 : 0);
    },
    LogicalExpression(t) {
      if (Fa(t.left) || Fa(t.right))
        return 2;
    },
    Literal(t) {
      if (NG(t) && t.value === "use strict")
        return 2;
    },
    CallExpression(t) {
      if (Fa(t.callee) || Ss(t))
        return 3;
    },
    OptionalCallExpression(t) {
      if (Fa(t.callee))
        return 3;
    },
    VariableDeclaration(t) {
      for (let e = 0; e < t.declarations.length; e++) {
        let r = t.declarations[e], s = Ss(r.id) && !OG(r.init);
        if (!s && r.init) {
          let i = YP(r.init);
          s = Ss(r.init) && i.hasCall || i.hasFunction;
        }
        if (s)
          return 3;
      }
    },
    IfStatement(t) {
      if (AG(t.consequent))
        return 3;
    }
  };
  Ri.ObjectProperty = Ri.ObjectTypeProperty = Ri.ObjectMethod = function(t, e) {
    if (e.properties[0] === t)
      return 1;
  };
  Ri.ObjectTypeCallProperty = function(t, e) {
    var r;
    if (e.callProperties[0] === t && !((r = e.properties) != null && r.length))
      return 1;
  };
  Ri.ObjectTypeIndexer = function(t, e) {
    var r, s;
    if (e.indexers[0] === t && !((r = e.properties) != null && r.length) && !((s = e.callProperties) != null && s.length))
      return 1;
  };
  Ri.ObjectTypeInternalSlot = function(t, e) {
    var r, s, i;
    if (e.internalSlots[0] === t && !((r = e.properties) != null && r.length) && !((s = e.callProperties) != null && s.length) && !((i = e.indexers) !=
    null && i.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  t, e]) {
    [t].concat(PG[t] || []).forEach(function(r) {
      let s = e ? 3 : 0;
      Ri[r] = () => s;
    });
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/node/parentheses.js
var eE = w((ct) => {
  "use strict";
  Object.defineProperty(ct, "__esModule", {
    value: !0
  });
  ct.ArrowFunctionExpression = nQ;
  ct.AssignmentExpression = oQ;
  ct.Binary = XG;
  ct.BinaryExpression = eQ;
  ct.ClassExpression = sQ;
  ct.ConditionalExpression = id;
  ct.DoExpression = JG;
  ct.FunctionExpression = iQ;
  ct.FunctionTypeAnnotation = KG;
  ct.Identifier = uQ;
  ct.LogicalExpression = lQ;
  ct.NullableTypeAnnotation = VG;
  ct.ObjectExpression = YG;
  ct.OptionalIndexedAccessType = HG;
  ct.OptionalCallExpression = ct.OptionalMemberExpression = aQ;
  ct.SequenceExpression = tQ;
  ct.TSTypeAssertion = ct.TSSatisfiesExpression = ct.TSAsExpression = zG;
  ct.TSInferType = QG;
  ct.TSInstantiationExpression = ZG;
  ct.TSIntersectionType = ct.TSUnionType = GG;
  ct.UnaryLike = ZP;
  ct.IntersectionTypeAnnotation = ct.UnionTypeAnnotation = $G;
  ct.UpdateExpression = WG;
  ct.AwaitExpression = ct.YieldExpression = rQ;
  var kG = Ce(), {
    isArrayTypeAnnotation: DG,
    isArrowFunctionExpression: _G,
    isBinaryExpression: LG,
    isCallExpression: MG,
    isExportDeclaration: BG,
    isForOfStatement: FG,
    isIndexedAccessType: jG,
    isMemberExpression: GP,
    isObjectPattern: RG,
    isOptionalMemberExpression: UG,
    isYieldExpression: qG
  } = kG, zP = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!\
=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function QP(t) {
    return t === "TSAsExpression" || t === "TSSatisfiesExpression" || t === "TSTypeAssertion";
  }
  n(QP, "isTSTypeExpression");
  var cu = /* @__PURE__ */ n((t, e) => {
    let r = e.type;
    return (r === "ClassDeclaration" || r === "ClassExpression") && e.superClass === t;
  }, "isClassExtendsClause"), ja = /* @__PURE__ */ n((t, e) => {
    let r = e.type;
    return (r === "MemberExpression" || r === "OptionalMemberExpression") && e.object === t || (r === "CallExpression" || r === "OptionalCal\
lExpression" || r === "NewExpression") && e.callee === t || r === "TaggedTemplateExpression" && e.tag === t || r === "TSNonNullExpression";
  }, "hasPostfixPart");
  function VG(t, e) {
    return DG(e);
  }
  n(VG, "NullableTypeAnnotation");
  function KG(t, e, r) {
    if (r.length < 3) return;
    let s = e.type;
    return s === "UnionTypeAnnotation" || s === "IntersectionTypeAnnotation" || s === "ArrayTypeAnnotation" || s === "TypeAnnotation" && _G(
    r[r.length - 3]);
  }
  n(KG, "FunctionTypeAnnotation");
  function WG(t, e) {
    return ja(t, e) || cu(t, e);
  }
  n(WG, "UpdateExpression");
  function YG(t, e, r) {
    return Ra(r, 3);
  }
  n(YG, "ObjectExpression");
  function JG(t, e, r) {
    return !t.async && Ra(r, 1);
  }
  n(JG, "DoExpression");
  function XG(t, e) {
    let r = e.type;
    if (t.operator === "**" && r === "BinaryExpression" && e.operator === "**")
      return e.left === t;
    if (cu(t, e) || ja(t, e) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
      return !0;
    if (r === "BinaryExpression" || r === "LogicalExpression") {
      let s = zP.get(e.operator), i = zP.get(t.operator);
      if (s === i && e.right === t && r !== "LogicalExpression" || s > i)
        return !0;
    }
  }
  n(XG, "Binary");
  function $G(t, e) {
    let r = e.type;
    return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
  }
  n($G, "UnionTypeAnnotation");
  function HG(t, e) {
    return jG(e) && e.objectType === t;
  }
  n(HG, "OptionalIndexedAccessType");
  function zG() {
    return !0;
  }
  n(zG, "TSAsExpression");
  function GG(t, e) {
    let r = e.type;
    return r === "TSArrayType" || r === "TSOptionalType" || r === "TSIntersectionType" || r === "TSUnionType" || r === "TSRestType";
  }
  n(GG, "TSUnionType");
  function QG(t, e) {
    let r = e.type;
    return r === "TSArrayType" || r === "TSOptionalType";
  }
  n(QG, "TSInferType");
  function ZG(t, e) {
    let r = e.type;
    return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!e.typeParameters;
  }
  n(ZG, "TSInstantiationExpression");
  function eQ(t, e) {
    if (t.operator === "in") {
      let r = e.type;
      return r === "VariableDeclarator" || r === "ForStatement" || r === "ForInStatement" || r === "ForOfStatement";
    }
    return !1;
  }
  n(eQ, "BinaryExpression");
  function tQ(t, e) {
    let r = e.type;
    return !(r === "ForStatement" || r === "ThrowStatement" || r === "ReturnStatement" || r === "IfStatement" && e.test === t || r === "Whil\
eStatement" && e.test === t || r === "ForInStatement" && e.right === t || r === "SwitchStatement" && e.discriminant === t || r === "Expressi\
onStatement" && e.expression === t);
  }
  n(tQ, "SequenceExpression");
  function rQ(t, e) {
    let r = e.type;
    return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || ja(t, e) || r === "A\
waitExpression" && qG(t) || r === "ConditionalExpression" && t === e.test || cu(t, e);
  }
  n(rQ, "YieldExpression");
  function sQ(t, e, r) {
    return Ra(r, 5);
  }
  n(sQ, "ClassExpression");
  function ZP(t, e) {
    return ja(t, e) || LG(e) && e.operator === "**" && e.left === t || cu(t, e);
  }
  n(ZP, "UnaryLike");
  function iQ(t, e, r) {
    return Ra(r, 5);
  }
  n(iQ, "FunctionExpression");
  function nQ(t, e) {
    return BG(e) || id(t, e);
  }
  n(nQ, "ArrowFunctionExpression");
  function id(t, e) {
    let r = e.type;
    return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalEx\
pression" && e.test === t || r === "AwaitExpression" || QP(r) ? !0 : ZP(t, e);
  }
  n(id, "ConditionalExpression");
  function aQ(t, e) {
    return MG(e) && e.callee === t || GP(e) && e.object === t;
  }
  n(aQ, "OptionalMemberExpression");
  function oQ(t, e) {
    return RG(t.left) ? !0 : id(t, e);
  }
  n(oQ, "AssignmentExpression");
  function lQ(t, e) {
    let r = e.type;
    if (QP(r)) return !0;
    if (r !== "LogicalExpression") return !1;
    switch (t.operator) {
      case "||":
        return e.operator === "??" || e.operator === "&&";
      case "&&":
        return e.operator === "??";
      case "??":
        return e.operator !== "??";
    }
  }
  n(lQ, "LogicalExpression");
  function uQ(t, e, r) {
    var s;
    let i = e.type;
    if ((s = t.extra) != null && s.parenthesized && i === "AssignmentExpression" && e.left === t) {
      let a = e.right.type;
      if ((a === "FunctionExpression" || a === "ClassExpression") && e.right.id == null)
        return !0;
    }
    if (t.name === "let") {
      let a = GP(e, {
        object: t,
        computed: !0
      }) || UG(e, {
        object: t,
        computed: !0,
        optional: !1
      });
      return Ra(r, a ? 57 : 32);
    }
    return t.name === "async" && FG(e) && t === e.left;
  }
  n(uQ, "Identifier");
  function Ra(t, e) {
    let r = e & 1, s = e & 2, i = e & 4, a = e & 8, o = e & 16, l = e & 32, u = t.length - 1;
    if (u <= 0) return;
    let c = t[u];
    u--;
    let p = t[u];
    for (; u >= 0; ) {
      let f = p.type;
      if (r && f === "ExpressionStatement" && p.expression === c || i && f === "ExportDefaultDeclaration" && c === p.declaration || s && f ===
      "ArrowFunctionExpression" && p.body === c || a && f === "ForStatement" && p.init === c || o && f === "ForInStatement" && p.left === c ||
      l && f === "ForOfStatement" && p.left === c)
        return !0;
      if (u > 0 && (ja(c, p) && f !== "NewExpression" || f === "SequenceExpression" && p.expressions[0] === c || f === "UpdateExpression" &&
      !p.prefix || f === "ConditionalExpression" && p.test === c || (f === "BinaryExpression" || f === "LogicalExpression") && p.left === c ||
      f === "AssignmentExpression" && p.left === c))
        c = p, u--, p = t[u];
      else
        return !1;
    }
    return !1;
  }
  n(Ra, "isFirstInContext");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/node/index.js
var ad = w((En) => {
  "use strict";
  Object.defineProperty(En, "__esModule", {
    value: !0
  });
  En.needsParens = PQ;
  En.needsWhitespace = nd;
  En.needsWhitespaceAfter = gQ;
  En.needsWhitespaceBefore = SQ;
  var cQ = HP(), pQ = eE(), fQ = Ce(), {
    FLIPPED_ALIAS_KEYS: hQ,
    isCallExpression: dQ,
    isExpressionStatement: mQ,
    isMemberExpression: yQ,
    isNewExpression: TQ
  } = fQ;
  function tE(t) {
    let e = /* @__PURE__ */ new Map();
    function r(s, i) {
      let a = e.get(s);
      e.set(s, a ? function(o, l, u) {
        var c;
        return (c = a(o, l, u)) != null ? c : i(o, l, u);
      } : i);
    }
    n(r, "add");
    for (let s of Object.keys(t)) {
      let i = hQ[s];
      if (i)
        for (let a of i)
          r(a, t[s]);
      else
        r(s, t[s]);
    }
    return e;
  }
  n(tE, "expandAliases");
  var bQ = tE(pQ), xQ = tE(cQ.nodes);
  function rE(t) {
    return dQ(t) ? !0 : yQ(t) && rE(t.object);
  }
  n(rE, "isOrHasCallExpression");
  function nd(t, e, r) {
    var s;
    if (!t) return !1;
    mQ(t) && (t = t.expression);
    let i = (s = xQ.get(t.type)) == null ? void 0 : s(t, e);
    return typeof i == "number" ? (i & r) !== 0 : !1;
  }
  n(nd, "needsWhitespace");
  function SQ(t, e) {
    return nd(t, e, 1);
  }
  n(SQ, "needsWhitespaceBefore");
  function gQ(t, e) {
    return nd(t, e, 2);
  }
  n(gQ, "needsWhitespaceAfter");
  function PQ(t, e, r) {
    var s;
    return e ? TQ(e) && e.callee === t && rE(t) ? !0 : (s = bQ.get(t.type)) == null ? void 0 : s(t, e, r) : !1;
  }
  n(PQ, "needsParens");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/template-literals.js
var sE = w((Ua) => {
  "use strict";
  Object.defineProperty(Ua, "__esModule", {
    value: !0
  });
  Ua.TaggedTemplateExpression = EQ;
  Ua.TemplateElement = AQ;
  Ua.TemplateLiteral = vQ;
  function EQ(t) {
    this.print(t.tag, t), this.print(t.typeParameters, t), this.print(t.quasi, t);
  }
  n(EQ, "TaggedTemplateExpression");
  function AQ(t, e) {
    let r = e.quasis[0] === t, s = e.quasis[e.quasis.length - 1] === t, i = (r ? "`" : "}") + t.value.raw + (s ? "`" : "${");
    this.token(i, !0);
  }
  n(AQ, "TemplateElement");
  function vQ(t) {
    let e = t.quasis;
    for (let r = 0; r < e.length; r++)
      this.print(e[r], t), r + 1 < e.length && this.print(t.expressions[r], t);
  }
  n(vQ, "TemplateLiteral");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/expressions.js
var aE = w((Tt) => {
  "use strict";
  Object.defineProperty(Tt, "__esModule", {
    value: !0
  });
  Tt.LogicalExpression = Tt.BinaryExpression = Tt.AssignmentExpression = GQ;
  Tt.AssignmentPattern = zQ;
  Tt.AwaitExpression = JQ;
  Tt.BindExpression = QQ;
  Tt.CallExpression = WQ;
  Tt.ConditionalExpression = LQ;
  Tt.Decorator = qQ;
  Tt.DoExpression = kQ;
  Tt.EmptyStatement = $Q;
  Tt.ExpressionStatement = HQ;
  Tt.Import = YQ;
  Tt.MemberExpression = ZQ;
  Tt.MetaProperty = eZ;
  Tt.ModuleExpression = sZ;
  Tt.NewExpression = MQ;
  Tt.OptionalCallExpression = KQ;
  Tt.OptionalMemberExpression = VQ;
  Tt.ParenthesizedExpression = DQ;
  Tt.PrivateName = tZ;
  Tt.SequenceExpression = BQ;
  Tt.Super = jQ;
  Tt.ThisExpression = FQ;
  Tt.UnaryExpression = OQ;
  Tt.UpdateExpression = _Q;
  Tt.V8IntrinsicIdentifier = rZ;
  Tt.YieldExpression = XQ;
  Tt._shouldPrintDecoratorsBeforeExport = UQ;
  var CQ = Ce(), IQ = ad(), {
    isCallExpression: wQ,
    isLiteral: iE,
    isMemberExpression: od,
    isNewExpression: NQ
  } = CQ;
  function OQ(t) {
    let {
      operator: e
    } = t;
    e === "void" || e === "delete" || e === "typeof" || e === "throw" ? (this.word(e), this.space()) : this.token(e), this.print(t.argument,
    t);
  }
  n(OQ, "UnaryExpression");
  function kQ(t) {
    t.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(t.body, t);
  }
  n(kQ, "DoExpression");
  function DQ(t) {
    this.tokenChar(40), this.print(t.expression, t), this.rightParens(t);
  }
  n(DQ, "ParenthesizedExpression");
  function _Q(t) {
    t.prefix ? (this.token(t.operator), this.print(t.argument, t)) : (this.printTerminatorless(t.argument, t, !0), this.token(t.operator));
  }
  n(_Q, "UpdateExpression");
  function LQ(t) {
    this.print(t.test, t), this.space(), this.tokenChar(63), this.space(), this.print(t.consequent, t), this.space(), this.tokenChar(58), this.
    space(), this.print(t.alternate, t);
  }
  n(LQ, "ConditionalExpression");
  function MQ(t, e) {
    this.word("new"), this.space(), this.print(t.callee, t), !(this.format.minified && t.arguments.length === 0 && !t.optional && !wQ(e, {
      callee: t
    }) && !od(e) && !NQ(e)) && (this.print(t.typeArguments, t), this.print(t.typeParameters, t), t.optional && this.token("?."), this.tokenChar(
    40), this.printList(t.arguments, t), this.rightParens(t));
  }
  n(MQ, "NewExpression");
  function BQ(t) {
    this.printList(t.expressions, t);
  }
  n(BQ, "SequenceExpression");
  function FQ() {
    this.word("this");
  }
  n(FQ, "ThisExpression");
  function jQ() {
    this.word("super");
  }
  n(jQ, "Super");
  function nE(t) {
    switch (t.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !t.computed && t.property.type === "Identifier" && nE(t.object);
      default:
        return !1;
    }
  }
  n(nE, "isDecoratorMemberExpression");
  function RQ(t) {
    return t.type === "ParenthesizedExpression" ? !1 : !nE(t.type === "CallExpression" ? t.callee : t);
  }
  n(RQ, "shouldParenthesizeDecoratorExpression");
  function UQ(t) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof t.start == "number" && t.start ===
    t.declaration.start;
  }
  n(UQ, "_shouldPrintDecoratorsBeforeExport");
  function qQ(t) {
    this.tokenChar(64);
    let {
      expression: e
    } = t;
    RQ(e) ? (this.tokenChar(40), this.print(e, t), this.tokenChar(41)) : this.print(e, t), this.newline();
  }
  n(qQ, "Decorator");
  function VQ(t) {
    let {
      computed: e
    } = t, {
      optional: r,
      property: s
    } = t;
    if (this.print(t.object, t), !e && od(s))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    iE(s) && typeof s.value == "number" && (e = !0), r && this.token("?."), e ? (this.tokenChar(91), this.print(s, t), this.tokenChar(93)) :
    (r || this.tokenChar(46), this.print(s, t));
  }
  n(VQ, "OptionalMemberExpression");
  function KQ(t) {
    this.print(t.callee, t), this.print(t.typeParameters, t), t.optional && this.token("?."), this.print(t.typeArguments, t), this.tokenChar(
    40), this.printList(t.arguments, t), this.rightParens(t);
  }
  n(KQ, "OptionalCallExpression");
  function WQ(t) {
    this.print(t.callee, t), this.print(t.typeArguments, t), this.print(t.typeParameters, t), this.tokenChar(40), this.printList(t.arguments,
    t), this.rightParens(t);
  }
  n(WQ, "CallExpression");
  function YQ() {
    this.word("import");
  }
  n(YQ, "Import");
  function JQ(t) {
    this.word("await"), t.argument && (this.space(), this.printTerminatorless(t.argument, t, !1));
  }
  n(JQ, "AwaitExpression");
  function XQ(t) {
    this.word("yield", !0), t.delegate ? (this.tokenChar(42), t.argument && (this.space(), this.print(t.argument, t))) : t.argument && (this.
    space(), this.printTerminatorless(t.argument, t, !1));
  }
  n(XQ, "YieldExpression");
  function $Q() {
    this.semicolon(!0);
  }
  n($Q, "EmptyStatement");
  function HQ(t) {
    this.print(t.expression, t), this.semicolon();
  }
  n(HQ, "ExpressionStatement");
  function zQ(t) {
    this.print(t.left, t), t.left.optional && this.tokenChar(63), this.print(t.left.typeAnnotation, t), this.space(), this.tokenChar(61), this.
    space(), this.print(t.right, t);
  }
  n(zQ, "AssignmentPattern");
  function GQ(t, e) {
    let r = this.inForStatementInitCounter && t.operator === "in" && !IQ.needsParens(t, e);
    r && this.tokenChar(40), this.print(t.left, t), this.space(), t.operator === "in" || t.operator === "instanceof" ? this.word(t.operator) :
    this.token(t.operator), this.space(), this.print(t.right, t), r && this.tokenChar(41);
  }
  n(GQ, "AssignmentExpression");
  function QQ(t) {
    this.print(t.object, t), this.token("::"), this.print(t.callee, t);
  }
  n(QQ, "BindExpression");
  function ZQ(t) {
    if (this.print(t.object, t), !t.computed && od(t.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let e = t.computed;
    iE(t.property) && typeof t.property.value == "number" && (e = !0), e ? (this.tokenChar(91), this.print(t.property, t), this.tokenChar(93)) :
    (this.tokenChar(46), this.print(t.property, t));
  }
  n(ZQ, "MemberExpression");
  function eZ(t) {
    this.print(t.meta, t), this.tokenChar(46), this.print(t.property, t);
  }
  n(eZ, "MetaProperty");
  function tZ(t) {
    this.tokenChar(35), this.print(t.id, t);
  }
  n(tZ, "PrivateName");
  function rZ(t) {
    this.tokenChar(37), this.word(t.name);
  }
  n(rZ, "V8IntrinsicIdentifier");
  function sZ(t) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: e
    } = t;
    (e.body.length || e.directives.length) && this.newline(), this.print(e, t), this.dedent(), this.rightBrace(t);
  }
  n(sZ, "ModuleExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/statements.js
var cE = w((_t) => {
  "use strict";
  Object.defineProperty(_t, "__esModule", {
    value: !0
  });
  _t.BreakStatement = hZ;
  _t.CatchClause = xZ;
  _t.ContinueStatement = dZ;
  _t.DebuggerStatement = PZ;
  _t.DoWhileStatement = fZ;
  _t.ForOfStatement = _t.ForInStatement = void 0;
  _t.ForStatement = cZ;
  _t.IfStatement = uZ;
  _t.LabeledStatement = TZ;
  _t.ReturnStatement = mZ;
  _t.SwitchCase = gZ;
  _t.SwitchStatement = SZ;
  _t.ThrowStatement = yZ;
  _t.TryStatement = bZ;
  _t.VariableDeclaration = EZ;
  _t.VariableDeclarator = AZ;
  _t.WhileStatement = pZ;
  _t.WithStatement = lZ;
  var iZ = Ce(), {
    isFor: oE,
    isForStatement: nZ,
    isIfStatement: aZ,
    isStatement: oZ
  } = iZ;
  function lZ(t) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(t.object, t), this.tokenChar(41), this.printBlock(t);
  }
  n(lZ, "WithStatement");
  function uZ(t) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(t.test, t), this.tokenChar(41), this.space();
    let e = t.alternate && aZ(lE(t.consequent));
    e && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(t.consequent, t), e && (this.dedent(), this.newline(),
    this.tokenChar(125)), t.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    t.alternate, t));
  }
  n(uZ, "IfStatement");
  function lE(t) {
    let {
      body: e
    } = t;
    return oZ(e) === !1 ? t : lE(e);
  }
  n(lE, "getLastStatement");
  function cZ(t) {
    this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(t.init, t), this.inForStatementInitCounter--,
    this.tokenChar(59), t.test && (this.space(), this.print(t.test, t)), this.tokenChar(59), t.update && (this.space(), this.print(t.update,
    t)), this.tokenChar(41), this.printBlock(t);
  }
  n(cZ, "ForStatement");
  function pZ(t) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(t.test, t), this.tokenChar(41), this.printBlock(t);
  }
  n(pZ, "WhileStatement");
  function uE(t) {
    this.word("for"), this.space();
    let e = t.type === "ForOfStatement";
    e && t.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(t.left, t), this.space(),
    this.word(e ? "of" : "in"), this.space(), this.print(t.right, t), this.tokenChar(41), this.printBlock(t);
  }
  n(uE, "ForXStatement");
  var L5e = _t.ForInStatement = uE, M5e = _t.ForOfStatement = uE;
  function fZ(t) {
    this.word("do"), this.space(), this.print(t.body, t), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(t.test,
    t), this.tokenChar(41), this.semicolon();
  }
  n(fZ, "DoWhileStatement");
  function pu(t, e, r, s) {
    e && (t.space(), t.printTerminatorless(e, r, s)), t.semicolon();
  }
  n(pu, "printStatementAfterKeyword");
  function hZ(t) {
    this.word("break"), pu(this, t.label, t, !0);
  }
  n(hZ, "BreakStatement");
  function dZ(t) {
    this.word("continue"), pu(this, t.label, t, !0);
  }
  n(dZ, "ContinueStatement");
  function mZ(t) {
    this.word("return"), pu(this, t.argument, t, !1);
  }
  n(mZ, "ReturnStatement");
  function yZ(t) {
    this.word("throw"), pu(this, t.argument, t, !1);
  }
  n(yZ, "ThrowStatement");
  function TZ(t) {
    this.print(t.label, t), this.tokenChar(58), this.space(), this.print(t.body, t);
  }
  n(TZ, "LabeledStatement");
  function bZ(t) {
    this.word("try"), this.space(), this.print(t.block, t), this.space(), t.handlers ? this.print(t.handlers[0], t) : this.print(t.handler, t),
    t.finalizer && (this.space(), this.word("finally"), this.space(), this.print(t.finalizer, t));
  }
  n(bZ, "TryStatement");
  function xZ(t) {
    this.word("catch"), this.space(), t.param && (this.tokenChar(40), this.print(t.param, t), this.print(t.param.typeAnnotation, t), this.tokenChar(
    41), this.space()), this.print(t.body, t);
  }
  n(xZ, "CatchClause");
  function SZ(t) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(t.discriminant, t), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(t.cases, t, {
      indent: !0,
      addNewlines(e, r) {
        if (!e && t.cases[t.cases.length - 1] === r) return -1;
      }
    }), this.rightBrace(t);
  }
  n(SZ, "SwitchStatement");
  function gZ(t) {
    t.test ? (this.word("case"), this.space(), this.print(t.test, t), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), t.consequent.
    length && (this.newline(), this.printSequence(t.consequent, t, {
      indent: !0
    }));
  }
  n(gZ, "SwitchCase");
  function PZ() {
    this.word("debugger"), this.semicolon();
  }
  n(PZ, "DebuggerStatement");
  function EZ(t, e) {
    t.declare && (this.word("declare"), this.space());
    let {
      kind: r
    } = t;
    this.word(r, r === "using" || r === "await using"), this.space();
    let s = !1;
    if (!oE(e))
      for (let i of t.declarations)
        i.init && (s = !0);
    if (this.printList(t.declarations, t, {
      separator: s ? function() {
        this.tokenChar(44), this.newline();
      } : void 0,
      indent: t.declarations.length > 1
    }), oE(e)) {
      if (nZ(e)) {
        if (e.init === t) return;
      } else if (e.left === t) return;
    }
    this.semicolon();
  }
  n(EZ, "VariableDeclaration");
  function AZ(t) {
    this.print(t.id, t), t.definite && this.tokenChar(33), this.print(t.id.typeAnnotation, t), t.init && (this.space(), this.tokenChar(61), this.
    space(), this.print(t.init, t));
  }
  n(AZ, "VariableDeclarator");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/classes.js
var pE = w((Rr) => {
  "use strict";
  Object.defineProperty(Rr, "__esModule", {
    value: !0
  });
  Rr.ClassAccessorProperty = kZ;
  Rr.ClassBody = NZ;
  Rr.ClassExpression = Rr.ClassDeclaration = wZ;
  Rr.ClassMethod = _Z;
  Rr.ClassPrivateMethod = LZ;
  Rr.ClassPrivateProperty = DZ;
  Rr.ClassProperty = OZ;
  Rr.StaticBlock = BZ;
  Rr._classMethodHead = MZ;
  var vZ = Ce(), {
    isExportDefaultDeclaration: CZ,
    isExportNamedDeclaration: IZ
  } = vZ;
  function wZ(t, e) {
    (!(CZ(e) || IZ(e)) || !this._shouldPrintDecoratorsBeforeExport(e)) && this.printJoin(t.decorators, t), t.declare && (this.word("declare"),
    this.space()), t.abstract && (this.word("abstract"), this.space()), this.word("class"), t.id && (this.space(), this.print(t.id, t)), this.
    print(t.typeParameters, t), t.superClass && (this.space(), this.word("extends"), this.space(), this.print(t.superClass, t), this.print(t.
    superTypeParameters, t)), t.implements && (this.space(), this.word("implements"), this.space(), this.printList(t.implements, t)), this.space(),
    this.print(t.body, t);
  }
  n(wZ, "ClassDeclaration");
  function NZ(t) {
    this.tokenChar(123), t.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(t.body, t, {
      indent: !0
    }), this.endsWith(10) || this.newline(), this.rightBrace(t));
  }
  n(NZ, "ClassBody");
  function OZ(t) {
    var e;
    this.printJoin(t.decorators, t);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), t.computed ? (this.tokenChar(91), this.print(t.key, t), this.tokenChar(93)) :
    (this._variance(t), this.print(t.key, t)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(33), this.print(t.typeAnnotation,
    t), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value, t)), this.semicolon();
  }
  n(OZ, "ClassProperty");
  function kZ(t) {
    var e;
    this.printJoin(t.decorators, t);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), this.word("accessor", !0), this.space(), t.computed ? (this.tokenChar(91), this.
    print(t.key, t), this.tokenChar(93)) : (this._variance(t), this.print(t.key, t)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(
    33), this.print(t.typeAnnotation, t), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value, t)), this.semicolon();
  }
  n(kZ, "ClassAccessorProperty");
  function DZ(t) {
    this.printJoin(t.decorators, t), t.static && (this.word("static"), this.space()), this.print(t.key, t), this.print(t.typeAnnotation, t),
    t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value, t)), this.semicolon();
  }
  n(DZ, "ClassPrivateProperty");
  function _Z(t) {
    this._classMethodHead(t), this.space(), this.print(t.body, t);
  }
  n(_Z, "ClassMethod");
  function LZ(t) {
    this._classMethodHead(t), this.space(), this.print(t.body, t);
  }
  n(LZ, "ClassPrivateMethod");
  function MZ(t) {
    var e;
    this.printJoin(t.decorators, t);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), this._methodHead(t);
  }
  n(MZ, "_classMethodHead");
  function BZ(t) {
    this.word("static"), this.space(), this.tokenChar(123), t.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    t.body, t, {
      indent: !0
    }), this.rightBrace(t));
  }
  n(BZ, "StaticBlock");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/methods.js
var fE = w((Xr) => {
  "use strict";
  Object.defineProperty(Xr, "__esModule", {
    value: !0
  });
  Xr.ArrowFunctionExpression = JZ;
  Xr.FunctionDeclaration = Xr.FunctionExpression = YZ;
  Xr._functionHead = WZ;
  Xr._methodHead = VZ;
  Xr._param = qZ;
  Xr._parameters = UZ;
  Xr._params = RZ;
  Xr._predicate = KZ;
  var FZ = Ce(), {
    isIdentifier: jZ
  } = FZ;
  function RZ(t, e, r) {
    this.print(t.typeParameters, t);
    let s = $Z.call(this, e, r);
    s && this.sourceIdentifierName(s.name, s.pos), this.tokenChar(40), this._parameters(t.params, t), this.tokenChar(41);
    let i = t.type === "ArrowFunctionExpression";
    this.print(t.returnType, t, i), this._noLineTerminator = i;
  }
  n(RZ, "_params");
  function UZ(t, e) {
    let r = t.length;
    for (let s = 0; s < r; s++)
      this._param(t[s], e), s < t.length - 1 && (this.tokenChar(44), this.space());
  }
  n(UZ, "_parameters");
  function qZ(t, e) {
    this.printJoin(t.decorators, t), this.print(t, e), t.optional && this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(qZ, "_param");
  function VZ(t) {
    let e = t.kind, r = t.key;
    (e === "get" || e === "set") && (this.word(e), this.space()), t.async && (this.word("async", !0), this.space()), (e === "method" || e ===
    "init") && t.generator && this.tokenChar(42), t.computed ? (this.tokenChar(91), this.print(r, t), this.tokenChar(93)) : this.print(r, t),
    t.optional && this.tokenChar(63), this._params(t, t.computed && t.key.type !== "StringLiteral" ? void 0 : t.key, void 0);
  }
  n(VZ, "_methodHead");
  function KZ(t, e) {
    t.predicate && (t.returnType || this.tokenChar(58), this.space(), this.print(t.predicate, t, e));
  }
  n(KZ, "_predicate");
  function WZ(t, e) {
    t.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), t.generator && (this._endsWithInnerRaw =
    !1, this.tokenChar(42)), this.space(), t.id && this.print(t.id, t), this._params(t, t.id, e), t.type !== "TSDeclareFunction" && this._predicate(
    t);
  }
  n(WZ, "_functionHead");
  function YZ(t, e) {
    this._functionHead(t, e), this.space(), this.print(t.body, t);
  }
  n(YZ, "FunctionExpression");
  function JZ(t, e) {
    t.async && (this.word("async", !0), this.space());
    let r;
    !this.format.retainLines && t.params.length === 1 && jZ(r = t.params[0]) && !XZ(t, r) ? this.print(r, t, !0) : this._params(t, void 0, e),
    this._predicate(t, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(t.body, t);
  }
  n(JZ, "ArrowFunctionExpression");
  function XZ(t, e) {
    var r, s;
    return !!(t.typeParameters || t.returnType || t.predicate || e.typeAnnotation || e.optional || (r = e.leadingComments) != null && r.length ||
    (s = e.trailingComments) != null && s.length);
  }
  n(XZ, "hasTypesOrComments");
  function $Z(t, e) {
    let r = t;
    if (!r && e) {
      let u = e.type;
      u === "VariableDeclarator" ? r = e.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? r = e.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!e.computed || e.key.type === "StringLiteral") && (r = e.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (r = e.key);
    }
    if (!r) return;
    let s;
    if (r.type === "Identifier") {
      var i, a;
      s = {
        pos: (i = r.loc) == null ? void 0 : i.start,
        name: ((a = r.loc) == null ? void 0 : a.identifierName) || r.name
      };
    } else if (r.type === "PrivateName") {
      var o;
      s = {
        pos: (o = r.loc) == null ? void 0 : o.start,
        name: "#" + r.id.name
      };
    } else if (r.type === "StringLiteral") {
      var l;
      s = {
        pos: (l = r.loc) == null ? void 0 : l.start,
        name: r.value
      };
    }
    return s;
  }
  n($Z, "_getFuncIdName");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/modules.js
var ld = w((hr) => {
  "use strict";
  Object.defineProperty(hr, "__esModule", {
    value: !0
  });
  hr.ExportAllDeclaration = oee;
  hr.ExportDefaultDeclaration = uee;
  hr.ExportDefaultSpecifier = see;
  hr.ExportNamedDeclaration = lee;
  hr.ExportNamespaceSpecifier = nee;
  hr.ExportSpecifier = iee;
  hr.ImportAttribute = pee;
  hr.ImportDeclaration = cee;
  hr.ImportDefaultSpecifier = ree;
  hr.ImportExpression = hee;
  hr.ImportNamespaceSpecifier = fee;
  hr.ImportSpecifier = tee;
  hr._printAttributes = aee;
  var HZ = Ce(), {
    isClassDeclaration: zZ,
    isExportDefaultSpecifier: GZ,
    isExportNamespaceSpecifier: QZ,
    isImportDefaultSpecifier: ZZ,
    isImportNamespaceSpecifier: eee,
    isStatement: dE
  } = HZ;
  function tee(t) {
    (t.importKind === "type" || t.importKind === "typeof") && (this.word(t.importKind), this.space()), this.print(t.imported, t), t.local &&
    t.local.name !== t.imported.name && (this.space(), this.word("as"), this.space(), this.print(t.local, t));
  }
  n(tee, "ImportSpecifier");
  function ree(t) {
    this.print(t.local, t);
  }
  n(ree, "ImportDefaultSpecifier");
  function see(t) {
    this.print(t.exported, t);
  }
  n(see, "ExportDefaultSpecifier");
  function iee(t) {
    t.exportKind === "type" && (this.word("type"), this.space()), this.print(t.local, t), t.exported && t.local.name !== t.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(t.exported, t));
  }
  n(iee, "ExportSpecifier");
  function nee(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.exported, t);
  }
  n(nee, "ExportNamespaceSpecifier");
  var hE = !1;
  function aee(t) {
    let {
      importAttributesKeyword: e
    } = this.format, {
      attributes: r,
      assertions: s
    } = t;
    r && !e && !hE && (hE = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify \
the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\
\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let i = e === "assert" || !e && s;
    if (this.word(i ? "assert" : "with"), this.space(), !i && e !== "with") {
      this.printList(r || s, t);
      return;
    }
    this.tokenChar(123), this.space(), this.printList(r || s, t), this.space(), this.tokenChar(125);
  }
  n(aee, "_printAttributes");
  function oee(t) {
    var e, r;
    this.word("export"), this.space(), t.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (e = t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.print(t.source, t, !0),
    this.space(), this._printAttributes(t)) : this.print(t.source, t), this.semicolon();
  }
  n(oee, "ExportAllDeclaration");
  function mE(t, e) {
    zZ(e.declaration) && t._shouldPrintDecoratorsBeforeExport(e) && t.printJoin(e.declaration.decorators, e);
  }
  n(mE, "maybePrintDecoratorsBeforeExport");
  function lee(t) {
    if (mE(this, t), this.word("export"), this.space(), t.declaration) {
      let s = t.declaration;
      this.print(s, t), dE(s) || this.semicolon();
    } else {
      t.exportKind === "type" && (this.word("type"), this.space());
      let s = t.specifiers.slice(0), i = !1;
      for (; ; ) {
        let a = s[0];
        if (GZ(a) || QZ(a))
          i = !0, this.print(s.shift(), t), s.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      if ((s.length || !s.length && !i) && (this.tokenChar(123), s.length && (this.space(), this.printList(s, t), this.space()), this.tokenChar(
      125)), t.source) {
        var e, r;
        this.space(), this.word("from"), this.space(), (e = t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.
        print(t.source, t, !0), this.space(), this._printAttributes(t)) : this.print(t.source, t);
      }
      this.semicolon();
    }
  }
  n(lee, "ExportNamedDeclaration");
  function uee(t) {
    mE(this, t), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
    let e = t.declaration;
    this.print(e, t), dE(e) || this.semicolon();
  }
  n(uee, "ExportDefaultDeclaration");
  function cee(t) {
    var e, r;
    this.word("import"), this.space();
    let s = t.importKind === "type" || t.importKind === "typeof";
    s ? (this.noIndentInnerCommentsHere(), this.word(t.importKind), this.space()) : t.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : t.phase && (this.noIndentInnerCommentsHere(), this.word(t.phase), this.space());
    let i = t.specifiers.slice(0), a = !!i.length;
    for (; a; ) {
      let o = i[0];
      if (ZZ(o) || eee(o))
        this.print(i.shift(), t), i.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    i.length ? (this.tokenChar(123), this.space(), this.printList(i, t), this.space(), this.tokenChar(125)) : s && !a && (this.tokenChar(123),
    this.tokenChar(125)), (a || s) && (this.space(), this.word("from"), this.space()), (e = t.attributes) != null && e.length || (r = t.assertions) !=
    null && r.length ? (this.print(t.source, t, !0), this.space(), this._printAttributes(t)) : this.print(t.source, t), this.semicolon();
  }
  n(cee, "ImportDeclaration");
  function pee(t) {
    this.print(t.key), this.tokenChar(58), this.space(), this.print(t.value);
  }
  n(pee, "ImportAttribute");
  function fee(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.local, t);
  }
  n(fee, "ImportNamespaceSpecifier");
  function hee(t) {
    this.word("import"), t.phase && (this.tokenChar(46), this.word(t.phase)), this.tokenChar(40), this.print(t.source, t), t.options != null &&
    (this.tokenChar(44), this.space(), this.print(t.options, t)), this.tokenChar(41);
  }
  n(hee, "ImportExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/types.js
var cd = w((Ot) => {
  "use strict";
  Object.defineProperty(Ot, "__esModule", {
    value: !0
  });
  Ot.ArgumentPlaceholder = Tee;
  Ot.ArrayPattern = Ot.ArrayExpression = Pee;
  Ot.BigIntLiteral = Oee;
  Ot.BooleanLiteral = Cee;
  Ot.DecimalLiteral = kee;
  Ot.Identifier = yee;
  Ot.NullLiteral = Iee;
  Ot.NumericLiteral = wee;
  Ot.ObjectPattern = Ot.ObjectExpression = xee;
  Ot.ObjectMethod = See;
  Ot.ObjectProperty = gee;
  Ot.PipelineBareFunction = Lee;
  Ot.PipelinePrimaryTopicReference = Mee;
  Ot.PipelineTopicExpression = _ee;
  Ot.RecordExpression = Eee;
  Ot.RegExpLiteral = vee;
  Ot.SpreadElement = Ot.RestElement = bee;
  Ot.StringLiteral = Nee;
  Ot.TopicReference = Dee;
  Ot.TupleExpression = Aee;
  var dee = Ce(), TE = xh(), {
    isAssignmentPattern: mee,
    isIdentifier: ud
  } = dee;
  function yee(t) {
    var e;
    this.sourceIdentifierName(((e = t.loc) == null ? void 0 : e.identifierName) || t.name), this.word(t.name);
  }
  n(yee, "Identifier");
  function Tee() {
    this.tokenChar(63);
  }
  n(Tee, "ArgumentPlaceholder");
  function bee(t) {
    this.token("..."), this.print(t.argument, t);
  }
  n(bee, "RestElement");
  function xee(t) {
    let e = t.properties;
    this.tokenChar(123), e.length && (this.space(), this.printList(e, t, {
      indent: !0,
      statement: !0
    }), this.space()), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
  }
  n(xee, "ObjectExpression");
  function See(t) {
    this.printJoin(t.decorators, t), this._methodHead(t), this.space(), this.print(t.body, t);
  }
  n(See, "ObjectMethod");
  function gee(t) {
    if (this.printJoin(t.decorators, t), t.computed)
      this.tokenChar(91), this.print(t.key, t), this.tokenChar(93);
    else {
      if (mee(t.value) && ud(t.key) && t.key.name === t.value.left.name) {
        this.print(t.value, t);
        return;
      }
      if (this.print(t.key, t), t.shorthand && ud(t.key) && ud(t.value) && t.key.name === t.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(t.value, t);
  }
  n(gee, "ObjectProperty");
  function Pee(t) {
    let e = t.elements, r = e.length;
    this.tokenChar(91);
    for (let s = 0; s < e.length; s++) {
      let i = e[s];
      i ? (s > 0 && this.space(), this.print(i, t), s < r - 1 && this.tokenChar(44)) : this.tokenChar(44);
    }
    this.tokenChar(93);
  }
  n(Pee, "ArrayExpression");
  function Eee(t) {
    let e = t.properties, r, s;
    if (this.format.recordAndTupleSyntaxType === "bar")
      r = "{|", s = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      r = "#{", s = "}";
    }
    this.token(r), e.length && (this.space(), this.printList(e, t, {
      indent: !0,
      statement: !0
    }), this.space()), this.token(s);
  }
  n(Eee, "RecordExpression");
  function Aee(t) {
    let e = t.elements, r = e.length, s, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      s = "[|", i = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      s = "#[", i = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(s);
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      o && (a > 0 && this.space(), this.print(o, t), a < r - 1 && this.tokenChar(44));
    }
    this.token(i);
  }
  n(Aee, "TupleExpression");
  function vee(t) {
    this.word(`/${t.pattern}/${t.flags}`);
  }
  n(vee, "RegExpLiteral");
  function Cee(t) {
    this.word(t.value ? "true" : "false");
  }
  n(Cee, "BooleanLiteral");
  function Iee() {
    this.word("null");
  }
  n(Iee, "NullLiteral");
  function wee(t) {
    let e = this.getPossibleRaw(t), r = this.format.jsescOption, s = t.value, i = s + "";
    r.numbers ? this.number(TE(s, r), s) : e == null ? this.number(i, s) : this.format.minified ? this.number(e.length < i.length ? e : i, s) :
    this.number(e, s);
  }
  n(wee, "NumericLiteral");
  function Nee(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let r = TE(t.value, this.format.jsescOption);
    this.token(r);
  }
  n(Nee, "StringLiteral");
  function Oee(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.word(e);
      return;
    }
    this.word(t.value + "n");
  }
  n(Oee, "BigIntLiteral");
  function kee(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.word(e);
      return;
    }
    this.word(t.value + "m");
  }
  n(kee, "DecimalLiteral");
  var yE = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function Dee() {
    let {
      topicToken: t
    } = this.format;
    if (yE.has(t))
      this.token(t);
    else {
      let e = JSON.stringify(t), r = Array.from(yE, (s) => JSON.stringify(s));
      throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${e} received instead).`);
    }
  }
  n(Dee, "TopicReference");
  function _ee(t) {
    this.print(t.expression, t);
  }
  n(_ee, "PipelineTopicExpression");
  function Lee(t) {
    this.print(t.callee, t);
  }
  n(Lee, "PipelineBareFunction");
  function Mee() {
    this.tokenChar(35);
  }
  n(Mee, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/flow.js
var xE = w((he) => {
  "use strict";
  Object.defineProperty(he, "__esModule", {
    value: !0
  });
  he.AnyTypeAnnotation = Ree;
  he.ArrayTypeAnnotation = Uee;
  he.BooleanLiteralTypeAnnotation = Vee;
  he.BooleanTypeAnnotation = qee;
  he.DeclareClass = Wee;
  he.DeclareExportAllDeclaration = tte;
  he.DeclareExportDeclaration = ete;
  he.DeclareFunction = Yee;
  he.DeclareInterface = $ee;
  he.DeclareModule = Hee;
  he.DeclareModuleExports = zee;
  he.DeclareOpaqueType = Qee;
  he.DeclareTypeAlias = Gee;
  he.DeclareVariable = Zee;
  he.DeclaredPredicate = Xee;
  he.EmptyTypeAnnotation = Ete;
  he.EnumBooleanBody = ste;
  he.EnumBooleanMember = lte;
  he.EnumDeclaration = rte;
  he.EnumDefaultedMember = ote;
  he.EnumNumberBody = ite;
  he.EnumNumberMember = ute;
  he.EnumStringBody = nte;
  he.EnumStringMember = cte;
  he.EnumSymbolBody = ate;
  he.ExistsTypeAnnotation = fte;
  he.FunctionTypeAnnotation = hte;
  he.FunctionTypeParam = dte;
  he.IndexedAccessType = $te;
  he.InferredPredicate = Jee;
  he.InterfaceDeclaration = bte;
  he.GenericTypeAnnotation = he.ClassImplements = he.InterfaceExtends = mte;
  he.InterfaceTypeAnnotation = Ste;
  he.IntersectionTypeAnnotation = gte;
  he.MixedTypeAnnotation = Pte;
  he.NullLiteralTypeAnnotation = Kee;
  he.NullableTypeAnnotation = Ate;
  Object.defineProperty(he, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return bE.NumericLiteral;
    }, "get")
  });
  he.NumberTypeAnnotation = vte;
  he.ObjectTypeAnnotation = Mte;
  he.ObjectTypeCallProperty = Fte;
  he.ObjectTypeIndexer = jte;
  he.ObjectTypeInternalSlot = Bte;
  he.ObjectTypeProperty = Rte;
  he.ObjectTypeSpreadProperty = Ute;
  he.OpaqueType = Lte;
  he.OptionalIndexedAccessType = Hte;
  he.QualifiedTypeIdentifier = qte;
  Object.defineProperty(he, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return bE.StringLiteral;
    }, "get")
  });
  he.StringTypeAnnotation = Cte;
  he.SymbolTypeAnnotation = Vte;
  he.ThisTypeAnnotation = Ite;
  he.TupleTypeAnnotation = wte;
  he.TypeAlias = Ote;
  he.TypeAnnotation = kte;
  he.TypeCastExpression = Yte;
  he.TypeParameter = _te;
  he.TypeParameterDeclaration = he.TypeParameterInstantiation = Dte;
  he.TypeofTypeAnnotation = Nte;
  he.UnionTypeAnnotation = Wte;
  he.Variance = Jte;
  he.VoidTypeAnnotation = Xte;
  he._interfaceish = yte;
  he._variance = Tte;
  var Bee = Ce(), Fee = ld(), bE = cd(), {
    isDeclareExportDeclaration: fu,
    isStatement: jee
  } = Bee;
  function Ree() {
    this.word("any");
  }
  n(Ree, "AnyTypeAnnotation");
  function Uee(t) {
    this.print(t.elementType, t, !0), this.tokenChar(91), this.tokenChar(93);
  }
  n(Uee, "ArrayTypeAnnotation");
  function qee() {
    this.word("boolean");
  }
  n(qee, "BooleanTypeAnnotation");
  function Vee(t) {
    this.word(t.value ? "true" : "false");
  }
  n(Vee, "BooleanLiteralTypeAnnotation");
  function Kee() {
    this.word("null");
  }
  n(Kee, "NullLiteralTypeAnnotation");
  function Wee(t, e) {
    fu(e) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(t);
  }
  n(Wee, "DeclareClass");
  function Yee(t, e) {
    fu(e) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(t.id, t), this.print(t.id.typeAnnotation.
    typeAnnotation, t), t.predicate && (this.space(), this.print(t.predicate, t)), this.semicolon();
  }
  n(Yee, "DeclareFunction");
  function Jee() {
    this.tokenChar(37), this.word("checks");
  }
  n(Jee, "InferredPredicate");
  function Xee(t) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(t.value, t), this.tokenChar(41);
  }
  n(Xee, "DeclaredPredicate");
  function $ee(t) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(t);
  }
  n($ee, "DeclareInterface");
  function Hee(t) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(t.id, t), this.space(), this.print(t.body, t);
  }
  n(Hee, "DeclareModule");
  function zee(t) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(t.typeAnnotation, t);
  }
  n(zee, "DeclareModuleExports");
  function Gee(t) {
    this.word("declare"), this.space(), this.TypeAlias(t);
  }
  n(Gee, "DeclareTypeAlias");
  function Qee(t, e) {
    fu(e) || (this.word("declare"), this.space()), this.OpaqueType(t);
  }
  n(Qee, "DeclareOpaqueType");
  function Zee(t, e) {
    fu(e) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(t.id, t), this.print(t.id.typeAnnotation, t), this.
    semicolon();
  }
  n(Zee, "DeclareVariable");
  function ete(t) {
    this.word("declare"), this.space(), this.word("export"), this.space(), t.default && (this.word("default"), this.space()), pte.call(this,
    t);
  }
  n(ete, "DeclareExportDeclaration");
  function tte(t) {
    this.word("declare"), this.space(), Fee.ExportAllDeclaration.call(this, t);
  }
  n(tte, "DeclareExportAllDeclaration");
  function rte(t) {
    let {
      id: e,
      body: r
    } = t;
    this.word("enum"), this.space(), this.print(e, t), this.print(r, t);
  }
  n(rte, "EnumDeclaration");
  function hu(t, e, r) {
    r && (t.space(), t.word("of"), t.space(), t.word(e)), t.space();
  }
  n(hu, "enumExplicitType");
  function du(t, e) {
    let {
      members: r
    } = e;
    t.token("{"), t.indent(), t.newline();
    for (let s of r)
      t.print(s, e), t.newline();
    e.hasUnknownMembers && (t.token("..."), t.newline()), t.dedent(), t.token("}");
  }
  n(du, "enumBody");
  function ste(t) {
    let {
      explicitType: e
    } = t;
    hu(this, "boolean", e), du(this, t);
  }
  n(ste, "EnumBooleanBody");
  function ite(t) {
    let {
      explicitType: e
    } = t;
    hu(this, "number", e), du(this, t);
  }
  n(ite, "EnumNumberBody");
  function nte(t) {
    let {
      explicitType: e
    } = t;
    hu(this, "string", e), du(this, t);
  }
  n(nte, "EnumStringBody");
  function ate(t) {
    hu(this, "symbol", !0), du(this, t);
  }
  n(ate, "EnumSymbolBody");
  function ote(t) {
    let {
      id: e
    } = t;
    this.print(e, t), this.tokenChar(44);
  }
  n(ote, "EnumDefaultedMember");
  function pd(t, e) {
    let {
      id: r,
      init: s
    } = e;
    t.print(r, e), t.space(), t.token("="), t.space(), t.print(s, e), t.token(",");
  }
  n(pd, "enumInitializedMember");
  function lte(t) {
    pd(this, t);
  }
  n(lte, "EnumBooleanMember");
  function ute(t) {
    pd(this, t);
  }
  n(ute, "EnumNumberMember");
  function cte(t) {
    pd(this, t);
  }
  n(cte, "EnumStringMember");
  function pte(t) {
    if (t.declaration) {
      let e = t.declaration;
      this.print(e, t), jee(e) || this.semicolon();
    } else
      this.tokenChar(123), t.specifiers.length && (this.space(), this.printList(t.specifiers, t), this.space()), this.tokenChar(125), t.source &&
      (this.space(), this.word("from"), this.space(), this.print(t.source, t)), this.semicolon();
  }
  n(pte, "FlowExportDeclaration");
  function fte() {
    this.tokenChar(42);
  }
  n(fte, "ExistsTypeAnnotation");
  function hte(t, e) {
    this.print(t.typeParameters, t), this.tokenChar(40), t.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(t.this.typeAnnotation,
    t), (t.params.length || t.rest) && (this.tokenChar(44), this.space())), this.printList(t.params, t), t.rest && (t.params.length && (this.
    tokenChar(44), this.space()), this.token("..."), this.print(t.rest, t)), this.tokenChar(41);
    let r = e?.type;
    r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" &&
    e.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(t.returnType, t);
  }
  n(hte, "FunctionTypeAnnotation");
  function dte(t) {
    this.print(t.name, t), t.optional && this.tokenChar(63), t.name && (this.tokenChar(58), this.space()), this.print(t.typeAnnotation, t);
  }
  n(dte, "FunctionTypeParam");
  function mte(t) {
    this.print(t.id, t), this.print(t.typeParameters, t, !0);
  }
  n(mte, "InterfaceExtends");
  function yte(t) {
    var e;
    if (this.print(t.id, t), this.print(t.typeParameters, t), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.
    space(), this.printList(t.extends, t)), t.type === "DeclareClass") {
      var r, s;
      (r = t.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(t.mixins, t)), (s = t.implements) !=
      null && s.length && (this.space(), this.word("implements"), this.space(), this.printList(t.implements, t));
    }
    this.space(), this.print(t.body, t);
  }
  n(yte, "_interfaceish");
  function Tte(t) {
    var e;
    let r = (e = t.variance) == null ? void 0 : e.kind;
    r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
  }
  n(Tte, "_variance");
  function bte(t) {
    this.word("interface"), this.space(), this._interfaceish(t);
  }
  n(bte, "InterfaceDeclaration");
  function xte() {
    this.space(), this.tokenChar(38), this.space();
  }
  n(xte, "andSeparator");
  function Ste(t) {
    var e;
    this.word("interface"), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(), this.printList(t.extends,
    t)), this.space(), this.print(t.body, t);
  }
  n(Ste, "InterfaceTypeAnnotation");
  function gte(t) {
    this.printJoin(t.types, t, {
      separator: xte
    });
  }
  n(gte, "IntersectionTypeAnnotation");
  function Pte() {
    this.word("mixed");
  }
  n(Pte, "MixedTypeAnnotation");
  function Ete() {
    this.word("empty");
  }
  n(Ete, "EmptyTypeAnnotation");
  function Ate(t) {
    this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(Ate, "NullableTypeAnnotation");
  function vte() {
    this.word("number");
  }
  n(vte, "NumberTypeAnnotation");
  function Cte() {
    this.word("string");
  }
  n(Cte, "StringTypeAnnotation");
  function Ite() {
    this.word("this");
  }
  n(Ite, "ThisTypeAnnotation");
  function wte(t) {
    this.tokenChar(91), this.printList(t.types, t), this.tokenChar(93);
  }
  n(wte, "TupleTypeAnnotation");
  function Nte(t) {
    this.word("typeof"), this.space(), this.print(t.argument, t);
  }
  n(Nte, "TypeofTypeAnnotation");
  function Ote(t) {
    this.word("type"), this.space(), this.print(t.id, t), this.print(t.typeParameters, t), this.space(), this.tokenChar(61), this.space(), this.
    print(t.right, t), this.semicolon();
  }
  n(Ote, "TypeAlias");
  function kte(t) {
    this.tokenChar(58), this.space(), t.optional && this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(kte, "TypeAnnotation");
  function Dte(t) {
    this.tokenChar(60), this.printList(t.params, t, {}), this.tokenChar(62);
  }
  n(Dte, "TypeParameterInstantiation");
  function _te(t) {
    this._variance(t), this.word(t.name), t.bound && this.print(t.bound, t), t.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(t.default, t));
  }
  n(_te, "TypeParameter");
  function Lte(t) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(t.id, t), this.print(t.typeParameters, t), t.supertype &&
    (this.tokenChar(58), this.space(), this.print(t.supertype, t)), t.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(
    t.impltype, t)), this.semicolon();
  }
  n(Lte, "OpaqueType");
  function Mte(t) {
    t.exact ? this.token("{|") : this.tokenChar(123);
    let e = [...t.properties, ...t.callProperties || [], ...t.indexers || [], ...t.internalSlots || []];
    e.length && (this.newline(), this.space(), this.printJoin(e, t, {
      addNewlines(r) {
        if (r && !e[0]) return 1;
      },
      indent: !0,
      statement: !0,
      iterator: /* @__PURE__ */ n(() => {
        (e.length !== 1 || t.inexact) && (this.tokenChar(44), this.space());
      }, "iterator")
    }), this.space()), t.inexact && (this.indent(), this.token("..."), e.length && this.newline(), this.dedent()), t.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  n(Mte, "ObjectTypeAnnotation");
  function Bte(t) {
    t.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(t.id, t), this.tokenChar(93), this.tokenChar(
    93), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58), this.space()), this.print(t.value, t);
  }
  n(Bte, "ObjectTypeInternalSlot");
  function Fte(t) {
    t.static && (this.word("static"), this.space()), this.print(t.value, t);
  }
  n(Fte, "ObjectTypeCallProperty");
  function jte(t) {
    t.static && (this.word("static"), this.space()), this._variance(t), this.tokenChar(91), t.id && (this.print(t.id, t), this.tokenChar(58),
    this.space()), this.print(t.key, t), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(t.value, t);
  }
  n(jte, "ObjectTypeIndexer");
  function Rte(t) {
    t.proto && (this.word("proto"), this.space()), t.static && (this.word("static"), this.space()), (t.kind === "get" || t.kind === "set") &&
    (this.word(t.kind), this.space()), this._variance(t), this.print(t.key, t), t.optional && this.tokenChar(63), t.method || (this.tokenChar(
    58), this.space()), this.print(t.value, t);
  }
  n(Rte, "ObjectTypeProperty");
  function Ute(t) {
    this.token("..."), this.print(t.argument, t);
  }
  n(Ute, "ObjectTypeSpreadProperty");
  function qte(t) {
    this.print(t.qualification, t), this.tokenChar(46), this.print(t.id, t);
  }
  n(qte, "QualifiedTypeIdentifier");
  function Vte() {
    this.word("symbol");
  }
  n(Vte, "SymbolTypeAnnotation");
  function Kte() {
    this.space(), this.tokenChar(124), this.space();
  }
  n(Kte, "orSeparator");
  function Wte(t) {
    this.printJoin(t.types, t, {
      separator: Kte
    });
  }
  n(Wte, "UnionTypeAnnotation");
  function Yte(t) {
    this.tokenChar(40), this.print(t.expression, t), this.print(t.typeAnnotation, t), this.tokenChar(41);
  }
  n(Yte, "TypeCastExpression");
  function Jte(t) {
    t.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  n(Jte, "Variance");
  function Xte() {
    this.word("void");
  }
  n(Xte, "VoidTypeAnnotation");
  function $te(t) {
    this.print(t.objectType, t, !0), this.tokenChar(91), this.print(t.indexType, t), this.tokenChar(93);
  }
  n($te, "IndexedAccessType");
  function Hte(t) {
    this.print(t.objectType, t), t.optional && this.token("?."), this.tokenChar(91), this.print(t.indexType, t), this.tokenChar(93);
  }
  n(Hte, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/base.js
var SE = w((gs) => {
  "use strict";
  Object.defineProperty(gs, "__esModule", {
    value: !0
  });
  gs.BlockStatement = Qte;
  gs.Directive = Zte;
  gs.DirectiveLiteral = rre;
  gs.File = zte;
  gs.InterpreterDirective = sre;
  gs.Placeholder = ire;
  gs.Program = Gte;
  function zte(t) {
    t.program && this.print(t.program.interpreter, t), this.print(t.program, t);
  }
  n(zte, "File");
  function Gte(t) {
    var e;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let r = (e = t.directives) == null ? void 0 : e.length;
    if (r) {
      var s;
      let i = t.body.length ? 2 : 1;
      this.printSequence(t.directives, t, {
        trailingCommentsLineOffset: i
      }), (s = t.directives[r - 1].trailingComments) != null && s.length || this.newline(i);
    }
    this.printSequence(t.body, t);
  }
  n(Gte, "Program");
  function Qte(t) {
    var e;
    this.tokenChar(123);
    let r = (e = t.directives) == null ? void 0 : e.length;
    if (r) {
      var s;
      let i = t.body.length ? 2 : 1;
      this.printSequence(t.directives, t, {
        indent: !0,
        trailingCommentsLineOffset: i
      }), (s = t.directives[r - 1].trailingComments) != null && s.length || this.newline(i);
    }
    this.printSequence(t.body, t, {
      indent: !0
    }), this.rightBrace(t);
  }
  n(Qte, "BlockStatement");
  function Zte(t) {
    this.print(t.value, t), this.semicolon();
  }
  n(Zte, "Directive");
  var ere = /(?:^|[^\\])(?:\\\\)*'/, tre = /(?:^|[^\\])(?:\\\\)*"/;
  function rre(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let {
      value: r
    } = t;
    if (!tre.test(r))
      this.token(`"${r}"`);
    else if (!ere.test(r))
      this.token(`'${r}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  n(rre, "DirectiveLiteral");
  function sre(t) {
    this.token(`#!${t.value}`), this.newline(1, !0);
  }
  n(sre, "InterpreterDirective");
  function ire(t) {
    this.token("%%"), this.print(t.name), this.token("%%"), t.expectedNode === "Statement" && this.semicolon();
  }
  n(ire, "Placeholder");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/jsx.js
var gE = w((er) => {
  "use strict";
  Object.defineProperty(er, "__esModule", {
    value: !0
  });
  er.JSXAttribute = nre;
  er.JSXClosingElement = yre;
  er.JSXClosingFragment = Sre;
  er.JSXElement = hre;
  er.JSXEmptyExpression = Tre;
  er.JSXExpressionContainer = cre;
  er.JSXFragment = bre;
  er.JSXIdentifier = are;
  er.JSXMemberExpression = lre;
  er.JSXNamespacedName = ore;
  er.JSXOpeningElement = mre;
  er.JSXOpeningFragment = xre;
  er.JSXSpreadAttribute = ure;
  er.JSXSpreadChild = pre;
  er.JSXText = fre;
  function nre(t) {
    this.print(t.name, t), t.value && (this.tokenChar(61), this.print(t.value, t));
  }
  n(nre, "JSXAttribute");
  function are(t) {
    this.word(t.name);
  }
  n(are, "JSXIdentifier");
  function ore(t) {
    this.print(t.namespace, t), this.tokenChar(58), this.print(t.name, t);
  }
  n(ore, "JSXNamespacedName");
  function lre(t) {
    this.print(t.object, t), this.tokenChar(46), this.print(t.property, t);
  }
  n(lre, "JSXMemberExpression");
  function ure(t) {
    this.tokenChar(123), this.token("..."), this.print(t.argument, t), this.tokenChar(125);
  }
  n(ure, "JSXSpreadAttribute");
  function cre(t) {
    this.tokenChar(123), this.print(t.expression, t), this.tokenChar(125);
  }
  n(cre, "JSXExpressionContainer");
  function pre(t) {
    this.tokenChar(123), this.token("..."), this.print(t.expression, t), this.tokenChar(125);
  }
  n(pre, "JSXSpreadChild");
  function fre(t) {
    let e = this.getPossibleRaw(t);
    e !== void 0 ? this.token(e, !0) : this.token(t.value, !0);
  }
  n(fre, "JSXText");
  function hre(t) {
    let e = t.openingElement;
    if (this.print(e, t), !e.selfClosing) {
      this.indent();
      for (let r of t.children)
        this.print(r, t);
      this.dedent(), this.print(t.closingElement, t);
    }
  }
  n(hre, "JSXElement");
  function dre() {
    this.space();
  }
  n(dre, "spaceSeparator");
  function mre(t) {
    this.tokenChar(60), this.print(t.name, t), this.print(t.typeParameters, t), t.attributes.length > 0 && (this.space(), this.printJoin(t.attributes,
    t, {
      separator: dre
    })), t.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
  }
  n(mre, "JSXOpeningElement");
  function yre(t) {
    this.token("</"), this.print(t.name, t), this.tokenChar(62);
  }
  n(yre, "JSXClosingElement");
  function Tre() {
    this.printInnerComments();
  }
  n(Tre, "JSXEmptyExpression");
  function bre(t) {
    this.print(t.openingFragment, t), this.indent();
    for (let e of t.children)
      this.print(e, t);
    this.dedent(), this.print(t.closingFragment, t);
  }
  n(bre, "JSXFragment");
  function xre() {
    this.tokenChar(60), this.tokenChar(62);
  }
  n(xre, "JSXOpeningFragment");
  function Sre() {
    this.token("</"), this.tokenChar(62);
  }
  n(Sre, "JSXClosingFragment");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/typescript.js
var AE = w((pe) => {
  "use strict";
  Object.defineProperty(pe, "__esModule", {
    value: !0
  });
  pe.TSAnyKeyword = Lre;
  pe.TSArrayType = rse;
  pe.TSSatisfiesExpression = pe.TSAsExpression = Sse;
  pe.TSBigIntKeyword = Mre;
  pe.TSBooleanKeyword = Rre;
  pe.TSCallSignatureDeclaration = wre;
  pe.TSConditionalType = use;
  pe.TSConstructSignatureDeclaration = Nre;
  pe.TSConstructorType = Hre;
  pe.TSDeclareFunction = vre;
  pe.TSDeclareMethod = Cre;
  pe.TSEnumDeclaration = Ese;
  pe.TSEnumMember = Ase;
  pe.TSExportAssignment = kse;
  pe.TSExpressionWithTypeArguments = yse;
  pe.TSExternalModuleReference = Nse;
  pe.TSFunctionType = $re;
  pe.TSImportEqualsDeclaration = wse;
  pe.TSImportType = Ise;
  pe.TSIndexSignature = _re;
  pe.TSIndexedAccessType = hse;
  pe.TSInferType = cse;
  pe.TSInstantiationExpression = Pse;
  pe.TSInterfaceBody = bse;
  pe.TSInterfaceDeclaration = Tse;
  pe.TSIntersectionType = lse;
  pe.TSIntrinsicKeyword = Jre;
  pe.TSLiteralType = mse;
  pe.TSMappedType = dse;
  pe.TSMethodSignature = Dre;
  pe.TSModuleBlock = Cse;
  pe.TSModuleDeclaration = vse;
  pe.TSNamedTupleMember = ase;
  pe.TSNamespaceExportDeclaration = Dse;
  pe.TSNeverKeyword = Yre;
  pe.TSNonNullExpression = Ose;
  pe.TSNullKeyword = Wre;
  pe.TSNumberKeyword = Fre;
  pe.TSObjectKeyword = jre;
  pe.TSOptionalType = ise;
  pe.TSParameterProperty = Are;
  pe.TSParenthesizedType = pse;
  pe.TSPropertySignature = Ore;
  pe.TSQualifiedName = Ire;
  pe.TSRestType = nse;
  pe.TSStringKeyword = Ure;
  pe.TSSymbolKeyword = qre;
  pe.TSThisType = Xre;
  pe.TSTupleType = sse;
  pe.TSTypeAliasDeclaration = xse;
  pe.TSTypeAnnotation = gre;
  pe.TSTypeAssertion = gse;
  pe.TSTypeLiteral = ese;
  pe.TSTypeOperator = fse;
  pe.TSTypeParameter = Ere;
  pe.TSTypeParameterDeclaration = pe.TSTypeParameterInstantiation = Pre;
  pe.TSTypePredicate = Qre;
  pe.TSTypeQuery = Zre;
  pe.TSTypeReference = Gre;
  pe.TSUndefinedKeyword = Kre;
  pe.TSUnionType = ose;
  pe.TSUnknownKeyword = Bre;
  pe.TSVoidKeyword = Vre;
  pe.tsPrintClassMemberModifiers = Lse;
  pe.tsPrintFunctionOrConstructorType = zre;
  pe.tsPrintPropertyOrMethodName = kre;
  pe.tsPrintSignatureDeclarationBase = _se;
  pe.tsPrintTypeLiteralOrInterfaceBody = tse;
  function gre(t) {
    this.tokenChar(58), this.space(), t.optional && this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(gre, "TSTypeAnnotation");
  function Pre(t, e) {
    this.tokenChar(60), this.printList(t.params, t, {}), e.type === "ArrowFunctionExpression" && t.params.length === 1 && this.tokenChar(44),
    this.tokenChar(62);
  }
  n(Pre, "TSTypeParameterInstantiation");
  function Ere(t) {
    t.in && (this.word("in"), this.space()), t.out && (this.word("out"), this.space()), this.word(t.name), t.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(t.constraint, t)), t.default && (this.space(), this.tokenChar(61), this.space(), this.print(t.
    default, t));
  }
  n(Ere, "TSTypeParameter");
  function Are(t) {
    t.accessibility && (this.word(t.accessibility), this.space()), t.readonly && (this.word("readonly"), this.space()), this._param(t.parameter);
  }
  n(Are, "TSParameterProperty");
  function vre(t, e) {
    t.declare && (this.word("declare"), this.space()), this._functionHead(t, e), this.tokenChar(59);
  }
  n(vre, "TSDeclareFunction");
  function Cre(t) {
    this._classMethodHead(t), this.tokenChar(59);
  }
  n(Cre, "TSDeclareMethod");
  function Ire(t) {
    this.print(t.left, t), this.tokenChar(46), this.print(t.right, t);
  }
  n(Ire, "TSQualifiedName");
  function wre(t) {
    this.tsPrintSignatureDeclarationBase(t), this.tokenChar(59);
  }
  n(wre, "TSCallSignatureDeclaration");
  function Nre(t) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(t), this.tokenChar(59);
  }
  n(Nre, "TSConstructSignatureDeclaration");
  function Ore(t) {
    let {
      readonly: e
    } = t;
    e && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(t), this.print(t.typeAnnotation, t), this.tokenChar(59);
  }
  n(Ore, "TSPropertySignature");
  function kre(t) {
    t.computed && this.tokenChar(91), this.print(t.key, t), t.computed && this.tokenChar(93), t.optional && this.tokenChar(63);
  }
  n(kre, "tsPrintPropertyOrMethodName");
  function Dre(t) {
    let {
      kind: e
    } = t;
    (e === "set" || e === "get") && (this.word(e), this.space()), this.tsPrintPropertyOrMethodName(t), this.tsPrintSignatureDeclarationBase(
    t), this.tokenChar(59);
  }
  n(Dre, "TSMethodSignature");
  function _re(t) {
    let {
      readonly: e,
      static: r
    } = t;
    r && (this.word("static"), this.space()), e && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(t.parameters,
    t), this.tokenChar(93), this.print(t.typeAnnotation, t), this.tokenChar(59);
  }
  n(_re, "TSIndexSignature");
  function Lre() {
    this.word("any");
  }
  n(Lre, "TSAnyKeyword");
  function Mre() {
    this.word("bigint");
  }
  n(Mre, "TSBigIntKeyword");
  function Bre() {
    this.word("unknown");
  }
  n(Bre, "TSUnknownKeyword");
  function Fre() {
    this.word("number");
  }
  n(Fre, "TSNumberKeyword");
  function jre() {
    this.word("object");
  }
  n(jre, "TSObjectKeyword");
  function Rre() {
    this.word("boolean");
  }
  n(Rre, "TSBooleanKeyword");
  function Ure() {
    this.word("string");
  }
  n(Ure, "TSStringKeyword");
  function qre() {
    this.word("symbol");
  }
  n(qre, "TSSymbolKeyword");
  function Vre() {
    this.word("void");
  }
  n(Vre, "TSVoidKeyword");
  function Kre() {
    this.word("undefined");
  }
  n(Kre, "TSUndefinedKeyword");
  function Wre() {
    this.word("null");
  }
  n(Wre, "TSNullKeyword");
  function Yre() {
    this.word("never");
  }
  n(Yre, "TSNeverKeyword");
  function Jre() {
    this.word("intrinsic");
  }
  n(Jre, "TSIntrinsicKeyword");
  function Xre() {
    this.word("this");
  }
  n(Xre, "TSThisType");
  function $re(t) {
    this.tsPrintFunctionOrConstructorType(t);
  }
  n($re, "TSFunctionType");
  function Hre(t) {
    t.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(t);
  }
  n(Hre, "TSConstructorType");
  function zre(t) {
    let {
      typeParameters: e
    } = t, r = t.parameters;
    this.print(e, t), this.tokenChar(40), this._parameters(r, t), this.tokenChar(41), this.space(), this.token("=>"), this.space();
    let s = t.typeAnnotation;
    this.print(s.typeAnnotation, t);
  }
  n(zre, "tsPrintFunctionOrConstructorType");
  function Gre(t) {
    this.print(t.typeName, t, !0), this.print(t.typeParameters, t, !0);
  }
  n(Gre, "TSTypeReference");
  function Qre(t) {
    t.asserts && (this.word("asserts"), this.space()), this.print(t.parameterName), t.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(t.typeAnnotation.typeAnnotation));
  }
  n(Qre, "TSTypePredicate");
  function Zre(t) {
    this.word("typeof"), this.space(), this.print(t.exprName), t.typeParameters && this.print(t.typeParameters, t);
  }
  n(Zre, "TSTypeQuery");
  function ese(t) {
    this.tsPrintTypeLiteralOrInterfaceBody(t.members, t);
  }
  n(ese, "TSTypeLiteral");
  function tse(t, e) {
    fd(this, t, e);
  }
  n(tse, "tsPrintTypeLiteralOrInterfaceBody");
  function fd(t, e, r) {
    if (t.token("{"), e.length) {
      t.indent(), t.newline();
      for (let s of e)
        t.print(s, r), t.newline();
      t.dedent();
    }
    t.rightBrace(r);
  }
  n(fd, "tsPrintBraced");
  function rse(t) {
    this.print(t.elementType, t, !0), this.token("[]");
  }
  n(rse, "TSArrayType");
  function sse(t) {
    this.tokenChar(91), this.printList(t.elementTypes, t), this.tokenChar(93);
  }
  n(sse, "TSTupleType");
  function ise(t) {
    this.print(t.typeAnnotation, t), this.tokenChar(63);
  }
  n(ise, "TSOptionalType");
  function nse(t) {
    this.token("..."), this.print(t.typeAnnotation, t);
  }
  n(nse, "TSRestType");
  function ase(t) {
    this.print(t.label, t), t.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(t.elementType, t);
  }
  n(ase, "TSNamedTupleMember");
  function ose(t) {
    EE(this, t, "|");
  }
  n(ose, "TSUnionType");
  function lse(t) {
    EE(this, t, "&");
  }
  n(lse, "TSIntersectionType");
  function EE(t, e, r) {
    t.printJoin(e.types, e, {
      separator() {
        this.space(), this.token(r), this.space();
      }
    });
  }
  n(EE, "tsPrintUnionOrIntersectionType");
  function use(t) {
    this.print(t.checkType), this.space(), this.word("extends"), this.space(), this.print(t.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(t.trueType), this.space(), this.tokenChar(58), this.space(), this.print(t.falseType);
  }
  n(use, "TSConditionalType");
  function cse(t) {
    this.token("infer"), this.space(), this.print(t.typeParameter);
  }
  n(cse, "TSInferType");
  function pse(t) {
    this.tokenChar(40), this.print(t.typeAnnotation, t), this.tokenChar(41);
  }
  n(pse, "TSParenthesizedType");
  function fse(t) {
    this.word(t.operator), this.space(), this.print(t.typeAnnotation, t);
  }
  n(fse, "TSTypeOperator");
  function hse(t) {
    this.print(t.objectType, t, !0), this.tokenChar(91), this.print(t.indexType, t), this.tokenChar(93);
  }
  n(hse, "TSIndexedAccessType");
  function dse(t) {
    let {
      nameType: e,
      optional: r,
      readonly: s,
      typeParameter: i,
      typeAnnotation: a
    } = t;
    this.tokenChar(123), this.space(), s && (PE(this, s), this.word("readonly"), this.space()), this.tokenChar(91), this.word(i.name), this.
    space(), this.word("in"), this.space(), this.print(i.constraint, i), e && (this.space(), this.word("as"), this.space(), this.print(e, t)),
    this.tokenChar(93), r && (PE(this, r), this.tokenChar(63)), a && (this.tokenChar(58), this.space(), this.print(a, t)), this.space(), this.
    tokenChar(125);
  }
  n(dse, "TSMappedType");
  function PE(t, e) {
    e !== !0 && t.token(e);
  }
  n(PE, "tokenIfPlusMinus");
  function mse(t) {
    this.print(t.literal, t);
  }
  n(mse, "TSLiteralType");
  function yse(t) {
    this.print(t.expression, t), this.print(t.typeParameters, t);
  }
  n(yse, "TSExpressionWithTypeArguments");
  function Tse(t) {
    let {
      declare: e,
      id: r,
      typeParameters: s,
      extends: i,
      body: a
    } = t;
    e && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r, t), this.print(s, t), i != null && i.length &&
    (this.space(), this.word("extends"), this.space(), this.printList(i, t)), this.space(), this.print(a, t);
  }
  n(Tse, "TSInterfaceDeclaration");
  function bse(t) {
    this.tsPrintTypeLiteralOrInterfaceBody(t.body, t);
  }
  n(bse, "TSInterfaceBody");
  function xse(t) {
    let {
      declare: e,
      id: r,
      typeParameters: s,
      typeAnnotation: i
    } = t;
    e && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r, t), this.print(s, t), this.space(), this.tokenChar(
    61), this.space(), this.print(i, t), this.tokenChar(59);
  }
  n(xse, "TSTypeAliasDeclaration");
  function Sse(t) {
    var e;
    let {
      type: r,
      expression: s,
      typeAnnotation: i
    } = t, a = !!((e = s.trailingComments) != null && e.length);
    this.print(s, t, !0, void 0, a), this.space(), this.word(r === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(i, t);
  }
  n(Sse, "TSTypeExpression");
  function gse(t) {
    let {
      typeAnnotation: e,
      expression: r
    } = t;
    this.tokenChar(60), this.print(e, t), this.tokenChar(62), this.space(), this.print(r, t);
  }
  n(gse, "TSTypeAssertion");
  function Pse(t) {
    this.print(t.expression, t), this.print(t.typeParameters, t);
  }
  n(Pse, "TSInstantiationExpression");
  function Ese(t) {
    let {
      declare: e,
      const: r,
      id: s,
      members: i
    } = t;
    e && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(s, t), this.
    space(), fd(this, i, t);
  }
  n(Ese, "TSEnumDeclaration");
  function Ase(t) {
    let {
      id: e,
      initializer: r
    } = t;
    this.print(e, t), r && (this.space(), this.tokenChar(61), this.space(), this.print(r, t)), this.tokenChar(44);
  }
  n(Ase, "TSEnumMember");
  function vse(t) {
    let {
      declare: e,
      id: r
    } = t;
    if (e && (this.word("declare"), this.space()), t.global || (this.word(r.type === "Identifier" ? "namespace" : "module"), this.space()), this.
    print(r, t), !t.body) {
      this.tokenChar(59);
      return;
    }
    let s = t.body;
    for (; s.type === "TSModuleDeclaration"; )
      this.tokenChar(46), this.print(s.id, s), s = s.body;
    this.space(), this.print(s, t);
  }
  n(vse, "TSModuleDeclaration");
  function Cse(t) {
    fd(this, t.body, t);
  }
  n(Cse, "TSModuleBlock");
  function Ise(t) {
    let {
      argument: e,
      qualifier: r,
      typeParameters: s
    } = t;
    this.word("import"), this.tokenChar(40), this.print(e, t), this.tokenChar(41), r && (this.tokenChar(46), this.print(r, t)), s && this.print(
    s, t);
  }
  n(Ise, "TSImportType");
  function wse(t) {
    let {
      isExport: e,
      id: r,
      moduleReference: s
    } = t;
    e && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r, t), this.space(), this.tokenChar(61), this.space(),
    this.print(s, t), this.tokenChar(59);
  }
  n(wse, "TSImportEqualsDeclaration");
  function Nse(t) {
    this.token("require("), this.print(t.expression, t), this.tokenChar(41);
  }
  n(Nse, "TSExternalModuleReference");
  function Ose(t) {
    this.print(t.expression, t), this.tokenChar(33);
  }
  n(Ose, "TSNonNullExpression");
  function kse(t) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(t.expression, t), this.tokenChar(59);
  }
  n(kse, "TSExportAssignment");
  function Dse(t) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(t.id, t);
  }
  n(Dse, "TSNamespaceExportDeclaration");
  function _se(t) {
    let {
      typeParameters: e
    } = t, r = t.parameters;
    this.print(e, t), this.tokenChar(40), this._parameters(r, t), this.tokenChar(41);
    let s = t.typeAnnotation;
    this.print(s, t);
  }
  n(_se, "tsPrintSignatureDeclarationBase");
  function Lse(t) {
    let e = t.type === "ClassAccessorProperty" || t.type === "ClassProperty";
    e && t.declare && (this.word("declare"), this.space()), t.accessibility && (this.word(t.accessibility), this.space()), t.static && (this.
    word("static"), this.space()), t.override && (this.word("override"), this.space()), t.abstract && (this.word("abstract"), this.space()),
    e && t.readonly && (this.word("readonly"), this.space());
  }
  n(Lse, "tsPrintClassMemberModifiers");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/index.js
var vE = w((Qe) => {
  "use strict";
  Object.defineProperty(Qe, "__esModule", {
    value: !0
  });
  var hd = sE();
  Object.keys(hd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === hd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return hd[t];
      }, "get")
    });
  });
  var dd = aE();
  Object.keys(dd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === dd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return dd[t];
      }, "get")
    });
  });
  var md = cE();
  Object.keys(md).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === md[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return md[t];
      }, "get")
    });
  });
  var yd = pE();
  Object.keys(yd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === yd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return yd[t];
      }, "get")
    });
  });
  var Td = fE();
  Object.keys(Td).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === Td[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Td[t];
      }, "get")
    });
  });
  var bd = ld();
  Object.keys(bd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === bd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return bd[t];
      }, "get")
    });
  });
  var xd = cd();
  Object.keys(xd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === xd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return xd[t];
      }, "get")
    });
  });
  var Sd = xE();
  Object.keys(Sd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === Sd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Sd[t];
      }, "get")
    });
  });
  var gd = SE();
  Object.keys(gd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === gd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return gd[t];
      }, "get")
    });
  });
  var Pd = gE();
  Object.keys(Pd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === Pd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Pd[t];
      }, "get")
    });
  });
  var Ed = AE();
  Object.keys(Ed).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === Ed[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Ed[t];
      }, "get")
    });
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/printer.js
var IE = w((mu) => {
  "use strict";
  Object.defineProperty(mu, "__esModule", {
    value: !0
  });
  mu.default = void 0;
  var Mse = WP(), Bse = ad(), Fse = Ce(), jse = vE(), {
    isFunction: Rse,
    isStatement: Use,
    isClassBody: qse,
    isTSInterfaceBody: Vse,
    isTSEnumDeclaration: Kse
  } = Fse, Wse = /e/i, Yse = /\.0+$/, CE = /[\n\r\u2028\u2029]/, Jse = /[\n\r\u2028\u2029]|\*\//, {
    needsParens: Xse
  } = Bse, qa = class {
    static {
      n(this, "Printer");
    }
    constructor(e, r) {
      this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState =
      null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger =
      !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = e, this.
      _indentRepeat = e.indent.style.length, this._inputMap = r?._inputMap, this._buf = new Mse.default(r, e.indent.style[0]);
    }
    generate(e) {
      return this.print(e), this._maybeAddAuxComment(), this._buf.get();
    }
    indent() {
      this.format.compact || this.format.concise || this._indent++;
    }
    dedent() {
      this.format.compact || this.format.concise || this._indent--;
    }
    semicolon(e = !1) {
      this._maybeAddAuxComment(), e ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(e) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
    }
    rightParens(e) {
      this.sourceWithOffset("end", e.loc, -1), this.tokenChar(41);
    }
    space(e = !1) {
      if (!this.format.compact) {
        if (e)
          this._space();
        else if (this._buf.hasContent()) {
          let r = this.getLastChar();
          r !== 32 && r !== 10 && this._space();
        }
      }
    }
    word(e, r = !1) {
      this._maybePrintInnerComments(), (this._endsWithWord || e.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(),
      this._append(e, !1), this._endsWithWord = !0, this._noLineTerminator = r;
    }
    number(e, r) {
      function s(i) {
        if (i.length > 2 && i.charCodeAt(0) === 48) {
          let a = i.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      n(s, "isNonDecimalLiteral"), this.word(e), this._endsWithInteger = Number.isInteger(r) && !s(e) && !Wse.test(e) && !Yse.test(e) && e.charCodeAt(
      e.length - 1) !== 46;
    }
    token(e, r = !1) {
      this._maybePrintInnerComments();
      let s = this.getLastChar(), i = e.charCodeAt(0);
      (s === 33 && (e === "--" || i === 61) || i === 43 && s === 43 || i === 45 && s === 45 || i === 46 && this._endsWithInteger) && this._space(),
      this._maybeAddAuxComment(), this._append(e, r), this._noLineTerminator = !1;
    }
    tokenChar(e) {
      this._maybePrintInnerComments();
      let r = this.getLastChar();
      (e === 43 && r === 43 || e === 45 && r === 45 || e === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this.
      _appendChar(e), this._noLineTerminator = !1;
    }
    newline(e = 1, r) {
      if (!(e <= 0)) {
        if (!r) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        e > 2 && (e = 2), e -= this._buf.getNewlineCount();
        for (let s = 0; s < e; s++)
          this._newline();
      }
    }
    endsWith(e) {
      return this.getLastChar() === e;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(e, r) {
      if (!e) {
        r();
        return;
      }
      this._catchUp("start", e), this._buf.exactSource(e, r);
    }
    source(e, r) {
      r && (this._catchUp(e, r), this._buf.source(e, r));
    }
    sourceWithOffset(e, r, s) {
      r && (this._catchUp(e, r), this._buf.sourceWithOffset(e, r, s));
    }
    withSource(e, r, s) {
      if (!r) {
        s();
        return;
      }
      this._catchUp(e, r), this._buf.withSource(e, r, s);
    }
    sourceIdentifierName(e, r) {
      if (!this._buf._canMarkIdName) return;
      let s = this._buf._sourcePosition;
      s.identifierNamePos = r, s.identifierName = e;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _append(e, r) {
      this._maybeAddParen(e), this._maybeIndent(e.charCodeAt(0)), this._buf.append(e, r), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _appendChar(e) {
      this._maybeAddParenChar(e), this._maybeIndent(e), this._buf.appendChar(e), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _queue(e) {
      this._maybeAddParenChar(e), this._maybeIndent(e), this._buf.queue(e), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(e) {
      this._indent && e !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(e) {
      if (this._indent && e !== 10 && this.endsWith(10))
        return !0;
    }
    _maybeAddParenChar(e) {
      let r = this._parenPushNewlineState;
      if (r && e !== 32) {
        if (e !== 10) {
          this._parenPushNewlineState = null;
          return;
        }
        this.tokenChar(40), this.indent(), r.printed = !0;
      }
    }
    _maybeAddParen(e) {
      let r = this._parenPushNewlineState;
      if (!r) return;
      let s = e.length, i;
      for (i = 0; i < s && e.charCodeAt(i) === 32; i++) ;
      if (i === s)
        return;
      let a = e.charCodeAt(i);
      if (a !== 10) {
        if (a !== 47 || i + 1 === s) {
          this._parenPushNewlineState = null;
          return;
        }
        let o = e.charCodeAt(i + 1);
        if (o === 42)
          return;
        if (o !== 47) {
          this._parenPushNewlineState = null;
          return;
        }
      }
      this.tokenChar(40), this.indent(), r.printed = !0;
    }
    catchUp(e) {
      if (!this.format.retainLines) return;
      let r = e - this._buf.getCurrentLine();
      for (let s = 0; s < r; s++)
        this._newline();
    }
    _catchUp(e, r) {
      var s;
      if (!this.format.retainLines) return;
      let i = r == null || (s = r[e]) == null ? void 0 : s.line;
      if (i != null) {
        let a = i - this._buf.getCurrentLine();
        for (let o = 0; o < a; o++)
          this._newline();
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(e, r, s) {
      if (s)
        this._noLineTerminator = !0, this.print(e, r);
      else {
        let i = {
          printed: !1
        };
        this._parenPushNewlineState = i, this.print(e, r), i.printed && (this.dedent(), this.newline(), this.tokenChar(41));
      }
    }
    print(e, r, s, i, a) {
      var o, l;
      if (!e) return;
      this._endsWithInnerRaw = !1;
      let u = e.type, c = this.format, p = c.concise;
      e._compact && (c.concise = !0);
      let f = this[u];
      if (f === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(u)} with constructor ${JSON.stringify(e.constructor.name)}`);
      this._printStack.push(e);
      let m = this._insideAux;
      this._insideAux = e.loc == null, this._maybeAddAuxComment(this._insideAux && !m);
      let y = (o = e.extra) == null ? void 0 : o.parenthesized, T = a || y && c.retainFunctionParens && u === "FunctionExpression" || Xse(e,
      r, this._printStack);
      if (!T && y && (l = e.leadingComments) != null && l.length && e.leadingComments[0].type === "CommentBlock")
        switch (r?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (r.callee !== e) break;
          default:
            T = !0;
        }
      T && (this.tokenChar(40), this._endsWithInnerRaw = !1), this._lastCommentLine = 0, this._printLeadingComments(e, r);
      let L = u === "Program" || u === "File" ? null : e.loc;
      this.exactSource(L, f.bind(this, e, r)), T ? (this._printTrailingComments(e, r), this.tokenChar(41), this._noLineTerminator = s) : s &&
      !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(e, r)) : this._printTrailingComments(e, r, i), this.
      _printStack.pop(), c.concise = p, this._insideAux = m, this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(e) {
      e && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let e = this.format.auxiliaryCommentBefore;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let e = this.format.auxiliaryCommentAfter;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    getPossibleRaw(e) {
      let r = e.extra;
      if (r?.raw != null && r.rawValue != null && e.value === r.rawValue)
        return r.raw;
    }
    printJoin(e, r, s = {}) {
      if (!(e != null && e.length)) return;
      let {
        indent: i
      } = s;
      if (i == null && this.format.retainLines) {
        var a;
        let f = (a = e[0].loc) == null ? void 0 : a.start.line;
        f != null && f !== this._buf.getCurrentLine() && (i = !0);
      }
      i && this.indent();
      let o = {
        addNewlines: s.addNewlines,
        nextNodeStartLine: 0
      }, l = s.separator ? s.separator.bind(this) : null, u = e.length;
      for (let f = 0; f < u; f++) {
        let m = e[f];
        if (m && (s.statement && this._printNewline(f === 0, o), this.print(m, r, void 0, s.trailingCommentsLineOffset || 0), s.iterator == null ||
        s.iterator(m, f), f < u - 1 && l?.(), s.statement)) {
          var c;
          if ((c = m.trailingComments) != null && c.length || (this._lastCommentLine = 0), f + 1 === u)
            this.newline(1);
          else {
            var p;
            let y = e[f + 1];
            o.nextNodeStartLine = ((p = y.loc) == null ? void 0 : p.start.line) || 0, this._printNewline(!0, o);
          }
        }
      }
      i && this.dedent();
    }
    printAndIndentOnComments(e, r) {
      let s = e.leadingComments && e.leadingComments.length > 0;
      s && this.indent(), this.print(e, r), s && this.dedent();
    }
    printBlock(e) {
      let r = e.body;
      r.type !== "EmptyStatement" && this.space(), this.print(r, e);
    }
    _printTrailingComments(e, r, s) {
      let {
        innerComments: i,
        trailingComments: a
      } = e;
      i != null && i.length && this._printComments(2, i, e, r, s), a != null && a.length && this._printComments(2, a, e, r, s);
    }
    _printLeadingComments(e, r) {
      let s = e.leadingComments;
      s != null && s.length && this._printComments(0, s, e, r);
    }
    _maybePrintInnerComments() {
      this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments() {
      let e = this._printStack[this._printStack.length - 1], r = e.innerComments;
      if (!(r != null && r.length)) return;
      let s = this.endsWith(32), i = this._indentInnerComments, a = this._printedComments.size;
      i && this.indent(), this._printComments(1, r, e), s && a !== this._printedComments.size && this.space(), i && this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(e, r, s = {}) {
      var i;
      s.statement = !0, (i = s.indent) != null || (s.indent = !1), this.printJoin(e, r, s);
    }
    printList(e, r, s = {}) {
      s.separator == null && (s.separator = $se), this.printJoin(e, r, s);
    }
    _printNewline(e, r) {
      let s = this.format;
      if (s.retainLines || s.compact) return;
      if (s.concise) {
        this.space();
        return;
      }
      if (!e)
        return;
      let i = r.nextNodeStartLine, a = this._lastCommentLine;
      if (i > 0 && a > 0) {
        let o = i - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(e) {
      return e.ignore || this._printedComments.has(e) ? 0 : this._noLineTerminator && Jse.test(e.value) ? 2 : (this._printedComments.add(e),
      this.format.shouldPrintComment(e.value) ? 1 : 0);
    }
    _printComment(e, r) {
      let s = this._noLineTerminator, i = e.type === "CommentBlock", a = i && r !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && r !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && this.space();
      let l;
      if (i) {
        let {
          _parenPushNewlineState: c
        } = this;
        if (c?.printed === !1 && CE.test(e.value) && (this.tokenChar(40), this.indent(), c.printed = !0), l = `/*${e.value}*/`, this.format.
        indent.adjustMultilineComment) {
          var u;
          let p = (u = e.loc) == null ? void 0 : u.start.column;
          if (p) {
            let f = new RegExp("\\n\\s{1," + p + "}", "g");
            l = l.replace(f, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let f = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (f += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(f)}`);
          }
        }
      } else s ? l = `/*${e.value}*/` : l = `//${e.value}`;
      this.endsWith(47) && this._space(), this.source("start", e.loc), this._append(l, i), !i && !s && this.newline(1, !0), a && r !== 3 && this.
      newline(1);
    }
    _printComments(e, r, s, i, a = 0) {
      let o = s.loc, l = r.length, u = !!o, c = u ? o.start.line : 0, p = u ? o.end.line : 0, f = 0, m = 0, y = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let T = 0; T < l; T++) {
        let L = r[T], q = this._shouldPrintComment(L);
        if (q === 2) {
          u = !1;
          break;
        }
        if (u && L.loc && q === 1) {
          let _ = L.loc.start.line, U = L.loc.end.line;
          if (e === 0) {
            let J = 0;
            T === 0 ? this._buf.hasContent() && (L.type === "CommentLine" || _ != U) && (J = m = 1) : J = _ - f, f = U, y(J), this._printComment(
            L, 1), T + 1 === l && (y(Math.max(c - f, m)), f = c);
          } else if (e === 1) {
            let J = _ - (T === 0 ? c : f);
            f = U, y(J), this._printComment(L, 1), T + 1 === l && (y(Math.min(1, p - f)), f = p);
          } else {
            let J = _ - (T === 0 ? p - a : f);
            f = U, y(J), this._printComment(L, 1);
          }
        } else {
          if (u = !1, q !== 1)
            continue;
          if (l === 1) {
            let _ = L.loc ? L.loc.start.line === L.loc.end.line : !CE.test(L.value), U = _ && !Use(s) && !qse(i) && !Vse(i) && !Kse(i);
            e === 0 ? this._printComment(L, U && s.type !== "ObjectExpression" || _ && Rse(i, {
              body: s
            }) ? 1 : 0) : U && e === 2 ? this._printComment(L, 1) : this._printComment(L, 0);
          } else e === 1 && !(s.type === "ObjectExpression" && s.properties.length > 1) && s.type !== "ClassBody" && s.type !== "TSInterface\
Body" ? this._printComment(L, T === 0 ? 2 : T === l - 1 ? 3 : 0) : this._printComment(L, 0);
        }
      }
      e === 2 && u && f && (this._lastCommentLine = f);
    }
  };
  Object.assign(qa.prototype, jse);
  qa.prototype.Noop = /* @__PURE__ */ n(function() {
  }, "Noop");
  var rje = mu.default = qa;
  function $se() {
    this.tokenChar(44), this.space();
  }
  n($se, "commaSeparator");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/index.js
var kE = w((yu) => {
  "use strict";
  Object.defineProperty(yu, "__esModule", {
    value: !0
  });
  yu.default = Hse;
  var wE = KP(), NE = IE();
  function OE(t, e) {
    var r;
    let s = {
      auxiliaryCommentBefore: e.auxiliaryCommentBefore,
      auxiliaryCommentAfter: e.auxiliaryCommentAfter,
      shouldPrintComment: e.shouldPrintComment,
      retainLines: e.retainLines,
      retainFunctionParens: e.retainFunctionParens,
      comments: e.comments == null || e.comments,
      compact: e.compact,
      minified: e.minified,
      concise: e.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, e.jsescOption),
      recordAndTupleSyntaxType: (r = e.recordAndTupleSyntaxType) != null ? r : "hash",
      topicToken: e.topicToken,
      importAttributesKeyword: e.importAttributesKeyword
    };
    s.decoratorsBeforeExport = e.decoratorsBeforeExport, s.jsescOption.json = e.jsonCompatibleStrings, s.minified ? (s.compact = !0, s.shouldPrintComment =
    s.shouldPrintComment || (() => s.comments)) : s.shouldPrintComment = s.shouldPrintComment || ((l) => s.comments || l.includes("@license") ||
    l.includes("@preserve")), s.compact === "auto" && (s.compact = typeof t == "string" && t.length > 5e5, s.compact && console.error(`[BABE\
L] Note: The code generator has deoptimised the styling of ${e.filename} as it exceeds the max of 500KB.`)), s.compact && (s.indent.adjustMultilineComment =
    !1);
    let {
      auxiliaryCommentBefore: i,
      auxiliaryCommentAfter: a,
      shouldPrintComment: o
    } = s;
    return i && !o(i) && (s.auxiliaryCommentBefore = void 0), a && !o(a) && (s.auxiliaryCommentAfter = void 0), s;
  }
  n(OE, "normalizeOptions");
  yu.CodeGenerator = class {
    static {
      n(this, "CodeGenerator");
    }
    constructor(e, r = {}, s) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = e, this._format = OE(s, r), this._map = r.sourceMaps ? new wE.
      default(r, s) : null;
    }
    generate() {
      return new NE.default(this._format, this._map).generate(this._ast);
    }
  };
  function Hse(t, e = {}, r) {
    let s = OE(r, e), i = e.sourceMaps ? new wE.default(e, r) : null;
    return new NE.default(s, i).generate(t);
  }
  n(Hse, "generate");
});

// ../node_modules/@babel/traverse/lib/path/ancestry.js
var DE = w((Ur) => {
  "use strict";
  Object.defineProperty(Ur, "__esModule", {
    value: !0
  });
  Ur.find = Zse;
  Ur.findParent = Qse;
  Ur.getAncestry = iie;
  Ur.getDeepestCommonAncestorFrom = sie;
  Ur.getEarliestCommonAncestorFrom = rie;
  Ur.getFunctionParent = eie;
  Ur.getStatementParent = tie;
  Ur.inType = oie;
  Ur.isAncestor = nie;
  Ur.isDescendant = aie;
  var zse = Ce(), {
    VISITOR_KEYS: Gse
  } = zse;
  function Qse(t) {
    let e = this;
    for (; e = e.parentPath; )
      if (t(e)) return e;
    return null;
  }
  n(Qse, "findParent");
  function Zse(t) {
    let e = this;
    do
      if (t(e)) return e;
    while (e = e.parentPath);
    return null;
  }
  n(Zse, "find");
  function eie() {
    return this.findParent((t) => t.isFunction());
  }
  n(eie, "getFunctionParent");
  function tie() {
    let t = this;
    do {
      if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
        break;
      t = t.parentPath;
    } while (t);
    if (t && (t.isProgram() || t.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return t;
  }
  n(tie, "getStatementParent");
  function rie(t) {
    return this.getDeepestCommonAncestorFrom(t, function(e, r, s) {
      let i, a = Gse[e.type];
      for (let o of s) {
        let l = o[r + 1];
        if (!i) {
          i = l;
          continue;
        }
        if (l.listKey && i.listKey === l.listKey && l.key < i.key) {
          i = l;
          continue;
        }
        let u = a.indexOf(i.parentKey), c = a.indexOf(l.parentKey);
        u > c && (i = l);
      }
      return i;
    });
  }
  n(rie, "getEarliestCommonAncestorFrom");
  function sie(t, e) {
    if (!t.length)
      return this;
    if (t.length === 1)
      return t[0];
    let r = 1 / 0, s, i, a = t.map((l) => {
      let u = [];
      do
        u.unshift(l);
      while ((l = l.parentPath) && l !== this);
      return u.length < r && (r = u.length), u;
    }), o = a[0];
    e: for (let l = 0; l < r; l++) {
      let u = o[l];
      for (let c of a)
        if (c[l] !== u)
          break e;
      s = l, i = u;
    }
    if (i)
      return e ? e(i, s, a) : i;
    throw new Error("Couldn't find intersection");
  }
  n(sie, "getDeepestCommonAncestorFrom");
  function iie() {
    let t = this, e = [];
    do
      e.push(t);
    while (t = t.parentPath);
    return e;
  }
  n(iie, "getAncestry");
  function nie(t) {
    return t.isDescendant(this);
  }
  n(nie, "isAncestor");
  function aie(t) {
    return !!this.findParent((e) => e === t);
  }
  n(aie, "isDescendant");
  function oie(...t) {
    let e = this;
    for (; e; ) {
      for (let r of t)
        if (e.node.type === r) return !0;
      e = e.parentPath;
    }
    return !1;
  }
  n(oie, "inType");
});

// ../node_modules/@babel/traverse/lib/path/inference/util.js
var vd = w((Ad) => {
  "use strict";
  Object.defineProperty(Ad, "__esModule", {
    value: !0
  });
  Ad.createUnionType = fie;
  var lie = Ce(), {
    createFlowUnionType: _E,
    createTSUnionType: LE,
    createUnionTypeAnnotation: uie,
    isFlowType: cie,
    isTSType: pie
  } = lie;
  function fie(t) {
    {
      if (t.every((e) => cie(e)))
        return _E ? _E(t) : uie(t);
      if (t.every((e) => pie(e)) && LE)
        return LE(t);
    }
  }
  n(fie, "createUnionType");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var RE = w((Cd) => {
  "use strict";
  Object.defineProperty(Cd, "__esModule", {
    value: !0
  });
  Cd.default = Tie;
  var hie = Ce(), BE = vd(), {
    BOOLEAN_NUMBER_BINARY_OPERATORS: die,
    createTypeAnnotationBasedOnTypeof: mie,
    numberTypeAnnotation: FE,
    voidTypeAnnotation: yie
  } = hie;
  function Tie(t) {
    if (!this.isReferenced()) return;
    let e = this.scope.getBinding(t.name);
    if (e)
      return e.identifier.typeAnnotation ? e.identifier.typeAnnotation : bie(e, this, t.name);
    if (t.name === "undefined")
      return yie();
    if (t.name === "NaN" || t.name === "Infinity")
      return FE();
    t.name;
  }
  n(Tie, "_default");
  function bie(t, e, r) {
    let s = [], i = [], a = ME(t, e, i), o = jE(t, e, r);
    if (o) {
      let l = ME(t, o.ifStatement);
      a = a.filter((u) => l.indexOf(u) < 0), s.push(o.typeAnnotation);
    }
    if (a.length) {
      a.push(...i);
      for (let l of a)
        s.push(l.getTypeAnnotation());
    }
    if (s.length)
      return (0, BE.createUnionType)(s);
  }
  n(bie, "getTypeAnnotationBindingConstantViolations");
  function ME(t, e, r) {
    let s = t.constantViolations.slice();
    return s.unshift(t.path), s.filter((i) => {
      i = i.resolve();
      let a = i._guessExecutionStatusRelativeTo(e);
      return r && a === "unknown" && r.push(i), a === "before";
    });
  }
  n(ME, "getConstantViolationsBefore");
  function xie(t, e) {
    let r = e.node.operator, s = e.get("right").resolve(), i = e.get("left").resolve(), a;
    if (i.isIdentifier({
      name: t
    }) ? a = s : s.isIdentifier({
      name: t
    }) && (a = i), a)
      return r === "===" ? a.getTypeAnnotation() : die.indexOf(r) >= 0 ? FE() : void 0;
    if (r !== "===" && r !== "==") return;
    let o, l;
    if (i.isUnaryExpression({
      operator: "typeof"
    }) ? (o = i, l = s) : s.isUnaryExpression({
      operator: "typeof"
    }) && (o = s, l = i), !o || !o.get("argument").isIdentifier({
      name: t
    }) || (l = l.resolve(), !l.isLiteral())) return;
    let u = l.node.value;
    if (typeof u == "string")
      return mie(u);
  }
  n(xie, "inferAnnotationFromBinaryExpression");
  function Sie(t, e, r) {
    let s;
    for (; s = e.parentPath; ) {
      if (s.isIfStatement() || s.isConditionalExpression())
        return e.key === "test" ? void 0 : s;
      if (s.isFunction() && s.parentPath.scope.getBinding(r) !== t)
        return;
      e = s;
    }
  }
  n(Sie, "getParentConditionalPath");
  function jE(t, e, r) {
    let s = Sie(t, e, r);
    if (!s) return;
    let a = [s.get("test")], o = [];
    for (let l = 0; l < a.length; l++) {
      let u = a[l];
      if (u.isLogicalExpression())
        u.node.operator === "&&" && (a.push(u.get("left")), a.push(u.get("right")));
      else if (u.isBinaryExpression()) {
        let c = xie(r, u);
        c && o.push(c);
      }
    }
    return o.length ? {
      typeAnnotation: (0, BE.createUnionType)(o),
      ifStatement: s
    } : jE(t, s, r);
  }
  n(jE, "getConditionalAnnotation");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferers.js
var XE = w((pt) => {
  "use strict";
  Object.defineProperty(pt, "__esModule", {
    value: !0
  });
  pt.ArrayExpression = WE;
  pt.AssignmentExpression = Kie;
  pt.BinaryExpression = jie;
  pt.BooleanLiteral = Xie;
  pt.CallExpression = rne;
  pt.ConditionalExpression = Uie;
  pt.ClassDeclaration = pt.ClassExpression = pt.FunctionDeclaration = pt.ArrowFunctionExpression = pt.FunctionExpression = Gie;
  Object.defineProperty(pt, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Pie.default;
    }, "get")
  });
  pt.LogicalExpression = Rie;
  pt.NewExpression = Mie;
  pt.NullLiteral = $ie;
  pt.NumericLiteral = Jie;
  pt.ObjectExpression = zie;
  pt.ParenthesizedExpression = Vie;
  pt.RegExpLiteral = Hie;
  pt.RestElement = YE;
  pt.SequenceExpression = qie;
  pt.StringLiteral = Yie;
  pt.TSAsExpression = KE;
  pt.TSNonNullExpression = Lie;
  pt.TaggedTemplateExpression = sne;
  pt.TemplateLiteral = Bie;
  pt.TypeCastExpression = VE;
  pt.UnaryExpression = Fie;
  pt.UpdateExpression = Wie;
  pt.VariableDeclarator = _ie;
  var gie = Ce(), Pie = RE(), qE = vd(), {
    BOOLEAN_BINARY_OPERATORS: Eie,
    BOOLEAN_UNARY_OPERATORS: Aie,
    NUMBER_BINARY_OPERATORS: vie,
    NUMBER_UNARY_OPERATORS: Cie,
    STRING_UNARY_OPERATORS: Iie,
    anyTypeAnnotation: UE,
    arrayTypeAnnotation: Id,
    booleanTypeAnnotation: wd,
    buildMatchMemberExpression: Tu,
    genericTypeAnnotation: Zs,
    identifier: Ui,
    nullLiteralTypeAnnotation: wie,
    numberTypeAnnotation: An,
    stringTypeAnnotation: qi,
    tupleTypeAnnotation: Nie,
    unionTypeAnnotation: Oie,
    voidTypeAnnotation: kie,
    isIdentifier: Die
  } = gie;
  function _ie() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  n(_ie, "VariableDeclarator");
  function VE(t) {
    return t.typeAnnotation;
  }
  n(VE, "TypeCastExpression");
  VE.validParent = !0;
  function KE(t) {
    return t.typeAnnotation;
  }
  n(KE, "TSAsExpression");
  KE.validParent = !0;
  function Lie() {
    return this.get("expression").getTypeAnnotation();
  }
  n(Lie, "TSNonNullExpression");
  function Mie(t) {
    if (t.callee.type === "Identifier")
      return Zs(t.callee);
  }
  n(Mie, "NewExpression");
  function Bie() {
    return qi();
  }
  n(Bie, "TemplateLiteral");
  function Fie(t) {
    let e = t.operator;
    if (e === "void")
      return kie();
    if (Cie.indexOf(e) >= 0)
      return An();
    if (Iie.indexOf(e) >= 0)
      return qi();
    if (Aie.indexOf(e) >= 0)
      return wd();
  }
  n(Fie, "UnaryExpression");
  function jie(t) {
    let e = t.operator;
    if (vie.indexOf(e) >= 0)
      return An();
    if (Eie.indexOf(e) >= 0)
      return wd();
    if (e === "+") {
      let r = this.get("right"), s = this.get("left");
      return s.isBaseType("number") && r.isBaseType("number") ? An() : s.isBaseType("string") || r.isBaseType("string") ? qi() : Oie([qi(), An()]);
    }
  }
  n(jie, "BinaryExpression");
  function Rie() {
    let t = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, qE.createUnionType)(t);
  }
  n(Rie, "LogicalExpression");
  function Uie() {
    let t = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, qE.createUnionType)(t);
  }
  n(Uie, "ConditionalExpression");
  function qie() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  n(qie, "SequenceExpression");
  function Vie() {
    return this.get("expression").getTypeAnnotation();
  }
  n(Vie, "ParenthesizedExpression");
  function Kie() {
    return this.get("right").getTypeAnnotation();
  }
  n(Kie, "AssignmentExpression");
  function Wie(t) {
    let e = t.operator;
    if (e === "++" || e === "--")
      return An();
  }
  n(Wie, "UpdateExpression");
  function Yie() {
    return qi();
  }
  n(Yie, "StringLiteral");
  function Jie() {
    return An();
  }
  n(Jie, "NumericLiteral");
  function Xie() {
    return wd();
  }
  n(Xie, "BooleanLiteral");
  function $ie() {
    return wie();
  }
  n($ie, "NullLiteral");
  function Hie() {
    return Zs(Ui("RegExp"));
  }
  n(Hie, "RegExpLiteral");
  function zie() {
    return Zs(Ui("Object"));
  }
  n(zie, "ObjectExpression");
  function WE() {
    return Zs(Ui("Array"));
  }
  n(WE, "ArrayExpression");
  function YE() {
    return WE();
  }
  n(YE, "RestElement");
  YE.validParent = !0;
  function Gie() {
    return Zs(Ui("Function"));
  }
  n(Gie, "Func");
  var Qie = Tu("Array.from"), Zie = Tu("Object.keys"), ene = Tu("Object.values"), tne = Tu("Object.entries");
  function rne() {
    let {
      callee: t
    } = this.node;
    return Zie(t) ? Id(qi()) : Qie(t) || ene(t) || Die(t, {
      name: "Array"
    }) ? Id(UE()) : tne(t) ? Id(Nie([qi(), UE()])) : JE(this.get("callee"));
  }
  n(rne, "CallExpression");
  function sne() {
    return JE(this.get("tag"));
  }
  n(sne, "TaggedTemplateExpression");
  function JE(t) {
    if (t = t.resolve(), t.isFunction()) {
      let {
        node: e
      } = t;
      if (e.async)
        return e.generator ? Zs(Ui("AsyncIterator")) : Zs(Ui("Promise"));
      if (e.generator)
        return Zs(Ui("Iterator"));
      if (t.node.returnType)
        return t.node.returnType;
    }
  }
  n(JE, "resolveCall");
});

// ../node_modules/@babel/traverse/lib/path/inference/index.js
var GE = w((ei) => {
  "use strict";
  Object.defineProperty(ei, "__esModule", {
    value: !0
  });
  ei._getTypeAnnotation = Ene;
  ei.baseTypeStrictlyMatches = Cne;
  ei.couldBeBaseType = vne;
  ei.getTypeAnnotation = Pne;
  ei.isBaseType = Ane;
  ei.isGenericType = Ine;
  var $E = XE(), ine = Ce(), {
    anyTypeAnnotation: zE,
    isAnyTypeAnnotation: bu,
    isArrayTypeAnnotation: nne,
    isBooleanTypeAnnotation: ane,
    isEmptyTypeAnnotation: one,
    isFlowBaseAnnotation: lne,
    isGenericTypeAnnotation: une,
    isIdentifier: HE,
    isMixedTypeAnnotation: cne,
    isNumberTypeAnnotation: pne,
    isStringTypeAnnotation: fne,
    isTSArrayType: hne,
    isTSTypeAnnotation: dne,
    isTSTypeReference: mne,
    isTupleTypeAnnotation: yne,
    isTypeAnnotation: Tne,
    isUnionTypeAnnotation: bne,
    isVoidTypeAnnotation: xne,
    stringTypeAnnotation: Sne,
    voidTypeAnnotation: gne
  } = ine;
  function Pne() {
    let t = this.getData("typeAnnotation");
    return t != null || (t = this._getTypeAnnotation() || zE(), (Tne(t) || dne(t)) && (t = t.typeAnnotation), this.setData("typeAnnotation",
    t)), t;
  }
  n(Pne, "getTypeAnnotation");
  var Nd = /* @__PURE__ */ new WeakSet();
  function Ene() {
    let t = this.node;
    if (!t)
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        let r = this.parentPath.parentPath, s = r.parentPath;
        return r.key === "left" && s.isForInStatement() ? Sne() : r.key === "left" && s.isForOfStatement() ? zE() : gne();
      } else
        return;
    if (t.typeAnnotation)
      return t.typeAnnotation;
    if (!Nd.has(t)) {
      Nd.add(t);
      try {
        var e;
        let r = $E[t.type];
        if (r)
          return r.call(this, t);
        if (r = $E[this.parentPath.type], (e = r) != null && e.validParent)
          return this.parentPath.getTypeAnnotation();
      } finally {
        Nd.delete(t);
      }
    }
  }
  n(Ene, "_getTypeAnnotation");
  function Ane(t, e) {
    return Od(t, this.getTypeAnnotation(), e);
  }
  n(Ane, "isBaseType");
  function Od(t, e, r) {
    if (t === "string")
      return fne(e);
    if (t === "number")
      return pne(e);
    if (t === "boolean")
      return ane(e);
    if (t === "any")
      return bu(e);
    if (t === "mixed")
      return cne(e);
    if (t === "empty")
      return one(e);
    if (t === "void")
      return xne(e);
    if (r)
      return !1;
    throw new Error(`Unknown base type ${t}`);
  }
  n(Od, "_isBaseType");
  function vne(t) {
    let e = this.getTypeAnnotation();
    if (bu(e)) return !0;
    if (bne(e)) {
      for (let r of e.types)
        if (bu(r) || Od(t, r, !0))
          return !0;
      return !1;
    } else
      return Od(t, e, !0);
  }
  n(vne, "couldBeBaseType");
  function Cne(t) {
    let e = this.getTypeAnnotation(), r = t.getTypeAnnotation();
    return !bu(e) && lne(e) ? r.type === e.type : !1;
  }
  n(Cne, "baseTypeStrictlyMatches");
  function Ine(t) {
    let e = this.getTypeAnnotation();
    return t === "Array" && (hne(e) || nne(e) || yne(e)) ? !0 : une(e) && HE(e.id, {
      name: t
    }) || mne(e) && HE(e.typeName, {
      name: t
    });
  }
  n(Ine, "isGenericType");
});

// ../node_modules/js-tokens/index.js
var kd = w((xu) => {
  Object.defineProperty(xu, "__esModule", {
    value: !0
  });
  xu.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  xu.matchToToken = function(t) {
    var e = { type: "invalid", value: t[0], closed: void 0 };
    return t[1] ? (e.type = "string", e.closed = !!(t[3] || t[4])) : t[5] ? e.type = "comment" : t[6] ? (e.type = "comment", e.closed = !!t[7]) :
    t[8] ? e.type = "regex" : t[9] ? e.type = "number" : t[10] ? e.type = "name" : t[11] ? e.type = "punctuator" : t[12] && (e.type = "white\
space"), e;
  };
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-validator-identifier/lib/identifier.js
var rA = w((Va) => {
  "use strict";
  Object.defineProperty(Va, "__esModule", {
    value: !0
  });
  Va.isIdentifierChar = tA;
  Va.isIdentifierName = kne;
  Va.isIdentifierStart = eA;
  var _d = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  QE = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", wne = new RegExp("[" + _d + "]"), Nne = new RegExp("[" + _d + QE + "\
]");
  _d = QE = null;
  var ZE = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], One = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41,
  2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9,
  6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Dd(t, e) {
    let r = 65536;
    for (let s = 0, i = e.length; s < i; s += 2) {
      if (r += e[s], r > t) return !1;
      if (r += e[s + 1], r >= t) return !0;
    }
    return !1;
  }
  n(Dd, "isInAstralSet");
  function eA(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && wne.test(String.fromCharCode(t)) :
    Dd(t, ZE);
  }
  n(eA, "isIdentifierStart");
  function tA(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && Nne.test(
    String.fromCharCode(t)) : Dd(t, ZE) || Dd(t, One);
  }
  n(tA, "isIdentifierChar");
  function kne(t) {
    let e = !0;
    for (let r = 0; r < t.length; r++) {
      let s = t.charCodeAt(r);
      if ((s & 64512) === 55296 && r + 1 < t.length) {
        let i = t.charCodeAt(++r);
        (i & 64512) === 56320 && (s = 65536 + ((s & 1023) << 10) + (i & 1023));
      }
      if (e) {
        if (e = !1, !eA(s))
          return !1;
      } else if (!tA(s))
        return !1;
    }
    return !e;
  }
  n(kne, "isIdentifierName");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-validator-identifier/lib/keyword.js
var aA = w((Vi) => {
  "use strict";
  Object.defineProperty(Vi, "__esModule", {
    value: !0
  });
  Vi.isKeyword = Bne;
  Vi.isReservedWord = sA;
  Vi.isStrictBindOnlyReservedWord = nA;
  Vi.isStrictBindReservedWord = Mne;
  Vi.isStrictReservedWord = iA;
  var Ld = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, Dne = new Set(Ld.keyword), _ne = new Set(Ld.strict), Lne = new Set(Ld.strictBind);
  function sA(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(sA, "isReservedWord");
  function iA(t, e) {
    return sA(t, e) || _ne.has(t);
  }
  n(iA, "isStrictReservedWord");
  function nA(t) {
    return Lne.has(t);
  }
  n(nA, "isStrictBindOnlyReservedWord");
  function Mne(t, e) {
    return iA(t, e) || nA(t);
  }
  n(Mne, "isStrictBindReservedWord");
  function Bne(t) {
    return Dne.has(t);
  }
  n(Bne, "isKeyword");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-validator-identifier/lib/index.js
var Wa = w((ns) => {
  "use strict";
  Object.defineProperty(ns, "__esModule", {
    value: !0
  });
  Object.defineProperty(ns, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Md.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(ns, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Md.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(ns, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Md.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(ns, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ka.isKeyword;
    }, "get")
  });
  Object.defineProperty(ns, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ka.isReservedWord;
    }, "get")
  });
  Object.defineProperty(ns, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ka.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(ns, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ka.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(ns, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ka.isStrictReservedWord;
    }, "get")
  });
  var Md = rA(), Ka = aA();
});

// ../node_modules/picocolors/picocolors.js
var Ya = w((vje, Bd) => {
  var oA = process.argv || [], Su = process.env, Fne = !("NO_COLOR" in Su || oA.includes("--no-color")) && ("FORCE_COLOR" in Su || oA.includes(
  "--color") || process.platform === "win32" || require != null && require("tty").isatty(1) && Su.TERM !== "dumb" || "CI" in Su), jne = /* @__PURE__ */ n(
  (t, e, r = t) => (s) => {
    let i = "" + s, a = i.indexOf(e, t.length);
    return ~a ? t + Rne(i, e, r, a) + e : t + i + e;
  }, "formatter"), Rne = /* @__PURE__ */ n((t, e, r, s) => {
    let i = "", a = 0;
    do
      i += t.substring(a, s) + r, a = s + e.length, s = t.indexOf(e, a);
    while (~s);
    return i + t.substring(a);
  }, "replaceClose"), lA = /* @__PURE__ */ n((t = Fne) => {
    let e = t ? jne : () => String;
    return {
      isColorSupported: t,
      reset: e("\x1B[0m", "\x1B[0m"),
      bold: e("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: e("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: e("\x1B[3m", "\x1B[23m"),
      underline: e("\x1B[4m", "\x1B[24m"),
      inverse: e("\x1B[7m", "\x1B[27m"),
      hidden: e("\x1B[8m", "\x1B[28m"),
      strikethrough: e("\x1B[9m", "\x1B[29m"),
      black: e("\x1B[30m", "\x1B[39m"),
      red: e("\x1B[31m", "\x1B[39m"),
      green: e("\x1B[32m", "\x1B[39m"),
      yellow: e("\x1B[33m", "\x1B[39m"),
      blue: e("\x1B[34m", "\x1B[39m"),
      magenta: e("\x1B[35m", "\x1B[39m"),
      cyan: e("\x1B[36m", "\x1B[39m"),
      white: e("\x1B[37m", "\x1B[39m"),
      gray: e("\x1B[90m", "\x1B[39m"),
      bgBlack: e("\x1B[40m", "\x1B[49m"),
      bgRed: e("\x1B[41m", "\x1B[49m"),
      bgGreen: e("\x1B[42m", "\x1B[49m"),
      bgYellow: e("\x1B[43m", "\x1B[49m"),
      bgBlue: e("\x1B[44m", "\x1B[49m"),
      bgMagenta: e("\x1B[45m", "\x1B[49m"),
      bgCyan: e("\x1B[46m", "\x1B[49m"),
      bgWhite: e("\x1B[47m", "\x1B[49m")
    };
  }, "createColors");
  Bd.exports = lA();
  Bd.exports.createColors = lA;
});

// ../node_modules/escape-string-regexp/index.js
var Fd = w((Ije, uA) => {
  "use strict";
  var Une = /[|\\{}()[\]^$+*?.]/g;
  uA.exports = function(t) {
    if (typeof t != "string")
      throw new TypeError("Expected a string");
    return t.replace(Une, "\\$&");
  };
});

// ../node_modules/@babel/traverse/node_modules/color-name/index.js
var pA = w((wje, cA) => {
  "use strict";
  cA.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../node_modules/@babel/traverse/node_modules/color-convert/conversions.js
var jd = w((Nje, mA) => {
  var Ki = pA(), dA = {};
  for (gu in Ki)
    Ki.hasOwnProperty(gu) && (dA[Ki[gu]] = gu);
  var gu, Se = mA.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (dr in Se)
    if (Se.hasOwnProperty(dr)) {
      if (!("channels" in Se[dr]))
        throw new Error("missing channels property: " + dr);
      if (!("labels" in Se[dr]))
        throw new Error("missing channel labels property: " + dr);
      if (Se[dr].labels.length !== Se[dr].channels)
        throw new Error("channel and label counts mismatch: " + dr);
      fA = Se[dr].channels, hA = Se[dr].labels, delete Se[dr].channels, delete Se[dr].labels, Object.defineProperty(Se[dr], "channels", { value: fA }),
      Object.defineProperty(Se[dr], "labels", { value: hA });
    }
  var fA, hA, dr;
  Se.rgb.hsl = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255, i = Math.min(e, r, s), a = Math.max(e, r, s), o = a - i, l, u, c;
    return a === i ? l = 0 : e === a ? l = (r - s) / o : r === a ? l = 2 + (s - e) / o : s === a && (l = 4 + (e - r) / o), l = Math.min(l * 60,
    360), l < 0 && (l += 360), c = (i + a) / 2, a === i ? u = 0 : c <= 0.5 ? u = o / (a + i) : u = o / (2 - a - i), [l, u * 100, c * 100];
  };
  Se.rgb.hsv = function(t) {
    var e, r, s, i, a, o = t[0] / 255, l = t[1] / 255, u = t[2] / 255, c = Math.max(o, l, u), p = c - Math.min(o, l, u), f = /* @__PURE__ */ n(
    function(m) {
      return (c - m) / 6 / p + 1 / 2;
    }, "diffc");
    return p === 0 ? i = a = 0 : (a = p / c, e = f(o), r = f(l), s = f(u), o === c ? i = s - r : l === c ? i = 1 / 3 + e - s : u === c && (i =
    2 / 3 + r - e), i < 0 ? i += 1 : i > 1 && (i -= 1)), [
      i * 360,
      a * 100,
      c * 100
    ];
  };
  Se.rgb.hwb = function(t) {
    var e = t[0], r = t[1], s = t[2], i = Se.rgb.hsl(t)[0], a = 1 / 255 * Math.min(e, Math.min(r, s));
    return s = 1 - 1 / 255 * Math.max(e, Math.max(r, s)), [i, a * 100, s * 100];
  };
  Se.rgb.cmyk = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255, i, a, o, l;
    return l = Math.min(1 - e, 1 - r, 1 - s), i = (1 - e - l) / (1 - l) || 0, a = (1 - r - l) / (1 - l) || 0, o = (1 - s - l) / (1 - l) || 0,
    [i * 100, a * 100, o * 100, l * 100];
  };
  function qne(t, e) {
    return Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2) + Math.pow(t[2] - e[2], 2);
  }
  n(qne, "comparativeDistance");
  Se.rgb.keyword = function(t) {
    var e = dA[t];
    if (e)
      return e;
    var r = 1 / 0, s;
    for (var i in Ki)
      if (Ki.hasOwnProperty(i)) {
        var a = Ki[i], o = qne(t, a);
        o < r && (r = o, s = i);
      }
    return s;
  };
  Se.keyword.rgb = function(t) {
    return Ki[t];
  };
  Se.rgb.xyz = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255;
    e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, s = s >
    0.04045 ? Math.pow((s + 0.055) / 1.055, 2.4) : s / 12.92;
    var i = e * 0.4124 + r * 0.3576 + s * 0.1805, a = e * 0.2126 + r * 0.7152 + s * 0.0722, o = e * 0.0193 + r * 0.1192 + s * 0.9505;
    return [i * 100, a * 100, o * 100];
  };
  Se.rgb.lab = function(t) {
    var e = Se.rgb.xyz(t), r = e[0], s = e[1], i = e[2], a, o, l;
    return r /= 95.047, s /= 100, i /= 108.883, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, s = s > 8856e-6 ? Math.pow(s, 1 /
    3) : 7.787 * s + 16 / 116, i = i > 8856e-6 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, a = 116 * s - 16, o = 500 * (r - s), l = 200 * (s -
    i), [a, o, l];
  };
  Se.hsl.rgb = function(t) {
    var e = t[0] / 360, r = t[1] / 100, s = t[2] / 100, i, a, o, l, u;
    if (r === 0)
      return u = s * 255, [u, u, u];
    s < 0.5 ? a = s * (1 + r) : a = s + r - s * r, i = 2 * s - a, l = [0, 0, 0];
    for (var c = 0; c < 3; c++)
      o = e + 1 / 3 * -(c - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? u = i + (a - i) * 6 * o : 2 * o < 1 ? u = a : 3 * o < 2 ? u = i + (a -
      i) * (2 / 3 - o) * 6 : u = i, l[c] = u * 255;
    return l;
  };
  Se.hsl.hsv = function(t) {
    var e = t[0], r = t[1] / 100, s = t[2] / 100, i = r, a = Math.max(s, 0.01), o, l;
    return s *= 2, r *= s <= 1 ? s : 2 - s, i *= a <= 1 ? a : 2 - a, l = (s + r) / 2, o = s === 0 ? 2 * i / (a + i) : 2 * r / (s + r), [e, o *
    100, l * 100];
  };
  Se.hsv.rgb = function(t) {
    var e = t[0] / 60, r = t[1] / 100, s = t[2] / 100, i = Math.floor(e) % 6, a = e - Math.floor(e), o = 255 * s * (1 - r), l = 255 * s * (1 -
    r * a), u = 255 * s * (1 - r * (1 - a));
    switch (s *= 255, i) {
      case 0:
        return [s, u, o];
      case 1:
        return [l, s, o];
      case 2:
        return [o, s, u];
      case 3:
        return [o, l, s];
      case 4:
        return [u, o, s];
      case 5:
        return [s, o, l];
    }
  };
  Se.hsv.hsl = function(t) {
    var e = t[0], r = t[1] / 100, s = t[2] / 100, i = Math.max(s, 0.01), a, o, l;
    return l = (2 - r) * s, a = (2 - r) * i, o = r * i, o /= a <= 1 ? a : 2 - a, o = o || 0, l /= 2, [e, o * 100, l * 100];
  };
  Se.hwb.rgb = function(t) {
    var e = t[0] / 360, r = t[1] / 100, s = t[2] / 100, i = r + s, a, o, l, u;
    i > 1 && (r /= i, s /= i), a = Math.floor(6 * e), o = 1 - s, l = 6 * e - a, a & 1 && (l = 1 - l), u = r + l * (o - r);
    var c, p, f;
    switch (a) {
      default:
      case 6:
      case 0:
        c = o, p = u, f = r;
        break;
      case 1:
        c = u, p = o, f = r;
        break;
      case 2:
        c = r, p = o, f = u;
        break;
      case 3:
        c = r, p = u, f = o;
        break;
      case 4:
        c = u, p = r, f = o;
        break;
      case 5:
        c = o, p = r, f = u;
        break;
    }
    return [c * 255, p * 255, f * 255];
  };
  Se.cmyk.rgb = function(t) {
    var e = t[0] / 100, r = t[1] / 100, s = t[2] / 100, i = t[3] / 100, a, o, l;
    return a = 1 - Math.min(1, e * (1 - i) + i), o = 1 - Math.min(1, r * (1 - i) + i), l = 1 - Math.min(1, s * (1 - i) + i), [a * 255, o * 255,
    l * 255];
  };
  Se.xyz.rgb = function(t) {
    var e = t[0] / 100, r = t[1] / 100, s = t[2] / 100, i, a, o;
    return i = e * 3.2406 + r * -1.5372 + s * -0.4986, a = e * -0.9689 + r * 1.8758 + s * 0.0415, o = e * 0.0557 + r * -0.204 + s * 1.057, i =
    i > 31308e-7 ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055 : i * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a * 12.92, o =
    o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o * 12.92, i = Math.min(Math.max(0, i), 1), a = Math.min(Math.max(0, a), 1), o = Math.
    min(Math.max(0, o), 1), [i * 255, a * 255, o * 255];
  };
  Se.xyz.lab = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    return e /= 95.047, r /= 100, s /= 108.883, e = e > 8856e-6 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, r = r > 8856e-6 ? Math.pow(r, 1 /
    3) : 7.787 * r + 16 / 116, s = s > 8856e-6 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116, i = 116 * r - 16, a = 500 * (e - r), o = 200 * (r -
    s), [i, a, o];
  };
  Se.lab.xyz = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    a = (e + 16) / 116, i = r / 500 + a, o = a - s / 200;
    var l = Math.pow(a, 3), u = Math.pow(i, 3), c = Math.pow(o, 3);
    return a = l > 8856e-6 ? l : (a - 16 / 116) / 7.787, i = u > 8856e-6 ? u : (i - 16 / 116) / 7.787, o = c > 8856e-6 ? c : (o - 16 / 116) /
    7.787, i *= 95.047, a *= 100, o *= 108.883, [i, a, o];
  };
  Se.lab.lch = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    return i = Math.atan2(s, r), a = i * 360 / 2 / Math.PI, a < 0 && (a += 360), o = Math.sqrt(r * r + s * s), [e, o, a];
  };
  Se.lch.lab = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    return o = s / 360 * 2 * Math.PI, i = r * Math.cos(o), a = r * Math.sin(o), [e, i, a];
  };
  Se.rgb.ansi16 = function(t) {
    var e = t[0], r = t[1], s = t[2], i = 1 in arguments ? arguments[1] : Se.rgb.hsv(t)[2];
    if (i = Math.round(i / 50), i === 0)
      return 30;
    var a = 30 + (Math.round(s / 255) << 2 | Math.round(r / 255) << 1 | Math.round(e / 255));
    return i === 2 && (a += 60), a;
  };
  Se.hsv.ansi16 = function(t) {
    return Se.rgb.ansi16(Se.hsv.rgb(t), t[2]);
  };
  Se.rgb.ansi256 = function(t) {
    var e = t[0], r = t[1], s = t[2];
    if (e === r && r === s)
      return e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232;
    var i = 16 + 36 * Math.round(e / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(s / 255 * 5);
    return i;
  };
  Se.ansi16.rgb = function(t) {
    var e = t % 10;
    if (e === 0 || e === 7)
      return t > 50 && (e += 3.5), e = e / 10.5 * 255, [e, e, e];
    var r = (~~(t > 50) + 1) * 0.5, s = (e & 1) * r * 255, i = (e >> 1 & 1) * r * 255, a = (e >> 2 & 1) * r * 255;
    return [s, i, a];
  };
  Se.ansi256.rgb = function(t) {
    if (t >= 232) {
      var e = (t - 232) * 10 + 8;
      return [e, e, e];
    }
    t -= 16;
    var r, s = Math.floor(t / 36) / 5 * 255, i = Math.floor((r = t % 36) / 6) / 5 * 255, a = r % 6 / 5 * 255;
    return [s, i, a];
  };
  Se.rgb.hex = function(t) {
    var e = ((Math.round(t[0]) & 255) << 16) + ((Math.round(t[1]) & 255) << 8) + (Math.round(t[2]) & 255), r = e.toString(16).toUpperCase();
    return "000000".substring(r.length) + r;
  };
  Se.hex.rgb = function(t) {
    var e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!e)
      return [0, 0, 0];
    var r = e[0];
    e[0].length === 3 && (r = r.split("").map(function(l) {
      return l + l;
    }).join(""));
    var s = parseInt(r, 16), i = s >> 16 & 255, a = s >> 8 & 255, o = s & 255;
    return [i, a, o];
  };
  Se.rgb.hcg = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255, i = Math.max(Math.max(e, r), s), a = Math.min(Math.min(e, r), s), o = i - a, l, u;
    return o < 1 ? l = a / (1 - o) : l = 0, o <= 0 ? u = 0 : i === e ? u = (r - s) / o % 6 : i === r ? u = 2 + (s - e) / o : u = 4 + (e - r) /
    o + 4, u /= 6, u %= 1, [u * 360, o * 100, l * 100];
  };
  Se.hsl.hcg = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = 1, i = 0;
    return r < 0.5 ? s = 2 * e * r : s = 2 * e * (1 - r), s < 1 && (i = (r - 0.5 * s) / (1 - s)), [t[0], s * 100, i * 100];
  };
  Se.hsv.hcg = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = e * r, i = 0;
    return s < 1 && (i = (r - s) / (1 - s)), [t[0], s * 100, i * 100];
  };
  Se.hcg.rgb = function(t) {
    var e = t[0] / 360, r = t[1] / 100, s = t[2] / 100;
    if (r === 0)
      return [s * 255, s * 255, s * 255];
    var i = [0, 0, 0], a = e % 1 * 6, o = a % 1, l = 1 - o, u = 0;
    switch (Math.floor(a)) {
      case 0:
        i[0] = 1, i[1] = o, i[2] = 0;
        break;
      case 1:
        i[0] = l, i[1] = 1, i[2] = 0;
        break;
      case 2:
        i[0] = 0, i[1] = 1, i[2] = o;
        break;
      case 3:
        i[0] = 0, i[1] = l, i[2] = 1;
        break;
      case 4:
        i[0] = o, i[1] = 0, i[2] = 1;
        break;
      default:
        i[0] = 1, i[1] = 0, i[2] = l;
    }
    return u = (1 - r) * s, [
      (r * i[0] + u) * 255,
      (r * i[1] + u) * 255,
      (r * i[2] + u) * 255
    ];
  };
  Se.hcg.hsv = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = e + r * (1 - e), i = 0;
    return s > 0 && (i = e / s), [t[0], i * 100, s * 100];
  };
  Se.hcg.hsl = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = r * (1 - e) + 0.5 * e, i = 0;
    return s > 0 && s < 0.5 ? i = e / (2 * s) : s >= 0.5 && s < 1 && (i = e / (2 * (1 - s))), [t[0], i * 100, s * 100];
  };
  Se.hcg.hwb = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = e + r * (1 - e);
    return [t[0], (s - e) * 100, (1 - s) * 100];
  };
  Se.hwb.hcg = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = 1 - r, i = s - e, a = 0;
    return i < 1 && (a = (s - i) / (1 - i)), [t[0], i * 100, a * 100];
  };
  Se.apple.rgb = function(t) {
    return [t[0] / 65535 * 255, t[1] / 65535 * 255, t[2] / 65535 * 255];
  };
  Se.rgb.apple = function(t) {
    return [t[0] / 255 * 65535, t[1] / 255 * 65535, t[2] / 255 * 65535];
  };
  Se.gray.rgb = function(t) {
    return [t[0] / 100 * 255, t[0] / 100 * 255, t[0] / 100 * 255];
  };
  Se.gray.hsl = Se.gray.hsv = function(t) {
    return [0, 0, t[0]];
  };
  Se.gray.hwb = function(t) {
    return [0, 100, t[0]];
  };
  Se.gray.cmyk = function(t) {
    return [0, 0, 0, t[0]];
  };
  Se.gray.lab = function(t) {
    return [t[0], 0, 0];
  };
  Se.gray.hex = function(t) {
    var e = Math.round(t[0] / 100 * 255) & 255, r = (e << 16) + (e << 8) + e, s = r.toString(16).toUpperCase();
    return "000000".substring(s.length) + s;
  };
  Se.rgb.gray = function(t) {
    var e = (t[0] + t[1] + t[2]) / 3;
    return [e / 255 * 100];
  };
});

// ../node_modules/@babel/traverse/node_modules/color-convert/route.js
var TA = w((kje, yA) => {
  var Pu = jd();
  function Vne() {
    for (var t = {}, e = Object.keys(Pu), r = e.length, s = 0; s < r; s++)
      t[e[s]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return t;
  }
  n(Vne, "buildGraph");
  function Kne(t) {
    var e = Vne(), r = [t];
    for (e[t].distance = 0; r.length; )
      for (var s = r.pop(), i = Object.keys(Pu[s]), a = i.length, o = 0; o < a; o++) {
        var l = i[o], u = e[l];
        u.distance === -1 && (u.distance = e[s].distance + 1, u.parent = s, r.unshift(l));
      }
    return e;
  }
  n(Kne, "deriveBFS");
  function Wne(t, e) {
    return function(r) {
      return e(t(r));
    };
  }
  n(Wne, "link");
  function Yne(t, e) {
    for (var r = [e[t].parent, t], s = Pu[e[t].parent][t], i = e[t].parent; e[i].parent; )
      r.unshift(e[i].parent), s = Wne(Pu[e[i].parent][i], s), i = e[i].parent;
    return s.conversion = r, s;
  }
  n(Yne, "wrapConversion");
  yA.exports = function(t) {
    for (var e = Kne(t), r = {}, s = Object.keys(e), i = s.length, a = 0; a < i; a++) {
      var o = s[a], l = e[o];
      l.parent !== null && (r[o] = Yne(o, e));
    }
    return r;
  };
});

// ../node_modules/@babel/traverse/node_modules/color-convert/index.js
var xA = w((_je, bA) => {
  var Rd = jd(), Jne = TA(), vn = {}, Xne = Object.keys(Rd);
  function $ne(t) {
    var e = /* @__PURE__ */ n(function(r) {
      return r == null ? r : (arguments.length > 1 && (r = Array.prototype.slice.call(arguments)), t(r));
    }, "wrappedFn");
    return "conversion" in t && (e.conversion = t.conversion), e;
  }
  n($ne, "wrapRaw");
  function Hne(t) {
    var e = /* @__PURE__ */ n(function(r) {
      if (r == null)
        return r;
      arguments.length > 1 && (r = Array.prototype.slice.call(arguments));
      var s = t(r);
      if (typeof s == "object")
        for (var i = s.length, a = 0; a < i; a++)
          s[a] = Math.round(s[a]);
      return s;
    }, "wrappedFn");
    return "conversion" in t && (e.conversion = t.conversion), e;
  }
  n(Hne, "wrapRounded");
  Xne.forEach(function(t) {
    vn[t] = {}, Object.defineProperty(vn[t], "channels", { value: Rd[t].channels }), Object.defineProperty(vn[t], "labels", { value: Rd[t].labels });
    var e = Jne(t), r = Object.keys(e);
    r.forEach(function(s) {
      var i = e[s];
      vn[t][s] = Hne(i), vn[t][s].raw = $ne(i);
    });
  });
  bA.exports = vn;
});

// ../node_modules/@babel/traverse/node_modules/ansi-styles/index.js
var gA = w((Mje, SA) => {
  "use strict";
  var Cn = xA(), Eu = /* @__PURE__ */ n((t, e) => function() {
    return `\x1B[${t.apply(Cn, arguments) + e}m`;
  }, "wrapAnsi16"), Au = /* @__PURE__ */ n((t, e) => function() {
    let r = t.apply(Cn, arguments);
    return `\x1B[${38 + e};5;${r}m`;
  }, "wrapAnsi256"), vu = /* @__PURE__ */ n((t, e) => function() {
    let r = t.apply(Cn, arguments);
    return `\x1B[${38 + e};2;${r[0]};${r[1]};${r[2]}m`;
  }, "wrapAnsi16m");
  function zne() {
    let t = /* @__PURE__ */ new Map(), e = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        // Bright color
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    e.color.grey = e.color.gray;
    for (let i of Object.keys(e)) {
      let a = e[i];
      for (let o of Object.keys(a)) {
        let l = a[o];
        e[o] = {
          open: `\x1B[${l[0]}m`,
          close: `\x1B[${l[1]}m`
        }, a[o] = e[o], t.set(l[0], l[1]);
      }
      Object.defineProperty(e, i, {
        value: a,
        enumerable: !1
      }), Object.defineProperty(e, "codes", {
        value: t,
        enumerable: !1
      });
    }
    let r = /* @__PURE__ */ n((i) => i, "ansi2ansi"), s = /* @__PURE__ */ n((i, a, o) => [i, a, o], "rgb2rgb");
    e.color.close = "\x1B[39m", e.bgColor.close = "\x1B[49m", e.color.ansi = {
      ansi: Eu(r, 0)
    }, e.color.ansi256 = {
      ansi256: Au(r, 0)
    }, e.color.ansi16m = {
      rgb: vu(s, 0)
    }, e.bgColor.ansi = {
      ansi: Eu(r, 10)
    }, e.bgColor.ansi256 = {
      ansi256: Au(r, 10)
    }, e.bgColor.ansi16m = {
      rgb: vu(s, 10)
    };
    for (let i of Object.keys(Cn)) {
      if (typeof Cn[i] != "object")
        continue;
      let a = Cn[i];
      i === "ansi16" && (i = "ansi"), "ansi16" in a && (e.color.ansi[i] = Eu(a.ansi16, 0), e.bgColor.ansi[i] = Eu(a.ansi16, 10)), "ansi256" in
      a && (e.color.ansi256[i] = Au(a.ansi256, 0), e.bgColor.ansi256[i] = Au(a.ansi256, 10)), "rgb" in a && (e.color.ansi16m[i] = vu(a.rgb, 0),
      e.bgColor.ansi16m[i] = vu(a.rgb, 10));
    }
    return e;
  }
  n(zne, "assembleStyles");
  Object.defineProperty(SA, "exports", {
    enumerable: !0,
    get: zne
  });
});

// ../node_modules/@babel/traverse/node_modules/has-flag/index.js
var EA = w((Fje, PA) => {
  "use strict";
  PA.exports = (t, e) => {
    e = e || process.argv;
    let r = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", s = e.indexOf(r + t), i = e.indexOf("--");
    return s !== -1 && (i === -1 ? !0 : s < i);
  };
});

// ../node_modules/@babel/traverse/node_modules/supports-color/index.js
var vA = w((jje, AA) => {
  "use strict";
  var Gne = require("os"), $r = EA(), sr = process.env, In;
  $r("no-color") || $r("no-colors") || $r("color=false") ? In = !1 : ($r("color") || $r("colors") || $r("color=true") || $r("color=always")) &&
  (In = !0);
  "FORCE_COLOR" in sr && (In = sr.FORCE_COLOR.length === 0 || parseInt(sr.FORCE_COLOR, 10) !== 0);
  function Qne(t) {
    return t === 0 ? !1 : {
      level: t,
      hasBasic: !0,
      has256: t >= 2,
      has16m: t >= 3
    };
  }
  n(Qne, "translateLevel");
  function Zne(t) {
    if (In === !1)
      return 0;
    if ($r("color=16m") || $r("color=full") || $r("color=truecolor"))
      return 3;
    if ($r("color=256"))
      return 2;
    if (t && !t.isTTY && In !== !0)
      return 0;
    let e = In ? 1 : 0;
    if (process.platform === "win32") {
      let r = Gne.release().split(".");
      return Number(process.versions.node.split(".")[0]) >= 8 && Number(r[0]) >= 10 && Number(r[2]) >= 10586 ? Number(r[2]) >= 14931 ? 3 : 2 :
      1;
    }
    if ("CI" in sr)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((r) => r in sr) || sr.CI_NAME === "codeship" ? 1 : e;
    if ("TEAMCITY_VERSION" in sr)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(sr.TEAMCITY_VERSION) ? 1 : 0;
    if (sr.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in sr) {
      let r = parseInt((sr.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (sr.TERM_PROGRAM) {
        case "iTerm.app":
          return r >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(sr.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(sr.TERM) || "COLORTERM" in
    sr ? 1 : (sr.TERM === "dumb", e);
  }
  n(Zne, "supportsColor");
  function Ud(t) {
    let e = Zne(t);
    return Qne(e);
  }
  n(Ud, "getSupportLevel");
  AA.exports = {
    supportsColor: Ud,
    stdout: Ud(process.stdout),
    stderr: Ud(process.stderr)
  };
});

// ../node_modules/@babel/traverse/node_modules/chalk/templates.js
var OA = w((Uje, NA) => {
  "use strict";
  var eae = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,
  CA = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, tae = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, rae = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, sae = /* @__PURE__ */ new Map(
  [
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function wA(t) {
    return t[0] === "u" && t.length === 5 || t[0] === "x" && t.length === 3 ? String.fromCharCode(parseInt(t.slice(1), 16)) : sae.get(t) || t;
  }
  n(wA, "unescape");
  function iae(t, e) {
    let r = [], s = e.trim().split(/\s*,\s*/g), i;
    for (let a of s)
      if (!isNaN(a))
        r.push(Number(a));
      else if (i = a.match(tae))
        r.push(i[2].replace(rae, (o, l, u) => l ? wA(l) : u));
      else
        throw new Error(`Invalid Chalk template style argument: ${a} (in style '${t}')`);
    return r;
  }
  n(iae, "parseArguments");
  function nae(t) {
    CA.lastIndex = 0;
    let e = [], r;
    for (; (r = CA.exec(t)) !== null; ) {
      let s = r[1];
      if (r[2]) {
        let i = iae(s, r[2]);
        e.push([s].concat(i));
      } else
        e.push([s]);
    }
    return e;
  }
  n(nae, "parseStyle");
  function IA(t, e) {
    let r = {};
    for (let i of e)
      for (let a of i.styles)
        r[a[0]] = i.inverse ? null : a.slice(1);
    let s = t;
    for (let i of Object.keys(r))
      if (Array.isArray(r[i])) {
        if (!(i in s))
          throw new Error(`Unknown Chalk style: ${i}`);
        r[i].length > 0 ? s = s[i].apply(s, r[i]) : s = s[i];
      }
    return s;
  }
  n(IA, "buildStyle");
  NA.exports = (t, e) => {
    let r = [], s = [], i = [];
    if (e.replace(eae, (a, o, l, u, c, p) => {
      if (o)
        i.push(wA(o));
      else if (u) {
        let f = i.join("");
        i = [], s.push(r.length === 0 ? f : IA(t, r)(f)), r.push({ inverse: l, styles: nae(u) });
      } else if (c) {
        if (r.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        s.push(IA(t, r)(i.join(""))), i = [], r.pop();
      } else
        i.push(p);
    }), s.push(i.join("")), r.length > 0) {
      let a = `Chalk template literal is missing ${r.length} closing bracket${r.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(a);
    }
    return s.join("");
  };
});

// ../node_modules/@babel/traverse/node_modules/chalk/index.js
var MA = w((Vje, Xa) => {
  "use strict";
  var Vd = Fd(), qt = gA(), qd = vA().stdout, aae = OA(), DA = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith(
  "xterm"), _A = ["ansi", "ansi", "ansi256", "ansi16m"], LA = /* @__PURE__ */ new Set(["gray"]), wn = /* @__PURE__ */ Object.create(null);
  function kA(t, e) {
    e = e || {};
    let r = qd ? qd.level : 0;
    t.level = e.level === void 0 ? r : e.level, t.enabled = "enabled" in e ? e.enabled : t.level > 0;
  }
  n(kA, "applyOptions");
  function Ja(t) {
    if (!this || !(this instanceof Ja) || this.template) {
      let e = {};
      return kA(e, t), e.template = function() {
        let r = [].slice.call(arguments);
        return uae.apply(null, [e.template].concat(r));
      }, Object.setPrototypeOf(e, Ja.prototype), Object.setPrototypeOf(e.template, e), e.template.constructor = Ja, e.template;
    }
    kA(this, t);
  }
  n(Ja, "Chalk");
  DA && (qt.blue.open = "\x1B[94m");
  for (let t of Object.keys(qt))
    qt[t].closeRe = new RegExp(Vd(qt[t].close), "g"), wn[t] = {
      get() {
        let e = qt[t];
        return Cu.call(this, this._styles ? this._styles.concat(e) : [e], this._empty, t);
      }
    };
  wn.visible = {
    get() {
      return Cu.call(this, this._styles || [], !0, "visible");
    }
  };
  qt.color.closeRe = new RegExp(Vd(qt.color.close), "g");
  for (let t of Object.keys(qt.color.ansi))
    LA.has(t) || (wn[t] = {
      get() {
        let e = this.level;
        return function() {
          let s = {
            open: qt.color[_A[e]][t].apply(null, arguments),
            close: qt.color.close,
            closeRe: qt.color.closeRe
          };
          return Cu.call(this, this._styles ? this._styles.concat(s) : [s], this._empty, t);
        };
      }
    });
  qt.bgColor.closeRe = new RegExp(Vd(qt.bgColor.close), "g");
  for (let t of Object.keys(qt.bgColor.ansi)) {
    if (LA.has(t))
      continue;
    let e = "bg" + t[0].toUpperCase() + t.slice(1);
    wn[e] = {
      get() {
        let r = this.level;
        return function() {
          let i = {
            open: qt.bgColor[_A[r]][t].apply(null, arguments),
            close: qt.bgColor.close,
            closeRe: qt.bgColor.closeRe
          };
          return Cu.call(this, this._styles ? this._styles.concat(i) : [i], this._empty, t);
        };
      }
    };
  }
  var oae = Object.defineProperties(() => {
  }, wn);
  function Cu(t, e, r) {
    let s = /* @__PURE__ */ n(function() {
      return lae.apply(s, arguments);
    }, "builder");
    s._styles = t, s._empty = e;
    let i = this;
    return Object.defineProperty(s, "level", {
      enumerable: !0,
      get() {
        return i.level;
      },
      set(a) {
        i.level = a;
      }
    }), Object.defineProperty(s, "enabled", {
      enumerable: !0,
      get() {
        return i.enabled;
      },
      set(a) {
        i.enabled = a;
      }
    }), s.hasGrey = this.hasGrey || r === "gray" || r === "grey", s.__proto__ = oae, s;
  }
  n(Cu, "build");
  function lae() {
    let t = arguments, e = t.length, r = String(arguments[0]);
    if (e === 0)
      return "";
    if (e > 1)
      for (let i = 1; i < e; i++)
        r += " " + t[i];
    if (!this.enabled || this.level <= 0 || !r)
      return this._empty ? "" : r;
    let s = qt.dim.open;
    DA && this.hasGrey && (qt.dim.open = "");
    for (let i of this._styles.slice().reverse())
      r = i.open + r.replace(i.closeRe, i.open) + i.close, r = r.replace(/\r?\n/g, `${i.close}$&${i.open}`);
    return qt.dim.open = s, r;
  }
  n(lae, "applyStyle");
  function uae(t, e) {
    if (!Array.isArray(e))
      return [].slice.call(arguments, 1).join(" ");
    let r = [].slice.call(arguments, 2), s = [e.raw[0]];
    for (let i = 1; i < e.length; i++)
      s.push(String(r[i - 1]).replace(/[{}\\]/g, "\\$&")), s.push(String(e.raw[i]));
    return aae(t, s.join(""));
  }
  n(uae, "chalkTag");
  Object.defineProperties(Ja.prototype, wn);
  Xa.exports = Ja();
  Xa.exports.supportsColor = qd;
  Xa.exports.default = Xa.exports;
});

// ../node_modules/@babel/traverse/node_modules/@babel/code-frame/node_modules/@babel/highlight/lib/index.js
var KA = w(($a) => {
  "use strict";
  Object.defineProperty($a, "__esModule", {
    value: !0
  });
  $a.default = Tae;
  $a.shouldHighlight = VA;
  var BA = kd(), FA = Wa(), Wd = cae(Ya(), !0);
  function RA(t) {
    if (typeof WeakMap != "function") return null;
    var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (RA = /* @__PURE__ */ n(function(s) {
      return s ? r : e;
    }, "_getRequireWildcardCache"))(t);
  }
  n(RA, "_getRequireWildcardCache");
  function cae(t, e) {
    if (!e && t && t.__esModule) return t;
    if (t === null || typeof t != "object" && typeof t != "function") return { default: t };
    var r = RA(e);
    if (r && r.has(t)) return r.get(t);
    var s = { __proto__: null }, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t) if (a !== "default" && Object.prototype.hasOwnProperty.call(t, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(t, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(s, a, o) : s[a] = t[a];
    }
    return s.default = t, r && r.set(t, s), s;
  }
  n(cae, "_interopRequireWildcard");
  var UA = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, Wd.createColors)(!1) :
  Wd.default, jA = /* @__PURE__ */ n((t, e) => (r) => t(e(r)), "compose"), pae = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of",
  "set"]);
  function fae(t) {
    return {
      keyword: t.cyan,
      capitalized: t.yellow,
      jsxIdentifier: t.yellow,
      punctuator: t.yellow,
      number: t.magenta,
      string: t.green,
      regex: t.magenta,
      comment: t.gray,
      invalid: jA(jA(t.white, t.bgRed), t.bold)
    };
  }
  n(fae, "getDefs");
  var hae = /\r\n|[\n\r\u2028\u2029]/, dae = /^[()[\]{}]$/, qA;
  {
    let t = /^[a-z][\w-]*$/i, e = /* @__PURE__ */ n(function(r, s, i) {
      if (r.type === "name") {
        if ((0, FA.isKeyword)(r.value) || (0, FA.isStrictReservedWord)(r.value, !0) || pae.has(r.value))
          return "keyword";
        if (t.test(r.value) && (i[s - 1] === "<" || i.slice(s - 2, s) == "</"))
          return "jsxIdentifier";
        if (r.value[0] !== r.value[0].toLowerCase())
          return "capitalized";
      }
      return r.type === "punctuator" && dae.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punc\
tuator" : r.type;
    }, "getTokenType");
    qA = /* @__PURE__ */ n(function* (r) {
      let s;
      for (; s = BA.default.exec(r); ) {
        let i = BA.matchToToken(s);
        yield {
          type: e(i, s.index, r),
          value: i.value
        };
      }
    }, "tokenize");
  }
  function mae(t, e) {
    let r = "";
    for (let {
      type: s,
      value: i
    } of qA(e)) {
      let a = t[s];
      a ? r += i.split(hae).map((o) => a(o)).join(`
`) : r += i;
    }
    return r;
  }
  n(mae, "highlightTokens");
  function VA(t) {
    return UA.isColorSupported || t.forceColor;
  }
  n(VA, "shouldHighlight");
  var Kd;
  function yae(t) {
    if (t) {
      var e;
      return (e = Kd) != null || (Kd = (0, Wd.createColors)(!0)), Kd;
    }
    return UA;
  }
  n(yae, "getColors");
  function Tae(t, e = {}) {
    if (t !== "" && VA(e)) {
      let r = fae(yae(e.forceColor));
      return mae(r, t);
    } else
      return t;
  }
  n(Tae, "highlight");
  {
    let t, e;
    $a.getChalk = ({
      forceColor: r
    }) => {
      var s;
      if ((s = t) != null || (t = MA()), r) {
        var i;
        return (i = e) != null || (e = new t.constructor({
          enabled: !0,
          level: 1
        })), e;
      }
      return t;
    };
  }
});

// ../node_modules/@babel/traverse/node_modules/@babel/code-frame/lib/index.js
var zA = w((Iu) => {
  "use strict";
  Object.defineProperty(Iu, "__esModule", {
    value: !0
  });
  Iu.codeFrameColumns = HA;
  Iu.default = Eae;
  var WA = KA(), Jd = bae(Ya(), !0);
  function $A(t) {
    if (typeof WeakMap != "function") return null;
    var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return ($A = /* @__PURE__ */ n(function(s) {
      return s ? r : e;
    }, "_getRequireWildcardCache"))(t);
  }
  n($A, "_getRequireWildcardCache");
  function bae(t, e) {
    if (!e && t && t.__esModule) return t;
    if (t === null || typeof t != "object" && typeof t != "function") return { default: t };
    var r = $A(e);
    if (r && r.has(t)) return r.get(t);
    var s = { __proto__: null }, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t) if (a !== "default" && Object.prototype.hasOwnProperty.call(t, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(t, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(s, a, o) : s[a] = t[a];
    }
    return s.default = t, r && r.set(t, s), s;
  }
  n(bae, "_interopRequireWildcard");
  var xae = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, Jd.createColors)(!1) :
  Jd.default, YA = /* @__PURE__ */ n((t, e) => (r) => t(e(r)), "compose"), Yd;
  function Sae(t) {
    if (t) {
      var e;
      return (e = Yd) != null || (Yd = (0, Jd.createColors)(!0)), Yd;
    }
    return xae;
  }
  n(Sae, "getColors");
  var JA = !1;
  function gae(t) {
    return {
      gutter: t.gray,
      marker: YA(t.red, t.bold),
      message: YA(t.red, t.bold)
    };
  }
  n(gae, "getDefs");
  var XA = /\r\n|[\n\r\u2028\u2029]/;
  function Pae(t, e, r) {
    let s = Object.assign({
      column: 0,
      line: -1
    }, t.start), i = Object.assign({}, s, t.end), {
      linesAbove: a = 2,
      linesBelow: o = 3
    } = r || {}, l = s.line, u = s.column, c = i.line, p = i.column, f = Math.max(l - (a + 1), 0), m = Math.min(e.length, c + o);
    l === -1 && (f = 0), c === -1 && (m = e.length);
    let y = c - l, T = {};
    if (y)
      for (let L = 0; L <= y; L++) {
        let q = L + l;
        if (!u)
          T[q] = !0;
        else if (L === 0) {
          let _ = e[q - 1].length;
          T[q] = [u, _ - u + 1];
        } else if (L === y)
          T[q] = [0, p];
        else {
          let _ = e[q - L].length;
          T[q] = [0, _];
        }
      }
    else
      u === p ? u ? T[l] = [u, 0] : T[l] = !0 : T[l] = [u, p - u];
    return {
      start: f,
      end: m,
      markerLines: T
    };
  }
  n(Pae, "getMarkerLines");
  function HA(t, e, r = {}) {
    let s = (r.highlightCode || r.forceColor) && (0, WA.shouldHighlight)(r), i = Sae(r.forceColor), a = gae(i), o = /* @__PURE__ */ n((L, q) => s ?
    L(q) : q, "maybeHighlight"), l = t.split(XA), {
      start: u,
      end: c,
      markerLines: p
    } = Pae(e, l, r), f = e.start && typeof e.start.column == "number", m = String(c).length, T = (s ? (0, WA.default)(t, r) : t).split(XA, c).
    slice(u, c).map((L, q) => {
      let _ = u + 1 + q, J = ` ${` ${_}`.slice(-m)} |`, ie = p[_], de = !p[_ + 1];
      if (ie) {
        let ne = "";
        if (Array.isArray(ie)) {
          let Be = L.slice(0, Math.max(ie[0] - 1, 0)).replace(/[^\t]/g, " "), bt = ie[1] || 1;
          ne = [`
 `, o(a.gutter, J.replace(/\d/g, " ")), " ", Be, o(a.marker, "^").repeat(bt)].join(""), de && r.message && (ne += " " + o(a.message, r.message));
        }
        return [o(a.marker, ">"), o(a.gutter, J), L.length > 0 ? ` ${L}` : "", ne].join("");
      } else
        return ` ${o(a.gutter, J)}${L.length > 0 ? ` ${L}` : ""}`;
    }).join(`
`);
    return r.message && !f && (T = `${" ".repeat(m + 1)}${r.message}
${T}`), s ? i.reset(T) : T;
  }
  n(HA, "codeFrameColumns");
  function Eae(t, e, r, s = {}) {
    if (!JA) {
      JA = !0;
      let a = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning)
        process.emitWarning(a, "DeprecationWarning");
      else {
        let o = new Error(a);
        o.name = "DeprecationWarning", console.warn(new Error(a));
      }
    }
    return r = Math.max(r, 0), HA(t, {
      start: {
        column: r,
        line: e
      }
    }, s);
  }
  n(Eae, "_default");
});

// ../node_modules/@babel/traverse/node_modules/@babel/parser/lib/index.js
var O1 = w((no) => {
  "use strict";
  Object.defineProperty(no, "__esModule", {
    value: !0
  });
  function h1(t, e) {
    if (t == null) return {};
    var r = {}, s = Object.keys(t), i, a;
    for (a = 0; a < s.length; a++)
      i = s[a], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
    return r;
  }
  n(h1, "_objectWithoutPropertiesLoose");
  var os = class {
    static {
      n(this, "Position");
    }
    constructor(e, r, s) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = r, this.index = s;
    }
  }, Dn = class {
    static {
      n(this, "SourceLocation");
    }
    constructor(e, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = r;
    }
  };
  function yr(t, e) {
    let {
      line: r,
      column: s,
      index: i
    } = t;
    return new os(r, s + e, i + e);
  }
  n(yr, "createPositionWithColumnOffset");
  var GA = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", Aae = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: GA
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: GA
    }
  }, QA = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, Ou = /* @__PURE__ */ n(({
    type: t,
    prefix: e
  }) => t === "UpdateExpression" ? QA.UpdateExpression[String(e)] : QA[t], "toNodeDescription"), vae = {
    AccessorIsGenerator: /* @__PURE__ */ n(({
      kind: t
    }) => `A ${t}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ n(({
      kind: t
    }) => `Missing initializer in ${t} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ n(({
      exportName: t
    }) => `\`${t}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ n(({
      phase: t
    }) => `'import.${t}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ n(({
      localName: t,
      exportName: e
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t}' as '${e}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ n(({
      type: t
    }) => `'${t === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ n(({
      type: t
    }) => `Unsyntactic ${t === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ n(({
      importName: t
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: /* @__PURE__ */ n(({
      maxArgumentCount: t
    }) => `\`import()\` requires exactly ${t === 1 ? "one argument" : "one or two arguments"}.`, "ImportCallArity"),
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ n(({
      radix: t
    }) => `Expected number in radix ${t}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Escape sequence in keyword ${t}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Invalid identifier ${t}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid left-hand side in ${Ou(t)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Binding invalid left-hand side in ${Ou(t)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid optional chaining in the left-hand side of ${Ou(t)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t
    }) => `Unexpected character '${t}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private name #${t} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ n(({
      labelName: t
    }) => `Label '${t}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling the parser plugin: ${t.map((e) => JSON.stringify(e)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${t.map((e) => JSON.stringify(e)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ n(({
      key: t
    }) => `Duplicate key "${t}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ n(({
      surrogateCharCode: t
    }) => `An export name cannot include a lone surrogate, found '\\u${t.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ n(({
      localName: t
    }) => `Export '${t}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private names are only allowed in property accesses (\`obj.#${t}\`) or in \`in\` expressions (\`#${t} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Duplicate private name #${t}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ n(({
      keyword: t
    }) => `Unexpected keyword '${t}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Unexpected reserved word '${t}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ n(({
      expected: t,
      unexpected: e
    }) => `Unexpected token${e ? ` '${e}'.` : ""}${t ? `, expected "${t}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ n(({
      target: t,
      onlyValidPropertyName: e
    }) => `The only valid meta property for ${t} is ${t}.${e}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Identifier '${t}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, Cae = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ n(({
      referenceName: t
    }) => `Assigning to '${t}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ n(({
      bindingName: t
    }) => `Binding '${t}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, Iae = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), wae = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ n(({
      token: t
    }) => `Invalid topic token ${t}. In order to use ${t} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${t}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ n(({
      type: t
    }) => `Hack-style pipe body cannot be an unparenthesized ${Ou({
      type: t
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody"),
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }, Nae = ["toMessage"], Oae = ["message"];
  function ZA(t, e, r) {
    Object.defineProperty(t, e, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  n(ZA, "defineHidden");
  function kae(t) {
    let {
      toMessage: e
    } = t, r = h1(t, Nae);
    return /* @__PURE__ */ n(function s(i, a) {
      let o = new SyntaxError();
      return Object.assign(o, r, {
        loc: i,
        pos: i.index
      }), "missingPlugin" in a && Object.assign(o, {
        missingPlugin: a.missingPlugin
      }), ZA(o, "clone", /* @__PURE__ */ n(function(u = {}) {
        var c;
        let {
          line: p,
          column: f,
          index: m
        } = (c = u.loc) != null ? c : i;
        return s(new os(p, f, m), Object.assign({}, a, u.details));
      }, "clone")), ZA(o, "details", a), Object.defineProperty(o, "message", {
        configurable: !0,
        get() {
          let l = `${e(a)} (${i.line}:${i.column})`;
          return this.message = l, l;
        },
        set(l) {
          Object.defineProperty(this, "message", {
            value: l,
            writable: !0
          });
        }
      }), o;
    }, "constructor");
  }
  n(kae, "toParseErrorConstructor");
  function vs(t, e) {
    if (Array.isArray(t))
      return (s) => vs(s, t[0]);
    let r = {};
    for (let s of Object.keys(t)) {
      let i = t[s], a = typeof i == "string" ? {
        message: /* @__PURE__ */ n(() => i, "message")
      } : typeof i == "function" ? {
        message: i
      } : i, {
        message: o
      } = a, l = h1(a, Oae), u = typeof o == "string" ? () => o : o;
      r[s] = kae(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: s,
        toMessage: u
      }, e ? {
        syntaxPlugin: e
      } : {}, l));
    }
    return r;
  }
  n(vs, "ParseErrorEnum");
  var F = Object.assign({}, vs(Aae), vs(vae), vs(Cae), vs`pipelineOperator`(wae)), {
    defineProperty: Dae
  } = Object, e1 = /* @__PURE__ */ n((t, e) => Dae(t, e, {
    enumerable: !1,
    value: t[e]
  }), "toUnenumerable");
  function Ha(t) {
    return t.loc.start && e1(t.loc.start, "index"), t.loc.end && e1(t.loc.end, "index"), t;
  }
  n(Ha, "toESTreeLocation");
  var _ae = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "ESTreeParserMixin");
    }
    parse() {
      let r = Ha(super.parse());
      return this.options.tokens && (r.tokens = r.tokens.map(Ha)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: s
    }) {
      let i = null;
      try {
        i = new RegExp(r, s);
      } catch {
      }
      let a = this.estreeParseLiteral(i);
      return a.regex = {
        pattern: r,
        flags: s
      }, a;
    }
    parseBigIntLiteral(r) {
      let s;
      try {
        s = BigInt(r);
      } catch {
        s = null;
      }
      let i = this.estreeParseLiteral(s);
      return i.bigint = String(i.value || r), i;
    }
    parseDecimalLiteral(r) {
      let i = this.estreeParseLiteral(null);
      return i.decimal = String(i.value || r), i;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    directiveToStmt(r) {
      let s = r.value;
      delete r.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
      let i = r;
      return i.type = "ExpressionStatement", i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
    }
    initFunction(r, s) {
      super.initFunction(r, s), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var s;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((s = r.expression.
      extra) != null && s.parenthesized);
    }
    parseBlockBody(r, s, i, a, o) {
      super.parseBlockBody(r, s, i, a, o);
      let l = r.directives.map((u) => this.directiveToStmt(u));
      r.body = l.concat(r.body), delete r.directives;
    }
    pushClassMethod(r, s, i, a, o, l) {
      this.parseMethod(s, i, a, o, l, "ClassMethod", !0), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters),
      r.body.push(s);
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let s = super.getPrivateNameSV(r);
      return r = r, delete r.id, r.name = s, r.type = "PrivateIdentifier", r;
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, s) {
      let i = super.parseLiteral(r, s);
      return i.raw = i.extra.raw, delete i.extra, i;
    }
    parseFunctionBody(r, s, i = !1) {
      super.parseFunctionBody(r, s, i), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, s, i, a, o, l, u = !1) {
      let c = this.startNode();
      return c.kind = r.kind, c = super.parseMethod(c, s, i, a, o, l, u), c.type = "FunctionExpression", delete c.kind, r.value = c, l === "\
ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
    }
    parseClassProperty(...r) {
      let s = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition"), s;
    }
    parseClassPrivateProperty(...r) {
      let s = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition", s.computed = !1), s;
    }
    parseObjectMethod(r, s, i, a, o) {
      let l = super.parseObjectMethod(r, s, i, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(r, s, i, a) {
      let o = super.parseObjectProperty(r, s, i, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(r, s, i) {
      return r === "Property" ? "value" : super.isValidLVal(r, s, i);
    }
    isAssignable(r, s) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: i,
          value: a
        } = r;
        this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(a, s);
      } else
        super.toAssignable(r, s);
    }
    toAssignableObjectExpressionProp(r, s, i) {
      r.kind === "get" || r.kind === "set" ? this.raise(F.PatternHasAccessor, r.key) : r.method ? this.raise(F.PatternHasMethod, r.key) : super.
      toAssignableObjectExpressionProp(r, s, i);
    }
    finishCallExpression(r, s) {
      let i = super.finishCallExpression(r, s);
      if (i.callee.type === "Import") {
        if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var a, o;
          i.options = (a = i.arguments[1]) != null ? a : null, i.attributes = (o = i.arguments[1]) != null ? o : null;
        }
        delete i.arguments, delete i.callee;
      }
      return i;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, s) {
      let i = this.state.lastTokStartLoc, a = super.parseExport(r, s);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, i);
          }
          break;
      }
      return a;
    }
    parseSubscript(r, s, i, a) {
      let o = super.parseSubscript(r, s, i, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.method || r.kind === "get" || r.kind === "set";
    }
    finishNodeAt(r, s, i) {
      return Ha(super.finishNodeAt(r, s, i));
    }
    resetStartLocation(r, s) {
      super.resetStartLocation(r, s), Ha(r);
    }
    resetEndLocation(r, s = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, s), Ha(r);
    }
  }, "estree"), Yi = class {
    static {
      n(this, "TokContext");
    }
    constructor(e, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!r;
    }
  }, St = {
    brace: new Yi("{"),
    j_oTag: new Yi("<tag"),
    j_cTag: new Yi("</tag"),
    j_expr: new Yi("<tag>...</tag>", !0)
  };
  St.template = new Yi("`", !0);
  var We = !0, ae = !0, Xd = !0, za = !0, ti = !0, Lae = !0, Lu = class {
    static {
      n(this, "ExportedTokenType");
    }
    constructor(e, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, bm = /* @__PURE__ */ new Map();
  function Ze(t, e = {}) {
    e.keyword = t;
    let r = Ee(t, e);
    return bm.set(t, r), r;
  }
  n(Ze, "createKeyword");
  function mr(t, e) {
    return Ee(t, {
      beforeExpr: We,
      binop: e
    });
  }
  n(mr, "createBinop");
  var eo = -1, Es = [], xm = [], Sm = [], gm = [], Pm = [], Em = [];
  function Ee(t, e = {}) {
    var r, s, i, a;
    return ++eo, xm.push(t), Sm.push((r = e.binop) != null ? r : -1), gm.push((s = e.beforeExpr) != null ? s : !1), Pm.push((i = e.startsExpr) !=
    null ? i : !1), Em.push((a = e.prefix) != null ? a : !1), Es.push(new Lu(t, e)), eo;
  }
  n(Ee, "createToken");
  function Ke(t, e = {}) {
    var r, s, i, a;
    return ++eo, bm.set(t, eo), xm.push(t), Sm.push((r = e.binop) != null ? r : -1), gm.push((s = e.beforeExpr) != null ? s : !1), Pm.push((i =
    e.startsExpr) != null ? i : !1), Em.push((a = e.prefix) != null ? a : !1), Es.push(new Lu("name", e)), eo;
  }
  n(Ke, "createKeywordLike");
  var Mae = {
    bracketL: Ee("[", {
      beforeExpr: We,
      startsExpr: ae
    }),
    bracketHashL: Ee("#[", {
      beforeExpr: We,
      startsExpr: ae
    }),
    bracketBarL: Ee("[|", {
      beforeExpr: We,
      startsExpr: ae
    }),
    bracketR: Ee("]"),
    bracketBarR: Ee("|]"),
    braceL: Ee("{", {
      beforeExpr: We,
      startsExpr: ae
    }),
    braceBarL: Ee("{|", {
      beforeExpr: We,
      startsExpr: ae
    }),
    braceHashL: Ee("#{", {
      beforeExpr: We,
      startsExpr: ae
    }),
    braceR: Ee("}"),
    braceBarR: Ee("|}"),
    parenL: Ee("(", {
      beforeExpr: We,
      startsExpr: ae
    }),
    parenR: Ee(")"),
    comma: Ee(",", {
      beforeExpr: We
    }),
    semi: Ee(";", {
      beforeExpr: We
    }),
    colon: Ee(":", {
      beforeExpr: We
    }),
    doubleColon: Ee("::", {
      beforeExpr: We
    }),
    dot: Ee("."),
    question: Ee("?", {
      beforeExpr: We
    }),
    questionDot: Ee("?."),
    arrow: Ee("=>", {
      beforeExpr: We
    }),
    template: Ee("template"),
    ellipsis: Ee("...", {
      beforeExpr: We
    }),
    backQuote: Ee("`", {
      startsExpr: ae
    }),
    dollarBraceL: Ee("${", {
      beforeExpr: We,
      startsExpr: ae
    }),
    templateTail: Ee("...`", {
      startsExpr: ae
    }),
    templateNonTail: Ee("...${", {
      beforeExpr: We,
      startsExpr: ae
    }),
    at: Ee("@"),
    hash: Ee("#", {
      startsExpr: ae
    }),
    interpreterDirective: Ee("#!..."),
    eq: Ee("=", {
      beforeExpr: We,
      isAssign: za
    }),
    assign: Ee("_=", {
      beforeExpr: We,
      isAssign: za
    }),
    slashAssign: Ee("_=", {
      beforeExpr: We,
      isAssign: za
    }),
    xorAssign: Ee("_=", {
      beforeExpr: We,
      isAssign: za
    }),
    moduloAssign: Ee("_=", {
      beforeExpr: We,
      isAssign: za
    }),
    incDec: Ee("++/--", {
      prefix: ti,
      postfix: Lae,
      startsExpr: ae
    }),
    bang: Ee("!", {
      beforeExpr: We,
      prefix: ti,
      startsExpr: ae
    }),
    tilde: Ee("~", {
      beforeExpr: We,
      prefix: ti,
      startsExpr: ae
    }),
    doubleCaret: Ee("^^", {
      startsExpr: ae
    }),
    doubleAt: Ee("@@", {
      startsExpr: ae
    }),
    pipeline: mr("|>", 0),
    nullishCoalescing: mr("??", 1),
    logicalOR: mr("||", 1),
    logicalAND: mr("&&", 2),
    bitwiseOR: mr("|", 3),
    bitwiseXOR: mr("^", 4),
    bitwiseAND: mr("&", 5),
    equality: mr("==/!=/===/!==", 6),
    lt: mr("</>/<=/>=", 7),
    gt: mr("</>/<=/>=", 7),
    relational: mr("</>/<=/>=", 7),
    bitShift: mr("<</>>/>>>", 8),
    bitShiftL: mr("<</>>/>>>", 8),
    bitShiftR: mr("<</>>/>>>", 8),
    plusMin: Ee("+/-", {
      beforeExpr: We,
      binop: 9,
      prefix: ti,
      startsExpr: ae
    }),
    modulo: Ee("%", {
      binop: 10,
      startsExpr: ae
    }),
    star: Ee("*", {
      binop: 10
    }),
    slash: mr("/", 10),
    exponent: Ee("**", {
      beforeExpr: We,
      binop: 11,
      rightAssociative: !0
    }),
    _in: Ze("in", {
      beforeExpr: We,
      binop: 7
    }),
    _instanceof: Ze("instanceof", {
      beforeExpr: We,
      binop: 7
    }),
    _break: Ze("break"),
    _case: Ze("case", {
      beforeExpr: We
    }),
    _catch: Ze("catch"),
    _continue: Ze("continue"),
    _debugger: Ze("debugger"),
    _default: Ze("default", {
      beforeExpr: We
    }),
    _else: Ze("else", {
      beforeExpr: We
    }),
    _finally: Ze("finally"),
    _function: Ze("function", {
      startsExpr: ae
    }),
    _if: Ze("if"),
    _return: Ze("return", {
      beforeExpr: We
    }),
    _switch: Ze("switch"),
    _throw: Ze("throw", {
      beforeExpr: We,
      prefix: ti,
      startsExpr: ae
    }),
    _try: Ze("try"),
    _var: Ze("var"),
    _const: Ze("const"),
    _with: Ze("with"),
    _new: Ze("new", {
      beforeExpr: We,
      startsExpr: ae
    }),
    _this: Ze("this", {
      startsExpr: ae
    }),
    _super: Ze("super", {
      startsExpr: ae
    }),
    _class: Ze("class", {
      startsExpr: ae
    }),
    _extends: Ze("extends", {
      beforeExpr: We
    }),
    _export: Ze("export"),
    _import: Ze("import", {
      startsExpr: ae
    }),
    _null: Ze("null", {
      startsExpr: ae
    }),
    _true: Ze("true", {
      startsExpr: ae
    }),
    _false: Ze("false", {
      startsExpr: ae
    }),
    _typeof: Ze("typeof", {
      beforeExpr: We,
      prefix: ti,
      startsExpr: ae
    }),
    _void: Ze("void", {
      beforeExpr: We,
      prefix: ti,
      startsExpr: ae
    }),
    _delete: Ze("delete", {
      beforeExpr: We,
      prefix: ti,
      startsExpr: ae
    }),
    _do: Ze("do", {
      isLoop: Xd,
      beforeExpr: We
    }),
    _for: Ze("for", {
      isLoop: Xd
    }),
    _while: Ze("while", {
      isLoop: Xd
    }),
    _as: Ke("as", {
      startsExpr: ae
    }),
    _assert: Ke("assert", {
      startsExpr: ae
    }),
    _async: Ke("async", {
      startsExpr: ae
    }),
    _await: Ke("await", {
      startsExpr: ae
    }),
    _defer: Ke("defer", {
      startsExpr: ae
    }),
    _from: Ke("from", {
      startsExpr: ae
    }),
    _get: Ke("get", {
      startsExpr: ae
    }),
    _let: Ke("let", {
      startsExpr: ae
    }),
    _meta: Ke("meta", {
      startsExpr: ae
    }),
    _of: Ke("of", {
      startsExpr: ae
    }),
    _sent: Ke("sent", {
      startsExpr: ae
    }),
    _set: Ke("set", {
      startsExpr: ae
    }),
    _source: Ke("source", {
      startsExpr: ae
    }),
    _static: Ke("static", {
      startsExpr: ae
    }),
    _using: Ke("using", {
      startsExpr: ae
    }),
    _yield: Ke("yield", {
      startsExpr: ae
    }),
    _asserts: Ke("asserts", {
      startsExpr: ae
    }),
    _checks: Ke("checks", {
      startsExpr: ae
    }),
    _exports: Ke("exports", {
      startsExpr: ae
    }),
    _global: Ke("global", {
      startsExpr: ae
    }),
    _implements: Ke("implements", {
      startsExpr: ae
    }),
    _intrinsic: Ke("intrinsic", {
      startsExpr: ae
    }),
    _infer: Ke("infer", {
      startsExpr: ae
    }),
    _is: Ke("is", {
      startsExpr: ae
    }),
    _mixins: Ke("mixins", {
      startsExpr: ae
    }),
    _proto: Ke("proto", {
      startsExpr: ae
    }),
    _require: Ke("require", {
      startsExpr: ae
    }),
    _satisfies: Ke("satisfies", {
      startsExpr: ae
    }),
    _keyof: Ke("keyof", {
      startsExpr: ae
    }),
    _readonly: Ke("readonly", {
      startsExpr: ae
    }),
    _unique: Ke("unique", {
      startsExpr: ae
    }),
    _abstract: Ke("abstract", {
      startsExpr: ae
    }),
    _declare: Ke("declare", {
      startsExpr: ae
    }),
    _enum: Ke("enum", {
      startsExpr: ae
    }),
    _module: Ke("module", {
      startsExpr: ae
    }),
    _namespace: Ke("namespace", {
      startsExpr: ae
    }),
    _interface: Ke("interface", {
      startsExpr: ae
    }),
    _type: Ke("type", {
      startsExpr: ae
    }),
    _opaque: Ke("opaque", {
      startsExpr: ae
    }),
    name: Ee("name", {
      startsExpr: ae
    }),
    string: Ee("string", {
      startsExpr: ae
    }),
    num: Ee("num", {
      startsExpr: ae
    }),
    bigint: Ee("bigint", {
      startsExpr: ae
    }),
    decimal: Ee("decimal", {
      startsExpr: ae
    }),
    regexp: Ee("regexp", {
      startsExpr: ae
    }),
    privateName: Ee("#name", {
      startsExpr: ae
    }),
    eof: Ee("eof"),
    jsxName: Ee("jsxName"),
    jsxText: Ee("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: Ee("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: Ee("jsxTagEnd"),
    placeholder: Ee("%%", {
      startsExpr: !0
    })
  };
  function ft(t) {
    return t >= 93 && t <= 132;
  }
  n(ft, "tokenIsIdentifier");
  function Bae(t) {
    return t <= 92;
  }
  n(Bae, "tokenKeywordOrIdentifierIsKeyword");
  function Hr(t) {
    return t >= 58 && t <= 132;
  }
  n(Hr, "tokenIsKeywordOrIdentifier");
  function d1(t) {
    return t >= 58 && t <= 136;
  }
  n(d1, "tokenIsLiteralPropertyName");
  function Fae(t) {
    return gm[t];
  }
  n(Fae, "tokenComesBeforeExpression");
  function Qd(t) {
    return Pm[t];
  }
  n(Qd, "tokenCanStartExpression");
  function jae(t) {
    return t >= 29 && t <= 33;
  }
  n(jae, "tokenIsAssignment");
  function t1(t) {
    return t >= 129 && t <= 131;
  }
  n(t1, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function Rae(t) {
    return t >= 90 && t <= 92;
  }
  n(Rae, "tokenIsLoop");
  function Am(t) {
    return t >= 58 && t <= 92;
  }
  n(Am, "tokenIsKeyword");
  function Uae(t) {
    return t >= 39 && t <= 59;
  }
  n(Uae, "tokenIsOperator");
  function qae(t) {
    return t === 34;
  }
  n(qae, "tokenIsPostfix");
  function Vae(t) {
    return Em[t];
  }
  n(Vae, "tokenIsPrefix");
  function Kae(t) {
    return t >= 121 && t <= 123;
  }
  n(Kae, "tokenIsTSTypeOperator");
  function Wae(t) {
    return t >= 124 && t <= 130;
  }
  n(Wae, "tokenIsTSDeclarationStart");
  function ii(t) {
    return xm[t];
  }
  n(ii, "tokenLabelName");
  function ku(t) {
    return Sm[t];
  }
  n(ku, "tokenOperatorPrecedence");
  function Yae(t) {
    return t === 57;
  }
  n(Yae, "tokenIsRightAssociative");
  function Mu(t) {
    return t >= 24 && t <= 25;
  }
  n(Mu, "tokenIsTemplate");
  function Ps(t) {
    return Es[t];
  }
  n(Ps, "getExportedToken");
  Es[8].updateContext = (t) => {
    t.pop();
  }, Es[5].updateContext = Es[7].updateContext = Es[23].updateContext = (t) => {
    t.push(St.brace);
  }, Es[22].updateContext = (t) => {
    t[t.length - 1] === St.template ? t.pop() : t.push(St.template);
  }, Es[142].updateContext = (t) => {
    t.push(St.j_expr, St.j_oTag);
  };
  var vm = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  m1 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", Jae = new RegExp("[" + vm + "]"), Xae = new RegExp("[" + vm + m1 + "\
]");
  vm = m1 = null;
  var y1 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], $ae = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41,
  2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9,
  6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Zd(t, e) {
    let r = 65536;
    for (let s = 0, i = e.length; s < i; s += 2) {
      if (r += e[s], r > t) return !1;
      if (r += e[s + 1], r >= t) return !0;
    }
    return !1;
  }
  n(Zd, "isInAstralSet");
  function As(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && Jae.test(String.fromCharCode(t)) :
    Zd(t, y1);
  }
  n(As, "isIdentifierStart");
  function On(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && Xae.test(
    String.fromCharCode(t)) : Zd(t, y1) || Zd(t, $ae);
  }
  n(On, "isIdentifierChar");
  var Cm = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, Hae = new Set(Cm.keyword), zae = new Set(Cm.strict), Gae = new Set(Cm.strictBind);
  function T1(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(T1, "isReservedWord");
  function b1(t, e) {
    return T1(t, e) || zae.has(t);
  }
  n(b1, "isStrictReservedWord");
  function x1(t) {
    return Gae.has(t);
  }
  n(x1, "isStrictBindOnlyReservedWord");
  function S1(t, e) {
    return b1(t, e) || x1(t);
  }
  n(S1, "isStrictBindReservedWord");
  function Qae(t) {
    return Hae.has(t);
  }
  n(Qae, "isKeyword");
  function Zae(t, e, r) {
    return t === 64 && e === 64 && As(r);
  }
  n(Zae, "isIteratorStart");
  var eoe = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function toe(t) {
    return eoe.has(t);
  }
  n(toe, "canBeReservedWord");
  var ro = class {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
    }
  }, so = class {
    static {
      n(this, "ScopeHandler");
    }
    constructor(e, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let e = this.currentThisScopeFlags();
      return (e & 64) > 0 && (e & 2) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 128)
          return !0;
        if (r & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new ro(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
    }
    declareName(e, r, s) {
      let i = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(i, e, r, s);
        let a = i.names.get(e) || 0;
        r & 16 ? a = a | 4 : (i.firstLexicalName || (i.firstLexicalName = e), a = a | 2), i.names.set(e, a), r & 8 && this.maybeExportDefined(
        i, e);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (i = this.scopeStack[a], this.checkRedeclarationInScope(i, e, r, s), i.names.set(
        e, (i.names.get(e) || 0) | 1), this.maybeExportDefined(i, e), !(i.flags & 387)); --a)
          ;
      this.parser.inModule && i.flags & 1 && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, r) {
      this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(e, r, s, i) {
      this.isRedeclaredInScope(e, r, s) && this.parser.raise(F.VarRedeclaration, i, {
        identifierName: r
      });
    }
    isRedeclaredInScope(e, r, s) {
      if (!(s & 1)) return !1;
      if (s & 8)
        return e.names.has(r);
      let i = e.names.get(r);
      return s & 16 ? (i & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (i & 1) > 0 : (i & 2) > 0 && !(e.flags & 8 && e.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(e) && (i & 4) > 0;
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 387)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 451 && !(r & 4))
          return r;
      }
    }
  }, em = class extends ro {
    static {
      n(this, "FlowScope");
    }
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, tm = class extends so {
    static {
      n(this, "FlowScopeHandler");
    }
    createScope(e) {
      return new em(e);
    }
    declareName(e, r, s) {
      let i = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(i, e, r, s), this.maybeExportDefined(i, e), i.declareFunctions.add(e);
        return;
      }
      super.declareName(e, r, s);
    }
    isRedeclaredInScope(e, r, s) {
      if (super.isRedeclaredInScope(e, r, s)) return !0;
      if (s & 2048 && !e.declareFunctions.has(r)) {
        let i = e.names.get(r);
        return (i & 4) > 0 || (i & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }, rm = class {
    static {
      n(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        let [r, s] = e;
        if (!this.hasPlugin(r))
          return !1;
        let i = this.plugins.get(r);
        for (let a of Object.keys(s))
          if (i?.[a] !== s[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(e, r) {
      var s;
      return (s = this.plugins.get(e)) == null ? void 0 : s[r];
    }
  };
  function g1(t, e) {
    t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
  }
  n(g1, "setTrailingComments");
  function roe(t, e) {
    t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
  }
  n(roe, "setLeadingComments");
  function io(t, e) {
    t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
  }
  n(io, "setInnerComments");
  function Ga(t, e, r) {
    let s = null, i = e.length;
    for (; s === null && i > 0; )
      s = e[--i];
    s === null || s.start > r.start ? io(t, r.comments) : g1(s, r.comments);
  }
  n(Ga, "adjustInnerComments");
  var sm = class extends rm {
    static {
      n(this, "CommentsParser");
    }
    addComment(e) {
      this.filename && (e.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length != r && (this.comments.length = r), this.comments.push(e), this.state.commentsLen++;
    }
    processComment(e) {
      let {
        commentStack: r
      } = this.state, s = r.length;
      if (s === 0) return;
      let i = s - 1, a = r[i];
      a.start === e.end && (a.leadingNode = e, i--);
      let {
        start: o
      } = e;
      for (; i >= 0; i--) {
        let l = r[i], u = l.end;
        if (u > o)
          l.containingNode = e, this.finalizeComment(l), r.splice(i, 1);
        else {
          u === o && (l.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      let {
        comments: r
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && g1(e.leadingNode, r), e.trailingNode !== null && roe(e.trailingNode, r);
      else {
        let {
          containingNode: s,
          start: i
        } = e;
        if (this.input.charCodeAt(i - 1) === 44)
          switch (s.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Ga(s, s.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Ga(s, s.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Ga(s, s.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Ga(s, s.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Ga(s, s.specifiers, e);
              break;
            default:
              io(s, r);
          }
        else
          io(s, r);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: e
      } = this.state;
      for (let r = e.length - 1; r >= 0; r--)
        this.finalizeComment(e[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      if (s === 0) return;
      let i = r[s - 1];
      i.leadingNode === e && (i.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      s !== 0 && (r[s - 1].trailingNode === e ? r[s - 1].trailingNode = null : s >= 2 && r[s - 2].trailingNode === e && (r[s - 2].trailingNode =
      null));
    }
    takeSurroundingComments(e, r, s) {
      let {
        commentStack: i
      } = this.state, a = i.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = i[o], u = l.end;
        if (l.start === s)
          l.leadingNode = e;
        else if (u === r)
          l.trailingNode = e;
        else if (u < r)
          break;
      }
    }
  }, P1 = /\r\n?|[\n\u2028\u2029]/, wu = new RegExp(P1.source, "g");
  function to(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  n(to, "isNewLine");
  var $d = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Du = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, r1 = new RegExp("(?=(" + Du.source + "))\\\
1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function soe(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  n(soe, "isWhitespace");
  var im = class t {
    static {
      n(this, "State");
    }
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.
      potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [St.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(e) {
      e ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: e,
      sourceType: r,
      startLine: s,
      startColumn: i
    }) {
      this.strict = e === !1 ? !1 : e === !0 ? !0 : r === "module", this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new os(
      s, i, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(e) {
      e ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(e) {
      e ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(e) {
      e ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(e) {
      e ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(e) {
      e ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(e) {
      e ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(e) {
      e ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(e) {
      e ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(e) {
      e ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(e) {
      e ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(e) {
      e ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new os(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let e = new t();
      return e.flags = this.flags, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.startLoc, e.endLoc = this.endLoc,
      e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.slice(), e.noArrowParamsConversionAt =
      this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.slice(), e.commentsLen = this.commentsLen,
      e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value = this.value, e.start = this.start, e.end = this.
      end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.context = this.context.slice(), e.firstInvalidTemplateEscapePos =
      this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors, e.tokensLength = this.tokensLength, e;
    }
  }, ioe = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), s1 = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Nu = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function i1(t, e, r, s, i, a) {
    let o = r, l = s, u = i, c = "", p = null, f = r, {
      length: m
    } = e;
    for (; ; ) {
      if (r >= m) {
        a.unterminated(o, l, u), c += e.slice(f, r);
        break;
      }
      let y = e.charCodeAt(r);
      if (noe(t, y, e, r)) {
        c += e.slice(f, r);
        break;
      }
      if (y === 92) {
        c += e.slice(f, r);
        let T = aoe(e, r, s, i, t === "template", a);
        T.ch === null && !p ? p = {
          pos: r,
          lineStart: s,
          curLine: i
        } : c += T.ch, {
          pos: r,
          lineStart: s,
          curLine: i
        } = T, f = r;
      } else y === 8232 || y === 8233 ? (++r, ++i, s = r) : y === 10 || y === 13 ? t === "template" ? (c += e.slice(f, r) + `
`, ++r, y === 13 && e.charCodeAt(r) === 10 && ++r, ++i, f = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: s,
      curLine: i,
      containsInvalid: !!p
    };
  }
  n(i1, "readStringContents");
  function noe(t, e, r, s) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(s + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(noe, "isStringEnd");
  function aoe(t, e, r, s, i, a) {
    let o = !i;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = nm(t, e, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = A1(t, e, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (i)
          return l(null);
        a.strictNumericEscape(e - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, f = t.slice(c, e + 2).match(/^[0-7]+/)[0], m = parseInt(f, 8);
          m > 255 && (f = f.slice(0, -1), m = parseInt(f, 8)), e += f.length - 1;
          let y = t.charCodeAt(e);
          if (f !== "0" || y === 56 || y === 57) {
            if (i)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(m));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(aoe, "readEscapedChar");
  function nm(t, e, r, s, i, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = E1(t, e, r, s, 16, i, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(nm, "readHexChar");
  function E1(t, e, r, s, i, a, o, l, u, c) {
    let p = e, f = i === 16 ? s1.hex : s1.decBinOct, m = i === 16 ? Nu.hex : i === 10 ? Nu.dec : i === 8 ? Nu.oct : Nu.bin, y = !1, T = 0;
    for (let L = 0, q = a ?? 1 / 0; L < q; ++L) {
      let _ = t.charCodeAt(e), U;
      if (_ === 95 && l !== "bail") {
        let J = t.charCodeAt(e - 1), ie = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(ie) || !m(ie) || f.has(J) || f.has(ie)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, s);
        }
        ++e;
        continue;
      }
      if (_ >= 97 ? U = _ - 97 + 10 : _ >= 65 ? U = _ - 65 + 10 : ioe(_) ? U = _ - 48 : U = 1 / 0, U >= i) {
        if (U <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (U <= 9 && u.invalidDigit(e, r, s, i))
          U = 0;
        else if (o)
          U = 0, y = !0;
        else
          break;
      }
      ++e, T = T * i + U;
    }
    return e === p || a != null && e - p !== a || y ? {
      n: null,
      pos: e
    } : {
      n: T,
      pos: e
    };
  }
  n(E1, "readInt");
  function A1(t, e, r, s, i, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = nm(t, e, r, s, t.indexOf("}", e) - e, !0, i, a), ++e, l !== null && l > 1114111)
        if (i)
          a.invalidCodePoint(e, r, s);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = nm(t, e, r, s, 4, !1, i, a));
    return {
      code: l,
      pos: e
    };
  }
  n(A1, "readCodePoint");
  function Qa(t, e, r) {
    return new os(r, t - e, t);
  }
  n(Qa, "buildPosition");
  var ooe = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), as = class {
    static {
      n(this, "Token");
    }
    constructor(e) {
      this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, this.loc = new Dn(e.startLoc, e.endLoc);
    }
  }, am = class extends sm {
    static {
      n(this, "Tokenizer");
    }
    constructor(e, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ n((s, i, a, o) => this.options.errorRecovery ? (this.raise(F.InvalidDigit, Qa(s, i, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(F.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(F.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(F.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(F.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ n((s, i, a) => {
          this.recordStrictModeErrors(F.StrictNumericEscape, Qa(s, i, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ n((s, i, a) => {
          throw this.raise(F.UnterminatedString, Qa(s - 1, i, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(F.StrictNumericEscape),
        unterminated: /* @__PURE__ */ n((s, i, a) => {
          throw this.raise(F.UnterminatedTemplate, Qa(s, i, a));
        }, "unterminated")
      }), this.state = new im(), this.state.init(e), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new as(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.
      state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      let e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = e, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return $d.lastIndex = e, $d.test(this.input) ? $d.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e) {
      return Du.lastIndex = e, Du.test(this.input) ? Du.lastIndex : e;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e) {
      let r = this.input.charCodeAt(e);
      if ((r & 64512) === 55296 && ++e < this.input.length) {
        let s = this.input.charCodeAt(e);
        (s & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (s & 1023));
      }
      return r;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([r, s]) => this.raise(r, s)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let s = this.state.pos, i = this.input.indexOf(e, s + 2);
      if (i === -1)
        throw this.raise(F.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = i + e.length, wu.lastIndex = s + 2; wu.test(this.input) && wu.lastIndex <= i; )
        ++this.state.curLine, this.state.lineStart = wu.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(s + 2, i),
        start: s,
        end: i + e.length,
        loc: new Dn(r, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(a), a;
    }
    skipLineComment(e) {
      let r = this.state.pos, s;
      this.isLookahead || (s = this.state.curPosition());
      let i = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !to(i) && ++this.state.pos < this.length; )
          i = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(r + e, a),
        start: r,
        end: a,
        loc: new Dn(s, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(l), l;
    }
    skipSpace() {
      let e = this.state.pos, r = [];
      e: for (; this.state.pos < this.length; ) {
        let s = this.input.charCodeAt(this.state.pos);
        switch (s) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let i = this.skipBlockComment("*/");
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              case 47: {
                let i = this.skipLineComment(2);
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (soe(s))
              ++this.state.pos;
            else if (s === 45 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else if (s === 60 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r.length > 0) {
        let s = this.state.pos, i = {
          start: e,
          end: s,
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(i);
      }
    }
    finishToken(e, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let s = this.state.type;
      this.state.type = e, this.state.value = r, this.isLookahead || this.updateContext(s);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let e = this.state.pos + 1, r = this.codePointAtPos(e);
      if (r >= 48 && r <= 57)
        throw this.raise(F.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? F.RecordExpressionHashIncorrectStartSyntaxType : F.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else As(r) ? (++this.state.pos, this.finishToken(138, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(138, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(!0);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !to(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      let s = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, s), !0;
    }
    readToken_mult_modulo(e) {
      let r = e === 42 ? 55 : 54, s = 1, i = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && i === 42 && (s++, i = this.input.charCodeAt(this.state.pos + 2), r = 57), i === 61 && !this.state.inType && (s++, r = e ===
      37 ? 33 : 30), this.finishOp(r, s);
    }
    readToken_pipe_amp(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(F.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(F.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 62) {
        let s = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + s) === 61) {
          this.finishOp(30, s + 1);
          return;
        }
        this.finishOp(52, s);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let e = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(F.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(F.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (As(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(F.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, r) {
      let s = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(e, s);
    }
    readRegexp() {
      let e = this.state.startLoc, r = this.state.start + 1, s, i, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(F.UnterminatedRegExp, yr(e, 1));
        let c = this.input.charCodeAt(a);
        if (to(c))
          throw this.raise(F.UnterminatedRegExp, yr(e, 1));
        if (s)
          s = !1;
        else {
          if (c === 91)
            i = !0;
          else if (c === 93 && i)
            i = !1;
          else if (c === 47 && !i)
            break;
          s = c === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let l = "", u = /* @__PURE__ */ n(() => yr(e, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (ooe.has(c))
          c === 118 ? l.includes("u") && this.raise(F.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(F.IncompatibleRegExpUVFlags,
          u()), l.includes(p) && this.raise(F.DuplicateRegExpFlags, u());
        else if (On(c) || c === 92)
          this.raise(F.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += p;
      }
      this.state.pos = a, this.finishToken(137, {
        pattern: o,
        flags: l
      });
    }
    readInt(e, r, s = !1, i = !0) {
      let {
        n: a,
        pos: o
      } = E1(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, r, s, i, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(e) {
      let r = this.state.curPosition(), s = !1;
      this.state.pos += 2;
      let i = this.readInt(e);
      i == null && this.raise(F.InvalidDigit, yr(r, 2), {
        radix: e
      });
      let a = this.input.charCodeAt(this.state.pos);
      if (a === 110)
        ++this.state.pos, s = !0;
      else if (a === 109)
        throw this.raise(F.InvalidDecimal, r);
      if (As(this.codePointAtPos(this.state.pos)))
        throw this.raise(F.NumberIdentifier, this.state.curPosition());
      if (s) {
        let o = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, o);
        return;
      }
      this.finishToken(134, i);
    }
    readNumber(e) {
      let r = this.state.pos, s = this.state.curPosition(), i = !1, a = !1, o = !1, l = !1, u = !1;
      !e && this.readInt(10) === null && this.raise(F.InvalidNumber, this.state.curPosition());
      let c = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (c) {
        let y = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(F.StrictOctalLiteral, s), !this.state.strict) {
          let T = y.indexOf("_");
          T > 0 && this.raise(F.ZeroDigitNumericSeparator, yr(s, T));
        }
        u = c && !/[89]/.test(y);
      }
      let p = this.input.charCodeAt(this.state.pos);
      if (p === 46 && !u && (++this.state.pos, this.readInt(10), i = !0, p = this.input.charCodeAt(this.state.pos)), (p === 69 || p === 101) &&
      !u && (p = this.input.charCodeAt(++this.state.pos), (p === 43 || p === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      F.InvalidOrMissingExponent, s), i = !0, l = !0, p = this.input.charCodeAt(this.state.pos)), p === 110 && ((i || c) && this.raise(F.InvalidBigIntLiteral,
      s), ++this.state.pos, a = !0), p === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (l || c) && this.raise(F.InvalidDecimal,
      s), ++this.state.pos, o = !0), As(this.codePointAtPos(this.state.pos)))
        throw this.raise(F.NumberIdentifier, this.state.curPosition());
      let f = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(135, f);
        return;
      }
      if (o) {
        this.finishToken(136, f);
        return;
      }
      let m = u ? parseInt(f, 8) : parseFloat(f);
      this.finishToken(134, m);
    }
    readCodePoint(e) {
      let {
        code: r,
        pos: s
      } = A1(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
      return this.state.pos = s, r;
    }
    readString(e) {
      let {
        str: r,
        pos: s,
        curLine: i,
        lineStart: a
      } = i1(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = i, this.finishToken(133, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: s,
        pos: i,
        curLine: a,
        lineStart: o
      } = i1("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = i + 1, this.state.lineStart = o, this.state.curLine = a, s && (this.state.firstInvalidTemplateEscapePos = new os(s.curLine,
      s.pos - s.lineStart, s.pos)), this.input.codePointAt(i) === 96 ? this.finishToken(24, s ? null : e + r + "`") : (this.state.pos++, this.
      finishToken(25, s ? null : e + r + "${"));
    }
    recordStrictModeErrors(e, r) {
      let s = r.index;
      this.state.strict && !this.state.strictErrors.has(s) ? this.raise(e, r) : this.state.strictErrors.set(s, [e, r]);
    }
    readWord1(e) {
      this.state.containsEsc = !1;
      let r = "", s = this.state.pos, i = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (On(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(i, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === s ? As : On;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(F.MissingUnicodeEscape, this.state.curPosition()), i = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(F.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(u)), i = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(i, this.state.pos);
    }
    readWord(e) {
      let r = this.readWord1(e), s = bm.get(r);
      s !== void 0 ? this.finishToken(s, ii(s)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: e
      } = this.state;
      Am(e) && this.state.containsEsc && this.raise(F.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: ii(e)
      });
    }
    raise(e, r, s = {}) {
      let i = r instanceof os ? r : r.loc.start, a = e(i, s);
      if (!this.options.errorRecovery) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(e, r, s = {}) {
      let i = r instanceof os ? r : r.loc.start, a = i.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = e(i, s);
        if (u.loc.index < a) break;
      }
      return this.raise(e, r, s);
    }
    updateContext(e) {
    }
    unexpected(e, r) {
      throw this.raise(F.UnexpectedToken, e ?? this.state.startLoc, {
        expected: r ? ii(r) : null
      });
    }
    expectPlugin(e, r) {
      if (this.hasPlugin(e))
        return !0;
      throw this.raise(F.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((r) => this.hasPlugin(r)))
        throw this.raise(F.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: e
        });
    }
    errorBuilder(e) {
      return (r, s, i) => {
        this.raise(e, Qa(r, s, i));
      };
    }
  }, om = class {
    static {
      n(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, lm = class {
    static {
      n(this, "ClassScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new om());
    }
    exit() {
      let e = this.stack.pop(), r = this.current();
      for (let [s, i] of Array.from(e.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(s) || r.undefinedPrivateNames.set(s, i) : this.parser.raise(F.InvalidPrivateFieldResolution, i, {
          identifierName: s
        });
    }
    declarePrivateName(e, r, s) {
      let {
        privateNames: i,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = i.has(e);
      if (r & 3) {
        let u = l && a.get(e);
        if (u) {
          let c = u & 4, p = r & 4, f = u & 3, m = r & 3;
          l = f === m || c !== p, l || a.delete(e);
        } else l || a.set(e, r);
      }
      l && this.parser.raise(F.PrivateNameRedeclaration, s, {
        identifierName: e
      }), i.add(e), o.delete(e);
    }
    usePrivateName(e, r) {
      let s;
      for (s of this.stack)
        if (s.privateNames.has(e)) return;
      s ? s.undefinedPrivateNames.set(e, r) : this.parser.raise(F.InvalidPrivateFieldResolution, r, {
        identifierName: e
      });
    }
  }, _n = class {
    static {
      n(this, "ExpressionScope");
    }
    constructor(e = 0) {
      this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, Bu = class extends _n {
    static {
      n(this, "ArrowHeadParsingScope");
    }
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, r) {
      let s = r.index;
      this.declarationErrors.set(s, [e, r]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }, um = class {
    static {
      n(this, "ExpressionScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [new _n()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, r) {
      let s = r.loc.start, {
        stack: i
      } = this, a = i.length - 1, o = i[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(e, s);
        else
          return;
        o = i[--a];
      }
      this.parser.raise(e, s);
    }
    recordArrowParameterBindingError(e, r) {
      let {
        stack: s
      } = this, i = s[s.length - 1], a = r.loc.start;
      if (i.isCertainlyParameterDeclaration())
        this.parser.raise(e, a);
      else if (i.canBeArrowParameterDeclaration())
        i.recordDeclarationError(e, a);
      else
        return;
    }
    recordAsyncArrowParametersError(e) {
      let {
        stack: r
      } = this, s = r.length - 1, i = r[s];
      for (; i.canBeArrowParameterDeclaration(); )
        i.type === 2 && i.recordDeclarationError(F.AwaitBindingIdentifier, e), i = r[--s];
    }
    validateAsPattern() {
      let {
        stack: e
      } = this, r = e[e.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([s, i]) => {
        this.parser.raise(s, i);
        let a = e.length - 2, o = e[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(i.index), o = e[--a];
      });
    }
  };
  function loe() {
    return new _n(3);
  }
  n(loe, "newParameterDeclarationScope");
  function uoe() {
    return new Bu(1);
  }
  n(uoe, "newArrowHeadScope");
  function coe() {
    return new Bu(2);
  }
  n(coe, "newAsyncArrowScope");
  function v1() {
    return new _n();
  }
  n(v1, "newExpressionScope");
  var cm = class {
    static {
      n(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function _u(t, e) {
    return (t ? 2 : 0) | (e ? 1 : 0);
  }
  n(_u, "functionFlags");
  var pm = class extends am {
    static {
      n(this, "UtilParser");
    }
    addExtra(e, r, s, i = !0) {
      if (!e) return;
      let a = e.extra = e.extra || {};
      i ? a[r] = s : Object.defineProperty(a, r, {
        enumerable: i,
        value: s
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, r) {
      let s = e + r.length;
      if (this.input.slice(e, s) === r) {
        let i = this.input.charCodeAt(s);
        return !(On(i) || (i & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(e) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1;
    }
    expectContextual(e, r) {
      if (!this.eatContextual(e)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, e);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return P1.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return r1.lastIndex = this.state.end, r1.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = !0) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(F.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e, r) {
      this.eat(e) || this.unexpected(r, e);
    }
    tryParse(e, r = this.state.clone()) {
      let s = {
        node: null
      };
      try {
        let i = e((a = null) => {
          throw s.node = a, s;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: i,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: i,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (i) {
        let a = this.state;
        if (this.state = r, i instanceof SyntaxError)
          return {
            node: null,
            error: i,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (i === s)
          return {
            node: s.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw i;
      }
    }
    checkExpressionErrors(e, r) {
      if (!e) return !1;
      let {
        shorthandAssignLoc: s,
        doubleProtoLoc: i,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = e, l = !!s || !!i || !!o || !!a;
      if (!r)
        return l;
      s != null && this.raise(F.InvalidCoverInitializedName, s), i != null && this.raise(F.DuplicateProto, i), a != null && this.raise(F.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return d1(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let s = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let i = this.inModule;
      this.inModule = e;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, e);
      let l = this.prodParam;
      this.prodParam = new cm();
      let u = this.classScope;
      this.classScope = new lm(this);
      let c = this.expressionScope;
      return this.expressionScope = new um(this), () => {
        this.state.labels = r, this.exportedIdentifiers = s, this.inModule = i, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let e = 0;
      this.inModule && (e |= 2), this.scope.enter(1), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      let {
        privateKeyLoc: r
      } = e;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, kn = class {
    static {
      n(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, Ln = class {
    static {
      n(this, "Node");
    }
    constructor(e, r, s) {
      this.type = "", this.start = r, this.end = 0, this.loc = new Dn(s), e != null && e.options.ranges && (this.range = [r, 0]), e != null &&
      e.filename && (this.loc.filename = e.filename);
    }
  }, Im = Ln.prototype;
  Im.__clone = function() {
    let t = new Ln(void 0, this.start, this.loc.start), e = Object.keys(this);
    for (let r = 0, s = e.length; r < s; r++) {
      let i = e[r];
      i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (t[i] = this[i]);
    }
    return t;
  };
  function poe(t) {
    return Cs(t);
  }
  n(poe, "clonePlaceholder");
  function Cs(t) {
    let {
      type: e,
      start: r,
      end: s,
      loc: i,
      range: a,
      extra: o,
      name: l
    } = t, u = Object.create(Im);
    return u.type = e, u.start = r, u.end = s, u.loc = i, u.range = a, u.extra = o, u.name = l, e === "Placeholder" && (u.expectedNode = t.expectedNode),
    u;
  }
  n(Cs, "cloneIdentifier");
  function foe(t) {
    let {
      type: e,
      start: r,
      end: s,
      loc: i,
      range: a,
      extra: o
    } = t;
    if (e === "Placeholder")
      return poe(t);
    let l = Object.create(Im);
    return l.type = e, l.start = r, l.end = s, l.loc = i, l.range = a, t.raw !== void 0 ? l.raw = t.raw : l.extra = o, l.value = t.value, l;
  }
  n(foe, "cloneStringLiteral");
  var fm = class extends pm {
    static {
      n(this, "NodeUtils");
    }
    startNode() {
      let e = this.state.startLoc;
      return new Ln(this, e.index, e);
    }
    startNodeAt(e) {
      return new Ln(this, e.index, e);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.loc.start);
    }
    finishNode(e, r) {
      return this.finishNodeAt(e, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, r, s) {
      return e.type = r, e.end = s.index, e.loc.end = s, this.options.ranges && (e.range[1] = s.index), this.options.attachComment && this.processComment(
      e), e;
    }
    resetStartLocation(e, r) {
      e.start = r.index, e.loc.start = r, this.options.ranges && (e.range[0] = r.index);
    }
    resetEndLocation(e, r = this.state.lastTokEndLoc) {
      e.end = r.index, e.loc.end = r, this.options.ranges && (e.range[1] = r.index);
    }
    resetStartLocationFromNode(e, r) {
      this.resetStartLocation(e, r.loc.start);
    }
  }, hoe = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "sta\
tic", "string", "true", "typeof", "void"]), Ne = vs`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Cannot overwrite reserved type ${t}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Boolean enum members need to be initialized. Use either \`${t} = true,\` or \`${t} = false,\` in enum \`${e}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Enum member names need to be unique, but the name \`${t}\` has already been used before in enum \`${e}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ n(({
      enumName: t
    }) => `Enum \`${t}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ n(({
      invalidEnumType: t,
      enumName: e
    }) => `Enum type \`${t}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ n(({
      enumName: t
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      explicitType: r
    }) => `Enum \`${t}\` has type \`${r}\`, so the initializer of \`${e}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${t}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${t}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${r}\`, in enum \`${t}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${t}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ n(({
      enumName: t
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Unexpected reserved type ${t}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ n(({
      unsupportedExportKind: t,
      suggestion: e
    }) => `\`declare export ${t}\` is not supported. Use \`${e}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function doe(t) {
    return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "T\
ypeAlias" && t.declaration.type !== "InterfaceDeclaration");
  }
  n(doe, "isEsModuleType");
  function n1(t) {
    return t.importKind === "type" || t.importKind === "typeof";
  }
  n(n1, "hasTypeImportKind");
  var moe = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function yoe(t, e) {
    let r = [], s = [];
    for (let i = 0; i < t.length; i++)
      (e(t[i], i, t) ? r : s).push(t[i]);
    return [r, s];
  }
  n(yoe, "partition");
  var Toe = /\*?\s*@((?:no)?flow)\b/, boe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return tm;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(r, s) {
      r !== 133 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, s);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let s = Toe.exec(r.value);
        if (s) if (s[1] === "flow")
          this.flowPragma = "flow";
        else if (s[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let s = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let i = this.flowParseType();
      return this.state.inType = s, i;
    }
    flowParsePredicate() {
      let r = this.startNode(), s = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(Ne.UnexpectedSpaceBetweenModuloChecks,
      s), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let s = null, i = null;
      return this.match(54) ? (this.state.inType = r, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = r, this.
      match(54) && (i = this.flowParsePredicate())), [s, i];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let s = r.id = this.parseIdentifier(), i = this.startNode(), a = this.startNode();
      this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return i.params = o.params, i.rest = o.rest, i.this = o._this, this.expect(11), [i.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      s), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, s) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (s && this.raise(Ne.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, s);
      this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(133) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let s = r.body = this.startNode(), i = s.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(Ne.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, Ne.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), i.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
      let a = null, o = !1;
      return i.forEach((l) => {
        doe(l) ? (a === "CommonJS" && this.raise(Ne.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(Ne.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(Ne.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, s) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
        let i = this.state.value;
        throw this.raise(Ne.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: i,
          suggestion: moe[i]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.
        exportKind), r.type = "Declare" + r.type, r;
      this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let s = this.flowParseTypeAlias(r);
      return s.type = "DeclareTypeAlias", s;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let s = this.flowParseOpaqueType(r, !0);
      return s.type = "DeclareOpaqueType", s;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, s) {
      if (r.id = this.flowParseRestrictedIdentifier(!s, !0), this.scope.declareName(r.id.name, s ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!s && this.eat(12));
      if (s) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: s,
        allowExact: !1,
        allowSpread: !1,
        allowProto: s,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(Ne.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, s, i) {
      hoe.has(r) && this.raise(i ? Ne.AssignReservedType : Ne.UnexpectedReservedType, s, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, s) {
      return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, s) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, s || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let s = this.state.startLoc, i = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return i.name = o.name, i.variance = a, i.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) :
      r && this.raise(Ne.MissingTypeParamDefault, s), this.finishNode(i, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, s = this.startNode();
      s.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = !1;
      do {
        let a = this.flowParseTypeParameter(i);
        s.params.push(a), a.default && (i = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(s, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), s = this.state.inType;
      r.params = [], this.state.inType = !0, this.expect(47);
      let i = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let r = this.startNode(), s = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, s, i) {
      return r.static = s, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = i, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, s) {
      return r.static = s, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, s) {
      let i = this.startNode();
      return r.static = s, r.value = this.flowParseObjectTypeMethodish(i), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: s,
      allowSpread: i,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, p, f = !1;
      for (s && this.match(6) ? (this.expect(6), c = 9, p = !0) : (this.expect(5), c = 8, p = !1), u.exact = p; !this.match(c); ) {
        let y = !1, T = null, L = null, q = this.startNode();
        if (a && this.isContextual(118)) {
          let U = this.lookahead();
          U.type !== 14 && U.type !== 17 && (this.next(), T = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let U = this.lookahead();
          U.type !== 14 && U.type !== 17 && (this.next(), y = !0);
        }
        let _ = this.flowParseVariance();
        if (this.eat(0))
          T != null && this.unexpected(T), this.eat(0) ? (_ && this.unexpected(_.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          q, y))) : u.indexers.push(this.flowParseObjectTypeIndexer(q, y, _));
        else if (this.match(10) || this.match(47))
          T != null && this.unexpected(T), _ && this.unexpected(_.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(q, y));
        else {
          let U = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let ie = this.lookahead();
            d1(ie.type) && (U = this.state.value, this.next());
          }
          let J = this.flowParseObjectTypeProperty(q, y, T, _, U, i, o ?? !p);
          J === null ? (f = !0, L = this.state.lastTokStartLoc) : u.properties.push(J);
        }
        this.flowObjectTypeSemicolon(), L && !this.match(8) && !this.match(9) && this.raise(Ne.UnexpectedExplicitInexactInObject, L);
      }
      this.expect(c), i && (u.inexact = f);
      let m = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, m;
    }
    flowParseObjectTypeProperty(r, s, i, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(Ne.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(Ne.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(Ne.InexactVariance, a), null) : (l || this.raise(
        Ne.UnexpectedSpreadType, this.state.lastTokStartLoc), i != null && this.unexpected(i), a && this.raise(Ne.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = s, r.proto = i != null, r.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, i != null && this.unexpected(i), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !l && r.key.name === "constructor" && r.value.this && this.raise(Ne.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (c = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = c, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let s = r.kind === "get" ? 0 : 1, i = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? Ne.GetterMayNotHaveThisParam : Ne.SetterMayNotHaveThisParam, r.value.this), i !== s && this.
      raise(r.kind === "get" ? F.BadGetterArity : F.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(F.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, s) {
      var i;
      (i = r) != null || (r = this.state.startLoc);
      let a = s || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let o = this.startNodeAt(r);
        o.qualification = a, o.id = this.flowParseRestrictedIdentifier(!0), a = this.finishNode(o, "QualifiedTypeIdentifier");
      }
      return a;
    }
    flowParseGenericType(r, s) {
      let i = this.startNodeAt(r);
      return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(r, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(i, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let s = null, i = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !r && this.raise(Ne.ThisParamMustBeFirst, o), s = this.parseIdentifier(u), this.eat(17) &&
      (i = !0, u && this.raise(Ne.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = s,
      o.optional = i, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let s = this.startNodeAt(r.loc.start);
      return s.name = null, s.optional = !1, s.typeAnnotation = r, this.finishNode(s, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let s = null, i = null;
      for (this.match(78) && (i = this.flowParseFunctionTypeParam(!0), i.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (s = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: s,
        _this: i
      };
    }
    flowIdentToTypeAnnotation(r, s, i) {
      switch (i.name) {
        case "any":
          return this.finishNode(s, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(s, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(s, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(s, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(s, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(s, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(s, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(i.name), this.flowParseGenericType(r, i);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, s = this.startNode(), i, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47:
          return s.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), s.params =
          i.params, s.rest = i.rest, s.this = i._this, this.expect(11), this.expect(19), s.returnType = this.flowParseType(), this.finishNode(
          s, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (ft(this.state.type) || this.match(78)) {
              let u = this.lookahead().type;
              o = u !== 17 && u !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : i = this.flowParseFunctionTypeParams(),
          s.params = i.params, s.rest = i.rest, s.this = i._this, this.expect(11), this.expect(19), s.returnType = this.flowParseType(), s.typeParameters =
          null, this.finishNode(s, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
            throw this.raise(Ne.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(s, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(s, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Am(this.state.type)) {
            let u = ii(this.state.type);
            return this.next(), super.createIdentifier(s, u);
          } else if (ft(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, s, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, s = this.flowParsePrimaryType(), i = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        i = i || o, this.expect(0), !o && this.match(3) ? (a.elementType = s, this.next(), s = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = s, a.indexType = this.flowParseType(), this.expect(3), i ? (a.optional = o, s = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : s = this.finishNode(a, "IndexedAccessType"));
      }
      return s;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let s = this.startNodeAt(r.loc.start);
        return s.params = [this.reinterpretTypeAsFunctionTypeParam(r)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.
        typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let s = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [s]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? s : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let s = this.flowParseIntersectionType();
      for (r.types = [s]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? s : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let s = this.flowParseUnionType();
      return this.state.inType = r, s;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, s = this.parseIdentifier();
        return this.flowParseGenericType(r, s);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let s = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, s, i = !1) {
      if (s) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, i));
        return;
      }
      super.parseFunctionBody(r, !1, i);
    }
    parseFunctionBodyAndFinish(r, s, i = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, s, i);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let i = this.lookahead();
        if (Hr(i.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      }
      let s = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
    }
    parseExpressionStatement(r, s, i) {
      if (s.type === "Identifier") {
        if (s.name === "declare") {
          if (this.match(80) || ft(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (ft(this.state.type)) {
          if (s.name === "interface")
            return this.flowParseInterface(r);
          if (s.name === "type")
            return this.flowParseTypeAlias(r);
          if (s.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, s, i);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return t1(r) || this.shouldParseEnums() && r === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return t1(r) || this.shouldParseEnums() && r === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, s, i) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let m = this.lookaheadCharCode();
        if (m === 44 || m === 61 || m === 58 || m === 41)
          return this.setOptionalParametersError(i), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(s), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [p, f] = this.getArrowLikeExpressions(u);
      if (c || f.length > 0) {
        let m = [...o];
        if (f.length > 0) {
          this.state = a, this.state.noArrowAt = m;
          for (let y = 0; y < f.length; y++)
            m.push(f[y].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [p, f] = this.getArrowLikeExpressions(u);
        }
        c && p.length > 1 && this.raise(Ne.AmbiguousConditionalArrow, a.startLoc), c && p.length === 1 && (this.state = a, m.push(p[0].start),
        this.state.noArrowAt = m, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = r, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), s = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: s
      };
    }
    getArrowLikeExpressions(r, s) {
      let i = [r], a = [];
      for (; i.length !== 0; ) {
        let o = i.pop();
        o.type === "ArrowFunctionExpression" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(o) : a.push(o), i.push(o.body)) :
        o.type === "ConditionalExpression" && (i.push(o.consequent), i.push(o.alternate));
      }
      return s ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : yoe(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(r) {
      var s;
      this.toAssignableList(r.params, (s = r.extra) == null ? void 0 : s.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, s) {
      let i;
      return this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), i =
      s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
    }
    parseParenItem(r, s) {
      if (r = super.parseParenItem(r, s), this.eat(17) && (r.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let i = this.startNodeAt(s);
        return i.expression = r, i.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i, "TypeCastExpression");
      }
      return r;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        s);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseOpaqueType(s, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseInterface(s);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        r.exportKind = "value";
        let s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: s
      } = this.state, i = super.maybeParseExportNamespaceSpecifier(r);
      return i && r.exportKind === "type" && this.unexpected(s), i;
    }
    parseClassId(r, s, i) {
      super.parseClassId(r, s, i), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, s, i) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, s))
          return;
        s.declare = !0;
      }
      super.parseClassMember(r, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "Property\
Definition" ? this.raise(Ne.DeclareClassElement, a) : s.value && this.raise(Ne.DeclareClassFieldInitializer, s.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), s = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(F.InvalidIdentifier, this.state.curPosition(), {
        identifierName: s
      }), this.finishToken(132, s);
    }
    getTokenFromCode(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : Zae(r, s, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, s) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      !s && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, s);
    }
    toAssignableList(r, s, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, i);
    }
    toReferencedList(r, s) {
      for (let a = 0; a < r.length; a++) {
        var i;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((i = o.extra) != null && i.parenthesized) && (r.length > 1 || !s) && this.raise(Ne.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, s, i, a) {
      let o = super.parseArrayLike(r, s, i, a);
      return s && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(r, s, i) {
      return r === "TypeCastExpression" || super.isValidLVal(r, s, i);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, s, i, a, o, l) {
      if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, s, i, a, o, l), s.params && o) {
        let u = s.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ne.ThisParamBannedInConstructor, s);
      } else if (s.type === "MethodDefinition" && o && s.value.params) {
        let u = s.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ne.ThisParamBannedInConstructor, s);
      }
    }
    pushClassPrivateMethod(r, s, i, a) {
      s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, s, i, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.
      isContextual(113)) {
        this.next();
        let s = r.implements = [];
        do {
          let i = this.startNode();
          i.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.
          typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let s = this.getObjectOrClassMethodParams(r);
      if (s.length > 0) {
        let i = s[0];
        this.isThisParam(i) && r.kind === "get" ? this.raise(Ne.GetterMayNotHaveThisParam, i) : this.isThisParam(i) && this.raise(Ne.SetterMayNotHaveThisParam,
        i);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, s, i, a, o, l, u) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let p = super.parseObjPropValue(r, s, i, a, o, l, u);
      return c && ((p.value || p).typeParameters = c), p;
    }
    parseAssignableListItemTypes(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(Ne.PatternIsOptional, r), this.isThisParam(r) && this.raise(Ne.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(Ne.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(Ne.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, s) {
      let i = super.parseMaybeDefault(r, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(Ne.TypeBeforeInitializer,
      i.typeAnnotation), i;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Ne.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, s, i) {
      s.local = n1(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(s,
      i));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let s = this.lookaheadCharCode();
        return s === 123 || s === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, i, a) {
      if (super.applyImportPhase(r, s, i, a), s) {
        if (!i && this.match(65))
          return;
        r.exportKind = i === "type" ? i : "value";
      } else
        i === "type" && this.match(55) && this.unexpected(), r.importKind = i === "type" || i === "typeof" ? i : "value";
    }
    parseImportSpecifier(r, s, i, a, o) {
      let l = r.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let f = this.parseIdentifier(!0);
        u !== null && !Hr(this.state.type) ? (r.imported = f, r.importKind = u, r.local = Cs(f)) : (r.imported = l, r.importKind = null, r.local =
        this.parseIdentifier());
      } else {
        if (u !== null && Hr(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = u;
        else {
          if (s)
            throw this.raise(F.ImportBindingIsString, r, {
              importName: l.value
            });
          r.imported = l, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (c = !0, r.local = Cs(r.imported));
      }
      let p = n1(r);
      return i && p && this.raise(Ne.ImportTypeShorthandOnlyInPureImport, r), (i || p) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), c && !i && !p && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, s) {
      let i = r.kind;
      i !== "get" && i !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      if (this.match(14)) {
        let i = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
      }
      return super.parseAsyncArrowFromCallExpression(r, s);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, s) {
      var i;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, s), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, p = c[c.length - 1];
        (p === St.j_oTag || p === St.j_expr) && c.pop();
      }
      if ((i = o) != null && i.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, p = this.tryParse((m) => {
          var y;
          c = this.flowParseTypeParameterDeclaration();
          let T = this.forwardNoArrowParamsConversionAt(c, () => {
            let q = super.parseMaybeAssign(r, s);
            return this.resetStartLocationFromNode(q, c), q;
          });
          (y = T.extra) != null && y.parenthesized && m();
          let L = this.maybeUnwrapTypeCastExpression(T);
          return L.type !== "ArrowFunctionExpression" && m(), L.typeParameters = c, this.resetStartLocationFromNode(L, c), T;
        }, a), f = null;
        if (p.node && this.maybeUnwrapTypeCastExpression(p.node).type === "ArrowFunctionExpression") {
          if (!p.error && !p.aborted)
            return p.node.async && this.raise(Ne.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), p.node;
          f = p.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (f)
          return this.state = p.failState, f;
        throw (u = o) != null && u.thrown ? o.error : p.thrown ? p.error : this.raise(Ne.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse(() => {
          let i = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (s.thrown) return null;
        s.error && (this.state = s.failState), r.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, s) {
      this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? r.params = s : super.setArrowFunctionParameters(r, s);
    }
    checkParams(r, s, i, a = !0) {
      if (!(i && this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1)) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(Ne.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, s, i, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(r, s, i) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.indexOf(s.index) !== -1) {
        this.next();
        let a = this.startNodeAt(s);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(11, !1), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(s) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(r, s, i), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(r, s, i);
    }
    parseSubscript(r, s, i, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, i)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(s);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11, !1), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!i && this.shouldParseTypes() && this.match(47)) {
        let o = this.startNodeAt(s);
        o.callee = r;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11, !1), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(r, s, i, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let s = null;
      this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      s;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let s = this.startNodeAt(r);
      if (this.parseFunctionParams(s, !1), !!this.parseArrow(s))
        return super.parseArrowExpression(s, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && s === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && s === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, s) {
      let i = super.parseTopLevel(r, s);
      return this.state.hasFlowComment && this.raise(Ne.UnterminatedFlowComment, this.state.curPosition()), i;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(Ne.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, s = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + s)); )
        s++;
      let i = this.input.charCodeAt(s + r), a = this.input.charCodeAt(s + r + 1);
      return i === 58 && a === 58 ? s + 2 : this.input.slice(s + r, s + r + 12) === "flow-include" ? s + 12 : i === 58 && a !== 58 ? s : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(F.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: s,
      memberName: i
    }) {
      this.raise(Ne.EnumBooleanMemberNotInitialized, r, {
        memberName: i,
        enumName: s
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, s) {
      return this.raise(s.explicitType ? s.explicitType === "symbol" ? Ne.EnumInvalidMemberInitializerSymbolType : Ne.EnumInvalidMemberInitializerPrimaryType :
      Ne.EnumInvalidMemberInitializerUnknownType, r, s);
    }
    flowEnumErrorNumberMemberNotInitialized(r, s) {
      this.raise(Ne.EnumNumberMemberNotInitialized, r, s);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, s) {
      this.raise(Ne.EnumStringMemberInconsistentlyInitialized, r, s);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, s = /* @__PURE__ */ n(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 134: {
          let i = this.parseNumericLiteral(this.state.value);
          return s() ? {
            type: "number",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 133: {
          let i = this.parseStringLiteral(this.state.value);
          return s() ? {
            type: "string",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let i = this.parseBooleanLiteral(this.match(85));
          return s() ? {
            type: "boolean",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, s = this.parseIdentifier(!0), i = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: s,
        init: i
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, s, i) {
      let {
        explicitType: a
      } = s;
      a !== null && a !== i && this.flowEnumErrorInvalidMemberInitializer(r, s);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: s
    }) {
      let i = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), p = u.name;
        if (p === "")
          continue;
        /^[a-z]/.test(p) && this.raise(Ne.EnumInvalidMemberName, u, {
          memberName: p,
          suggestion: p[0].toUpperCase() + p.slice(1),
          enumName: r
        }), i.has(p) && this.raise(Ne.EnumDuplicateMemberName, u, {
          memberName: p,
          enumName: r
        }), i.add(p);
        let f = {
          enumName: r,
          explicitType: s,
          memberName: p
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, f);
          case "none":
            switch (s) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, f);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, f);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, s, {
      enumName: i
    }) {
      if (r.length === 0)
        return s;
      if (s.length === 0)
        return r;
      if (s.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return s;
      } else {
        for (let a of s)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!ft(this.state.type))
        throw this.raise(Ne.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: s
      } = this.state;
      return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(Ne.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: s
      }), s;
    }
    flowEnumBody(r, s) {
      let i = s.name, a = s.loc.start, o = this.flowEnumParseExplicitType({
        enumName: i
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: i,
        explicitType: o
      });
      switch (r.hasUnknownMembers = u, o) {
        case "boolean":
          return r.explicitType = !0, r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: i
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = l.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ n(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let p = l.booleanMembers.length, f = l.numberMembers.length, m = l.stringMembers.length, y = l.defaultedMembers.length;
          if (!p && !f && !m && !y)
            return c();
          if (!p && !f)
            return r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: i
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!f && !m && p >= y) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(T.loc.start, {
                enumName: i,
                memberName: T.id.name
              });
            return r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!p && !m && f >= y) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(T.loc.start, {
                enumName: i,
                memberName: T.id.name
              });
            return r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(Ne.EnumInconsistentMemberValues, a, {
              enumName: i
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let s = this.parseIdentifier();
      return r.id = s, r.body = this.flowEnumBody(this.startNode(), s), this.finishNode(r, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let s = this.input.charCodeAt(r + 1);
        return s !== 60 && s !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), xoe = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, Wi = vs`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ n(({
      openingTagName: t
    }) => `Expected corresponding JSX closing tag for <${t}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t,
      HTMLEntity: e
    }) => `Unexpected token \`${t}\`. Did you mean \`${e}\` or \`{'${t}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function ri(t) {
    return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : !1;
  }
  n(ri, "isFragment");
  function Nn(t) {
    if (t.type === "JSXIdentifier")
      return t.name;
    if (t.type === "JSXNamespacedName")
      return t.namespace.name + ":" + t.name.name;
    if (t.type === "JSXMemberExpression")
      return Nn(t.object) + "." + Nn(t.property);
    throw new Error("Node had unexpected type: " + t.type);
  }
  n(Nn, "getQualifiedJSXName");
  var Soe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", s = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Wi.UnterminatedJsxContent, this.state.startLoc);
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(i);
              return;
            }
            r += this.input.slice(s, this.state.pos), this.finishToken(141, r);
            return;
          case 38:
            r += this.input.slice(s, this.state.pos), r += this.jsxReadEntity(), s = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            to(i) ? (r += this.input.slice(s, this.state.pos), r += this.jsxReadNewLine(!0), s = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let s = this.input.charCodeAt(this.state.pos), i;
      return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = r ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
    }
    jsxReadString(r) {
      let s = "", i = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(F.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : to(a) ? (s += this.input.slice(
        i, this.state.pos), s += this.jsxReadNewLine(!1), i = this.state.pos) : ++this.state.pos;
      }
      s += this.input.slice(i, this.state.pos++), this.finishToken(133, s);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let s = 10;
        this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
        let i = this.readInt(s, void 0, !1, "bail");
        if (i !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(i);
      } else {
        let s = 0, i = !1;
        for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (i) {
          let a = this.input.slice(r, this.state.pos), o = xoe[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, s = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (On(r) || r === 45);
      this.finishToken(140, this.input.slice(s, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(140) ? r.name = this.state.value : Am(this.state.type) ? r.name = ii(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, s = this.jsxParseIdentifier();
      if (!this.eat(14)) return s;
      let i = this.startNodeAt(r);
      return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, s = this.jsxParseNamespacedName();
      if (s.type === "JSXNamespacedName")
        return s;
      for (; this.eat(16); ) {
        let i = this.startNodeAt(r);
        i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
      }
      return s;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(St.brace), this.next(), r = this.jsxParseExpressionContainer(r, St.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(Wi.AttributeIsEmpty, r), r;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(Wi.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(St.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, s) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let i = this.parseExpression();
        r.expression = i;
      }
      return this.setContext(s), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(St.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      St.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      s));
    }
    jsxParseOpeningElementAfterName(r) {
      let s = [];
      for (; !this.match(56) && !this.match(143); )
        s.push(this.jsxParseAttribute());
      return r.attributes = s, r.selfClosing = this.eat(56), this.expect(143), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(143), this.finishNode(
      s, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let s = this.startNodeAt(r), i = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 142:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              i.push(this.jsxParseElementAt(r));
              break;
            case 141:
              i.push(this.parseExprAtom());
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(St.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(l)) : i.push(this.jsxParseExpressionContainer(
              l, St.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        ri(a) && !ri(o) && o !== null ? this.raise(Wi.MissingClosingTagFragment, o) : !ri(a) && ri(o) ? this.raise(Wi.MissingClosingTagElement,
        o, {
          openingTagName: Nn(a.name)
        }) : !ri(a) && !ri(o) && Nn(o.name) !== Nn(a.name) && this.raise(Wi.MissingClosingTagElement, o, {
          openingTagName: Nn(a.name)
        });
      }
      if (ri(a) ? (s.openingFragment = a, s.closingFragment = o) : (s.openingElement = a, s.closingElement = o), s.children = i, this.match(
      47))
        throw this.raise(Wi.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return ri(a) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: s
      } = this.state;
      s[s.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) &&
      this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let s = this.curContext();
      if (s === St.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (s === St.j_oTag || s === St.j_cTag) {
        if (As(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((r === 34 || r === 39) && s === St.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: s,
        type: i
      } = this.state;
      if (i === 56 && r === 142)
        s.splice(-2, 2, St.j_cTag), this.state.canStartJSXElement = !1;
      else if (i === 142)
        s.push(St.j_oTag);
      else if (i === 143) {
        let a = s[s.length - 1];
        a === St.j_oTag && r === 56 || a === St.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === St.j_expr) : (this.setContext(
        St.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = Fae(i);
    }
  }, "jsx"), hm = class extends ro {
    static {
      n(this, "TypeScriptScope");
    }
    constructor(...e) {
      super(...e), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, dm = class extends so {
    static {
      n(this, "TypeScriptScopeHandler");
    }
    constructor(...e) {
      super(...e), this.importsStack = [];
    }
    createScope(e) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new hm(e);
    }
    enter(e) {
      e == 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e);
    }
    exit() {
      let e = super.exit();
      return e == 256 && this.importsStack.pop(), e;
    }
    hasImport(e, r) {
      let s = this.importsStack.length;
      if (this.importsStack[s - 1].has(e))
        return !0;
      if (!r && s > 1) {
        for (let i = 0; i < s - 1; i++)
          if (this.importsStack[i].has(e)) return !0;
      }
      return !1;
    }
    declareName(e, r, s) {
      if (r & 4096) {
        this.hasImport(e, !0) && this.parser.raise(F.VarRedeclaration, s, {
          identifierName: e
        }), this.importsStack[this.importsStack.length - 1].add(e);
        return;
      }
      let i = this.currentScope(), a = i.tsNames.get(e) || 0;
      if (r & 1024) {
        this.maybeExportDefined(i, e), i.tsNames.set(e, a | 16);
        return;
      }
      super.declareName(e, r, s), r & 2 && (r & 1 || (this.checkRedeclarationInScope(i, e, r, s), this.maybeExportDefined(i, e)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && i.tsNames.set(e, a);
    }
    isRedeclaredInScope(e, r, s) {
      let i = e.tsNames.get(r);
      if ((i & 2) > 0) {
        if (s & 256) {
          let a = !!(s & 512), o = (i & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return s & 128 && (i & 8) > 0 ? e.names.get(r) & 2 ? !!(s & 1) : !1 : s & 2 && (i & 1) > 0 ? !0 : super.isRedeclaredInScope(e, r, s);
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      if (this.hasImport(r)) return;
      let s = this.scopeStack.length;
      for (let i = s - 1; i >= 0; i--) {
        let o = this.scopeStack[i].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(e);
    }
  }, goe = /* @__PURE__ */ n((t, e) => hasOwnProperty.call(t, e) && t[e], "getOwn$1"), C1 = /* @__PURE__ */ n((t) => t.type === "Parenthesiz\
edExpression" ? C1(t.expression) : t, "unwrapParenthesizedExpression"), mm = class extends fm {
    static {
      n(this, "LValParser");
    }
    toAssignable(e, r = !1) {
      var s, i;
      let a;
      switch ((e.type === "ParenthesizedExpression" || (s = e.extra) != null && s.parenthesized) && (a = C1(e), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(F.InvalidParenthesizedAssignment, e) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(F.InvalidParenthesizedAssignment, e) : this.raise(F.InvalidParenthesizedAssignment, e)), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let l = 0, u = e.properties.length, c = u - 1; l < u; l++) {
            var o;
            let p = e.properties[l], f = l === c;
            this.toAssignableObjectExpressionProp(p, f, r), f && p.type === "RestElement" && (o = e.extra) != null && o.trailingCommaLoc && this.
            raise(F.RestTrailingComma, e.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = e;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (i = e.extra) == null ? void 0 : i.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(F.MissingEqInAssignment, e.left.loc.end), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(
          e.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, r, s) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? F.PatternHasAccessor : F.PatternHasMethod, e.key);
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        let i = e.argument;
        this.checkToRestConversion(i, !1), this.toAssignable(i, s), r || this.raise(F.RestTrailingComma, e);
      } else
        this.toAssignable(e, s);
    }
    toAssignableList(e, r, s) {
      let i = e.length - 1;
      for (let a = 0; a <= i; a++) {
        let o = e[a];
        if (o) {
          if (o.type === "SpreadElement") {
            o.type = "RestElement";
            let l = o.argument;
            this.checkToRestConversion(l, !0), this.toAssignable(l, s);
          } else
            this.toAssignable(o, s);
          o.type === "RestElement" && (a < i ? this.raise(F.RestTrailingComma, o) : r && this.raise(F.RestTrailingComma, r));
        }
      }
    }
    isAssignable(e, r) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let s = e.properties.length - 1;
          return e.properties.every((i, a) => i.type !== "ObjectMethod" && (a === s || i.type !== "SpreadElement") && this.isAssignable(i));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((s) => s === null || this.isAssignable(s));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(e, r) {
      return e;
    }
    toReferencedListDeep(e, r) {
      this.toReferencedList(e, r);
      for (let s of e)
        s?.type === "ArrayExpression" && this.toReferencedListDeep(s.elements);
    }
    parseSpread(e) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(e, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, 1), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, r, s) {
      let i = s & 1, a = [], o = !0;
      for (; !this.eat(e); )
        if (o ? o = !1 : this.expect(12), i && this.match(12))
          a.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            if (a.push(this.parseAssignableListItemTypes(this.parseRestBinding(), s)), !this.checkCommaAfterRest(r)) {
              this.expect(e);
              break;
            }
          } else {
            let l = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(F.UnsupportedParameterDecorator, this.state.startLoc); this.match(
            26); )
              l.push(this.parseDecorator());
            a.push(this.parseAssignableListItem(s, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      let e = this.startNode(), {
        type: r,
        startLoc: s
      } = this.state;
      return r === 21 ? this.parseBindingRestProperty(e) : (r === 138 ? (this.expectPlugin("destructuringPrivate", s), this.classScope.usePrivateName(
      this.state.value, s), e.key = this.parsePrivateName()) : this.parsePropertyName(e), e.method = !1, this.parseObjPropValue(e, s, !1, !1,
      !0, !1));
    }
    parseAssignableListItem(e, r) {
      let s = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(s, e);
      let i = this.parseMaybeDefault(s.loc.start, s);
      return r.length && (s.decorators = r), i;
    }
    parseAssignableListItemTypes(e, r) {
      return e;
    }
    parseMaybeDefault(e, r) {
      var s, i;
      if ((s = e) != null || (e = this.state.startLoc), r = (i = r) != null ? i : this.parseBindingAtom(), !this.eat(29)) return r;
      let a = this.startNodeAt(e);
      return a.left = r, a.right = this.parseMaybeAssignAllowIn(), this.finishNode(a, "AssignmentPattern");
    }
    isValidLVal(e, r, s) {
      return goe({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, e);
    }
    isOptionalMemberExpression(e) {
      return e.type === "OptionalMemberExpression";
    }
    checkLVal(e, {
      in: r,
      binding: s = 64,
      checkClashes: i = !1,
      strictModeChanged: a = !1,
      hasParenthesizedAncestor: o = !1
    }) {
      var l;
      let u = e.type;
      if (this.isObjectMethod(e)) return;
      let c = this.isOptionalMemberExpression(e);
      if (c || u === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", e.loc.start), r.type !== "AssignmentExpression" && this.raise(F.InvalidLhsOptionalChaining,
        e, {
          ancestor: r
        })), s !== 64 && this.raise(F.InvalidPropertyBindingPattern, e);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(e, s, a);
        let {
          name: T
        } = e;
        i && (i.has(T) ? this.raise(F.ParamDupe, e) : i.add(T));
        return;
      }
      let p = this.isValidLVal(u, !(o || (l = e.extra) != null && l.parenthesized) && r.type === "AssignmentExpression", s);
      if (p === !0) return;
      if (p === !1) {
        let T = s === 64 ? F.InvalidLhs : F.InvalidLhsBinding;
        this.raise(T, e, {
          ancestor: r
        });
        return;
      }
      let [f, m] = Array.isArray(p) ? p : [p, u === "ParenthesizedExpression"], y = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : r;
      for (let T of [].concat(e[f]))
        T && this.checkLVal(T, {
          in: y,
          binding: s,
          checkClashes: i,
          strictModeChanged: a,
          hasParenthesizedAncestor: m
        });
    }
    checkIdentifier(e, r, s = !1) {
      this.state.strict && (s ? S1(e.name, this.inModule) : x1(e.name)) && (r === 64 ? this.raise(F.StrictEvalArguments, e, {
        referenceName: e.name
      }) : this.raise(F.StrictEvalArgumentsBinding, e, {
        bindingName: e.name
      })), r & 8192 && e.name === "let" && this.raise(F.LetInLexicalBinding, e), r & 64 || this.declareNameFromIdentifier(e, r);
    }
    declareNameFromIdentifier(e, r) {
      this.scope.declareName(e.name, r, e.loc.start);
    }
    checkToRestConversion(e, r) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(F.InvalidRestAssignmentPattern, e);
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? F.RestTrailingComma : F.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  }, Poe = /* @__PURE__ */ n((t, e) => hasOwnProperty.call(t, e) && t[e], "getOwn");
  function Eoe(t) {
    if (t == null)
      throw new Error(`Unexpected ${t} value.`);
    return t;
  }
  n(Eoe, "nonNull");
  function a1(t) {
    if (!t)
      throw new Error("Assert fail");
  }
  n(a1, "assert");
  var me = vs`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ n(({
      methodName: t
    }) => `Method '${t}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ n(({
      propertyName: t
    }) => `Property '${t}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or nu\
meric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ n(({
      kind: t
    }) => `'declare' is not allowed in ${t}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => `Duplicate modifier: '${t}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ n(({
      token: t
    }) => `'${t}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ n(({
      modifiers: t
    }) => `'${t[0]}' modifier cannot be used with '${t[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Index signatures cannot have an accessibility modifier ('${t}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ n(({
      orderedModifiers: t
    }) => `'${t[0]}' modifier must precede '${t[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Private elements cannot have an accessibility modifier ('${t}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ n(({
      typeParameterName: t
    }) => `Single type parameter ${t} should have a trailing comma. Example usage: <${t},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ n(({
      type: t
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t}.`, "UnsupportedSignatureParameterKind")
  });
  function Aoe(t) {
    switch (t) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  n(Aoe, "keywordTypeFromName");
  function o1(t) {
    return t === "private" || t === "public" || t === "protected";
  }
  n(o1, "tsIsAccessModifier");
  function voe(t) {
    return t === "in" || t === "out";
  }
  n(voe, "tsIsVarianceAnnotations");
  var Coe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: me.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: me.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: me.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return dm;
    }
    tsIsIdentifier() {
      return ft(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.
      hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(r, s) {
      if (!ft(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let i = this.state.value;
      if (r.indexOf(i) !== -1) {
        if (s && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return i;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: s,
      stopOnStartOfClassStaticBlock: i,
      errorTemplate: a = me.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ n((c, p, f, m) => {
        p === f && o[m] && this.raise(me.InvalidModifiersOrder, c, {
          orderedModifiers: [f, m]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ n((c, p, f, m) => {
        (o[f] && p === m || o[m] && p === f) && this.raise(me.IncompatibleModifiers, c, {
          modifiers: [f, m]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, p = this.tsParseModifier(r.concat(s ?? []), i);
        if (!p) break;
        o1(p) ? o.accessibility ? this.raise(me.DuplicateAccessibilityModifier, c, {
          modifier: p
        }) : (l(c, p, p, "override"), l(c, p, p, "static"), l(c, p, p, "readonly"), o.accessibility = p) : voe(p) ? (o[p] && this.raise(me.DuplicateModifier,
        c, {
          modifier: p
        }), o[p] = !0, l(c, p, "in", "out")) : (hasOwnProperty.call(o, p) ? this.raise(me.DuplicateModifier, c, {
          modifier: p
        }) : (l(c, p, "static", "readonly"), l(c, p, "static", "override"), l(c, p, "override", "readonly"), l(c, p, "abstract", "override"),
        u(c, p, "declare", "override"), u(c, p, "static", "abstract")), o[p] = !0), s != null && s.includes(p) && this.raise(a, c, {
          modifier: p
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, s) {
      let i = [];
      for (; !this.tsIsListTerminator(r); )
        i.push(s());
      return i;
    }
    tsParseDelimitedList(r, s, i) {
      return Eoe(this.tsParseDelimitedListWorker(r, s, !0, i));
    }
    tsParseDelimitedListWorker(r, s, i, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(r); ) {
        l = -1;
        let u = s();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        i && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(r, s, i, a, o) {
      a || (i ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(r, s, o);
      return i ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(me.UnsupportedImportTypeArgument, this.state.startLoc), r.argument =
      super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r.options = null), this.eat(12) &&
      (this.expectImportAttributesPlugin(), this.match(11) || (r.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11),
      this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(
      r, "TSImportType");
    }
    tsParseEntityName(r = !0) {
      let s = this.parseIdentifier(r);
      for (; this.eat(16); ) {
        let i = this.startNodeAtNode(s);
        i.left = s, i.right = this.parseIdentifier(r), s = this.finishNode(i, "TSQualifiedName");
      }
      return s;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let s = this.startNodeAtNode(r);
      return s.parameterName = r, s.typeAnnotation = this.tsParseTypeAnnotation(!1), s.asserts = !1, this.finishNode(s, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let s = this.startNode();
      return r(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(
      29), this.finishNode(s, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let s = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = {
        value: -1
      };
      return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, i), s.params.
      length === 0 && this.raise(me.EmptyTypeParameters, s), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, s) {
      let i = r === 19, a = "parameters", o = "typeAnnotation";
      s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[a] = this.tsParseBindingListForSignature(),
      i ? s[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (s[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let s of r) {
        let {
          type: i
        } = s;
        (i === "AssignmentPattern" || i === "TSParameterProperty") && this.raise(me.UnsupportedSignatureParameterKind, s, {
          type: i
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, s) {
      return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), ft(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let s = this.parseIdentifier();
      s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), r.parameters = [s];
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, s) {
      this.eat(17) && (r.optional = !0);
      let i = r;
      if (this.match(10) || this.match(47)) {
        s && this.raise(me.ReadonlyForMethodSignature, r);
        let a = i;
        a.kind && this.match(47) && this.raise(me.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(F.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(me.AccesorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(F.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(me.AccesorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(me.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            me.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          a[l] && this.raise(me.SetAccesorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = i;
        s && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let i = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let s = this.tsTryParseIndexSignature(r);
      return s || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let r = this.startNode();
      return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), this.finishNode(r, "TSTypeParameter");
    }
    tsParseMappedType() {
      let r = this.startNode();
      return this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(
      122) && (r.readonly = !0), this.expect(0), r.typeParameter = this.tsParseMappedTypeParameter(), r.nameType = this.eatContextual(93) ? this.
      tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) &&
      (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let s = !1;
      return r.elementTypes.forEach((i) => {
        let {
          type: a
        } = i;
        s && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && i.optional) && this.raise(me.OptionalTypeBeforeRequired,
        i), s || (s = a === "TSNamedTupleMember" && i.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let {
        startLoc: r
      } = this.state, s = this.eat(21), i, a, o, l, c = Hr(this.state.type) ? this.lookaheadCharCode() : null;
      if (c === 58)
        i = !0, o = !1, a = this.parseIdentifier(!0), this.expect(14), l = this.tsParseType();
      else if (c === 63) {
        o = !0;
        let p = this.state.startLoc, f = this.state.value, m = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (i = !0, a = this.createIdentifier(this.startNodeAt(p), f), this.expect(17), this.expect(14), l = this.
        tsParseType()) : (i = !1, l = m, this.expect(17));
      } else
        l = this.tsParseType(), o = this.eat(17), i = this.eat(14);
      if (i) {
        let p;
        a ? (p = this.startNodeAtNode(a), p.optional = o, p.label = a, p.elementType = l, this.eat(17) && (p.optional = !0, this.raise(me.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (p = this.startNodeAtNode(l), p.optional = o, this.raise(me.InvalidTupleMemberLabel, l), p.label = l,
        p.elementType = this.tsParseType()), l = this.finishNode(p, "TSNamedTupleMember");
      } else if (o) {
        let p = this.startNodeAtNode(l);
        p.typeAnnotation = l, l = this.finishNode(p, "TSOptionalType");
      }
      if (s) {
        let p = this.startNodeAt(r);
        p.typeAnnotation = l, l = this.finishNode(p, "TSRestType");
      }
      return l;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, s) {
      let i = this.startNode();
      return r === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, i)), this.finishNode(i, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let r = this.startNode();
      return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), s = this.lookahead();
            return s.type !== 134 && s.type !== 135 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (ft(r) || r === 88 || r === 84) {
            let s = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : Aoe(this.state.value);
            if (s !== void 0 && this.lookaheadCharCode() !== 46) {
              let i = this.startNode();
              return this.next(), this.finishNode(i, s);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let r = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let s = this.startNodeAtNode(r);
          s.elementType = r, this.expect(3), r = this.finishNode(s, "TSArrayType");
        } else {
          let s = this.startNodeAtNode(r);
          s.objectType = r, s.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(s, "TSIndexedAccessType");
        }
      return r;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), s = this.state.value;
      return this.next(), r.operator = s, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(me.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let s = this.startNode();
      return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(s, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return Kae(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, s, i) {
      let a = this.startNode(), o = this.eat(i), l = [];
      do
        l.push(s());
      while (this.eat(i));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (ft(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === s;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === s;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let s = this.startNode();
        this.expect(r);
        let i = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (i.parameterName = u, i.asserts = !0, i.typeAnnotation = null, u = this.finishNode(i, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, i), u.asserts = !0), s.typeAnnotation = u, this.finishNode(s, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (i.parameterName = this.parseIdentifier(), i.asserts = a, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i,
          "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, s);
        let l = this.tsParseTypeAnnotation(!1);
        return i.parameterName = o, i.typeAnnotation = l, i.asserts = a, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(
        s, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !ft(this.state.type) && !this.match(78) ? !1 : (r && this.raise(F.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, s = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), s.typeAnnotation = this.tsParseType();
      }), this.finishNode(s, "TSTypeAnnotation");
    }
    tsParseType() {
      a1(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let s = this.startNodeAtNode(r);
      return s.checkType = r, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(s, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(me.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let a = this.startNode();
        return a.expression = this.tsParseEntityName(), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
        a, "TSExpressionWithTypeArguments");
      });
      return i.length || this.raise(me.EmptyHeritageClauseType, s, {
        token: r
      }), i;
    }
    tsParseInterfaceDeclaration(r, s = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), s.declare && (r.declare = !0), ft(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(me.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let i = this.startNode();
      return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let s = this.startNode();
          return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInNoContext(r) {
      let s = this.state.context;
      this.state.context = [s[0]];
      try {
        return r();
      } finally {
        this.state.context = s;
      }
    }
    tsInType(r) {
      let s = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = s;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, s = {}) {
      return s.const && (r.const = !0), s.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, s = !1) {
      if (r.id = this.parseIdentifier(), s || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let i = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(i, !0), r.body = i;
      } else
        this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.global = !0, r.id = this.parseIdentifier()) : this.match(133) ? r.id = super.parseStringLiteral(this.
      state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(),
      this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(r, s, i) {
      r.isExport = i || !1, r.id = s || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(me.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let s = this.state.clone(), i = r();
      return this.state = s, i;
    }
    tsTryParseAndCatch(r) {
      let s = this.tryParse((i) => r() || i());
      if (!(s.aborted || !s.node))
        return s.error && (this.state = s.failState), s.node;
    }
    tsTryParse(r) {
      let s = this.state.clone(), i = r();
      if (i !== void 0 && i !== !1)
        return i;
      this.state = s;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let s = this.state.type, i;
      return this.isContextual(100) && (s = 74, i = "let"), this.tsInAmbientContext(() => {
        switch (s) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, i || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (ft(s))
              return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, s, i) {
      switch (s.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(r);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = r;
            return a.global = !0, a.id = s, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a,
            "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, s.name, !1, i);
      }
    }
    tsParseDeclaration(r, s, i, a) {
      switch (s) {
        case "abstract":
          if (this.tsCheckLineTerminator(i) && (this.match(80) || ft(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(i)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (ft(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(i) && ft(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(i) && ft(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let s = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let i = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = s, !!i)
        return super.parseArrowExpression(i, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments",
      this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(me.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      St.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return Wae(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(r, s) {
      let i = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(r & 4) && (o || u || l) && this.raise(me.UnexpectedParameterModifier, i);
      let c = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(c, r);
      let p = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let f = this.startNodeAt(i);
        return s.length && (f.decorators = s), o && (f.accessibility = o), u && (f.readonly = u), l && (f.override = l), p.type !== "Identif\
ier" && p.type !== "AssignmentPattern" && this.raise(me.UnsupportedParameterPropertyKind, f), f.parameter = p, this.finishNode(f, "TSParamet\
erProperty");
      }
      return s.length && (c.decorators = s), p;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let s of r.params)
        s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(me.PatternIsOptional, s);
    }
    setArrowFunctionParameters(r, s, i) {
      super.setArrowFunctionParameters(r, s, i), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, s, i = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(me.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, i) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, s, i));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((s) => {
        s?.type === "TSTypeCastExpression" && this.raise(me.UnexpectedTypeAnnotation, s.typeAnnotation);
      });
    }
    toReferencedList(r, s) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, s, i, a) {
      let o = super.parseArrayLike(r, s, i, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(r, s, i, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(s);
        return l.expression = r, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (i)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!i && this.atPossibleAsyncArrow(r)) {
            let m = this.tsTryParseGenericAsyncArrowFunction(s);
            if (m)
              return m;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (Mu(this.state.type)) {
            let m = super.parseTaggedTemplateExpression(r, s, a);
            return m.typeParameters = c, m;
          }
          if (!i && this.eat(10)) {
            let m = this.startNodeAt(s);
            return m.callee = r, m.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(m.arguments), m.typeParameters =
            c, a.optionalChainMember && (m.optional = o), this.finishCallExpression(m, a.optionalChainMember);
          }
          let p = this.state.type;
          if (p === 48 || p === 52 || p !== 10 && Qd(p) && !this.hasPrecedingLineBreak())
            return;
          let f = this.startNodeAt(s);
          return f.expression = r, f.typeParameters = c, this.finishNode(f, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          me.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(r, s, i, a);
    }
    parseNewCallee(r) {
      var s;
      super.parseNewCallee(r);
      let {
        callee: i
      } = r;
      i.type === "TSInstantiationExpression" && !((s = i.extra) != null && s.parenthesized) && (r.typeParameters = i.typeParameters, r.callee =
      i.expression);
    }
    parseExprOp(r, s, i) {
      let a;
      if (ku(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(s);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(F.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, s, i);
      }
      return super.parseExprOp(r, s, i);
    }
    checkReservedWord(r, s, i, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, s, i, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(me.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let s = this.lookaheadCharCode();
        return r ? s === 123 || s === 42 : s !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, i, a) {
      super.applyImportPhase(r, s, i, a), s ? r.exportKind = i === "type" ? "type" : "value" : r.importKind = i === "type" || i === "typeof" ?
      i : "value";
    }
    parseImport(r) {
      if (this.match(133))
        return r.importKind = "value", super.parseImport(r);
      let s;
      if (ft(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let i = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, i);
        s = super.parseImportSpecifiersAndAfter(r, i);
      } else
        s = super.parseImport(r);
      return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(me.TypeImportCannotSpecifyDefaultAndNamed,
      s), s;
    }
    parseExport(r, s) {
      if (this.match(83)) {
        this.next();
        let i = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? i = this.parseMaybeImportPhase(r, !1) : r.importKind = "value", this.
        tsParseImportEqualsDeclaration(r, i, !0);
      } else if (this.eat(29)) {
        let i = r;
        return i.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(i, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let i = r;
        return this.expectContextual(128), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, s);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, s, i = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, s, i || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (s !== "const" || l.typeAnnotation ? this.raise(me.InitializerNotAllowedInAmbientContext, u) : woe(u, this.hasPlugin("estree")) ||
        this.raise(me.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(r, s) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let i = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(i, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let i = this.tsParseInterfaceDeclaration(this.startNode());
        if (i) return i;
      }
      return super.parseStatementContent(r, s);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, s) {
      return s.some((i) => o1(i) ? r.accessibility === i : !!r[i]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, s, i) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: me.InvalidModifierOnTypeParameterPositions
      }, s);
      let o = /* @__PURE__ */ n(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, a) && this.raise(me.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, s)) : this.parseClassMemberWithIsStatic(r, s, i, !!s.static);
      }, "callParseClassMemberWithIsStatic");
      s.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, s, i, a) {
      let o = this.tsTryParseIndexSignature(s);
      if (o) {
        r.body.push(o), s.abstract && this.raise(me.IndexSignatureHasAbstract, s), s.accessibility && this.raise(me.IndexSignatureHasAccessibility,
        s, {
          modifier: s.accessibility
        }), s.declare && this.raise(me.IndexSignatureHasDeclare, s), s.override && this.raise(me.IndexSignatureHasOverride, s);
        return;
      }
      !this.state.inAbstractClass && s.abstract && this.raise(me.NonAbstractClassHasAbstractMethod, s), s.override && (i.hadSuperClass || this.
      raise(me.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(r, s, i, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(me.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(me.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, s, i) {
      return (s.type === "Identifier" ? this.tsParseExpressionStatement(r, s, i) : void 0) || super.parseExpressionStatement(r, s, i);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, s, i) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(r, s, i);
      let a = this.tryParse(() => super.parseConditional(r, s));
      return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(i, a.error), r);
    }
    parseParenItem(r, s) {
      if (r = super.parseParenItem(r, s), this.eat(17) && (r.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let i = this.startNodeAt(s);
        return i.expression = r, i.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let s = this.state.startLoc, i = this.eatContextual(125);
      if (i && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(me.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = ft(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || i) && (r.exportKind = "type"), i && (this.resetStartLocation(
      o, s), o.declare = !0), o) : null;
    }
    parseClassId(r, s, i, a) {
      if ((!s || i) && this.isContextual(113))
        return;
      super.parseClassId(r, s, i, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let s = this.tsTryParseTypeAnnotation();
      s && (r.typeAnnotation = s);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(me.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: s
        } = r;
        this.raise(me.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: s.type === "Identifier" && !r.computed ? s.name : `[${this.input.slice(s.start, s.end)}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(me.PrivateElementHasAbstract, r), r.accessibility && this.raise(me.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(me.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, s, i, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(me.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: p
      } = s;
      c && (p === "get" || p === "set") && this.raise(me.DeclareAccessor, s, {
        kind: p
      }), u && (s.typeParameters = u), super.pushClassMethod(r, s, i, a, o, l);
    }
    pushClassPrivateMethod(r, s, i, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (s.typeParameters = o), super.pushClassPrivateMethod(r, s, i, a);
    }
    declareClassPrivateMethodInScope(r, s) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !r.value.body || super.declareClassPrivateMethodInScope(r, s));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, s, i, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (r.typeParameters = c), super.parseObjPropValue(r, s, i, a, o, l, u);
    }
    parseFunctionParams(r, s) {
      let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      i && (r.typeParameters = i), super.parseFunctionParams(r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let i = this.tsTryParseTypeAnnotation();
      i && (r.id.typeAnnotation = i, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, s);
    }
    parseMaybeAssign(r, s) {
      var i, a, o, l, u;
      let c, p, f;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (c = this.state.clone(), p = this.tryParse(() => super.parseMaybeAssign(r, s), c), !p.error) return p.node;
        let {
          context: T
        } = this.state, L = T[T.length - 1];
        (L === St.j_oTag || L === St.j_expr) && T.pop();
      }
      if (!((i = p) != null && i.error) && !this.match(47))
        return super.parseMaybeAssign(r, s);
      (!c || c === this.state) && (c = this.state.clone());
      let m, y = this.tryParse((T) => {
        var L, q;
        m = this.tsParseTypeParameters(this.tsParseConstModifier);
        let _ = super.parseMaybeAssign(r, s);
        return (_.type !== "ArrowFunctionExpression" || (L = _.extra) != null && L.parenthesized) && T(), ((q = m) == null ? void 0 : q.params.
        length) !== 0 && this.resetStartLocationFromNode(_, m), _.typeParameters = m, _;
      }, c);
      if (!y.error && !y.aborted)
        return m && this.reportReservedArrowTypeParam(m), y.node;
      if (!p && (a1(!this.hasPlugin("jsx")), f = this.tryParse(() => super.parseMaybeAssign(r, s), c), !f.error))
        return f.node;
      if ((a = p) != null && a.node)
        return this.state = p.failState, p.node;
      if (y.node)
        return this.state = y.failState, m && this.reportReservedArrowTypeParam(m), y.node;
      if ((o = f) != null && o.node)
        return this.state = f.failState, f.node;
      throw ((l = p) == null ? void 0 : l.error) || y.error || ((u = f) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(r) {
      var s;
      r.params.length === 1 && !r.params[0].constraint && !((s = r.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(me.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, s) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse((i) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && i(), a;
        });
        if (s.aborted) return;
        s.thrown || (s.error && (this.state = s.failState), r.returnType = s.node);
      }
      return super.parseArrow(r);
    }
    parseAssignableListItemTypes(r, s) {
      if (!(s & 2)) return r;
      this.eat(17) && (r.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.resetEndLocation(r), r;
    }
    isAssignable(r, s) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, s);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, s);
      }
    }
    toAssignable(r, s = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, s);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          s ? this.expressionScope.recordArrowParameterBindingError(me.UnexpectedTypeCastInParameter, r) : this.raise(me.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, s);
          break;
        case "AssignmentExpression":
          !s && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, s);
      }
    }
    toAssignableParenthesizedExpression(r, s) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, s);
          break;
        default:
          super.toAssignable(r, s);
      }
    }
    checkToRestConversion(r, s) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, s);
      }
    }
    isValidLVal(r, s, i) {
      return Poe({
        TSTypeCastExpression: !0,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSAsExpression: (i !== 64 || !s) && ["expression", !0],
        TSSatisfiesExpression: (i !== 64 || !s) && ["expression", !0],
        TSTypeAssertion: (i !== 64 || !s) && ["expression", !0]
      }, r) || super.isValidLVal(r, s, i);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let i = super.parseMaybeDecoratorArguments(r);
          return i.typeParameters = s, i;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, s) {
      let i = super.parseMaybeDefault(r, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(me.TypeAnnotationAfterAssign,
      i.typeAnnotation), i;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableList(r, s, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TSTypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, i);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((s) => this.isAssignable(s, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        s && (r.typeParameters = s);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let s = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? s + 1 : s;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
      return s && (r.typeAnnotation = s, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let s = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = s;
      }
    }
    parseClass(r, s, i) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, s, i);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, s) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(s, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return r.abstract = !0, this.raise(me.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(r, s, i, a, o, l, u) {
      let c = super.parseMethod(r, s, i, a, o, l, u);
      if (c.abstract && (this.hasPlugin("estree") ? !!c.value.body : !!c.body)) {
        let {
          key: f
        } = c;
        this.raise(me.AbstractMethodHasImplementation, c, {
          methodName: f.type === "Identifier" && !c.computed ? f.name : `[${this.input.slice(f.start, f.end)}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, s, i, a) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, i), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, s, i, a));
    }
    parseImportSpecifier(r, s, i, a, o) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, i), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, s, i, a, i ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, s, i) {
      let a = s ? "imported" : "local", o = s ? "local" : "exported", l = r[a], u, c = !1, p = !0, f = l.loc.start;
      if (this.isContextual(93)) {
        let y = this.parseIdentifier();
        if (this.isContextual(93)) {
          let T = this.parseIdentifier();
          Hr(this.state.type) ? (c = !0, l = y, u = s ? this.parseIdentifier() : this.parseModuleExportName(), p = !1) : (u = T, p = !1);
        } else Hr(this.state.type) ? (p = !1, u = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = y);
      } else Hr(this.state.type) && (c = !0, s ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && i && this.raise(s ? me.TypeModifierIsUsedInTypeImports : me.TypeModifierIsUsedInTypeExports, f), r[a] = l, r[o] = u;
      let m = s ? "importKind" : "exportKind";
      r[m] = c ? "type" : "value", p && this.eatContextual(93) && (r[o] = s ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = Cs(r[a])), s && this.checkIdentifier(r[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function Ioe(t) {
    if (t.type !== "MemberExpression") return !1;
    let {
      computed: e,
      property: r
    } = t;
    return e && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : w1(t.object);
  }
  n(Ioe, "isPossiblyLiteralEnum");
  function woe(t, e) {
    var r;
    let {
      type: s
    } = t;
    if ((r = t.extra) != null && r.parenthesized)
      return !1;
    if (e) {
      if (s === "Literal") {
        let {
          value: i
        } = t;
        if (typeof i == "string" || typeof i == "boolean")
          return !0;
      }
    } else if (s === "StringLiteral" || s === "BooleanLiteral")
      return !0;
    return !!(I1(t, e) || Noe(t, e) || s === "TemplateLiteral" && t.expressions.length === 0 || Ioe(t));
  }
  n(woe, "isValidAmbientConstInitializer");
  function I1(t, e) {
    return e ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLite\
ral";
  }
  n(I1, "isNumber");
  function Noe(t, e) {
    if (t.type === "UnaryExpression") {
      let {
        operator: r,
        argument: s
      } = t;
      if (r === "-" && I1(s, e))
        return !0;
    }
    return !1;
  }
  n(Noe, "isNegativeNumber");
  function w1(t) {
    return t.type === "Identifier" ? !0 : t.type !== "MemberExpression" || t.computed ? !1 : w1(t.object);
  }
  n(w1, "isUncomputedMemberExpressionChain");
  var l1 = vs`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), Ooe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(144)) {
        let s = this.startNode();
        return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(
        s, r);
      }
    }
    finishPlaceholder(r, s) {
      let i = !!(r.expectedNode && r.type === "Placeholder");
      return r.expectedNode = s, i ? r : this.finishNode(r, "Placeholder");
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, s, i, a) {
      r !== void 0 && super.checkReservedWord(r, s, i, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, s, i) {
      return r === "Placeholder" || super.isValidLVal(r, s, i);
    }
    toAssignable(r, s) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, s);
    }
    chStartsBindingIdentifier(r, s) {
      return !!(super.chStartsBindingIdentifier(r, s) || this.lookahead().type === 144);
    }
    verifyBreakContinue(r, s) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, s);
    }
    parseExpressionStatement(r, s) {
      var i;
      if (s.type !== "Placeholder" || (i = s.extra) != null && i.parenthesized)
        return super.parseExpressionStatement(r, s);
      if (this.match(14)) {
        let a = r;
        return a.label = this.finishPlaceholder(s, "Identifier"), this.next(), a.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(a, "LabeledStatement");
      }
      return this.semicolon(), r.name = s.name, this.finishPlaceholder(r, "Statement");
    }
    parseBlock(r, s, i) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, s, i);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, s, i) {
      let a = s ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(144) || this.match(5))
          r.id = l;
        else {
          if (i || !s)
            return r.id = null, r.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(r, a);
          throw this.raise(l1.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, s, i);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, s) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseExport(r, s);
      if (!this.isContextual(98) && !this.match(12))
        return r.specifiers = [], r.source = null, r.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(r, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let a = this.startNode();
      return a.exported = i, r.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], super.parseExport(r, s);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(ii(144), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, s) {
      var i;
      return (i = r.specifiers) != null && i.length ? !0 : super.maybeParseExportDefaultSpecifier(r, s);
    }
    checkExport(r) {
      let {
        specifiers: s
      } = r;
      s != null && s.length && (r.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = s;
    }
    parseImport(r) {
      let s = this.parsePlaceholder("Identifier");
      if (!s) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let i = this.startNodeAtNode(s);
      return i.local = s, r.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(l1.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), koe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, s = this.startNode();
        if (this.next(), ft(this.state.type)) {
          let i = this.parseIdentifierName(), a = this.createIdentifier(s, i);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic");
  function Vt(t, e) {
    let [r, s] = typeof e == "string" ? [e, {}] : e, i = Object.keys(s), a = i.length === 0;
    return t.some((o) => {
      if (typeof o == "string")
        return a && o === r;
      {
        let [l, u] = o;
        if (l !== r)
          return !1;
        for (let c of i)
          if (u[c] !== s[c])
            return !1;
        return !0;
      }
    });
  }
  n(Vt, "hasPlugin");
  function si(t, e, r) {
    let s = t.find((i) => Array.isArray(i) ? i[0] === e : i === e);
    return s && Array.isArray(s) && s.length > 1 ? s[1][r] : null;
  }
  n(si, "getPluginOption");
  var u1 = ["minimal", "fsharp", "hack", "smart"], c1 = ["^^", "@@", "^", "%", "#"], p1 = ["hash", "bar"];
  function Doe(t) {
    if (Vt(t, "decorators")) {
      if (Vt(t, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let e = si(t, "decorators", "decoratorsBeforeExport");
      if (e != null && typeof e != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let r = si(t, "decorators", "allowCallParenthesized");
      if (r != null && typeof r != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (Vt(t, "flow") && Vt(t, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Vt(t, "placeholders") && Vt(t, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Vt(t, "pipelineOperator")) {
      let e = si(t, "pipelineOperator", "proposal");
      if (!u1.includes(e)) {
        let s = u1.map((i) => `"${i}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${s}.`);
      }
      let r = Vt(t, ["recordAndTuple", {
        syntaxType: "hash"
      }]);
      if (e === "hack") {
        if (Vt(t, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Vt(t, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let s = si(t, "pipelineOperator", "topicToken");
        if (!c1.includes(s)) {
          let i = c1.map((a) => `"${a}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${i}\
.`);
        }
        if (s === "#" && r)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { s\
yntaxType: "hash"}]`.');
      } else if (e === "smart" && r)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}\
]`.');
    }
    if (Vt(t, "moduleAttributes")) {
      if (Vt(t, "importAssertions") || Vt(t, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (si(t, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (Vt(t, "importAssertions") && Vt(t, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (Vt(t, "recordAndTuple") && si(t, "recordAndTuple", "syntaxType") != null && !p1.includes(si(t, "recordAndTuple", "syntaxType")))
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + p1.map((e) => `'${e}'`).join(", "));
    if (Vt(t, "asyncDoExpressions") && !Vt(t, "doExpressions")) {
      let e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e.missingPlugins = "doExpressions", e;
    }
    if (Vt(t, "optionalChainingAssign") && si(t, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  n(Doe, "validatePlugins");
  var N1 = {
    estree: _ae,
    jsx: Soe,
    flow: boe,
    typescript: Coe,
    v8intrinsic: koe,
    placeholders: Ooe
  }, _oe = Object.keys(N1), Hd = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowNewTargetOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createImportExpressions: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1,
    attachComment: !0,
    annexB: !0
  };
  function Loe(t) {
    if (t == null)
      return Object.assign({}, Hd);
    if (t.annexB != null && t.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let e = {};
    for (let s of Object.keys(Hd)) {
      var r;
      e[s] = (r = t[s]) != null ? r : Hd[s];
    }
    return e;
  }
  n(Loe, "getOptions");
  var ym = class extends mm {
    static {
      n(this, "ExpressionParser");
    }
    checkProto(e, r, s, i) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return;
      let a = e.key;
      if ((a.type === "Identifier" ? a.name : a.value) === "__proto__") {
        if (r) {
          this.raise(F.RecordNoProto, a);
          return;
        }
        s.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = a.loc.start) : this.raise(F.DuplicateProto, a)), s.used = !0;
      }
    }
    shouldExitDescending(e, r) {
      return e.type === "ArrowFunctionExpression" && e.start === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let e = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.comments, e.errors = this.state.errors,
      this.options.tokens && (e.tokens = this.tokens), e;
    }
    parseExpression(e, r) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(e) {
      let r = this.state.startLoc, s = this.parseMaybeAssign(e);
      if (this.match(12)) {
        let i = this.startNodeAt(r);
        for (i.expressions = [s]; this.eat(12); )
          i.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
      }
      return s;
    }
    parseMaybeAssignDisallowIn(e, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, r));
    }
    parseMaybeAssignAllowIn(e, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, r));
    }
    setOptionalParametersError(e, r) {
      var s;
      e.optionalParametersLoc = (s = r?.loc) != null ? s : this.state.startLoc;
    }
    parseMaybeAssign(e, r) {
      let s = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let l = this.parseYield();
        return r && (l = r.call(this, l, s)), l;
      }
      let i;
      e ? i = !1 : (e = new kn(), i = !0);
      let {
        type: a
      } = this.state;
      (a === 10 || ft(a)) && (this.state.potentialArrowAt = this.state.start);
      let o = this.parseMaybeConditional(e);
      if (r && (o = r.call(this, o, s)), jae(this.state.type)) {
        let l = this.startNodeAt(s), u = this.state.value;
        if (l.operator = u, this.match(29)) {
          this.toAssignable(o, !0), l.left = o;
          let c = s.index;
          e.doubleProtoLoc != null && e.doubleProtoLoc.index >= c && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.
          index >= c && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= c && (this.checkDestructuringPrivate(
          e), e.privateKeyLoc = null);
        } else
          l.left = o;
        return this.next(), l.right = this.parseMaybeAssign(), this.checkLVal(o, {
          in: this.finishNode(l, "AssignmentExpression")
        }), l;
      } else i && this.checkExpressionErrors(e, !0);
      return o;
    }
    parseMaybeConditional(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprOps(e);
      return this.shouldExitDescending(i, s) ? i : this.parseConditional(i, r, e);
    }
    parseConditional(e, r, s) {
      if (this.eat(17)) {
        let i = this.startNodeAt(r);
        return i.test = e, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(
        i, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(i, s) ? i : this.parseExprOp(i, r, -1);
    }
    parseExprOp(e, r, s) {
      if (this.isPrivateName(e)) {
        let a = this.getPrivateNameSV(e);
        (s >= ku(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(F.PrivateInExpectedIn, e, {
          identifierName: a
        }), this.classScope.usePrivateName(a, e.loc.start);
      }
      let i = this.state.type;
      if (Uae(i) && (this.prodParam.hasIn || !this.match(58))) {
        let a = ku(i);
        if (a > s) {
          if (i === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, r);
          }
          let o = this.startNodeAt(r);
          o.left = e, o.operator = this.state.value;
          let l = i === 41 || i === 42, u = i === 40;
          if (u && (a = ku(42)), this.next(), i === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(F.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(i, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
          if (u && (p === 41 || p === 42) || l && p === 40)
            throw this.raise(F.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, r, s);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, r) {
      let s = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(F.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, r), s);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
        default:
          return this.parseExprOpBaseRightExpr(e, r);
      }
    }
    parseExprOpBaseRightExpr(e, r) {
      let s = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, Yae(e) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var e;
      let {
        startLoc: r
      } = this.state, s = this.parseMaybeAssign();
      return Iae.has(s.type) && !((e = s.extra) != null && e.parenthesized) && this.raise(F.PipeUnparenthesizedBody, r, {
        type: s.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(F.PipeTopicUnused, r), s;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(F.UnexpectedTokenUnaryExponentiation, e.argument);
    }
    parseMaybeUnary(e, r) {
      let s = this.state.startLoc, i = this.isContextual(96);
      if (i && this.isAwaitAllowed()) {
        this.next();
        let u = this.parseAwait(s);
        return r || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (Vae(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(F.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(F.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, e);
      if (i) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Qd(u) : Qd(u) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(F.AwaitNotInAsyncContext, s), this.parseAwait(s);
      }
      return l;
    }
    parseUpdate(e, r, s) {
      if (r) {
        let o = e;
        return this.checkLVal(o.argument, {
          in: this.finishNode(o, "UpdateExpression")
        }), e;
      }
      let i = this.state.startLoc, a = this.parseExprSubscripts(s);
      if (this.checkExpressionErrors(s, !1)) return a;
      for (; qae(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(i);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, {
          in: a = this.finishNode(o, "UpdateExpression")
        });
      }
      return a;
    }
    parseExprSubscripts(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprAtom(e);
      return this.shouldExitDescending(i, s) ? i : this.parseSubscripts(i, r);
    }
    parseSubscripts(e, r, s) {
      let i = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: !1
      };
      do
        e = this.parseSubscript(e, r, s, i), i.maybeAsyncArrow = !1;
      while (!i.stop);
      return e;
    }
    parseSubscript(e, r, s, i) {
      let {
        type: a
      } = this.state;
      if (!s && a === 15)
        return this.parseBind(e, r, s, i);
      if (Mu(a))
        return this.parseTaggedTemplateExpression(e, r, i);
      let o = !1;
      if (a === 18) {
        if (s && (this.raise(F.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return i.stop = !0, e;
        i.optionalChainMember = o = !0, this.next();
      }
      if (!s && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, r, i, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(e, r, i, l, o) : (i.stop = !0, e);
      }
    }
    parseMember(e, r, s, i, a) {
      let o = this.startNodeAt(r);
      return o.object = e, o.computed = i, i ? (o.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (e.type === "Super" &&
      this.raise(F.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), s.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(e, r, s, i) {
      let a = this.startNodeAt(r);
      return a.object = e, this.next(), a.callee = this.parseNoCallExpr(), i.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, s);
    }
    parseCoverCallAndAsyncArrowHead(e, r, s, i) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(r);
      l.callee = e;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = s;
      u && (this.expressionScope.enter(coe()), o = new kn()), c && (l.optional = i), i ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, e.type === "Import", e.type !== "Super", l, o);
      let p = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !i ? (s.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), p)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = a, p;
    }
    toReferencedArguments(e, r) {
      this.toReferencedListDeep(e.arguments, r);
    }
    parseTaggedTemplateExpression(e, r, s) {
      let i = this.startNodeAt(r);
      return i.tag = e, i.quasi = this.parseTemplate(!0), s.optionalChainMember && this.raise(F.OptionalChainingNoTemplate, r), this.finishNode(
      i, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end -
      e.start === 5 && e.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(e, r) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), e.arguments.length === 0 ||
        e.arguments.length > 2)
          this.raise(F.ImportCallArity, e, {
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ?
            2 : 1
          });
        else
          for (let s of e.arguments)
            s.type === "SpreadElement" && this.raise(F.ImportCallSpreadArgument, s);
      return this.finishNode(e, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, r, s, i, a) {
      let o = [], l = !0, u = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          r && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(
          F.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        o.push(this.parseExprListItem(!1, a, s));
      }
      return this.state.inFSharpPipelineDirectBody = u, o;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, r) {
      var s;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(e, r.arguments, !0, (s = r.extra) == null ?
      void 0 : s.trailingCommaLoc), r.innerComments && io(e, r.innerComments), r.callee.trailingComments && io(e, r.callee.trailingComments),
      e;
    }
    parseNoCallExpr() {
      let e = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, !0);
    }
    parseExprAtom(e) {
      let r, s = null, {
        type: i
      } = this.state;
      switch (i) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.options.createImportExpressions ?
          this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(F.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          s = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(F.UnsupportedBind, a);
        }
        case 138:
          return this.raise(F.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          As(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (ft(i)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (ft(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, r) {
      let s = this.getPluginOption("pipelineOperator", "proposal");
      if (s)
        return this.state.type = e, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = yr(this.state.endLoc, -1),
        this.parseTopicReference(s);
      this.unexpected();
    }
    parseTopicReference(e) {
      let r = this.startNode(), s = this.state.startLoc, i = this.state.type;
      return this.next(), this.finishTopicReference(r, s, e, i);
    }
    finishTopicReference(e, r, s, i) {
      if (this.testTopicReferenceConfiguration(s, r, i)) {
        let a = s === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s === "smart" ? F.PrimaryTopicNotAllowed : F.PipeTopicUnbound, r),
        this.registerTopicReference(), this.finishNode(e, a);
      } else
        throw this.raise(F.PipeTopicUnconfiguredToken, r, {
          token: ii(i)
        });
    }
    testTopicReferenceConfiguration(e, r, s) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: ii(s)
          }]);
        case "smart":
          return s === 27;
        default:
          throw this.raise(F.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(_u(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(F.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(e, r, !0);
    }
    parseDo(e, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), e.async = r, this.next();
      let s = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(),
      this.state.labels = s, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      let e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(F.SuperNotAllowed,
      e) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(F.UnexpectedSuper, e), !this.match(10) && !this.match(
      0) && !this.match(16) && this.raise(F.UnsupportedSuper, e), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      let e = this.startNode(), r = this.startNodeAt(yr(this.state.startLoc, 1)), s = this.state.value;
      return this.next(), e.id = this.createIdentifier(r, s), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(e, r, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, r, s) {
      e.meta = r;
      let i = this.state.containsEsc;
      return e.property = this.parseIdentifier(!0), (e.property.name !== s || i) && this.raise(F.UnsupportedMetaProperty, e.property, {
        target: r.name,
        onlyValidPropertyName: s
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      let r = this.createIdentifier(this.startNodeAtNode(e), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(F.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let s = this.isContextual(105);
        if (s || this.unexpected(), this.expectPlugin(s ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(F.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), e.phase = s ? "source" : "defer", this.parseImportCall(e);
      }
      return this.parseMetaProperty(e, r, "meta");
    }
    parseLiteralAtNode(e, r, s) {
      return this.addExtra(s, "rawValue", e), this.addExtra(s, "raw", this.input.slice(s.start, this.state.end)), s.value = e, this.next(), this.
      finishNode(s, r);
    }
    parseLiteral(e, r) {
      let s = this.startNode();
      return this.parseLiteralAtNode(e, r, s);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      let r = this.parseLiteral(e.value, "RegExpLiteral");
      return r.pattern = e.pattern, r.flags = e.flags, r;
    }
    parseBooleanLiteral(e) {
      let r = this.startNode();
      return r.value = e, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      let r = this.state.startLoc, s;
      this.next(), this.expressionScope.enter(uoe());
      let i = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new kn(), c = !0, p, f;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          f = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let T = this.state.startLoc;
          if (p = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), T)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let m = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = a;
      let y = this.startNodeAt(r);
      return e && this.shouldParseArrow(l) && (y = this.parseArrow(y)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(y, l, !1), y) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), f && this.unexpected(f), p && this.unexpected(p), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (s = this.startNodeAt(o), s.expressions = l, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s,
      m)) : s = l[0], this.wrapParenthesis(r, s));
    }
    wrapParenthesis(e, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", e.index), this.takeSurroundingComments(r, e.index, this.
        state.lastTokEndLoc.index), r;
      let s = this.startNodeAt(e);
      return s.expression = r, this.finishNode(s, "ParenthesizedExpression");
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, r) {
      return e;
    }
    parseNewOrNewTarget() {
      let e = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        let s = this.parseMetaProperty(e, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(F.UnexpectedNewTarget,
        s), s;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), e.arguments = r;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      let r = this.match(83), s = this.parseNoCallExpr();
      e.callee = s, r && (s.type === "Import" || s.type === "ImportExpression") && this.raise(F.ImportCallNotNewExpression, s);
    }
    parseTemplateElement(e) {
      let {
        start: r,
        startLoc: s,
        end: i,
        value: a
      } = this.state, o = r + 1, l = this.startNodeAt(yr(s, 1));
      a === null && (e || this.raise(F.InvalidEscapeSequenceTemplate, yr(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, p = i + c;
      l.value = {
        raw: this.input.slice(o, p).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let f = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(f, yr(this.state.lastTokEndLoc, c)), f;
    }
    parseTemplate(e) {
      let r = this.startNode();
      r.expressions = [];
      let s = this.parseTemplateElement(e);
      for (r.quasis = [s]; !s.tail; )
        r.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r.quasis.push(s = this.parseTemplateElement(e));
      return this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, r, s, i) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = /* @__PURE__ */ Object.create(null), l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let p;
        r ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(i), this.checkProto(p, s, o, i)), s && !this.isObjectProperty(
        p) && p.type !== "SpreadElement" && this.raise(F.InvalidRecordProperty, p), p.shorthand && this.addExtra(p, "shorthand", !0), u.properties.
        push(p);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return r ? c = "ObjectPattern" : s && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(F.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let s = this.startNode(), i = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (s.decorators = r, r = []), s.method = !1, e && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(s);
      let u = this.state.containsEsc, c = this.parsePropertyName(s, e);
      if (!l && !u && this.maybeAsyncOrAccessorProp(s)) {
        let p = c.name;
        p === "async" && !this.hasPrecedingLineBreak() && (i = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        s)), (p === "get" || p === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), s.kind = p, this.match(55) && (l = !0, this.
        raise(F.AccessorIsGenerator, this.state.curPosition(), {
          kind: p
        }), this.next()), this.parsePropertyName(s));
      }
      return this.parseObjPropValue(s, o, l, i, !1, a, e);
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var r;
      let s = this.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e);
      i.length !== s && this.raise(e.kind === "get" ? F.BadGetterArity : F.BadSetterArity, e), e.kind === "set" && ((r = i[i.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(F.BadSetterRestParameter, e);
    }
    parseObjectMethod(e, r, s, i, a) {
      if (a) {
        let o = this.parseMethod(e, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (s || r || this.match(10))
        return i && this.unexpected(), e.kind = "method", e.method = !0, this.parseMethod(e, r, s, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(e, r, s, i) {
      if (e.shorthand = !1, this.eat(14))
        return e.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(e, "ObjectProper\
ty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), s)
          e.value = this.parseMaybeDefault(r, Cs(e.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = a) : this.raise(F.InvalidCoverInitializedName, a), e.value = this.
          parseMaybeDefault(r, Cs(e.key));
        } else
          e.value = Cs(e.key);
        return e.shorthand = !0, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, r, s, i, a, o, l) {
      let u = this.parseObjectMethod(e, s, i, a, o) || this.parseObjectProperty(e, r, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(e, r) {
      if (this.eat(0))
        e.computed = !0, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: s,
          value: i
        } = this.state, a;
        if (Hr(s))
          a = this.parseIdentifier(!0);
        else
          switch (s) {
            case 134:
              a = this.parseNumericLiteral(i);
              break;
            case 133:
              a = this.parseStringLiteral(i);
              break;
            case 135:
              a = this.parseBigIntLiteral(i);
              break;
            case 136:
              a = this.parseDecimalLiteral(i);
              break;
            case 138: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(F.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        e.key = a, s !== 138 && (e.computed = !1);
      }
      return e.key;
    }
    initFunction(e, r) {
      e.id = null, e.generator = !1, e.async = r;
    }
    parseMethod(e, r, s, i, a, o, l = !1) {
      this.initFunction(e, s), e.generator = r, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(_u(s, e.generator)),
      this.parseFunctionParams(e, i);
      let u = this.parseFunctionBodyAndFinish(e, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(e, r, s, i) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(e, !s, i, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, s ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, r, s, i) {
      this.scope.enter(6);
      let a = _u(s, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(e, s);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e, r, i)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(e, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(e, r, s) {
      this.toAssignableList(r, s, !1), e.params = r;
    }
    parseFunctionBodyAndFinish(e, r, s = !1) {
      return this.parseFunctionBody(e, !1, s), this.finishNode(e, r);
    }
    parseFunctionBody(e, r, s = !1) {
      let i = r && !this.match(5);
      if (this.expressionScope.enter(v1()), i)
        e.body = this.parseMaybeAssign(), this.checkParams(e, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), e.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(e.params);
          l && u && this.raise(F.IllegalLanguageModeDirective, (e.kind === "method" || e.kind === "constructor") && e.key ? e.key.loc.end : e);
          let c = !a && this.state.strict;
          this.checkParams(e, !this.state.strict && !r && !s && !u, r, c), this.state.strict && e.id && this.checkIdentifier(e.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let r = 0, s = e.length; r < s; r++)
        if (!this.isSimpleParameter(e[r])) return !1;
      return !0;
    }
    checkParams(e, r, s, i = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of e.params)
        this.checkLVal(l, {
          in: o,
          binding: 5,
          checkClashes: a,
          strictModeChanged: i
        });
    }
    parseExprList(e, r, s, i) {
      let a = [], o = !0;
      for (; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        a.push(this.parseExprListItem(r, s));
      }
      return a;
    }
    parseExprListItem(e, r, s) {
      let i;
      if (this.match(12))
        e || this.raise(F.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), i = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        i = this.parseParenItem(this.parseSpread(r), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), s || this.raise(F.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), i = this.finishNode(a, "ArgumentPlaceholder");
      } else
        i = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return i;
    }
    parseIdentifier(e) {
      let r = this.startNode(), s = this.parseIdentifierName(e);
      return this.createIdentifier(r, s);
    }
    createIdentifier(e, r) {
      return e.name = r, e.loc.identifierName = r, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e) {
      let r, {
        startLoc: s,
        type: i
      } = this.state;
      Hr(i) ? r = this.state.value : this.unexpected();
      let a = Bae(i);
      return e ? a && this.replaceToken(132) : this.checkReservedWord(r, s, a, !1), this.next(), r;
    }
    checkReservedWord(e, r, s, i) {
      if (e.length > 10 || !toe(e))
        return;
      if (s && Qae(e)) {
        this.raise(F.UnexpectedKeyword, r, {
          keyword: e
        });
        return;
      }
      if ((this.state.strict ? i ? S1 : b1 : T1)(e, this.inModule)) {
        this.raise(F.UnexpectedReservedWord, r, {
          reservedWord: e
        });
        return;
      } else if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(F.YieldBindingIdentifier, r);
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(F.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(F.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(F.ArgumentsInClass, r);
        return;
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(e) {
      let r = this.startNodeAt(e);
      return this.expressionScope.recordParameterInitializerError(F.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(F.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst =
      !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExp\
ression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || Mu(e) || e === 102 && !this.state.containsEsc || e === 137 || e === 56 || this.hasPlugin("v8\
intrinsic") && e === 54;
    }
    parseYield() {
      let e = this.startNode();
      this.expressionScope.recordParameterInitializerError(F.YieldInParameter, e), this.next();
      let r = !1, s = null;
      if (!this.hasPrecedingLineBreak())
        switch (r = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!r) break;
          default:
            s = this.parseMaybeAssign();
        }
      return e.delegate = r, e.argument = s, this.finishNode(e, "YieldExpression");
    }
    parseImportCall(e) {
      return this.next(), e.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) &&
      (e.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e.options = this.parseMaybeAssignAllowIn(),
      this.eat(12))), this.expect(11), this.finishNode(e, "ImportExpression");
    }
    checkPipelineAtInfixOperator(e, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(F.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(e, r) {
      if (this.isSimpleReference(e)) {
        let s = this.startNodeAt(r);
        return s.callee = e, this.finishNode(s, "PipelineBareFunction");
      } else {
        let s = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), s.expression = e, this.finishNode(s, "PipelineTopicExpression");
      }
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(F.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(F.PipelineTopicUnused, e);
    }
    withTopicBindingContext(e) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return e();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let s = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, e);
      return this.state.inFSharpPipelineDirectBody = s, i;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let e = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let s = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        e.body = this.parseProgram(r, 8, "module");
      } finally {
        s();
      }
      return this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }, zd = {
    kind: 1
  }, Moe = {
    kind: 2
  }, Boe = /[\uD800-\uDFFF]/u, Gd = /in(?:stanceof)?/y;
  function Foe(t, e) {
    for (let r = 0; r < t.length; r++) {
      let s = t[r], {
        type: i
      } = s;
      if (typeof i == "number") {
        {
          if (i === 138) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, p = yr(a.start, 1);
            t.splice(r, 1, new as({
              type: Ps(27),
              value: "#",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }), new as({
              type: Ps(132),
              value: l,
              start: c,
              end: u,
              startLoc: p,
              endLoc: a.end
            })), r++;
            continue;
          }
          if (Mu(i)) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, p = yr(a.start, 1), f;
            e.charCodeAt(o) === 96 ? f = new as({
              type: Ps(22),
              value: "`",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }) : f = new as({
              type: Ps(8),
              value: "}",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            });
            let m, y, T, L;
            i === 24 ? (y = u - 1, T = yr(a.end, -1), m = l === null ? null : l.slice(1, -1), L = new as({
              type: Ps(22),
              value: "`",
              start: y,
              end: u,
              startLoc: T,
              endLoc: a.end
            })) : (y = u - 2, T = yr(a.end, -2), m = l === null ? null : l.slice(1, -2), L = new as({
              type: Ps(23),
              value: "${",
              start: y,
              end: u,
              startLoc: T,
              endLoc: a.end
            })), t.splice(r, 1, f, new as({
              type: Ps(20),
              value: m,
              start: c,
              end: y,
              startLoc: p,
              endLoc: T
            }), L), r += 2;
            continue;
          }
        }
        s.type = Ps(i);
      }
    }
    return t;
  }
  n(Foe, "babel7CompatTokens");
  var Tm = class extends ym {
    static {
      n(this, "StatementParser");
    }
    parseTopLevel(e, r) {
      return e.program = this.parseProgram(r), e.comments = this.comments, this.options.tokens && (e.tokens = Foe(this.tokens, this.input)),
      this.finishNode(e, "File");
    }
    parseProgram(e, r = 139, s = this.options.sourceType) {
      if (e.sourceType = s, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, r), this.inModule && !this.options.
      allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [a, o] of Array.from(this.scope.undefinedExports))
          this.raise(F.ModuleExportUndefined, o, {
            localName: a
          });
      let i;
      return r === 139 ? i = this.finishNode(e, "Program") : i = this.finishNodeAt(e, "Program", yr(this.state.startLoc, -1)), i;
    }
    stmtToDirective(e) {
      let r = e;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let s = r.value, i = s.value, a = this.input.slice(s.start, s.end), o = s.value = a.slice(1, -1);
      return this.addExtra(s, "raw", a), this.addExtra(s, "rawValue", o), this.addExtra(s, "expressionValue", i), s.type = "DirectiveLiteral",
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(e, r) {
      if (As(e)) {
        if (Gd.lastIndex = r, Gd.test(this.input)) {
          let s = this.codePointAtPos(Gd.lastIndex);
          if (!On(s) && s !== 92)
            return !1;
        }
        return !0;
      } else return e === 92;
    }
    chStartsBindingPattern(e) {
      return e === 91 || e === 123;
    }
    hasFollowingBindingAtom() {
      let e = this.nextTokenStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, e);
    }
    hasInLineFollowingBindingIdentifier() {
      let e = this.nextTokenInLineStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingIdentifier(r, e);
    }
    startsUsingForOf() {
      let {
        type: e,
        containsEsc: r
      } = this.lookahead();
      if (e === 102 && !r)
        return !1;
      if (ft(e) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let e = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e, "using")) {
        e = this.nextTokenInLineStartSince(e + 5);
        let r = this.codePointAtPos(e);
        if (this.chStartsBindingIdentifier(r, e))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, e && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(e) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(e, r);
    }
    parseStatementContent(e, r) {
      let s = this.state.type, i = this.startNode(), a = !!(e & 2), o = !!(e & 4), l = e & 1;
      switch (s) {
        case 60:
          return this.parseBreakContinueStatement(i, !0);
        case 63:
          return this.parseBreakContinueStatement(i, !1);
        case 64:
          return this.parseDebuggerStatement(i);
        case 90:
          return this.parseDoWhileStatement(i);
        case 91:
          return this.parseForStatement(i);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? F.StrictFunction : this.options.annexB ? F.SloppyFunctionAnnexB : F.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(i, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, i), !0);
        case 69:
          return this.parseIfStatement(i);
        case 70:
          return this.parseReturnStatement(i);
        case 71:
          return this.parseSwitchStatement(i);
        case 72:
          return this.parseThrowStatement(i);
        case 73:
          return this.parseTryStatement(i);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? a || this.raise(F.UnexpectedLexicalDeclaration, i) : this.raise(F.AwaitUsingNotInAsyncContext, i),
            this.next(), this.parseVarStatement(i, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(F.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(F.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(i, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let p = this.nextTokenStart(), f = this.codePointAtPos(p);
          if (f !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(f, p) && f !== 123))
            break;
        }
        case 75:
          a || this.raise(F.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let p = this.state.value;
          return this.parseVarStatement(i, p);
        }
        case 92:
          return this.parseWhileStatement(i);
        case 76:
          return this.parseWithStatement(i);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(i);
        case 83: {
          let p = this.lookaheadCharCode();
          if (p === 40 || p === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !l && this.raise(F.UnexpectedImportExport, this.state.startLoc), this.next();
          let p;
          return s === 83 ? (p = this.parseImport(i), p.type === "ImportDeclaration" && (!p.importKind || p.importKind === "value") && (this.
          sawUnambiguousESM = !0)) : (p = this.parseExport(i, r), (p.type === "ExportNamedDeclaration" && (!p.exportKind || p.exportKind ===
          "value") || p.type === "ExportAllDeclaration" && (!p.exportKind || p.exportKind === "value") || p.type === "ExportDefaultDeclarati\
on") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(p), p;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(F.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return ft(s) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, u, c, e) : this.parseExpressionStatement(i, c,
      r);
    }
    assertModuleNodeAllowed(e) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(F.ImportOutsideModule, e);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(e, r, s) {
      return e && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolea\
n" && this.raise(F.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...e)) : r.decorators = e, this.resetStartLocationFromNode(
      r, e[0]), s && this.resetStartLocationFromNode(s, r)), r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(F.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(F.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, s;
        if (this.match(10)) {
          let i = this.state.startLoc;
          this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(i, s);
          let a = this.state.startLoc;
          e.expression = this.parseMaybeDecoratorArguments(s), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && e.expression !==
          s && this.raise(F.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (s = this.parseIdentifier(!1); this.eat(16); ) {
            let i = this.startNodeAt(r);
            i.object = s, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i.property = this.parsePrivateName()) :
            i.property = this.parseIdentifier(!0), i.computed = !1, s = this.finishNode(i, "MemberExpression");
          }
          e.expression = this.parseMaybeDecoratorArguments(s);
        }
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e) {
      if (this.eat(10)) {
        let r = this.startNodeAtNode(e);
        return r.callee = e, r.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(r.arguments), this.finishNode(r,
        "CallExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, r) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      e, r), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, r) {
      let s;
      for (s = 0; s < this.state.labels.length; ++s) {
        let i = this.state.labels[s];
        if ((e.label == null || i.name === e.label.name) && (i.kind != null && (r || i.kind === 1) || e.label && r))
          break;
      }
      if (s === this.state.labels.length) {
        let i = r ? "BreakStatement" : "ContinueStatement";
        this.raise(F.IllegalBreakContinue, e, {
          type: i
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoWhileStatement(e) {
      return this.next(), this.state.labels.push(zd), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(zd);
      let r = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(
      13))
        return r !== null && this.unexpected(r), this.parseFor(e, null);
      let s = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), c = u || this.isContextual(107) && this.startsUsingForOf(), p = s && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || p) {
          let f = this.startNode(), m;
          u ? (m = "await using", this.isAwaitAllowed() || this.raise(F.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : m =
          this.state.value, this.next(), this.parseVar(f, !0, m);
          let y = this.finishNode(f, "VariableDeclaration"), T = this.match(58);
          return T && c && this.raise(F.ForInUsing, y), (T || this.isContextual(102)) && y.declarations.length === 1 ? this.parseForIn(e, y,
          r) : (r !== null && this.unexpected(r), this.parseFor(e, y));
        }
      }
      let i = this.isContextual(95), a = new kn(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (s && this.raise(F.ForOfLet, o), r === null && i && o.type === "Identifier" && this.raise(F.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          in: {
            type: u
          }
        }), this.parseForIn(e, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(e, o);
    }
    parseFunctionStatement(e, r, s) {
      return this.next(), this.parseFunction(e, 1 | (s ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(F.IllegalReturn, this.state.startLoc), this.
      next(), this.isLineTerminator() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "Ret\
urnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      let r = e.cases = [];
      this.expect(5), this.state.labels.push(Moe), this.scope.enter(0);
      let s;
      for (let i; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          s && this.finishNode(s, "SwitchCase"), r.push(s = this.startNode()), s.consequent = [], this.next(), a ? s.test = this.parseExpression() :
          (i && this.raise(F.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i = !0, s.test = null), this.expect(14);
        } else
          s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchState\
ment");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(F.NewlineAfterThrow, this.state.lastTokEndLoc), e.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let e = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && e.type === "Identifier" ? 8 : 0), this.checkLVal(e, {
        in: {
          type: "CatchClause"
        },
        binding: 9
      }), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), e.handler = this.finishNode(
        r, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(F.NoCatchOrFinally, e), this.finishNode(
      e, "TryStatement");
    }
    parseVarStatement(e, r, s = !1) {
      return this.next(), this.parseVar(e, !1, r, s), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(zd), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(F.StrictWith, this.state.startLoc), this.next(), e.object = this.parseHeaderExpression(), e.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, r, s, i) {
      for (let o of this.state.labels)
        o.name === r && this.raise(F.LabelRedeclaration, s, {
          labelName: r
        });
      let a = Rae(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === e.start)
          l.statementStart = this.state.start, l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.state.start
      }), e.body = i & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e.label =
      s, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, r, s) {
      return e.expression = r, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = !1, r = !0, s) {
      let i = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(i, e, !1, 8, s), r && this.
      scope.exit(), this.finishNode(i, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, r, s, i, a) {
      let o = e.body = [], l = e.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? l : void 0, s, i, a);
    }
    parseBlockOrModuleBlockBody(e, r, s, i, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(i); ) {
        let c = s ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !u) {
          if (this.isValidDirective(c)) {
            let p = this.stmtToDirective(c);
            r.push(p), !l && p.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        e.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(e, r) {
      return e.init = r, this.semicolon(!1), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, r, s) {
      let i = this.match(58);
      return this.next(), i ? s !== null && this.unexpected(s) : e.await = s !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!i || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(F.ForInOfLoopInitializer, r, {
        type: i ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(F.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = r, e.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, i ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, r, s, i = !1) {
      let a = e.declarations = [];
      for (e.kind = s; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, s), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !i && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(F.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(F.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: s
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return e;
    }
    parseVarId(e, r) {
      let s = this.parseBindingAtom();
      this.checkLVal(s, {
        in: {
          type: "VariableDeclarator"
        },
        binding: r === "var" ? 5 : 8201
      }), e.id = s;
    }
    parseAsyncFunctionExpression(e) {
      return this.parseFunction(e, 8);
    }
    parseFunction(e, r = 0) {
      let s = r & 2, i = !!(r & 1), a = i && !(r & 4), o = !!(r & 8);
      this.initFunction(e, o), this.match(55) && (s && this.raise(F.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e.
      generator = !0), i && (e.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(_u(o, e.generator)), i || (e.id = this.parseFunctionId()),
      this.parseFunctionParams(e, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, i ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), i && !s && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = l, e;
    }
    parseFunctionId(e) {
      return e || ft(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, r) {
      this.expect(10), this.expressionScope.enter(loe()), e.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, e.id.loc.start);
    }
    parseClass(e, r, s) {
      this.next();
      let i = this.state.strict;
      return this.state.strict = !0, this.parseClassId(e, r, s), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, i), this.
      finishNode(e, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && (e.key.name === "constructor" || e.key.value === "constructor");
    }
    parseClassBody(e, r) {
      this.classScope.enter();
      let s = {
        hadConstructor: !1,
        hadSuperClass: e
      }, i = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (i.length > 0)
              throw this.raise(F.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            i.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          i.length && (o.decorators = i, this.resetStartLocationFromNode(o, i[0]), i = []), this.parseClassMember(a, o, s), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(F.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), i.length)
        throw this.raise(F.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(e, r) {
      let s = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let i = r;
        return i.kind = "method", i.computed = !1, i.key = s, i.static = !1, this.pushClassMethod(e, i, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let i = r;
        return i.computed = !1, i.key = s, i.static = !1, e.body.push(this.parseClassProperty(i)), !0;
      }
      return this.resetPreviousNodeTrailingComments(s), !1;
    }
    parseClassMember(e, r, s) {
      let i = this.isContextual(106);
      if (i) {
        if (this.parseClassMemberFromModifier(e, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, r, s, i);
    }
    parseClassMemberWithIsStatic(e, r, s, i) {
      let a = r, o = r, l = r, u = r, c = r, p = a, f = a;
      if (r.static = i, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        p.kind = "method";
        let q = this.match(138);
        if (this.parseClassElementName(p), q) {
          this.pushClassPrivateMethod(e, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(F.ConstructorIsGenerator, a.key), this.pushClassMethod(e, a, !0, !1, !1, !1);
        return;
      }
      let m = ft(this.state.type) && !this.state.containsEsc, y = this.match(138), T = this.parseClassElementName(r), L = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(f), this.isClassMethod()) {
        if (p.kind = "method", y) {
          this.pushClassPrivateMethod(e, o, !1, !1);
          return;
        }
        let q = this.isNonstaticConstructor(a), _ = !1;
        q && (a.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(F.DuplicateConstructor, T), q && this.
        hasPlugin("typescript") && r.override && this.raise(F.OverrideOnConstructor, T), s.hadConstructor = !0, _ = s.hadSuperClass), this.pushClassMethod(
        e, a, !1, !1, q, _);
      } else if (this.isClassProperty())
        y ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l);
      else if (m && T.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(T);
        let q = this.eat(55);
        f.optional && this.unexpected(L), p.kind = "method";
        let _ = this.match(138);
        this.parseClassElementName(p), this.parsePostMemberNameModifiers(f), _ ? this.pushClassPrivateMethod(e, o, q, !0) : (this.isNonstaticConstructor(
        a) && this.raise(F.ConstructorIsAsync, a.key), this.pushClassMethod(e, a, q, !0, !1, !1));
      } else if (m && (T.name === "get" || T.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(T), p.kind = T.name;
        let q = this.match(138);
        this.parseClassElementName(a), q ? this.pushClassPrivateMethod(e, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(F.ConstructorIsAccessor,
        a.key), this.pushClassMethod(e, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (m && T.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(T);
        let q = this.match(138);
        this.parseClassElementName(l), this.pushClassAccessorProperty(e, c, q);
      } else this.isLineTerminator() ? y ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l) : this.unexpected();
    }
    parseClassElementName(e) {
      let {
        type: r,
        value: s
      } = this.state;
      if ((r === 132 || r === 133) && e.static && s === "prototype" && this.raise(F.StaticPrototype, this.state.startLoc), r === 138) {
        s === "constructor" && this.raise(F.ConstructorClassPrivateField, this.state.startLoc);
        let i = this.parsePrivateName();
        return e.key = i, i;
      }
      return this.parsePropertyName(e);
    }
    parseClassStaticBlock(e, r) {
      var s;
      this.scope.enter(208);
      let i = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, e.body.push(this.
      finishNode(r, "StaticBlock")), (s = r.decorators) != null && s.length && this.raise(F.DecoratorStaticBlock, r);
    }
    pushClassProperty(e, r) {
      !r.computed && (r.key.name === "constructor" || r.key.value === "constructor") && this.raise(F.ConstructorClassField, r.key), e.body.push(
      this.parseClassProperty(r));
    }
    pushClassPrivateProperty(e, r) {
      let s = this.parseClassPrivateProperty(r);
      e.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
    }
    pushClassAccessorProperty(e, r, s) {
      if (!s && !r.computed) {
        let a = r.key;
        (a.name === "constructor" || a.value === "constructor") && this.raise(F.ConstructorClassField, a);
      }
      let i = this.parseClassAccessorProperty(r);
      e.body.push(i), s && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassMethod(e, r, s, i, a, o) {
      e.body.push(this.parseMethod(r, s, i, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(e, r, s, i) {
      let a = this.parseMethod(r, s, i, !1, !1, "ClassPrivateMethod", !0);
      e.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(e, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), r, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(80), this.expressionScope.enter(v1()), this.prodParam.enter(0), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, r, s, i = 8331) {
      if (ft(this.state.type))
        e.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(e.id, i);
      else if (s || !r)
        e.id = null;
      else
        throw this.raise(F.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e, r) {
      let s = this.parseMaybeImportPhase(e, !0), i = this.maybeParseExportDefaultSpecifier(e, s), a = !i || this.eat(12), o = a && this.eatExportStar(
      e), l = o && this.maybeParseExportNamespaceSpecifier(e), u = a && (!l || this.eat(12)), c = i || o;
      if (o && !l) {
        if (i && this.unexpected(), r)
          throw this.raise(F.UnsupportedDecoratorExport, e);
        return this.parseExportFrom(e, !0), this.finishNode(e, "ExportAllDeclaration");
      }
      let p = this.maybeParseExportNamedSpecifiers(e);
      i && a && !o && !p && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let f;
      if (c || p) {
        if (f = !1, r)
          throw this.raise(F.UnsupportedDecoratorExport, e);
        this.parseExportFrom(e, c);
      } else
        f = this.maybeParseExportDeclaration(e);
      if (c || p || f) {
        var m;
        let y = e;
        if (this.checkExport(y, !0, !1, !!y.source), ((m = y.declaration) == null ? void 0 : m.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, y.declaration, y);
        else if (r)
          throw this.raise(F.UnsupportedDecoratorExport, e);
        return this.finishNode(y, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let y = e, T = this.parseExportDefaultExpression();
        if (y.declaration = T, T.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, T, y);
        else if (r)
          throw this.raise(F.UnsupportedDecoratorExport, e);
        return this.checkExport(y, !0, !0), this.finishNode(y, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let s = r || this.parseIdentifier(!0), i = this.startNodeAtNode(s);
        return i.exported = s, e.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        e.specifiers || (e.specifiers = []);
        let r = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), r.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(r, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        e.specifiers || (e.specifiers = []);
        let r = e.exportKind === "type";
        return e.specifiers.push(...this.parseExportSpecifiers(r)), e.source = null, e.declaration = null, this.hasPlugin("importAssertions") &&
        (e.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") && (e.assertions =
      []), e.declaration = this.parseExportDeclaration(e), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let e = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      let e = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(e, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(e, 13);
      if (this.match(80))
        return this.parseClass(e, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(F.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(F.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(e) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: e
      } = this.state;
      if (ft(e)) {
        if (e === 95 && !this.state.containsEsc || e === 100)
          return !1;
        if ((e === 130 || e === 129) && !this.state.containsEsc) {
          let {
            type: i
          } = this.lookahead();
          if (ft(i) && i !== 98 || i === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), s = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || ft(this.state.type) && s)
        return !0;
      if (this.match(65) && s) {
        let i = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return i === 34 || i === 39;
      }
      return !1;
    }
    parseExportFrom(e, r) {
      this.eatContextual(98) ? (e.source = this.parseImportSource(), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(
      e)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: e
      } = this.state;
      return e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(F.DecoratorBeforeExport, this.state.startLoc), !0) : e === 74 || e === 75 || e ===
      68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, r, s, i) {
      if (r) {
        var a;
        if (s) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = e.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            F.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = e.specifiers) != null && a.length)
          for (let l of e.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !i && l.local) {
              let {
                local: p
              } = l;
              p.type !== "Identifier" ? this.raise(F.ExportBindingIsString, l, {
                localName: p.value,
                exportName: c
              }) : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p));
            }
          }
        else if (e.declaration) {
          if (e.declaration.type === "FunctionDeclaration" || e.declaration.type === "ClassDeclaration") {
            let l = e.declaration.id;
            if (!l) throw new Error("Assertion failure");
            this.checkDuplicateExports(e, l.name);
          } else if (e.declaration.type === "VariableDeclaration")
            for (let l of e.declaration.declarations)
              this.checkDeclaration(l.id);
        }
      }
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (let r of e.properties)
          this.checkDeclaration(r);
      else if (e.type === "ArrayPattern")
        for (let r of e.elements)
          r && this.checkDeclaration(r);
      else e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type ===
      "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(F.DuplicateDefaultExport, e) : this.raise(F.DuplicateExport, e, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(e) {
      let r = [], s = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (s)
          s = !1;
        else if (this.expect(12), this.eat(8)) break;
        let i = this.isContextual(130), a = this.match(133), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, e, i));
      }
      return r;
    }
    parseExportSpecifier(e, r, s, i) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : r ? e.exported = foe(e.local) : e.exported || (e.exported =
      Cs(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let e = this.parseStringLiteral(this.state.value), r = e.value.match(Boe);
        return r && this.raise(F.ModuleExportNameHasLoneSurrogate, e, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: r,
        value: s
      }) => s.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(e) {
      let {
        specifiers: r
      } = e, s = r.length === 1 ? r[0].type : null;
      if (e.phase === "source")
        s !== "ImportDefaultSpecifier" && this.raise(F.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (e.phase === "defer")
        s !== "ImportNamespaceSpecifier" && this.raise(F.DeferImportRequiresNamespace, r[0].loc.start);
      else if (e.module) {
        var i;
        s !== "ImportDefaultSpecifier" && this.raise(F.ImportReflectionNotBinding, r[0].loc.start), ((i = e.assertions) == null ? void 0 : i.
        length) > 0 && this.raise(F.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = e;
        if (r != null) {
          let s = r.find((i) => {
            let a;
            if (i.type === "ExportSpecifier" ? a = i.local : i.type === "ImportSpecifier" && (a = i.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          s !== void 0 && this.raise(F.ImportJSONBindingNotDefault, s.loc.start);
        }
      }
    }
    isPotentialImportPhase(e) {
      return e ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(e, r, s, i) {
      r || (s === "module" ? (this.expectPlugin("importReflection", i), e.module = !0) : this.hasPlugin("importReflection") && (e.module = !1),
      s === "source" ? (this.expectPlugin("sourcePhaseImports", i), e.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", i), e.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
    }
    parseMaybeImportPhase(e, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(e, r, null), null;
      let s = this.parseIdentifier(!0), {
        type: i
      } = this.state;
      return (Hr(i) ? i !== 98 || this.lookaheadCharCode() === 102 : i !== 12) ? (this.resetPreviousIdentifierLeadingComments(s), this.applyImportPhase(
      e, r, s.name, s.loc.start), null) : (this.applyImportPhase(e, r, null), s);
    }
    isPrecedingIdImportPhase(e) {
      let {
        type: r
      } = this.state;
      return ft(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(e) {
      return this.match(133) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
    }
    parseImportSpecifiersAndAfter(e, r) {
      e.specifiers = [];
      let i = !this.maybeParseDefaultImportSpecifier(e, r) || this.eat(12), a = i && this.maybeParseStarImportSpecifier(e);
      return i && !a && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
    }
    parseImportSourceAndAttributes(e) {
      var r;
      return (r = e.specifiers) != null || (e.specifiers = []), e.source = this.parseImportSource(), this.maybeParseImportAttributes(e), this.
      checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(e, r, s) {
      r.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(r, s));
    }
    finishImportSpecifier(e, r, s = 8201) {
      return this.checkLVal(e.local, {
        in: {
          type: r
        },
        binding: s
      }), this.finishNode(e, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let s = this.startNode(), i = this.state.value;
        if (r.has(i) && this.raise(F.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: i
        }), r.add(i), this.match(133) ? s.key = this.parseStringLiteral(i) : s.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        133))
          throw this.raise(F.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), e;
    }
    parseModuleAttributes() {
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        let s = this.startNode();
        if (s.key = this.parseIdentifier(!0), s.key.name !== "type" && this.raise(F.ModuleAttributeDifferentFromType, s.key), r.has(s.key.name) &&
        this.raise(F.ModuleAttributesWithDuplicateKeys, s.key, {
          key: s.key.name
        }), r.add(s.key.name), this.expect(14), !this.match(133))
          throw this.raise(F.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAttributes(e) {
      let r, s = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), r = this.
        parseImportAttributes()), s = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(F.ImportAttributesUseAssert,
        this.state.startLoc), this.addExtra(e, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]),
        this.next(), r = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        r = [];
      else if (this.hasPlugin("moduleAttributes"))
        r = [];
      else return;
      !s && this.hasPlugin("importAssertions") ? e.assertions = r : e.attributes = r;
    }
    maybeParseDefaultImportSpecifier(e, r) {
      if (r) {
        let s = this.startNodeAtNode(r);
        return s.local = r, e.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), !0;
      } else if (Hr(this.state.type))
        return this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(e) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(F.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let s = this.startNode(), i = this.match(133), a = this.isContextual(130);
        s.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(s, i, e.importKind === "type" || e.importKind === "typeof", a, void 0);
        e.specifiers.push(o);
      }
    }
    parseImportSpecifier(e, r, s, i, a) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = e;
        if (r)
          throw this.raise(F.ImportBindingIsString, e, {
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, !0, !0), e.local || (e.local = Cs(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier", a);
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }, Fu = class extends Tm {
    static {
      n(this, "Parser");
    }
    constructor(e, r) {
      e = Loe(e), super(e, r), this.options = e, this.initializeScopes(), this.plugins = joe(this.options.plugins), this.filename = e.sourceFilename;
    }
    getScopeHandler() {
      return so;
    }
    parse() {
      this.enterInitialScopes();
      let e = this.startNode(), r = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, r), e.errors = this.state.errors, e.comments.length = this.state.commentsLen,
      e;
    }
  };
  function joe(t) {
    let e = /* @__PURE__ */ new Map();
    for (let r of t) {
      let [s, i] = Array.isArray(r) ? r : [r, {}];
      e.has(s) || e.set(s, i || {});
    }
    return e;
  }
  n(joe, "pluginsMap");
  function Roe(t, e) {
    var r;
    if (((r = e) == null ? void 0 : r.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        let s = Za(e, t), i = s.parse();
        if (s.sawUnambiguousESM)
          return i;
        if (s.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", Za(e, t).parse();
          } catch {
          }
        else
          i.program.sourceType = "script";
        return i;
      } catch (s) {
        try {
          return e.sourceType = "script", Za(e, t).parse();
        } catch {
        }
        throw s;
      }
    } else
      return Za(e, t).parse();
  }
  n(Roe, "parse");
  function Uoe(t, e) {
    let r = Za(e, t);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  n(Uoe, "parseExpression");
  function qoe(t) {
    let e = {};
    for (let r of Object.keys(t))
      e[r] = Ps(t[r]);
    return e;
  }
  n(qoe, "generateExportedTokenTypes");
  var Voe = qoe(Mae);
  function Za(t, e) {
    let r = Fu;
    return t != null && t.plugins && (Doe(t.plugins), r = Koe(t.plugins)), new r(t, e);
  }
  n(Za, "getParser");
  var f1 = {};
  function Koe(t) {
    let e = _oe.filter((i) => Vt(t, i)), r = e.join("/"), s = f1[r];
    if (!s) {
      s = Fu;
      for (let i of e)
        s = N1[i](s);
      f1[r] = s;
    }
    return s;
  }
  n(Koe, "getParserClass");
  no.parse = Roe;
  no.parseExpression = Uoe;
  no.tokTypes = Voe;
});

// ../node_modules/@babel/helper-hoist-variables/lib/index.js
var k1 = w((wm) => {
  "use strict";
  Object.defineProperty(wm, "__esModule", {
    value: !0
  });
  wm.default = Hoe;
  var Woe = Ce(), {
    assignmentExpression: Yoe,
    expressionStatement: Joe,
    identifier: Xoe
  } = Woe, $oe = {
    Scope(t, e) {
      e.kind === "let" && t.skip();
    },
    FunctionParent(t) {
      t.skip();
    },
    VariableDeclaration(t, e) {
      if (e.kind && t.node.kind !== e.kind) return;
      let r = [], s = t.get("declarations"), i;
      for (let a of s) {
        i = a.node.id, a.node.init && r.push(Joe(Yoe("=", a.node.id, a.node.init)));
        for (let o of Object.keys(a.getBindingIdentifiers()))
          e.emit(Xoe(o), o, a.node.init !== null);
      }
      t.parentPath.isFor({
        left: t.node
      }) ? t.replaceWith(i) : t.replaceWithMultiple(r);
    }
  };
  function Hoe(t, e, r = "var") {
    t.traverse($oe, {
      kind: r,
      emit: e
    });
  }
  n(Hoe, "hoistVariables");
});

// ../node_modules/@babel/traverse/lib/path/replacement.js
var R1 = w((ni) => {
  "use strict";
  Object.defineProperty(ni, "__esModule", {
    value: !0
  });
  ni._replaceWith = Ale;
  ni.replaceExpressionWithStatements = vle;
  ni.replaceInline = Cle;
  ni.replaceWith = Ele;
  ni.replaceWithMultiple = gle;
  ni.replaceWithSourceString = Ple;
  var zoe = zA(), Om = ji(), Goe = ai(), B1 = Mi(), Qoe = O1(), Zoe = Ce(), ele = k1(), {
    FUNCTION_TYPES: D1,
    arrowFunctionExpression: tle,
    assignmentExpression: F1,
    awaitExpression: rle,
    blockStatement: sle,
    buildUndefinedNode: Nm,
    callExpression: ile,
    cloneNode: km,
    conditionalExpression: nle,
    expressionStatement: ale,
    getBindingIdentifiers: ole,
    identifier: lle,
    inheritLeadingComments: ule,
    inheritTrailingComments: cle,
    inheritsComments: ple,
    isBlockStatement: fle,
    isEmptyStatement: _1,
    isExpression: j1,
    isExpressionStatement: hle,
    isIfStatement: dle,
    isProgram: mle,
    isStatement: yle,
    isVariableDeclaration: Tle,
    removeComments: ble,
    returnStatement: L1,
    sequenceExpression: xle,
    validate: M1,
    yieldExpression: Sle
  } = Zoe;
  function gle(t) {
    var e;
    this.resync(), t = this._verifyNodeList(t), ule(t[0], this.node), cle(t[t.length - 1], this.node), (e = (0, B1.getCachedPaths)(this.hub,
    this.parent)) == null || e.delete(this.node), this.node = this.container[this.key] = null;
    let r = this.insertAfter(t);
    return this.node ? this.requeue() : this.remove(), r;
  }
  n(gle, "replaceWithMultiple");
  function Ple(t) {
    this.resync();
    let e;
    try {
      t = `(${t})`, e = (0, Qoe.parse)(t);
    } catch (s) {
      let i = s.loc;
      throw i && (s.message += ` - make sure this is an expression.
` + (0, zoe.codeFrameColumns)(t, {
        start: {
          line: i.line,
          column: i.column + 1
        }
      }), s.code = "BABEL_REPLACE_SOURCE_ERROR"), s;
    }
    let r = e.program.body[0].expression;
    return Om.default.removeProperties(r), this.replaceWith(r);
  }
  n(Ple, "replaceWithSourceString");
  function Ele(t) {
    if (this.resync(), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let e = t instanceof Goe.default ? t.node : t;
    if (!e)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === e)
      return [this];
    if (this.isProgram() && !mle(e))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(e))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof e == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let r = "";
    if (this.isNodeType("Statement") && j1(e) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(
    e) && !this.parentPath.isExportDefaultDeclaration() && (e = ale(e), r = "expression"), this.isNodeType("Expression") && yle(e) && !this.
    canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(e))
      return this.replaceExpressionWithStatements([e]);
    let s = this.node;
    return s && (ple(e, s), ble(s)), this._replaceWith(e), this.type = e.type, this.setScope(), this.requeue(), [r ? this.get(r) : this];
  }
  n(Ele, "replaceWith");
  function Ale(t) {
    var e;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? M1(this.parent, this.key, [t]) : M1(this.parent, this.key, t), this.debug(`Replace with ${t?.type}`), (e = (0, B1.getCachedPaths)(
    this.hub, this.parent)) == null || e.set(t, this).delete(this.node), this.node = this.container[this.key] = t;
  }
  n(Ale, "_replaceWith");
  function vle(t) {
    this.resync();
    let e = [], r = ju(t, e);
    if (r) {
      for (let m of e) this.scope.push({
        id: m
      });
      return this.replaceWith(r)[0].get("expressions");
    }
    let s = this.getFunctionParent(), i = s?.is("async"), a = s?.is("generator"), o = tle([], sle(t));
    this.replaceWith(ile(o, []));
    let l = this.get("callee");
    (0, ele.default)(l.get("body"), (m) => {
      this.scope.push({
        id: m
      });
    }, "var");
    let u = this.get("callee").getCompletionRecords();
    for (let m of u) {
      if (!m.isExpressionStatement()) continue;
      let y = m.findParent((T) => T.isLoop());
      if (y) {
        let T = y.getData("expressionReplacementReturnUid");
        T ? T = lle(T.name) : (T = l.scope.generateDeclaredUidIdentifier("ret"), l.get("body").pushContainer("body", L1(km(T))), y.setData("\
expressionReplacementReturnUid", T)), m.get("expression").replaceWith(F1("=", km(T), m.node.expression));
      } else
        m.replaceWith(L1(m.node.expression));
    }
    l.arrowFunctionToExpression();
    let c = l, p = i && Om.default.hasType(this.get("callee.body").node, "AwaitExpression", D1), f = a && Om.default.hasType(this.get("calle\
e.body").node, "YieldExpression", D1);
    return p && (c.set("async", !0), f || this.replaceWith(rle(this.node))), f && (c.set("generator", !0), this.replaceWith(Sle(this.node, !0))),
    c.get("body.body");
  }
  n(vle, "replaceExpressionWithStatements");
  function ju(t, e) {
    let r = [], s = !0;
    for (let i of t)
      if (_1(i) || (s = !1), j1(i))
        r.push(i);
      else if (hle(i))
        r.push(i.expression);
      else if (Tle(i)) {
        if (i.kind !== "var") return;
        for (let a of i.declarations) {
          let o = ole(a);
          for (let l of Object.keys(o))
            e.push(km(o[l]));
          a.init && r.push(F1("=", a.id, a.init));
        }
        s = !0;
      } else if (dle(i)) {
        let a = i.consequent ? ju([i.consequent], e) : Nm(), o = i.alternate ? ju([i.alternate], e) : Nm();
        if (!a || !o) return;
        r.push(nle(i.test, a, o));
      } else if (fle(i)) {
        let a = ju(i.body, e);
        if (!a) return;
        r.push(a);
      } else if (_1(i))
        t.indexOf(i) === 0 && (s = !0);
      else
        return;
    return s && r.push(Nm()), r.length === 1 ? r[0] : xle(r);
  }
  n(ju, "gatherSequenceExpressions");
  function Cle(t) {
    if (this.resync(), Array.isArray(t))
      if (Array.isArray(this.container)) {
        t = this._verifyNodeList(t);
        let e = this._containerInsertAfter(t);
        return this.remove(), e;
      } else
        return this.replaceWithMultiple(t);
    else
      return this.replaceWith(t);
  }
  n(Cle, "replaceInline");
});

// ../node_modules/@babel/traverse/lib/path/evaluation.js
var K1 = w((Ru) => {
  "use strict";
  Object.defineProperty(Ru, "__esModule", {
    value: !0
  });
  Ru.evaluate = Lle;
  Ru.evaluateTruthy = Dle;
  var Ile = ["Number", "String", "Math"], wle = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeUR\
I", "encodeURIComponent", null, null], Nle = ["random"];
  function U1(t) {
    return Ile.includes(t);
  }
  n(U1, "isValidObjectCallee");
  function Ole(t) {
    return wle.includes(t);
  }
  n(Ole, "isValidIdentifierCallee");
  function kle(t) {
    return Nle.includes(t);
  }
  n(kle, "isInvalidMethod");
  function Dle() {
    let t = this.evaluate();
    if (t.confident) return !!t.value;
  }
  n(Dle, "evaluateTruthy");
  function Is(t, e) {
    e.confident && (e.deoptPath = t, e.confident = !1);
  }
  n(Is, "deopt");
  var q1 = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
  function Tr(t, e) {
    let {
      node: r
    } = t, {
      seen: s
    } = e;
    if (s.has(r)) {
      let i = s.get(r);
      if (i.resolved)
        return i.value;
      Is(t, e);
      return;
    } else {
      let i = {
        resolved: !1
      };
      s.set(r, i);
      let a = _le(t, e);
      return e.confident && (i.resolved = !0, i.value = a), a;
    }
  }
  n(Tr, "evaluateCached");
  function _le(t, e) {
    if (e.confident) {
      if (t.isSequenceExpression()) {
        let r = t.get("expressions");
        return Tr(r[r.length - 1], e);
      }
      if (t.isStringLiteral() || t.isNumericLiteral() || t.isBooleanLiteral())
        return t.node.value;
      if (t.isNullLiteral())
        return null;
      if (t.isTemplateLiteral())
        return V1(t, t.node.quasis, e);
      if (t.isTaggedTemplateExpression() && t.get("tag").isMemberExpression()) {
        let r = t.get("tag.object"), {
          node: {
            name: s
          }
        } = r, i = t.get("tag.property");
        if (r.isIdentifier() && s === "String" && !t.scope.getBinding(s) && i.isIdentifier() && i.node.name === "raw")
          return V1(t, t.node.quasi.quasis, e, !0);
      }
      if (t.isConditionalExpression()) {
        let r = Tr(t.get("test"), e);
        return e.confident ? Tr(r ? t.get("consequent") : t.get("alternate"), e) : void 0;
      }
      if (t.isExpressionWrapper())
        return Tr(t.get("expression"), e);
      if (t.isMemberExpression() && !t.parentPath.isCallExpression({
        callee: t.node
      })) {
        let r = t.get("property"), s = t.get("object");
        if (s.isLiteral()) {
          let i = s.node.value, a = typeof i, o = null;
          if (t.node.computed) {
            if (o = Tr(r, e), !e.confident) return;
          } else r.isIdentifier() && (o = r.node.name);
          if ((a === "number" || a === "string") && o != null && (typeof o == "number" || typeof o == "string"))
            return i[o];
        }
      }
      if (t.isReferencedIdentifier()) {
        let r = t.scope.getBinding(t.node.name);
        if (r) {
          if (r.constantViolations.length > 0 || t.node.start < r.path.node.end) {
            Is(r.path, e);
            return;
          }
          if (r.hasValue)
            return r.value;
        }
        let s = t.node.name;
        if (q1.has(s)) {
          if (!r)
            return q1.get(s);
          Is(r.path, e);
          return;
        }
        let i = t.resolve();
        if (i === t) {
          Is(t, e);
          return;
        } else
          return Tr(i, e);
      }
      if (t.isUnaryExpression({
        prefix: !0
      })) {
        if (t.node.operator === "void")
          return;
        let r = t.get("argument");
        if (t.node.operator === "typeof" && (r.isFunction() || r.isClass()))
          return "function";
        let s = Tr(r, e);
        if (!e.confident) return;
        switch (t.node.operator) {
          case "!":
            return !s;
          case "+":
            return +s;
          case "-":
            return -s;
          case "~":
            return ~s;
          case "typeof":
            return typeof s;
        }
      }
      if (t.isArrayExpression()) {
        let r = [], s = t.get("elements");
        for (let i of s) {
          let a = i.evaluate();
          if (a.confident)
            r.push(a.value);
          else {
            Is(a.deopt, e);
            return;
          }
        }
        return r;
      }
      if (t.isObjectExpression()) {
        let r = {}, s = t.get("properties");
        for (let i of s) {
          if (i.isObjectMethod() || i.isSpreadElement()) {
            Is(i, e);
            return;
          }
          let a = i.get("key"), o;
          if (i.node.computed) {
            if (o = a.evaluate(), !o.confident) {
              Is(o.deopt, e);
              return;
            }
            o = o.value;
          } else a.isIdentifier() ? o = a.node.name : o = a.node.value;
          let u = i.get("value").evaluate();
          if (!u.confident) {
            Is(u.deopt, e);
            return;
          }
          u = u.value, r[o] = u;
        }
        return r;
      }
      if (t.isLogicalExpression()) {
        let r = e.confident, s = Tr(t.get("left"), e), i = e.confident;
        e.confident = r;
        let a = Tr(t.get("right"), e), o = e.confident;
        switch (t.node.operator) {
          case "||":
            return e.confident = i && (!!s || o), e.confident ? s || a : void 0;
          case "&&":
            return e.confident = i && (!s || o), e.confident ? s && a : void 0;
          case "??":
            return e.confident = i && (s != null || o), e.confident ? s ?? a : void 0;
        }
      }
      if (t.isBinaryExpression()) {
        let r = Tr(t.get("left"), e);
        if (!e.confident) return;
        let s = Tr(t.get("right"), e);
        if (!e.confident) return;
        switch (t.node.operator) {
          case "-":
            return r - s;
          case "+":
            return r + s;
          case "/":
            return r / s;
          case "*":
            return r * s;
          case "%":
            return r % s;
          case "**":
            return Math.pow(r, s);
          case "<":
            return r < s;
          case ">":
            return r > s;
          case "<=":
            return r <= s;
          case ">=":
            return r >= s;
          case "==":
            return r == s;
          case "!=":
            return r != s;
          case "===":
            return r === s;
          case "!==":
            return r !== s;
          case "|":
            return r | s;
          case "&":
            return r & s;
          case "^":
            return r ^ s;
          case "<<":
            return r << s;
          case ">>":
            return r >> s;
          case ">>>":
            return r >>> s;
        }
      }
      if (t.isCallExpression()) {
        let r = t.get("callee"), s, i;
        if (r.isIdentifier() && !t.scope.getBinding(r.node.name) && (U1(r.node.name) || Ole(r.node.name)) && (i = global[r.node.name]), r.isMemberExpression()) {
          let a = r.get("object"), o = r.get("property");
          if (a.isIdentifier() && o.isIdentifier() && U1(a.node.name) && !kle(o.node.name)) {
            s = global[a.node.name];
            let l = o.node.name;
            hasOwnProperty.call(s, l) && (i = s[l]);
          }
          if (a.isLiteral() && o.isIdentifier()) {
            let l = typeof a.node.value;
            (l === "string" || l === "number") && (s = a.node.value, i = s[o.node.name]);
          }
        }
        if (i) {
          let a = t.get("arguments").map((o) => Tr(o, e));
          return e.confident ? i.apply(s, a) : void 0;
        }
      }
      Is(t, e);
    }
  }
  n(_le, "_evaluate");
  function V1(t, e, r, s = !1) {
    let i = "", a = 0, o = t.isTemplateLiteral() ? t.get("expressions") : t.get("quasi.expressions");
    for (let l of e) {
      if (!r.confident) break;
      i += s ? l.value.raw : l.value.cooked;
      let u = o[a++];
      u && (i += String(Tr(u, r)));
    }
    if (r.confident)
      return i;
  }
  n(V1, "evaluateQuasis");
  function Lle() {
    let t = {
      confident: !0,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    }, e = Tr(this, t);
    return t.confident || (e = void 0), {
      confident: t.confident,
      deopt: t.deoptPath,
      value: e
    };
  }
  n(Lle, "evaluate");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/formatters.js
var W1 = w((qr) => {
  "use strict";
  Object.defineProperty(qr, "__esModule", {
    value: !0
  });
  qr.statements = qr.statement = qr.smart = qr.program = qr.expression = void 0;
  var Mle = Ce(), {
    assertExpressionStatement: Ble
  } = Mle;
  function Dm(t) {
    return {
      code: /* @__PURE__ */ n((e) => `/* @babel/template */;
${e}`, "code"),
      validate: /* @__PURE__ */ n(() => {
      }, "validate"),
      unwrap: /* @__PURE__ */ n((e) => t(e.program.body.slice(1)), "unwrap")
    };
  }
  n(Dm, "makeStatementFormatter");
  var l8e = qr.smart = Dm((t) => t.length > 1 ? t : t[0]), u8e = qr.statements = Dm((t) => t), c8e = qr.statement = Dm((t) => {
    if (t.length === 0)
      throw new Error("Found nothing to return.");
    if (t.length > 1)
      throw new Error("Found multiple statements but wanted one");
    return t[0];
  }), Fle = qr.expression = {
    code: /* @__PURE__ */ n((t) => `(
${t}
)`, "code"),
    validate: /* @__PURE__ */ n((t) => {
      if (t.program.body.length > 1)
        throw new Error("Found multiple statements but wanted one");
      if (Fle.unwrap(t).start === 0)
        throw new Error("Parse result included parens.");
    }, "validate"),
    unwrap: /* @__PURE__ */ n(({
      program: t
    }) => {
      let [e] = t.body;
      return Ble(e), e.expression;
    }, "unwrap")
  }, p8e = qr.program = {
    code: /* @__PURE__ */ n((t) => t, "code"),
    validate: /* @__PURE__ */ n(() => {
    }, "validate"),
    unwrap: /* @__PURE__ */ n((t) => t.program, "unwrap")
  };
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/options.js
var Uu = w((ao) => {
  "use strict";
  Object.defineProperty(ao, "__esModule", {
    value: !0
  });
  ao.merge = Ule;
  ao.normalizeReplacements = Vle;
  ao.validate = qle;
  var jle = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function Rle(t, e) {
    if (t == null) return {};
    var r = {}, s = Object.keys(t), i, a;
    for (a = 0; a < s.length; a++)
      i = s[a], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
    return r;
  }
  n(Rle, "_objectWithoutPropertiesLoose");
  function Ule(t, e) {
    let {
      placeholderWhitelist: r = t.placeholderWhitelist,
      placeholderPattern: s = t.placeholderPattern,
      preserveComments: i = t.preserveComments,
      syntacticPlaceholders: a = t.syntacticPlaceholders
    } = e;
    return {
      parser: Object.assign({}, t.parser, e.parser),
      placeholderWhitelist: r,
      placeholderPattern: s,
      preserveComments: i,
      syntacticPlaceholders: a
    };
  }
  n(Ule, "merge");
  function qle(t) {
    if (t != null && typeof t != "object")
      throw new Error("Unknown template options.");
    let e = t || {}, {
      placeholderWhitelist: r,
      placeholderPattern: s,
      preserveComments: i,
      syntacticPlaceholders: a
    } = e, o = Rle(e, jle);
    if (r != null && !(r instanceof Set))
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (s != null && !(s instanceof RegExp) && s !== !1)
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (i != null && typeof i != "boolean")
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (a != null && typeof a != "boolean")
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (a === !0 && (r != null || s != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return {
      parser: o,
      placeholderWhitelist: r || void 0,
      placeholderPattern: s ?? void 0,
      preserveComments: i ?? void 0,
      syntacticPlaceholders: a ?? void 0
    };
  }
  n(qle, "validate");
  function Vle(t) {
    if (Array.isArray(t))
      return t.reduce((e, r, s) => (e["$" + s] = r, e), {});
    if (typeof t == "object" || t == null)
      return t || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  n(Vle, "normalizeReplacements");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/node_modules/@babel/parser/lib/index.js
var Ev = w((bo) => {
  "use strict";
  Object.defineProperty(bo, "__esModule", {
    value: !0
  });
  function av(t, e) {
    if (t == null) return {};
    var r = {}, s = Object.keys(t), i, a;
    for (a = 0; a < s.length; a++)
      i = s[a], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
    return r;
  }
  n(av, "_objectWithoutPropertiesLoose");
  var us = class {
    static {
      n(this, "Position");
    }
    constructor(e, r, s) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = r, this.index = s;
    }
  }, jn = class {
    static {
      n(this, "SourceLocation");
    }
    constructor(e, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = r;
    }
  };
  function xr(t, e) {
    let {
      line: r,
      column: s,
      index: i
    } = t;
    return new us(r, s + e, i + e);
  }
  n(xr, "createPositionWithColumnOffset");
  var Y1 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", Kle = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: Y1
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: Y1
    }
  }, J1 = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, Ku = /* @__PURE__ */ n((t) => t.type === "UpdateExpression" ? J1.UpdateExpression[`${t.prefix}`] : J1[t.type], "toNodeDescription"), Wle = {
    AccessorIsGenerator: /* @__PURE__ */ n(({
      kind: t
    }) => `A ${t}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ n(({
      kind: t
    }) => `Missing initializer in ${t} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ n(({
      exportName: t
    }) => `\`${t}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ n(({
      phase: t
    }) => `'import.${t}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ n(({
      localName: t,
      exportName: e
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t}' as '${e}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ n(({
      type: t
    }) => `'${t === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ n(({
      type: t
    }) => `Unsyntactic ${t === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ n(({
      importName: t
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: /* @__PURE__ */ n(({
      maxArgumentCount: t
    }) => `\`import()\` requires exactly ${t === 1 ? "one argument" : "one or two arguments"}.`, "ImportCallArity"),
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ n(({
      radix: t
    }) => `Expected number in radix ${t}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Escape sequence in keyword ${t}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Invalid identifier ${t}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid left-hand side in ${Ku(t)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Binding invalid left-hand side in ${Ku(t)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid optional chaining in the left-hand side of ${Ku(t)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t
    }) => `Unexpected character '${t}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private name #${t} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ n(({
      labelName: t
    }) => `Label '${t}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling the parser plugin: ${t.map((e) => JSON.stringify(e)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${t.map((e) => JSON.stringify(e)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ n(({
      key: t
    }) => `Duplicate key "${t}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ n(({
      surrogateCharCode: t
    }) => `An export name cannot include a lone surrogate, found '\\u${t.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ n(({
      localName: t
    }) => `Export '${t}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private names are only allowed in property accesses (\`obj.#${t}\`) or in \`in\` expressions (\`#${t} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Duplicate private name #${t}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ n(({
      keyword: t
    }) => `Unexpected keyword '${t}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Unexpected reserved word '${t}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ n(({
      expected: t,
      unexpected: e
    }) => `Unexpected token${e ? ` '${e}'.` : ""}${t ? `, expected "${t}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ n(({
      target: t,
      onlyValidPropertyName: e
    }) => `The only valid meta property for ${t} is ${t}.${e}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Identifier '${t}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, Yle = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ n(({
      referenceName: t
    }) => `Assigning to '${t}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ n(({
      bindingName: t
    }) => `Binding '${t}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, Jle = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), Xle = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ n(({
      token: t
    }) => `Invalid topic token ${t}. In order to use ${t} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${t}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ n(({
      type: t
    }) => `Hack-style pipe body cannot be an unparenthesized ${Ku({
      type: t
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody"),
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }, $le = ["toMessage"], Hle = ["message"];
  function X1(t, e, r) {
    Object.defineProperty(t, e, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  n(X1, "defineHidden");
  function zle(t) {
    let {
      toMessage: e
    } = t, r = av(t, $le);
    return /* @__PURE__ */ n(function s(i, a) {
      let o = new SyntaxError();
      return Object.assign(o, r, {
        loc: i,
        pos: i.index
      }), "missingPlugin" in a && Object.assign(o, {
        missingPlugin: a.missingPlugin
      }), X1(o, "clone", /* @__PURE__ */ n(function(u = {}) {
        var c;
        let {
          line: p,
          column: f,
          index: m
        } = (c = u.loc) != null ? c : i;
        return s(new us(p, f, m), Object.assign({}, a, u.details));
      }, "clone")), X1(o, "details", a), Object.defineProperty(o, "message", {
        configurable: !0,
        get() {
          let l = `${e(a)} (${i.line}:${i.column})`;
          return this.message = l, l;
        },
        set(l) {
          Object.defineProperty(this, "message", {
            value: l,
            writable: !0
          });
        }
      }), o;
    }, "constructor");
  }
  n(zle, "toParseErrorConstructor");
  function ks(t, e) {
    if (Array.isArray(t))
      return (s) => ks(s, t[0]);
    let r = {};
    for (let s of Object.keys(t)) {
      let i = t[s], a = typeof i == "string" ? {
        message: /* @__PURE__ */ n(() => i, "message")
      } : typeof i == "function" ? {
        message: i
      } : i, {
        message: o
      } = a, l = av(a, Hle), u = typeof o == "string" ? () => o : o;
      r[s] = zle(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: s,
        toMessage: u
      }, e ? {
        syntaxPlugin: e
      } : {}, l));
    }
    return r;
  }
  n(ks, "ParseErrorEnum");
  var M = Object.assign({}, ks(Kle), ks(Wle), ks(Yle), ks`pipelineOperator`(Xle)), {
    defineProperty: Gle
  } = Object, $1 = /* @__PURE__ */ n((t, e) => Gle(t, e, {
    enumerable: !1,
    value: t[e]
  }), "toUnenumerable");
  function oo(t) {
    return t.loc.start && $1(t.loc.start, "index"), t.loc.end && $1(t.loc.end, "index"), t;
  }
  n(oo, "toESTreeLocation");
  var Qle = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "ESTreeParserMixin");
    }
    parse() {
      let r = oo(super.parse());
      return this.options.tokens && (r.tokens = r.tokens.map(oo)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: s
    }) {
      let i = null;
      try {
        i = new RegExp(r, s);
      } catch {
      }
      let a = this.estreeParseLiteral(i);
      return a.regex = {
        pattern: r,
        flags: s
      }, a;
    }
    parseBigIntLiteral(r) {
      let s;
      try {
        s = BigInt(r);
      } catch {
        s = null;
      }
      let i = this.estreeParseLiteral(s);
      return i.bigint = String(i.value || r), i;
    }
    parseDecimalLiteral(r) {
      let i = this.estreeParseLiteral(null);
      return i.decimal = String(i.value || r), i;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    directiveToStmt(r) {
      let s = r.value;
      delete r.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
      let i = r;
      return i.type = "ExpressionStatement", i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
    }
    initFunction(r, s) {
      super.initFunction(r, s), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var s;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((s = r.expression.
      extra) != null && s.parenthesized);
    }
    parseBlockBody(r, s, i, a, o) {
      super.parseBlockBody(r, s, i, a, o);
      let l = r.directives.map((u) => this.directiveToStmt(u));
      r.body = l.concat(r.body), delete r.directives;
    }
    pushClassMethod(r, s, i, a, o, l) {
      this.parseMethod(s, i, a, o, l, "ClassMethod", !0), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters),
      r.body.push(s);
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let s = super.getPrivateNameSV(r);
      return r = r, delete r.id, r.name = s, r.type = "PrivateIdentifier", r;
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, s) {
      let i = super.parseLiteral(r, s);
      return i.raw = i.extra.raw, delete i.extra, i;
    }
    parseFunctionBody(r, s, i = !1) {
      super.parseFunctionBody(r, s, i), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, s, i, a, o, l, u = !1) {
      let c = this.startNode();
      return c.kind = r.kind, c = super.parseMethod(c, s, i, a, o, l, u), c.type = "FunctionExpression", delete c.kind, r.value = c, l === "\
ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
    }
    nameIsConstructor(r) {
      return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
    }
    parseClassProperty(...r) {
      let s = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition"), s;
    }
    parseClassPrivateProperty(...r) {
      let s = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition", s.computed = !1), s;
    }
    parseObjectMethod(r, s, i, a, o) {
      let l = super.parseObjectMethod(r, s, i, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(r, s, i, a) {
      let o = super.parseObjectProperty(r, s, i, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(r, s, i) {
      return r === "Property" ? "value" : super.isValidLVal(r, s, i);
    }
    isAssignable(r, s) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: i,
          value: a
        } = r;
        this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(a, s);
      } else
        super.toAssignable(r, s);
    }
    toAssignableObjectExpressionProp(r, s, i) {
      r.type === "Property" && (r.kind === "get" || r.kind === "set") ? this.raise(M.PatternHasAccessor, r.key) : r.type === "Property" && r.
      method ? this.raise(M.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, s, i);
    }
    finishCallExpression(r, s) {
      let i = super.finishCallExpression(r, s);
      if (i.callee.type === "Import") {
        if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var a, o;
          i.options = (a = i.arguments[1]) != null ? a : null, i.attributes = (o = i.arguments[1]) != null ? o : null;
        }
        delete i.arguments, delete i.callee;
      }
      return i;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, s) {
      let i = this.state.lastTokStartLoc, a = super.parseExport(r, s);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, i);
          }
          break;
      }
      return a;
    }
    parseSubscript(r, s, i, a) {
      let o = super.parseSubscript(r, s, i, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
    }
    finishNodeAt(r, s, i) {
      return oo(super.finishNodeAt(r, s, i));
    }
    resetStartLocation(r, s) {
      super.resetStartLocation(r, s), oo(r);
    }
    resetEndLocation(r, s = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, s), oo(r);
    }
  }, "estree"), $i = class {
    static {
      n(this, "TokContext");
    }
    constructor(e, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!r;
    }
  }, gt = {
    brace: new $i("{"),
    j_oTag: new $i("<tag"),
    j_cTag: new $i("</tag"),
    j_expr: new $i("<tag>...</tag>", !0)
  };
  gt.template = new $i("`", !0);
  var Je = !0, oe = !0, _m = !0, lo = !0, oi = !0, Zle = !0, Xu = class {
    static {
      n(this, "ExportedTokenType");
    }
    constructor(e, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, iy = /* @__PURE__ */ new Map();
  function et(t, e = {}) {
    e.keyword = t;
    let r = Ae(t, e);
    return iy.set(t, r), r;
  }
  n(et, "createKeyword");
  function br(t, e) {
    return Ae(t, {
      beforeExpr: Je,
      binop: e
    });
  }
  n(br, "createBinop");
  var fo = -1, Ns = [], ny = [], ay = [], oy = [], ly = [], uy = [];
  function Ae(t, e = {}) {
    var r, s, i, a;
    return ++fo, ny.push(t), ay.push((r = e.binop) != null ? r : -1), oy.push((s = e.beforeExpr) != null ? s : !1), ly.push((i = e.startsExpr) !=
    null ? i : !1), uy.push((a = e.prefix) != null ? a : !1), Ns.push(new Xu(t, e)), fo;
  }
  n(Ae, "createToken");
  function Ye(t, e = {}) {
    var r, s, i, a;
    return ++fo, iy.set(t, fo), ny.push(t), ay.push((r = e.binop) != null ? r : -1), oy.push((s = e.beforeExpr) != null ? s : !1), ly.push((i =
    e.startsExpr) != null ? i : !1), uy.push((a = e.prefix) != null ? a : !1), Ns.push(new Xu("name", e)), fo;
  }
  n(Ye, "createKeywordLike");
  var eue = {
    bracketL: Ae("[", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    bracketHashL: Ae("#[", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    bracketBarL: Ae("[|", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    bracketR: Ae("]"),
    bracketBarR: Ae("|]"),
    braceL: Ae("{", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    braceBarL: Ae("{|", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    braceHashL: Ae("#{", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    braceR: Ae("}"),
    braceBarR: Ae("|}"),
    parenL: Ae("(", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    parenR: Ae(")"),
    comma: Ae(",", {
      beforeExpr: Je
    }),
    semi: Ae(";", {
      beforeExpr: Je
    }),
    colon: Ae(":", {
      beforeExpr: Je
    }),
    doubleColon: Ae("::", {
      beforeExpr: Je
    }),
    dot: Ae("."),
    question: Ae("?", {
      beforeExpr: Je
    }),
    questionDot: Ae("?."),
    arrow: Ae("=>", {
      beforeExpr: Je
    }),
    template: Ae("template"),
    ellipsis: Ae("...", {
      beforeExpr: Je
    }),
    backQuote: Ae("`", {
      startsExpr: oe
    }),
    dollarBraceL: Ae("${", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    templateTail: Ae("...`", {
      startsExpr: oe
    }),
    templateNonTail: Ae("...${", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    at: Ae("@"),
    hash: Ae("#", {
      startsExpr: oe
    }),
    interpreterDirective: Ae("#!..."),
    eq: Ae("=", {
      beforeExpr: Je,
      isAssign: lo
    }),
    assign: Ae("_=", {
      beforeExpr: Je,
      isAssign: lo
    }),
    slashAssign: Ae("_=", {
      beforeExpr: Je,
      isAssign: lo
    }),
    xorAssign: Ae("_=", {
      beforeExpr: Je,
      isAssign: lo
    }),
    moduloAssign: Ae("_=", {
      beforeExpr: Je,
      isAssign: lo
    }),
    incDec: Ae("++/--", {
      prefix: oi,
      postfix: Zle,
      startsExpr: oe
    }),
    bang: Ae("!", {
      beforeExpr: Je,
      prefix: oi,
      startsExpr: oe
    }),
    tilde: Ae("~", {
      beforeExpr: Je,
      prefix: oi,
      startsExpr: oe
    }),
    doubleCaret: Ae("^^", {
      startsExpr: oe
    }),
    doubleAt: Ae("@@", {
      startsExpr: oe
    }),
    pipeline: br("|>", 0),
    nullishCoalescing: br("??", 1),
    logicalOR: br("||", 1),
    logicalAND: br("&&", 2),
    bitwiseOR: br("|", 3),
    bitwiseXOR: br("^", 4),
    bitwiseAND: br("&", 5),
    equality: br("==/!=/===/!==", 6),
    lt: br("</>/<=/>=", 7),
    gt: br("</>/<=/>=", 7),
    relational: br("</>/<=/>=", 7),
    bitShift: br("<</>>/>>>", 8),
    bitShiftL: br("<</>>/>>>", 8),
    bitShiftR: br("<</>>/>>>", 8),
    plusMin: Ae("+/-", {
      beforeExpr: Je,
      binop: 9,
      prefix: oi,
      startsExpr: oe
    }),
    modulo: Ae("%", {
      binop: 10,
      startsExpr: oe
    }),
    star: Ae("*", {
      binop: 10
    }),
    slash: br("/", 10),
    exponent: Ae("**", {
      beforeExpr: Je,
      binop: 11,
      rightAssociative: !0
    }),
    _in: et("in", {
      beforeExpr: Je,
      binop: 7
    }),
    _instanceof: et("instanceof", {
      beforeExpr: Je,
      binop: 7
    }),
    _break: et("break"),
    _case: et("case", {
      beforeExpr: Je
    }),
    _catch: et("catch"),
    _continue: et("continue"),
    _debugger: et("debugger"),
    _default: et("default", {
      beforeExpr: Je
    }),
    _else: et("else", {
      beforeExpr: Je
    }),
    _finally: et("finally"),
    _function: et("function", {
      startsExpr: oe
    }),
    _if: et("if"),
    _return: et("return", {
      beforeExpr: Je
    }),
    _switch: et("switch"),
    _throw: et("throw", {
      beforeExpr: Je,
      prefix: oi,
      startsExpr: oe
    }),
    _try: et("try"),
    _var: et("var"),
    _const: et("const"),
    _with: et("with"),
    _new: et("new", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    _this: et("this", {
      startsExpr: oe
    }),
    _super: et("super", {
      startsExpr: oe
    }),
    _class: et("class", {
      startsExpr: oe
    }),
    _extends: et("extends", {
      beforeExpr: Je
    }),
    _export: et("export"),
    _import: et("import", {
      startsExpr: oe
    }),
    _null: et("null", {
      startsExpr: oe
    }),
    _true: et("true", {
      startsExpr: oe
    }),
    _false: et("false", {
      startsExpr: oe
    }),
    _typeof: et("typeof", {
      beforeExpr: Je,
      prefix: oi,
      startsExpr: oe
    }),
    _void: et("void", {
      beforeExpr: Je,
      prefix: oi,
      startsExpr: oe
    }),
    _delete: et("delete", {
      beforeExpr: Je,
      prefix: oi,
      startsExpr: oe
    }),
    _do: et("do", {
      isLoop: _m,
      beforeExpr: Je
    }),
    _for: et("for", {
      isLoop: _m
    }),
    _while: et("while", {
      isLoop: _m
    }),
    _as: Ye("as", {
      startsExpr: oe
    }),
    _assert: Ye("assert", {
      startsExpr: oe
    }),
    _async: Ye("async", {
      startsExpr: oe
    }),
    _await: Ye("await", {
      startsExpr: oe
    }),
    _defer: Ye("defer", {
      startsExpr: oe
    }),
    _from: Ye("from", {
      startsExpr: oe
    }),
    _get: Ye("get", {
      startsExpr: oe
    }),
    _let: Ye("let", {
      startsExpr: oe
    }),
    _meta: Ye("meta", {
      startsExpr: oe
    }),
    _of: Ye("of", {
      startsExpr: oe
    }),
    _sent: Ye("sent", {
      startsExpr: oe
    }),
    _set: Ye("set", {
      startsExpr: oe
    }),
    _source: Ye("source", {
      startsExpr: oe
    }),
    _static: Ye("static", {
      startsExpr: oe
    }),
    _using: Ye("using", {
      startsExpr: oe
    }),
    _yield: Ye("yield", {
      startsExpr: oe
    }),
    _asserts: Ye("asserts", {
      startsExpr: oe
    }),
    _checks: Ye("checks", {
      startsExpr: oe
    }),
    _exports: Ye("exports", {
      startsExpr: oe
    }),
    _global: Ye("global", {
      startsExpr: oe
    }),
    _implements: Ye("implements", {
      startsExpr: oe
    }),
    _intrinsic: Ye("intrinsic", {
      startsExpr: oe
    }),
    _infer: Ye("infer", {
      startsExpr: oe
    }),
    _is: Ye("is", {
      startsExpr: oe
    }),
    _mixins: Ye("mixins", {
      startsExpr: oe
    }),
    _proto: Ye("proto", {
      startsExpr: oe
    }),
    _require: Ye("require", {
      startsExpr: oe
    }),
    _satisfies: Ye("satisfies", {
      startsExpr: oe
    }),
    _keyof: Ye("keyof", {
      startsExpr: oe
    }),
    _readonly: Ye("readonly", {
      startsExpr: oe
    }),
    _unique: Ye("unique", {
      startsExpr: oe
    }),
    _abstract: Ye("abstract", {
      startsExpr: oe
    }),
    _declare: Ye("declare", {
      startsExpr: oe
    }),
    _enum: Ye("enum", {
      startsExpr: oe
    }),
    _module: Ye("module", {
      startsExpr: oe
    }),
    _namespace: Ye("namespace", {
      startsExpr: oe
    }),
    _interface: Ye("interface", {
      startsExpr: oe
    }),
    _type: Ye("type", {
      startsExpr: oe
    }),
    _opaque: Ye("opaque", {
      startsExpr: oe
    }),
    name: Ae("name", {
      startsExpr: oe
    }),
    string: Ae("string", {
      startsExpr: oe
    }),
    num: Ae("num", {
      startsExpr: oe
    }),
    bigint: Ae("bigint", {
      startsExpr: oe
    }),
    decimal: Ae("decimal", {
      startsExpr: oe
    }),
    regexp: Ae("regexp", {
      startsExpr: oe
    }),
    privateName: Ae("#name", {
      startsExpr: oe
    }),
    eof: Ae("eof"),
    jsxName: Ae("jsxName"),
    jsxText: Ae("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: Ae("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: Ae("jsxTagEnd"),
    placeholder: Ae("%%", {
      startsExpr: !0
    })
  };
  function ht(t) {
    return t >= 93 && t <= 132;
  }
  n(ht, "tokenIsIdentifier");
  function tue(t) {
    return t <= 92;
  }
  n(tue, "tokenKeywordOrIdentifierIsKeyword");
  function zr(t) {
    return t >= 58 && t <= 132;
  }
  n(zr, "tokenIsKeywordOrIdentifier");
  function ov(t) {
    return t >= 58 && t <= 136;
  }
  n(ov, "tokenIsLiteralPropertyName");
  function rue(t) {
    return oy[t];
  }
  n(rue, "tokenComesBeforeExpression");
  function jm(t) {
    return ly[t];
  }
  n(jm, "tokenCanStartExpression");
  function sue(t) {
    return t >= 29 && t <= 33;
  }
  n(sue, "tokenIsAssignment");
  function H1(t) {
    return t >= 129 && t <= 131;
  }
  n(H1, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function iue(t) {
    return t >= 90 && t <= 92;
  }
  n(iue, "tokenIsLoop");
  function cy(t) {
    return t >= 58 && t <= 92;
  }
  n(cy, "tokenIsKeyword");
  function nue(t) {
    return t >= 39 && t <= 59;
  }
  n(nue, "tokenIsOperator");
  function aue(t) {
    return t === 34;
  }
  n(aue, "tokenIsPostfix");
  function oue(t) {
    return uy[t];
  }
  n(oue, "tokenIsPrefix");
  function lue(t) {
    return t >= 121 && t <= 123;
  }
  n(lue, "tokenIsTSTypeOperator");
  function uue(t) {
    return t >= 124 && t <= 130;
  }
  n(uue, "tokenIsTSDeclarationStart");
  function ui(t) {
    return ny[t];
  }
  n(ui, "tokenLabelName");
  function Wu(t) {
    return ay[t];
  }
  n(Wu, "tokenOperatorPrecedence");
  function cue(t) {
    return t === 57;
  }
  n(cue, "tokenIsRightAssociative");
  function $u(t) {
    return t >= 24 && t <= 25;
  }
  n($u, "tokenIsTemplate");
  function ws(t) {
    return Ns[t];
  }
  n(ws, "getExportedToken");
  Ns[8].updateContext = (t) => {
    t.pop();
  }, Ns[5].updateContext = Ns[7].updateContext = Ns[23].updateContext = (t) => {
    t.push(gt.brace);
  }, Ns[22].updateContext = (t) => {
    t[t.length - 1] === gt.template ? t.pop() : t.push(gt.template);
  }, Ns[142].updateContext = (t) => {
    t.push(gt.j_expr, gt.j_oTag);
  };
  var py = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  lv = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", pue = new RegExp("[" + py + "]"), fue = new RegExp("[" + py + lv + "\
]");
  py = lv = null;
  var uv = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], hue = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41,
  2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9,
  6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Rm(t, e) {
    let r = 65536;
    for (let s = 0, i = e.length; s < i; s += 2) {
      if (r += e[s], r > t) return !1;
      if (r += e[s + 1], r >= t) return !0;
    }
    return !1;
  }
  n(Rm, "isInAstralSet");
  function Os(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && pue.test(String.fromCharCode(t)) :
    Rm(t, uv);
  }
  n(Os, "isIdentifierStart");
  function Bn(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && fue.test(
    String.fromCharCode(t)) : Rm(t, uv) || Rm(t, hue);
  }
  n(Bn, "isIdentifierChar");
  var fy = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, due = new Set(fy.keyword), mue = new Set(fy.strict), yue = new Set(fy.strictBind);
  function cv(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(cv, "isReservedWord");
  function pv(t, e) {
    return cv(t, e) || mue.has(t);
  }
  n(pv, "isStrictReservedWord");
  function fv(t) {
    return yue.has(t);
  }
  n(fv, "isStrictBindOnlyReservedWord");
  function hv(t, e) {
    return pv(t, e) || fv(t);
  }
  n(hv, "isStrictBindReservedWord");
  function Tue(t) {
    return due.has(t);
  }
  n(Tue, "isKeyword");
  function bue(t, e, r) {
    return t === 64 && e === 64 && Os(r);
  }
  n(bue, "isIteratorStart");
  var xue = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function Sue(t) {
    return xue.has(t);
  }
  n(Sue, "canBeReservedWord");
  var mo = class {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
    }
  }, yo = class {
    static {
      n(this, "ScopeHandler");
    }
    constructor(e, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let e = this.currentThisScopeFlags();
      return (e & 64) > 0 && (e & 2) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 128)
          return !0;
        if (r & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new mo(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
    }
    declareName(e, r, s) {
      let i = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(i, e, r, s);
        let a = i.names.get(e) || 0;
        r & 16 ? a = a | 4 : (i.firstLexicalName || (i.firstLexicalName = e), a = a | 2), i.names.set(e, a), r & 8 && this.maybeExportDefined(
        i, e);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (i = this.scopeStack[a], this.checkRedeclarationInScope(i, e, r, s), i.names.set(
        e, (i.names.get(e) || 0) | 1), this.maybeExportDefined(i, e), !(i.flags & 387)); --a)
          ;
      this.parser.inModule && i.flags & 1 && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, r) {
      this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(e, r, s, i) {
      this.isRedeclaredInScope(e, r, s) && this.parser.raise(M.VarRedeclaration, i, {
        identifierName: r
      });
    }
    isRedeclaredInScope(e, r, s) {
      if (!(s & 1)) return !1;
      if (s & 8)
        return e.names.has(r);
      let i = e.names.get(r);
      return s & 16 ? (i & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (i & 1) > 0 : (i & 2) > 0 && !(e.flags & 8 && e.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(e) && (i & 4) > 0;
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 387)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 451 && !(r & 4))
          return r;
      }
    }
  }, Um = class extends mo {
    static {
      n(this, "FlowScope");
    }
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, qm = class extends yo {
    static {
      n(this, "FlowScopeHandler");
    }
    createScope(e) {
      return new Um(e);
    }
    declareName(e, r, s) {
      let i = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(i, e, r, s), this.maybeExportDefined(i, e), i.declareFunctions.add(e);
        return;
      }
      super.declareName(e, r, s);
    }
    isRedeclaredInScope(e, r, s) {
      if (super.isRedeclaredInScope(e, r, s)) return !0;
      if (s & 2048 && !e.declareFunctions.has(r)) {
        let i = e.names.get(r);
        return (i & 4) > 0 || (i & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }, Vm = class {
    static {
      n(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        let [r, s] = e;
        if (!this.hasPlugin(r))
          return !1;
        let i = this.plugins.get(r);
        for (let a of Object.keys(s))
          if (i?.[a] !== s[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(e, r) {
      var s;
      return (s = this.plugins.get(e)) == null ? void 0 : s[r];
    }
  };
  function dv(t, e) {
    t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
  }
  n(dv, "setTrailingComments");
  function gue(t, e) {
    t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
  }
  n(gue, "setLeadingComments");
  function To(t, e) {
    t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
  }
  n(To, "setInnerComments");
  function uo(t, e, r) {
    let s = null, i = e.length;
    for (; s === null && i > 0; )
      s = e[--i];
    s === null || s.start > r.start ? To(t, r.comments) : dv(s, r.comments);
  }
  n(uo, "adjustInnerComments");
  var Km = class extends Vm {
    static {
      n(this, "CommentsParser");
    }
    addComment(e) {
      this.filename && (e.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length !== r && (this.comments.length = r), this.comments.push(e), this.state.commentsLen++;
    }
    processComment(e) {
      let {
        commentStack: r
      } = this.state, s = r.length;
      if (s === 0) return;
      let i = s - 1, a = r[i];
      a.start === e.end && (a.leadingNode = e, i--);
      let {
        start: o
      } = e;
      for (; i >= 0; i--) {
        let l = r[i], u = l.end;
        if (u > o)
          l.containingNode = e, this.finalizeComment(l), r.splice(i, 1);
        else {
          u === o && (l.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      let {
        comments: r
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && dv(e.leadingNode, r), e.trailingNode !== null && gue(e.trailingNode, r);
      else {
        let {
          containingNode: s,
          start: i
        } = e;
        if (this.input.charCodeAt(i - 1) === 44)
          switch (s.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              uo(s, s.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              uo(s, s.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              uo(s, s.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              uo(s, s.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              uo(s, s.specifiers, e);
              break;
            default:
              To(s, r);
          }
        else
          To(s, r);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: e
      } = this.state;
      for (let r = e.length - 1; r >= 0; r--)
        this.finalizeComment(e[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      if (s === 0) return;
      let i = r[s - 1];
      i.leadingNode === e && (i.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      s !== 0 && (r[s - 1].trailingNode === e ? r[s - 1].trailingNode = null : s >= 2 && r[s - 2].trailingNode === e && (r[s - 2].trailingNode =
      null));
    }
    takeSurroundingComments(e, r, s) {
      let {
        commentStack: i
      } = this.state, a = i.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = i[o], u = l.end;
        if (l.start === s)
          l.leadingNode = e;
        else if (u === r)
          l.trailingNode = e;
        else if (u < r)
          break;
      }
    }
  }, mv = /\r\n?|[\n\u2028\u2029]/, qu = new RegExp(mv.source, "g");
  function ho(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  n(ho, "isNewLine");
  var Lm = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Yu = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, z1 = new RegExp("(?=(" + Yu.source + "))\\\
1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function Pue(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  n(Pue, "isWhitespace");
  var Wm = class t {
    static {
      n(this, "State");
    }
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.
      potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [gt.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(e) {
      e ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: e,
      sourceType: r,
      startLine: s,
      startColumn: i
    }) {
      this.strict = e === !1 ? !1 : e === !0 ? !0 : r === "module", this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new us(
      s, i, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(e) {
      e ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(e) {
      e ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(e) {
      e ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(e) {
      e ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(e) {
      e ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(e) {
      e ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(e) {
      e ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(e) {
      e ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(e) {
      e ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(e) {
      e ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(e) {
      e ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new us(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let e = new t();
      return e.flags = this.flags, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.startLoc, e.endLoc = this.endLoc,
      e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.slice(), e.noArrowParamsConversionAt =
      this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.slice(), e.commentsLen = this.commentsLen,
      e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value = this.value, e.start = this.start, e.end = this.
      end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.context = this.context.slice(), e.firstInvalidTemplateEscapePos =
      this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors, e.tokensLength = this.tokensLength, e;
    }
  }, Eue = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), G1 = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Vu = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function Q1(t, e, r, s, i, a) {
    let o = r, l = s, u = i, c = "", p = null, f = r, {
      length: m
    } = e;
    for (; ; ) {
      if (r >= m) {
        a.unterminated(o, l, u), c += e.slice(f, r);
        break;
      }
      let y = e.charCodeAt(r);
      if (Aue(t, y, e, r)) {
        c += e.slice(f, r);
        break;
      }
      if (y === 92) {
        c += e.slice(f, r);
        let T = vue(e, r, s, i, t === "template", a);
        T.ch === null && !p ? p = {
          pos: r,
          lineStart: s,
          curLine: i
        } : c += T.ch, {
          pos: r,
          lineStart: s,
          curLine: i
        } = T, f = r;
      } else y === 8232 || y === 8233 ? (++r, ++i, s = r) : y === 10 || y === 13 ? t === "template" ? (c += e.slice(f, r) + `
`, ++r, y === 13 && e.charCodeAt(r) === 10 && ++r, ++i, f = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: s,
      curLine: i,
      containsInvalid: !!p
    };
  }
  n(Q1, "readStringContents");
  function Aue(t, e, r, s) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(s + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(Aue, "isStringEnd");
  function vue(t, e, r, s, i, a) {
    let o = !i;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = Ym(t, e, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = Tv(t, e, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (i)
          return l(null);
        a.strictNumericEscape(e - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, f = t.slice(c, e + 2).match(/^[0-7]+/)[0], m = parseInt(f, 8);
          m > 255 && (f = f.slice(0, -1), m = parseInt(f, 8)), e += f.length - 1;
          let y = t.charCodeAt(e);
          if (f !== "0" || y === 56 || y === 57) {
            if (i)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(m));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(vue, "readEscapedChar");
  function Ym(t, e, r, s, i, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = yv(t, e, r, s, 16, i, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(Ym, "readHexChar");
  function yv(t, e, r, s, i, a, o, l, u, c) {
    let p = e, f = i === 16 ? G1.hex : G1.decBinOct, m = i === 16 ? Vu.hex : i === 10 ? Vu.dec : i === 8 ? Vu.oct : Vu.bin, y = !1, T = 0;
    for (let L = 0, q = a ?? 1 / 0; L < q; ++L) {
      let _ = t.charCodeAt(e), U;
      if (_ === 95 && l !== "bail") {
        let J = t.charCodeAt(e - 1), ie = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(ie) || !m(ie) || f.has(J) || f.has(ie)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, s);
        }
        ++e;
        continue;
      }
      if (_ >= 97 ? U = _ - 97 + 10 : _ >= 65 ? U = _ - 65 + 10 : Eue(_) ? U = _ - 48 : U = 1 / 0, U >= i) {
        if (U <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (U <= 9 && u.invalidDigit(e, r, s, i))
          U = 0;
        else if (o)
          U = 0, y = !0;
        else
          break;
      }
      ++e, T = T * i + U;
    }
    return e === p || a != null && e - p !== a || y ? {
      n: null,
      pos: e
    } : {
      n: T,
      pos: e
    };
  }
  n(yv, "readInt");
  function Tv(t, e, r, s, i, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = Ym(t, e, r, s, t.indexOf("}", e) - e, !0, i, a), ++e, l !== null && l > 1114111)
        if (i)
          a.invalidCodePoint(e, r, s);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = Ym(t, e, r, s, 4, !1, i, a));
    return {
      code: l,
      pos: e
    };
  }
  n(Tv, "readCodePoint");
  function co(t, e, r) {
    return new us(r, t - e, t);
  }
  n(co, "buildPosition");
  var Cue = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), ls = class {
    static {
      n(this, "Token");
    }
    constructor(e) {
      this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, this.loc = new jn(e.startLoc, e.endLoc);
    }
  }, Jm = class extends Km {
    static {
      n(this, "Tokenizer");
    }
    constructor(e, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ n((s, i, a, o) => this.options.errorRecovery ? (this.raise(M.InvalidDigit, co(s, i, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(M.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(M.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(M.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(M.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ n((s, i, a) => {
          this.recordStrictModeErrors(M.StrictNumericEscape, co(s, i, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ n((s, i, a) => {
          throw this.raise(M.UnterminatedString, co(s - 1, i, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(M.StrictNumericEscape),
        unterminated: /* @__PURE__ */ n((s, i, a) => {
          throw this.raise(M.UnterminatedTemplate, co(s, i, a));
        }, "unterminated")
      }), this.state = new Wm(), this.state.init(e), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new ls(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.
      state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      let e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = e, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return Lm.lastIndex = e, Lm.test(this.input) ? Lm.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e) {
      return Yu.lastIndex = e, Yu.test(this.input) ? Yu.lastIndex : e;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e) {
      let r = this.input.charCodeAt(e);
      if ((r & 64512) === 55296 && ++e < this.input.length) {
        let s = this.input.charCodeAt(e);
        (s & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (s & 1023));
      }
      return r;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([r, s]) => this.raise(r, s)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let s = this.state.pos, i = this.input.indexOf(e, s + 2);
      if (i === -1)
        throw this.raise(M.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = i + e.length, qu.lastIndex = s + 2; qu.test(this.input) && qu.lastIndex <= i; )
        ++this.state.curLine, this.state.lineStart = qu.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(s + 2, i),
        start: s,
        end: i + e.length,
        loc: new jn(r, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(a), a;
    }
    skipLineComment(e) {
      let r = this.state.pos, s;
      this.isLookahead || (s = this.state.curPosition());
      let i = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !ho(i) && ++this.state.pos < this.length; )
          i = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(r + e, a),
        start: r,
        end: a,
        loc: new jn(s, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(l), l;
    }
    skipSpace() {
      let e = this.state.pos, r = [];
      e: for (; this.state.pos < this.length; ) {
        let s = this.input.charCodeAt(this.state.pos);
        switch (s) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let i = this.skipBlockComment("*/");
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              case 47: {
                let i = this.skipLineComment(2);
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (Pue(s))
              ++this.state.pos;
            else if (s === 45 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else if (s === 60 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r.length > 0) {
        let s = this.state.pos, i = {
          start: e,
          end: s,
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(i);
      }
    }
    finishToken(e, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let s = this.state.type;
      this.state.type = e, this.state.value = r, this.isLookahead || this.updateContext(s);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let e = this.state.pos + 1, r = this.codePointAtPos(e);
      if (r >= 48 && r <= 57)
        throw this.raise(M.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? M.RecordExpressionHashIncorrectStartSyntaxType : M.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else Os(r) ? (++this.state.pos, this.finishToken(138, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(138, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(!0);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !ho(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      let s = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, s), !0;
    }
    readToken_mult_modulo(e) {
      let r = e === 42 ? 55 : 54, s = 1, i = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && i === 42 && (s++, i = this.input.charCodeAt(this.state.pos + 2), r = 57), i === 61 && !this.state.inType && (s++, r = e ===
      37 ? 33 : 30), this.finishOp(r, s);
    }
    readToken_pipe_amp(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(M.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(M.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 62) {
        let s = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + s) === 61) {
          this.finishOp(30, s + 1);
          return;
        }
        this.finishOp(52, s);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let e = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(M.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(M.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Os(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(M.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, r) {
      let s = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(e, s);
    }
    readRegexp() {
      let e = this.state.startLoc, r = this.state.start + 1, s, i, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(M.UnterminatedRegExp, xr(e, 1));
        let c = this.input.charCodeAt(a);
        if (ho(c))
          throw this.raise(M.UnterminatedRegExp, xr(e, 1));
        if (s)
          s = !1;
        else {
          if (c === 91)
            i = !0;
          else if (c === 93 && i)
            i = !1;
          else if (c === 47 && !i)
            break;
          s = c === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let l = "", u = /* @__PURE__ */ n(() => xr(e, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (Cue.has(c))
          c === 118 ? l.includes("u") && this.raise(M.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(M.IncompatibleRegExpUVFlags,
          u()), l.includes(p) && this.raise(M.DuplicateRegExpFlags, u());
        else if (Bn(c) || c === 92)
          this.raise(M.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += p;
      }
      this.state.pos = a, this.finishToken(137, {
        pattern: o,
        flags: l
      });
    }
    readInt(e, r, s = !1, i = !0) {
      let {
        n: a,
        pos: o
      } = yv(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, r, s, i, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(e) {
      let r = this.state.curPosition(), s = !1;
      this.state.pos += 2;
      let i = this.readInt(e);
      i == null && this.raise(M.InvalidDigit, xr(r, 2), {
        radix: e
      });
      let a = this.input.charCodeAt(this.state.pos);
      if (a === 110)
        ++this.state.pos, s = !0;
      else if (a === 109)
        throw this.raise(M.InvalidDecimal, r);
      if (Os(this.codePointAtPos(this.state.pos)))
        throw this.raise(M.NumberIdentifier, this.state.curPosition());
      if (s) {
        let o = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, o);
        return;
      }
      this.finishToken(134, i);
    }
    readNumber(e) {
      let r = this.state.pos, s = this.state.curPosition(), i = !1, a = !1, o = !1, l = !1, u = !1;
      !e && this.readInt(10) === null && this.raise(M.InvalidNumber, this.state.curPosition());
      let c = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (c) {
        let y = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(M.StrictOctalLiteral, s), !this.state.strict) {
          let T = y.indexOf("_");
          T > 0 && this.raise(M.ZeroDigitNumericSeparator, xr(s, T));
        }
        u = c && !/[89]/.test(y);
      }
      let p = this.input.charCodeAt(this.state.pos);
      if (p === 46 && !u && (++this.state.pos, this.readInt(10), i = !0, p = this.input.charCodeAt(this.state.pos)), (p === 69 || p === 101) &&
      !u && (p = this.input.charCodeAt(++this.state.pos), (p === 43 || p === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      M.InvalidOrMissingExponent, s), i = !0, l = !0, p = this.input.charCodeAt(this.state.pos)), p === 110 && ((i || c) && this.raise(M.InvalidBigIntLiteral,
      s), ++this.state.pos, a = !0), p === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (l || c) && this.raise(M.InvalidDecimal,
      s), ++this.state.pos, o = !0), Os(this.codePointAtPos(this.state.pos)))
        throw this.raise(M.NumberIdentifier, this.state.curPosition());
      let f = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(135, f);
        return;
      }
      if (o) {
        this.finishToken(136, f);
        return;
      }
      let m = u ? parseInt(f, 8) : parseFloat(f);
      this.finishToken(134, m);
    }
    readCodePoint(e) {
      let {
        code: r,
        pos: s
      } = Tv(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
      return this.state.pos = s, r;
    }
    readString(e) {
      let {
        str: r,
        pos: s,
        curLine: i,
        lineStart: a
      } = Q1(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = i, this.finishToken(133, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: s,
        pos: i,
        curLine: a,
        lineStart: o
      } = Q1("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = i + 1, this.state.lineStart = o, this.state.curLine = a, s && (this.state.firstInvalidTemplateEscapePos = new us(s.curLine,
      s.pos - s.lineStart, s.pos)), this.input.codePointAt(i) === 96 ? this.finishToken(24, s ? null : e + r + "`") : (this.state.pos++, this.
      finishToken(25, s ? null : e + r + "${"));
    }
    recordStrictModeErrors(e, r) {
      let s = r.index;
      this.state.strict && !this.state.strictErrors.has(s) ? this.raise(e, r) : this.state.strictErrors.set(s, [e, r]);
    }
    readWord1(e) {
      this.state.containsEsc = !1;
      let r = "", s = this.state.pos, i = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (Bn(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(i, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === s ? Os : Bn;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(M.MissingUnicodeEscape, this.state.curPosition()), i = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(M.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(u)), i = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(i, this.state.pos);
    }
    readWord(e) {
      let r = this.readWord1(e), s = iy.get(r);
      s !== void 0 ? this.finishToken(s, ui(s)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: e
      } = this.state;
      cy(e) && this.state.containsEsc && this.raise(M.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: ui(e)
      });
    }
    raise(e, r, s = {}) {
      let i = r instanceof us ? r : r.loc.start, a = e(i, s);
      if (!this.options.errorRecovery) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(e, r, s = {}) {
      let i = r instanceof us ? r : r.loc.start, a = i.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = e(i, s);
        if (u.loc.index < a) break;
      }
      return this.raise(e, r, s);
    }
    updateContext(e) {
    }
    unexpected(e, r) {
      throw this.raise(M.UnexpectedToken, e ?? this.state.startLoc, {
        expected: r ? ui(r) : null
      });
    }
    expectPlugin(e, r) {
      if (this.hasPlugin(e))
        return !0;
      throw this.raise(M.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((r) => this.hasPlugin(r)))
        throw this.raise(M.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: e
        });
    }
    errorBuilder(e) {
      return (r, s, i) => {
        this.raise(e, co(r, s, i));
      };
    }
  }, Xm = class {
    static {
      n(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, $m = class {
    static {
      n(this, "ClassScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new Xm());
    }
    exit() {
      let e = this.stack.pop(), r = this.current();
      for (let [s, i] of Array.from(e.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(s) || r.undefinedPrivateNames.set(s, i) : this.parser.raise(M.InvalidPrivateFieldResolution, i, {
          identifierName: s
        });
    }
    declarePrivateName(e, r, s) {
      let {
        privateNames: i,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = i.has(e);
      if (r & 3) {
        let u = l && a.get(e);
        if (u) {
          let c = u & 4, p = r & 4, f = u & 3, m = r & 3;
          l = f === m || c !== p, l || a.delete(e);
        } else l || a.set(e, r);
      }
      l && this.parser.raise(M.PrivateNameRedeclaration, s, {
        identifierName: e
      }), i.add(e), o.delete(e);
    }
    usePrivateName(e, r) {
      let s;
      for (s of this.stack)
        if (s.privateNames.has(e)) return;
      s ? s.undefinedPrivateNames.set(e, r) : this.parser.raise(M.InvalidPrivateFieldResolution, r, {
        identifierName: e
      });
    }
  }, Rn = class {
    static {
      n(this, "ExpressionScope");
    }
    constructor(e = 0) {
      this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, Hu = class extends Rn {
    static {
      n(this, "ArrowHeadParsingScope");
    }
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, r) {
      let s = r.index;
      this.declarationErrors.set(s, [e, r]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }, Hm = class {
    static {
      n(this, "ExpressionScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [new Rn()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, r) {
      let s = r.loc.start, {
        stack: i
      } = this, a = i.length - 1, o = i[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(e, s);
        else
          return;
        o = i[--a];
      }
      this.parser.raise(e, s);
    }
    recordArrowParameterBindingError(e, r) {
      let {
        stack: s
      } = this, i = s[s.length - 1], a = r.loc.start;
      if (i.isCertainlyParameterDeclaration())
        this.parser.raise(e, a);
      else if (i.canBeArrowParameterDeclaration())
        i.recordDeclarationError(e, a);
      else
        return;
    }
    recordAsyncArrowParametersError(e) {
      let {
        stack: r
      } = this, s = r.length - 1, i = r[s];
      for (; i.canBeArrowParameterDeclaration(); )
        i.type === 2 && i.recordDeclarationError(M.AwaitBindingIdentifier, e), i = r[--s];
    }
    validateAsPattern() {
      let {
        stack: e
      } = this, r = e[e.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([s, i]) => {
        this.parser.raise(s, i);
        let a = e.length - 2, o = e[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(i.index), o = e[--a];
      });
    }
  };
  function Iue() {
    return new Rn(3);
  }
  n(Iue, "newParameterDeclarationScope");
  function wue() {
    return new Hu(1);
  }
  n(wue, "newArrowHeadScope");
  function Nue() {
    return new Hu(2);
  }
  n(Nue, "newAsyncArrowScope");
  function bv() {
    return new Rn();
  }
  n(bv, "newExpressionScope");
  var zm = class {
    static {
      n(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function Ju(t, e) {
    return (t ? 2 : 0) | (e ? 1 : 0);
  }
  n(Ju, "functionFlags");
  var Gm = class extends Jm {
    static {
      n(this, "UtilParser");
    }
    addExtra(e, r, s, i = !0) {
      if (!e) return;
      let a = e.extra = e.extra || {};
      i ? a[r] = s : Object.defineProperty(a, r, {
        enumerable: i,
        value: s
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, r) {
      let s = e + r.length;
      if (this.input.slice(e, s) === r) {
        let i = this.input.charCodeAt(s);
        return !(Bn(i) || (i & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(e) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1;
    }
    expectContextual(e, r) {
      if (!this.eatContextual(e)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, e);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return mv.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return z1.lastIndex = this.state.end, z1.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = !0) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(M.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e, r) {
      this.eat(e) || this.unexpected(r, e);
    }
    tryParse(e, r = this.state.clone()) {
      let s = {
        node: null
      };
      try {
        let i = e((a = null) => {
          throw s.node = a, s;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: i,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: i,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (i) {
        let a = this.state;
        if (this.state = r, i instanceof SyntaxError)
          return {
            node: null,
            error: i,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (i === s)
          return {
            node: s.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw i;
      }
    }
    checkExpressionErrors(e, r) {
      if (!e) return !1;
      let {
        shorthandAssignLoc: s,
        doubleProtoLoc: i,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = e, l = !!s || !!i || !!o || !!a;
      if (!r)
        return l;
      s != null && this.raise(M.InvalidCoverInitializedName, s), i != null && this.raise(M.DuplicateProto, i), a != null && this.raise(M.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return ov(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let s = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let i = this.inModule;
      this.inModule = e;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, e);
      let l = this.prodParam;
      this.prodParam = new zm();
      let u = this.classScope;
      this.classScope = new $m(this);
      let c = this.expressionScope;
      return this.expressionScope = new Hm(this), () => {
        this.state.labels = r, this.exportedIdentifiers = s, this.inModule = i, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let e = 0;
      this.inModule && (e |= 2), this.scope.enter(1), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      let {
        privateKeyLoc: r
      } = e;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, Fn = class {
    static {
      n(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, Un = class {
    static {
      n(this, "Node");
    }
    constructor(e, r, s) {
      this.type = "", this.start = r, this.end = 0, this.loc = new jn(s), e != null && e.options.ranges && (this.range = [r, 0]), e != null &&
      e.filename && (this.loc.filename = e.filename);
    }
  }, hy = Un.prototype;
  hy.__clone = function() {
    let t = new Un(void 0, this.start, this.loc.start), e = Object.keys(this);
    for (let r = 0, s = e.length; r < s; r++) {
      let i = e[r];
      i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (t[i] = this[i]);
    }
    return t;
  };
  function Oue(t) {
    return Ds(t);
  }
  n(Oue, "clonePlaceholder");
  function Ds(t) {
    let {
      type: e,
      start: r,
      end: s,
      loc: i,
      range: a,
      extra: o,
      name: l
    } = t, u = Object.create(hy);
    return u.type = e, u.start = r, u.end = s, u.loc = i, u.range = a, u.extra = o, u.name = l, e === "Placeholder" && (u.expectedNode = t.expectedNode),
    u;
  }
  n(Ds, "cloneIdentifier");
  function kue(t) {
    let {
      type: e,
      start: r,
      end: s,
      loc: i,
      range: a,
      extra: o
    } = t;
    if (e === "Placeholder")
      return Oue(t);
    let l = Object.create(hy);
    return l.type = e, l.start = r, l.end = s, l.loc = i, l.range = a, t.raw !== void 0 ? l.raw = t.raw : l.extra = o, l.value = t.value, l;
  }
  n(kue, "cloneStringLiteral");
  var Qm = class extends Gm {
    static {
      n(this, "NodeUtils");
    }
    startNode() {
      let e = this.state.startLoc;
      return new Un(this, e.index, e);
    }
    startNodeAt(e) {
      return new Un(this, e.index, e);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.loc.start);
    }
    finishNode(e, r) {
      return this.finishNodeAt(e, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, r, s) {
      return e.type = r, e.end = s.index, e.loc.end = s, this.options.ranges && (e.range[1] = s.index), this.options.attachComment && this.processComment(
      e), e;
    }
    resetStartLocation(e, r) {
      e.start = r.index, e.loc.start = r, this.options.ranges && (e.range[0] = r.index);
    }
    resetEndLocation(e, r = this.state.lastTokEndLoc) {
      e.end = r.index, e.loc.end = r, this.options.ranges && (e.range[1] = r.index);
    }
    resetStartLocationFromNode(e, r) {
      this.resetStartLocation(e, r.loc.start);
    }
  }, Due = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "sta\
tic", "string", "true", "typeof", "void"]), Oe = ks`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Cannot overwrite reserved type ${t}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Boolean enum members need to be initialized. Use either \`${t} = true,\` or \`${t} = false,\` in enum \`${e}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Enum member names need to be unique, but the name \`${t}\` has already been used before in enum \`${e}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ n(({
      enumName: t
    }) => `Enum \`${t}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ n(({
      invalidEnumType: t,
      enumName: e
    }) => `Enum type \`${t}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ n(({
      enumName: t
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      explicitType: r
    }) => `Enum \`${t}\` has type \`${r}\`, so the initializer of \`${e}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${t}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${t}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${r}\`, in enum \`${t}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${t}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ n(({
      enumName: t
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Unexpected reserved type ${t}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ n(({
      unsupportedExportKind: t,
      suggestion: e
    }) => `\`declare export ${t}\` is not supported. Use \`${e}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function _ue(t) {
    return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "T\
ypeAlias" && t.declaration.type !== "InterfaceDeclaration");
  }
  n(_ue, "isEsModuleType");
  function Z1(t) {
    return t.importKind === "type" || t.importKind === "typeof";
  }
  n(Z1, "hasTypeImportKind");
  var Lue = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function Mue(t, e) {
    let r = [], s = [];
    for (let i = 0; i < t.length; i++)
      (e(t[i], i, t) ? r : s).push(t[i]);
    return [r, s];
  }
  n(Mue, "partition");
  var Bue = /\*?\s*@((?:no)?flow)\b/, Fue = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return qm;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(r, s) {
      r !== 133 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, s);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let s = Bue.exec(r.value);
        if (s) if (s[1] === "flow")
          this.flowPragma = "flow";
        else if (s[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let s = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let i = this.flowParseType();
      return this.state.inType = s, i;
    }
    flowParsePredicate() {
      let r = this.startNode(), s = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(Oe.UnexpectedSpaceBetweenModuloChecks,
      s), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let s = null, i = null;
      return this.match(54) ? (this.state.inType = r, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = r, this.
      match(54) && (i = this.flowParsePredicate())), [s, i];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let s = r.id = this.parseIdentifier(), i = this.startNode(), a = this.startNode();
      this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return i.params = o.params, i.rest = o.rest, i.this = o._this, this.expect(11), [i.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      s), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, s) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (s && this.raise(Oe.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, s);
      this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(133) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let s = r.body = this.startNode(), i = s.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(Oe.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, Oe.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), i.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
      let a = null, o = !1;
      return i.forEach((l) => {
        _ue(l) ? (a === "CommonJS" && this.raise(Oe.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(Oe.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(Oe.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, s) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
        let i = this.state.value;
        throw this.raise(Oe.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: i,
          suggestion: Lue[i]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.
        exportKind), r.type = "Declare" + r.type, r;
      this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let s = this.flowParseTypeAlias(r);
      return s.type = "DeclareTypeAlias", s;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let s = this.flowParseOpaqueType(r, !0);
      return s.type = "DeclareOpaqueType", s;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, s) {
      if (r.id = this.flowParseRestrictedIdentifier(!s, !0), this.scope.declareName(r.id.name, s ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!s && this.eat(12));
      if (s) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: s,
        allowExact: !1,
        allowSpread: !1,
        allowProto: s,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(Oe.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, s, i) {
      Due.has(r) && this.raise(i ? Oe.AssignReservedType : Oe.UnexpectedReservedType, s, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, s) {
      return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, s) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, s || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let s = this.state.startLoc, i = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return i.name = o.name, i.variance = a, i.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) :
      r && this.raise(Oe.MissingTypeParamDefault, s), this.finishNode(i, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, s = this.startNode();
      s.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = !1;
      do {
        let a = this.flowParseTypeParameter(i);
        s.params.push(a), a.default && (i = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(s, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), s = this.state.inType;
      r.params = [], this.state.inType = !0, this.expect(47);
      let i = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let r = this.startNode(), s = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, s, i) {
      return r.static = s, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = i, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, s) {
      return r.static = s, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, s) {
      let i = this.startNode();
      return r.static = s, r.value = this.flowParseObjectTypeMethodish(i), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: s,
      allowSpread: i,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, p, f = !1;
      for (s && this.match(6) ? (this.expect(6), c = 9, p = !0) : (this.expect(5), c = 8, p = !1), u.exact = p; !this.match(c); ) {
        let y = !1, T = null, L = null, q = this.startNode();
        if (a && this.isContextual(118)) {
          let U = this.lookahead();
          U.type !== 14 && U.type !== 17 && (this.next(), T = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let U = this.lookahead();
          U.type !== 14 && U.type !== 17 && (this.next(), y = !0);
        }
        let _ = this.flowParseVariance();
        if (this.eat(0))
          T != null && this.unexpected(T), this.eat(0) ? (_ && this.unexpected(_.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          q, y))) : u.indexers.push(this.flowParseObjectTypeIndexer(q, y, _));
        else if (this.match(10) || this.match(47))
          T != null && this.unexpected(T), _ && this.unexpected(_.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(q, y));
        else {
          let U = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let ie = this.lookahead();
            ov(ie.type) && (U = this.state.value, this.next());
          }
          let J = this.flowParseObjectTypeProperty(q, y, T, _, U, i, o ?? !p);
          J === null ? (f = !0, L = this.state.lastTokStartLoc) : u.properties.push(J);
        }
        this.flowObjectTypeSemicolon(), L && !this.match(8) && !this.match(9) && this.raise(Oe.UnexpectedExplicitInexactInObject, L);
      }
      this.expect(c), i && (u.inexact = f);
      let m = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, m;
    }
    flowParseObjectTypeProperty(r, s, i, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(Oe.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(Oe.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(Oe.InexactVariance, a), null) : (l || this.raise(
        Oe.UnexpectedSpreadType, this.state.lastTokStartLoc), i != null && this.unexpected(i), a && this.raise(Oe.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = s, r.proto = i != null, r.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, i != null && this.unexpected(i), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !l && r.key.name === "constructor" && r.value.this && this.raise(Oe.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (c = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = c, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let s = r.kind === "get" ? 0 : 1, i = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? Oe.GetterMayNotHaveThisParam : Oe.SetterMayNotHaveThisParam, r.value.this), i !== s && this.
      raise(r.kind === "get" ? M.BadGetterArity : M.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(M.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, s) {
      var i;
      (i = r) != null || (r = this.state.startLoc);
      let a = s || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let o = this.startNodeAt(r);
        o.qualification = a, o.id = this.flowParseRestrictedIdentifier(!0), a = this.finishNode(o, "QualifiedTypeIdentifier");
      }
      return a;
    }
    flowParseGenericType(r, s) {
      let i = this.startNodeAt(r);
      return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(r, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(i, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let s = null, i = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !r && this.raise(Oe.ThisParamMustBeFirst, o), s = this.parseIdentifier(u), this.eat(17) &&
      (i = !0, u && this.raise(Oe.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = s,
      o.optional = i, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let s = this.startNodeAt(r.loc.start);
      return s.name = null, s.optional = !1, s.typeAnnotation = r, this.finishNode(s, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let s = null, i = null;
      for (this.match(78) && (i = this.flowParseFunctionTypeParam(!0), i.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (s = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: s,
        _this: i
      };
    }
    flowIdentToTypeAnnotation(r, s, i) {
      switch (i.name) {
        case "any":
          return this.finishNode(s, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(s, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(s, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(s, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(s, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(s, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(s, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(i.name), this.flowParseGenericType(r, i);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, s = this.startNode(), i, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47: {
          let u = this.startNode();
          return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), u.params =
          i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(
          u, "FunctionTypeAnnotation");
        }
        case 10: {
          let u = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (ht(this.state.type) || this.match(78)) {
              let c = this.lookahead().type;
              o = c !== 17 && c !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : i = this.flowParseFunctionTypeParams(),
          u.params = i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters =
          null, this.finishNode(u, "FunctionTypeAnnotation");
        }
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
            throw this.raise(Oe.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(s, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(s, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (cy(this.state.type)) {
            let u = ui(this.state.type);
            return this.next(), super.createIdentifier(s, u);
          } else if (ht(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, s, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, s = this.flowParsePrimaryType(), i = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        i = i || o, this.expect(0), !o && this.match(3) ? (a.elementType = s, this.next(), s = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = s, a.indexType = this.flowParseType(), this.expect(3), i ? (a.optional = o, s = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : s = this.finishNode(a, "IndexedAccessType"));
      }
      return s;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let s = this.startNodeAt(r.loc.start);
        return s.params = [this.reinterpretTypeAsFunctionTypeParam(r)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.
        typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let s = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [s]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? s : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let s = this.flowParseIntersectionType();
      for (r.types = [s]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? s : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let s = this.flowParseUnionType();
      return this.state.inType = r, s;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, s = this.parseIdentifier();
        return this.flowParseGenericType(r, s);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let s = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, s, i = !1) {
      if (s) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, i));
        return;
      }
      super.parseFunctionBody(r, !1, i);
    }
    parseFunctionBodyAndFinish(r, s, i = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, s, i);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let i = this.lookahead();
        if (zr(i.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      }
      let s = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
    }
    parseExpressionStatement(r, s, i) {
      if (s.type === "Identifier") {
        if (s.name === "declare") {
          if (this.match(80) || ht(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (ht(this.state.type)) {
          if (s.name === "interface")
            return this.flowParseInterface(r);
          if (s.name === "type")
            return this.flowParseTypeAlias(r);
          if (s.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, s, i);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return H1(r) || this.shouldParseEnums() && r === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return H1(r) || this.shouldParseEnums() && r === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, s, i) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let m = this.lookaheadCharCode();
        if (m === 44 || m === 61 || m === 58 || m === 41)
          return this.setOptionalParametersError(i), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(s), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [p, f] = this.getArrowLikeExpressions(u);
      if (c || f.length > 0) {
        let m = [...o];
        if (f.length > 0) {
          this.state = a, this.state.noArrowAt = m;
          for (let y = 0; y < f.length; y++)
            m.push(f[y].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [p, f] = this.getArrowLikeExpressions(u);
        }
        c && p.length > 1 && this.raise(Oe.AmbiguousConditionalArrow, a.startLoc), c && p.length === 1 && (this.state = a, m.push(p[0].start),
        this.state.noArrowAt = m, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = r, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), s = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: s
      };
    }
    getArrowLikeExpressions(r, s) {
      let i = [r], a = [];
      for (; i.length !== 0; ) {
        let o = i.pop();
        o.type === "ArrowFunctionExpression" && o.body.type !== "BlockStatement" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(
        o) : a.push(o), i.push(o.body)) : o.type === "ConditionalExpression" && (i.push(o.consequent), i.push(o.alternate));
      }
      return s ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : Mue(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(r) {
      var s;
      this.toAssignableList(r.params, (s = r.extra) == null ? void 0 : s.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, s) {
      let i;
      return this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), i =
      s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
    }
    parseParenItem(r, s) {
      let i = super.parseParenItem(r, s);
      if (this.eat(17) && (i.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(s);
        return a.expression = i, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
      }
      return i;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        s);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseOpaqueType(s, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseInterface(s);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        r.exportKind = "value";
        let s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: s
      } = this.state, i = super.maybeParseExportNamespaceSpecifier(r);
      return i && r.exportKind === "type" && this.unexpected(s), i;
    }
    parseClassId(r, s, i) {
      super.parseClassId(r, s, i), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, s, i) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, s))
          return;
        s.declare = !0;
      }
      super.parseClassMember(r, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "Property\
Definition" ? this.raise(Oe.DeclareClassElement, a) : s.value && this.raise(Oe.DeclareClassFieldInitializer, s.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), s = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(M.InvalidIdentifier, this.state.curPosition(), {
        identifierName: s
      }), this.finishToken(132, s);
    }
    getTokenFromCode(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : bue(r, s, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, s) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      !s && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, s);
    }
    toAssignableList(r, s, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, i);
    }
    toReferencedList(r, s) {
      for (let a = 0; a < r.length; a++) {
        var i;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((i = o.extra) != null && i.parenthesized) && (r.length > 1 || !s) && this.raise(Oe.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, s, i, a) {
      let o = super.parseArrayLike(r, s, i, a);
      return s && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(r, s, i) {
      return r === "TypeCastExpression" || super.isValidLVal(r, s, i);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, s, i, a, o, l) {
      if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, s, i, a, o, l), s.params && o) {
        let u = s.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Oe.ThisParamBannedInConstructor, s);
      } else if (s.type === "MethodDefinition" && o && s.value.params) {
        let u = s.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Oe.ThisParamBannedInConstructor, s);
      }
    }
    pushClassPrivateMethod(r, s, i, a) {
      s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, s, i, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.
      isContextual(113)) {
        this.next();
        let s = r.implements = [];
        do {
          let i = this.startNode();
          i.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.
          typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let s = this.getObjectOrClassMethodParams(r);
      if (s.length > 0) {
        let i = s[0];
        this.isThisParam(i) && r.kind === "get" ? this.raise(Oe.GetterMayNotHaveThisParam, i) : this.isThisParam(i) && this.raise(Oe.SetterMayNotHaveThisParam,
        i);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, s, i, a, o, l, u) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let p = super.parseObjPropValue(r, s, i, a, o, l, u);
      return c && ((p.value || p).typeParameters = c), p;
    }
    parseAssignableListItemTypes(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(Oe.PatternIsOptional, r), this.isThisParam(r) && this.raise(Oe.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(Oe.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(Oe.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, s) {
      let i = super.parseMaybeDefault(r, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(Oe.TypeBeforeInitializer,
      i.typeAnnotation), i;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Oe.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, s, i) {
      s.local = Z1(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(s,
      i));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let s = this.lookaheadCharCode();
        return s === 123 || s === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, i, a) {
      if (super.applyImportPhase(r, s, i, a), s) {
        if (!i && this.match(65))
          return;
        r.exportKind = i === "type" ? i : "value";
      } else
        i === "type" && this.match(55) && this.unexpected(), r.importKind = i === "type" || i === "typeof" ? i : "value";
    }
    parseImportSpecifier(r, s, i, a, o) {
      let l = r.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let f = this.parseIdentifier(!0);
        u !== null && !zr(this.state.type) ? (r.imported = f, r.importKind = u, r.local = Ds(f)) : (r.imported = l, r.importKind = null, r.local =
        this.parseIdentifier());
      } else {
        if (u !== null && zr(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = u;
        else {
          if (s)
            throw this.raise(M.ImportBindingIsString, r, {
              importName: l.value
            });
          r.imported = l, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (c = !0, r.local = Ds(r.imported));
      }
      let p = Z1(r);
      return i && p && this.raise(Oe.ImportTypeShorthandOnlyInPureImport, r), (i || p) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), c && !i && !p && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, s) {
      let i = r.kind;
      i !== "get" && i !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      if (this.match(14)) {
        let i = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
      }
      return super.parseAsyncArrowFromCallExpression(r, s);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, s) {
      var i;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, s), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, p = c[c.length - 1];
        (p === gt.j_oTag || p === gt.j_expr) && c.pop();
      }
      if ((i = o) != null && i.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, p = this.tryParse((m) => {
          var y;
          c = this.flowParseTypeParameterDeclaration();
          let T = this.forwardNoArrowParamsConversionAt(c, () => {
            let q = super.parseMaybeAssign(r, s);
            return this.resetStartLocationFromNode(q, c), q;
          });
          (y = T.extra) != null && y.parenthesized && m();
          let L = this.maybeUnwrapTypeCastExpression(T);
          return L.type !== "ArrowFunctionExpression" && m(), L.typeParameters = c, this.resetStartLocationFromNode(L, c), T;
        }, a), f = null;
        if (p.node && this.maybeUnwrapTypeCastExpression(p.node).type === "ArrowFunctionExpression") {
          if (!p.error && !p.aborted)
            return p.node.async && this.raise(Oe.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), p.node;
          f = p.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (f)
          return this.state = p.failState, f;
        throw (u = o) != null && u.thrown ? o.error : p.thrown ? p.error : this.raise(Oe.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse(() => {
          let i = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (s.thrown) return null;
        s.error && (this.state = s.failState), r.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, s) {
      this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? r.params = s : super.setArrowFunctionParameters(r, s);
    }
    checkParams(r, s, i, a = !0) {
      if (!(i && this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1)) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(Oe.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, s, i, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(r, s, i) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.indexOf(s.index) !== -1) {
        this.next();
        let a = this.startNodeAt(s);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(11, !1), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(s) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(r, s, i), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(r, s, i);
    }
    parseSubscript(r, s, i, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, i)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(s);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11, !1), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!i && this.shouldParseTypes() && this.match(47)) {
        let o = this.startNodeAt(s);
        o.callee = r;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11, !1), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(r, s, i, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let s = null;
      this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      s;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let s = this.startNodeAt(r);
      if (this.parseFunctionParams(s, !1), !!this.parseArrow(s))
        return super.parseArrowExpression(s, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && s === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && s === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, s) {
      let i = super.parseTopLevel(r, s);
      return this.state.hasFlowComment && this.raise(Oe.UnterminatedFlowComment, this.state.curPosition()), i;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(Oe.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, s = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + s)); )
        s++;
      let i = this.input.charCodeAt(s + r), a = this.input.charCodeAt(s + r + 1);
      return i === 58 && a === 58 ? s + 2 : this.input.slice(s + r, s + r + 12) === "flow-include" ? s + 12 : i === 58 && a !== 58 ? s : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(M.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: s,
      memberName: i
    }) {
      this.raise(Oe.EnumBooleanMemberNotInitialized, r, {
        memberName: i,
        enumName: s
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, s) {
      return this.raise(s.explicitType ? s.explicitType === "symbol" ? Oe.EnumInvalidMemberInitializerSymbolType : Oe.EnumInvalidMemberInitializerPrimaryType :
      Oe.EnumInvalidMemberInitializerUnknownType, r, s);
    }
    flowEnumErrorNumberMemberNotInitialized(r, s) {
      this.raise(Oe.EnumNumberMemberNotInitialized, r, s);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, s) {
      this.raise(Oe.EnumStringMemberInconsistentlyInitialized, r, s);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, s = /* @__PURE__ */ n(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 134: {
          let i = this.parseNumericLiteral(this.state.value);
          return s() ? {
            type: "number",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 133: {
          let i = this.parseStringLiteral(this.state.value);
          return s() ? {
            type: "string",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let i = this.parseBooleanLiteral(this.match(85));
          return s() ? {
            type: "boolean",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, s = this.parseIdentifier(!0), i = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: s,
        init: i
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, s, i) {
      let {
        explicitType: a
      } = s;
      a !== null && a !== i && this.flowEnumErrorInvalidMemberInitializer(r, s);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: s
    }) {
      let i = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), p = u.name;
        if (p === "")
          continue;
        /^[a-z]/.test(p) && this.raise(Oe.EnumInvalidMemberName, u, {
          memberName: p,
          suggestion: p[0].toUpperCase() + p.slice(1),
          enumName: r
        }), i.has(p) && this.raise(Oe.EnumDuplicateMemberName, u, {
          memberName: p,
          enumName: r
        }), i.add(p);
        let f = {
          enumName: r,
          explicitType: s,
          memberName: p
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, f);
          case "none":
            switch (s) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, f);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, f);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, s, {
      enumName: i
    }) {
      if (r.length === 0)
        return s;
      if (s.length === 0)
        return r;
      if (s.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return s;
      } else {
        for (let a of s)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!ht(this.state.type))
        throw this.raise(Oe.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: s
      } = this.state;
      return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(Oe.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: s
      }), s;
    }
    flowEnumBody(r, s) {
      let i = s.name, a = s.loc.start, o = this.flowEnumParseExplicitType({
        enumName: i
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: i,
        explicitType: o
      });
      switch (r.hasUnknownMembers = u, o) {
        case "boolean":
          return r.explicitType = !0, r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: i
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = l.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ n(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let p = l.booleanMembers.length, f = l.numberMembers.length, m = l.stringMembers.length, y = l.defaultedMembers.length;
          if (!p && !f && !m && !y)
            return c();
          if (!p && !f)
            return r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: i
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!f && !m && p >= y) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(T.loc.start, {
                enumName: i,
                memberName: T.id.name
              });
            return r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!p && !m && f >= y) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(T.loc.start, {
                enumName: i,
                memberName: T.id.name
              });
            return r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(Oe.EnumInconsistentMemberValues, a, {
              enumName: i
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let s = this.parseIdentifier();
      return r.id = s, r.body = this.flowEnumBody(this.startNode(), s), this.finishNode(r, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let s = this.input.charCodeAt(r + 1);
        return s !== 60 && s !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), jue = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, Ji = ks`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ n(({
      openingTagName: t
    }) => `Expected corresponding JSX closing tag for <${t}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t,
      HTMLEntity: e
    }) => `Unexpected token \`${t}\`. Did you mean \`${e}\` or \`{'${t}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function li(t) {
    return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : !1;
  }
  n(li, "isFragment");
  function Mn(t) {
    if (t.type === "JSXIdentifier")
      return t.name;
    if (t.type === "JSXNamespacedName")
      return t.namespace.name + ":" + t.name.name;
    if (t.type === "JSXMemberExpression")
      return Mn(t.object) + "." + Mn(t.property);
    throw new Error("Node had unexpected type: " + t.type);
  }
  n(Mn, "getQualifiedJSXName");
  var Rue = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", s = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Ji.UnterminatedJsxContent, this.state.startLoc);
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(i);
              return;
            }
            r += this.input.slice(s, this.state.pos), this.finishToken(141, r);
            return;
          case 38:
            r += this.input.slice(s, this.state.pos), r += this.jsxReadEntity(), s = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            ho(i) ? (r += this.input.slice(s, this.state.pos), r += this.jsxReadNewLine(!0), s = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let s = this.input.charCodeAt(this.state.pos), i;
      return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = r ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
    }
    jsxReadString(r) {
      let s = "", i = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(M.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : ho(a) ? (s += this.input.slice(
        i, this.state.pos), s += this.jsxReadNewLine(!1), i = this.state.pos) : ++this.state.pos;
      }
      s += this.input.slice(i, this.state.pos++), this.finishToken(133, s);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let s = 10;
        this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
        let i = this.readInt(s, void 0, !1, "bail");
        if (i !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(i);
      } else {
        let s = 0, i = !1;
        for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (i) {
          let a = this.input.slice(r, this.state.pos), o = jue[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, s = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (Bn(r) || r === 45);
      this.finishToken(140, this.input.slice(s, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(140) ? r.name = this.state.value : cy(this.state.type) ? r.name = ui(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, s = this.jsxParseIdentifier();
      if (!this.eat(14)) return s;
      let i = this.startNodeAt(r);
      return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, s = this.jsxParseNamespacedName();
      if (s.type === "JSXNamespacedName")
        return s;
      for (; this.eat(16); ) {
        let i = this.startNodeAt(r);
        i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
      }
      return s;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(gt.brace), this.next(), r = this.jsxParseExpressionContainer(r, gt.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(Ji.AttributeIsEmpty, r), r;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(Ji.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(gt.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, s) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let i = this.parseExpression();
        r.expression = i;
      }
      return this.setContext(s), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(gt.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      gt.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      s));
    }
    jsxParseOpeningElementAfterName(r) {
      let s = [];
      for (; !this.match(56) && !this.match(143); )
        s.push(this.jsxParseAttribute());
      return r.attributes = s, r.selfClosing = this.eat(56), this.expect(143), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(143), this.finishNode(
      s, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let s = this.startNodeAt(r), i = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 142:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              i.push(this.jsxParseElementAt(r));
              break;
            case 141:
              i.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(gt.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(l)) : i.push(this.jsxParseExpressionContainer(
              l, gt.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        li(a) && !li(o) && o !== null ? this.raise(Ji.MissingClosingTagFragment, o) : !li(a) && li(o) ? this.raise(Ji.MissingClosingTagElement,
        o, {
          openingTagName: Mn(a.name)
        }) : !li(a) && !li(o) && Mn(o.name) !== Mn(a.name) && this.raise(Ji.MissingClosingTagElement, o, {
          openingTagName: Mn(a.name)
        });
      }
      if (li(a) ? (s.openingFragment = a, s.closingFragment = o) : (s.openingElement = a, s.closingElement = o), s.children = i, this.match(
      47))
        throw this.raise(Ji.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return li(a) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: s
      } = this.state;
      s[s.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(
      142), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let s = this.curContext();
      if (s === gt.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (s === gt.j_oTag || s === gt.j_cTag) {
        if (Os(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((r === 34 || r === 39) && s === gt.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: s,
        type: i
      } = this.state;
      if (i === 56 && r === 142)
        s.splice(-2, 2, gt.j_cTag), this.state.canStartJSXElement = !1;
      else if (i === 142)
        s.push(gt.j_oTag);
      else if (i === 143) {
        let a = s[s.length - 1];
        a === gt.j_oTag && r === 56 || a === gt.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === gt.j_expr) : (this.setContext(
        gt.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = rue(i);
    }
  }, "jsx"), Zm = class extends mo {
    static {
      n(this, "TypeScriptScope");
    }
    constructor(...e) {
      super(...e), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, ey = class extends yo {
    static {
      n(this, "TypeScriptScopeHandler");
    }
    constructor(...e) {
      super(...e), this.importsStack = [];
    }
    createScope(e) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new Zm(e);
    }
    enter(e) {
      e === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e);
    }
    exit() {
      let e = super.exit();
      return e === 256 && this.importsStack.pop(), e;
    }
    hasImport(e, r) {
      let s = this.importsStack.length;
      if (this.importsStack[s - 1].has(e))
        return !0;
      if (!r && s > 1) {
        for (let i = 0; i < s - 1; i++)
          if (this.importsStack[i].has(e)) return !0;
      }
      return !1;
    }
    declareName(e, r, s) {
      if (r & 4096) {
        this.hasImport(e, !0) && this.parser.raise(M.VarRedeclaration, s, {
          identifierName: e
        }), this.importsStack[this.importsStack.length - 1].add(e);
        return;
      }
      let i = this.currentScope(), a = i.tsNames.get(e) || 0;
      if (r & 1024) {
        this.maybeExportDefined(i, e), i.tsNames.set(e, a | 16);
        return;
      }
      super.declareName(e, r, s), r & 2 && (r & 1 || (this.checkRedeclarationInScope(i, e, r, s), this.maybeExportDefined(i, e)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && i.tsNames.set(e, a);
    }
    isRedeclaredInScope(e, r, s) {
      let i = e.tsNames.get(r);
      if ((i & 2) > 0) {
        if (s & 256) {
          let a = !!(s & 512), o = (i & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return s & 128 && (i & 8) > 0 ? e.names.get(r) & 2 ? !!(s & 1) : !1 : s & 2 && (i & 1) > 0 ? !0 : super.isRedeclaredInScope(e, r, s);
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      if (this.hasImport(r)) return;
      let s = this.scopeStack.length;
      for (let i = s - 1; i >= 0; i--) {
        let o = this.scopeStack[i].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(e);
    }
  }, Uue = /* @__PURE__ */ n((t, e) => hasOwnProperty.call(t, e) && t[e], "getOwn$1"), xv = /* @__PURE__ */ n((t) => t.type === "Parenthesiz\
edExpression" ? xv(t.expression) : t, "unwrapParenthesizedExpression"), ty = class extends Qm {
    static {
      n(this, "LValParser");
    }
    toAssignable(e, r = !1) {
      var s, i;
      let a;
      switch ((e.type === "ParenthesizedExpression" || (s = e.extra) != null && s.parenthesized) && (a = xv(e), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(M.InvalidParenthesizedAssignment, e) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(M.InvalidParenthesizedAssignment, e) : this.raise(M.InvalidParenthesizedAssignment, e)), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let l = 0, u = e.properties.length, c = u - 1; l < u; l++) {
            var o;
            let p = e.properties[l], f = l === c;
            this.toAssignableObjectExpressionProp(p, f, r), f && p.type === "RestElement" && (o = e.extra) != null && o.trailingCommaLoc && this.
            raise(M.RestTrailingComma, e.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = e;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (i = e.extra) == null ? void 0 : i.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(M.MissingEqInAssignment, e.left.loc.end), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(
          e.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, r, s) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? M.PatternHasAccessor : M.PatternHasMethod, e.key);
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        let i = e.argument;
        this.checkToRestConversion(i, !1), this.toAssignable(i, s), r || this.raise(M.RestTrailingComma, e);
      } else
        this.toAssignable(e, s);
    }
    toAssignableList(e, r, s) {
      let i = e.length - 1;
      for (let a = 0; a <= i; a++) {
        let o = e[a];
        if (o) {
          if (o.type === "SpreadElement") {
            o.type = "RestElement";
            let l = o.argument;
            this.checkToRestConversion(l, !0), this.toAssignable(l, s);
          } else
            this.toAssignable(o, s);
          o.type === "RestElement" && (a < i ? this.raise(M.RestTrailingComma, o) : r && this.raise(M.RestTrailingComma, r));
        }
      }
    }
    isAssignable(e, r) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let s = e.properties.length - 1;
          return e.properties.every((i, a) => i.type !== "ObjectMethod" && (a === s || i.type !== "SpreadElement") && this.isAssignable(i));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((s) => s === null || this.isAssignable(s));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(e, r) {
      return e;
    }
    toReferencedListDeep(e, r) {
      this.toReferencedList(e, r);
      for (let s of e)
        s?.type === "ArrayExpression" && this.toReferencedListDeep(s.elements);
    }
    parseSpread(e) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(e, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, 1), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, r, s) {
      let i = s & 1, a = [], o = !0;
      for (; !this.eat(e); )
        if (o ? o = !1 : this.expect(12), i && this.match(12))
          a.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            if (a.push(this.parseAssignableListItemTypes(this.parseRestBinding(), s)), !this.checkCommaAfterRest(r)) {
              this.expect(e);
              break;
            }
          } else {
            let l = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(M.UnsupportedParameterDecorator, this.state.startLoc); this.match(
            26); )
              l.push(this.parseDecorator());
            a.push(this.parseAssignableListItem(s, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      let {
        type: e,
        startLoc: r
      } = this.state;
      if (e === 21)
        return this.parseBindingRestProperty(this.startNode());
      let s = this.startNode();
      return e === 138 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), s.key = this.parsePrivateName()) :
      this.parsePropertyName(s), s.method = !1, this.parseObjPropValue(s, r, !1, !1, !0, !1);
    }
    parseAssignableListItem(e, r) {
      let s = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(s, e);
      let i = this.parseMaybeDefault(s.loc.start, s);
      return r.length && (s.decorators = r), i;
    }
    parseAssignableListItemTypes(e, r) {
      return e;
    }
    parseMaybeDefault(e, r) {
      var s, i;
      if ((s = e) != null || (e = this.state.startLoc), r = (i = r) != null ? i : this.parseBindingAtom(), !this.eat(29)) return r;
      let a = this.startNodeAt(e);
      return a.left = r, a.right = this.parseMaybeAssignAllowIn(), this.finishNode(a, "AssignmentPattern");
    }
    isValidLVal(e, r, s) {
      return Uue({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, e);
    }
    isOptionalMemberExpression(e) {
      return e.type === "OptionalMemberExpression";
    }
    checkLVal(e, {
      in: r,
      binding: s = 64,
      checkClashes: i = !1,
      strictModeChanged: a = !1,
      hasParenthesizedAncestor: o = !1
    }) {
      var l;
      let u = e.type;
      if (this.isObjectMethod(e)) return;
      let c = this.isOptionalMemberExpression(e);
      if (c || u === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", e.loc.start), r.type !== "AssignmentExpression" && this.raise(M.InvalidLhsOptionalChaining,
        e, {
          ancestor: r
        })), s !== 64 && this.raise(M.InvalidPropertyBindingPattern, e);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(e, s, a);
        let {
          name: T
        } = e;
        i && (i.has(T) ? this.raise(M.ParamDupe, e) : i.add(T));
        return;
      }
      let p = this.isValidLVal(u, !(o || (l = e.extra) != null && l.parenthesized) && r.type === "AssignmentExpression", s);
      if (p === !0) return;
      if (p === !1) {
        let T = s === 64 ? M.InvalidLhs : M.InvalidLhsBinding;
        this.raise(T, e, {
          ancestor: r
        });
        return;
      }
      let [f, m] = Array.isArray(p) ? p : [p, u === "ParenthesizedExpression"], y = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : r;
      for (let T of [].concat(e[f]))
        T && this.checkLVal(T, {
          in: y,
          binding: s,
          checkClashes: i,
          strictModeChanged: a,
          hasParenthesizedAncestor: m
        });
    }
    checkIdentifier(e, r, s = !1) {
      this.state.strict && (s ? hv(e.name, this.inModule) : fv(e.name)) && (r === 64 ? this.raise(M.StrictEvalArguments, e, {
        referenceName: e.name
      }) : this.raise(M.StrictEvalArgumentsBinding, e, {
        bindingName: e.name
      })), r & 8192 && e.name === "let" && this.raise(M.LetInLexicalBinding, e), r & 64 || this.declareNameFromIdentifier(e, r);
    }
    declareNameFromIdentifier(e, r) {
      this.scope.declareName(e.name, r, e.loc.start);
    }
    checkToRestConversion(e, r) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(M.InvalidRestAssignmentPattern, e);
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? M.RestTrailingComma : M.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  }, que = /* @__PURE__ */ n((t, e) => hasOwnProperty.call(t, e) && t[e], "getOwn");
  function Vue(t) {
    if (t == null)
      throw new Error(`Unexpected ${t} value.`);
    return t;
  }
  n(Vue, "nonNull");
  function ev(t) {
    if (!t)
      throw new Error("Assert fail");
  }
  n(ev, "assert");
  var ye = ks`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ n(({
      methodName: t
    }) => `Method '${t}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ n(({
      propertyName: t
    }) => `Property '${t}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or nu\
meric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ n(({
      kind: t
    }) => `'declare' is not allowed in ${t}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => `Duplicate modifier: '${t}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ n(({
      token: t
    }) => `'${t}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ n(({
      modifiers: t
    }) => `'${t[0]}' modifier cannot be used with '${t[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Index signatures cannot have an accessibility modifier ('${t}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ n(({
      orderedModifiers: t
    }) => `'${t[0]}' modifier must precede '${t[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Private elements cannot have an accessibility modifier ('${t}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ n(({
      typeParameterName: t
    }) => `Single type parameter ${t} should have a trailing comma. Example usage: <${t},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ n(({
      type: t
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t}.`, "UnsupportedSignatureParameterKind")
  });
  function Kue(t) {
    switch (t) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  n(Kue, "keywordTypeFromName");
  function tv(t) {
    return t === "private" || t === "public" || t === "protected";
  }
  n(tv, "tsIsAccessModifier");
  function Wue(t) {
    return t === "in" || t === "out";
  }
  n(Wue, "tsIsVarianceAnnotations");
  var Yue = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ye.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: ye.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ye.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return ey;
    }
    tsIsIdentifier() {
      return ht(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.
      hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(r, s) {
      if (!ht(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let i = this.state.value;
      if (r.indexOf(i) !== -1) {
        if (s && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return i;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: s,
      stopOnStartOfClassStaticBlock: i,
      errorTemplate: a = ye.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ n((c, p, f, m) => {
        p === f && o[m] && this.raise(ye.InvalidModifiersOrder, c, {
          orderedModifiers: [f, m]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ n((c, p, f, m) => {
        (o[f] && p === m || o[m] && p === f) && this.raise(ye.IncompatibleModifiers, c, {
          modifiers: [f, m]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, p = this.tsParseModifier(r.concat(s ?? []), i);
        if (!p) break;
        tv(p) ? o.accessibility ? this.raise(ye.DuplicateAccessibilityModifier, c, {
          modifier: p
        }) : (l(c, p, p, "override"), l(c, p, p, "static"), l(c, p, p, "readonly"), o.accessibility = p) : Wue(p) ? (o[p] && this.raise(ye.DuplicateModifier,
        c, {
          modifier: p
        }), o[p] = !0, l(c, p, "in", "out")) : (hasOwnProperty.call(o, p) ? this.raise(ye.DuplicateModifier, c, {
          modifier: p
        }) : (l(c, p, "static", "readonly"), l(c, p, "static", "override"), l(c, p, "override", "readonly"), l(c, p, "abstract", "override"),
        u(c, p, "declare", "override"), u(c, p, "static", "abstract")), o[p] = !0), s != null && s.includes(p) && this.raise(a, c, {
          modifier: p
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, s) {
      let i = [];
      for (; !this.tsIsListTerminator(r); )
        i.push(s());
      return i;
    }
    tsParseDelimitedList(r, s, i) {
      return Vue(this.tsParseDelimitedListWorker(r, s, !0, i));
    }
    tsParseDelimitedListWorker(r, s, i, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(r); ) {
        l = -1;
        let u = s();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        i && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(r, s, i, a, o) {
      a || (i ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(r, s, o);
      return i ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(ye.UnsupportedImportTypeArgument, this.state.startLoc), r.argument =
      super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r.options = null), this.eat(12) &&
      (this.expectImportAttributesPlugin(), this.match(11) || (r.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11),
      this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(
      r, "TSImportType");
    }
    tsParseEntityName(r = !0) {
      let s = this.parseIdentifier(r);
      for (; this.eat(16); ) {
        let i = this.startNodeAtNode(s);
        i.left = s, i.right = this.parseIdentifier(r), s = this.finishNode(i, "TSQualifiedName");
      }
      return s;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let s = this.startNodeAtNode(r);
      return s.parameterName = r, s.typeAnnotation = this.tsParseTypeAnnotation(!1), s.asserts = !1, this.finishNode(s, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let s = this.startNode();
      return r(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(
      29), this.finishNode(s, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let s = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = {
        value: -1
      };
      return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, i), s.params.
      length === 0 && this.raise(ye.EmptyTypeParameters, s), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, s) {
      let i = r === 19, a = "parameters", o = "typeAnnotation";
      s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[a] = this.tsParseBindingListForSignature(),
      i ? s[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (s[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let s of r) {
        let {
          type: i
        } = s;
        (i === "AssignmentPattern" || i === "TSParameterProperty") && this.raise(ye.UnsupportedSignatureParameterKind, s, {
          type: i
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, s) {
      return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), ht(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let s = this.parseIdentifier();
      s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), r.parameters = [s];
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, s) {
      this.eat(17) && (r.optional = !0);
      let i = r;
      if (this.match(10) || this.match(47)) {
        s && this.raise(ye.ReadonlyForMethodSignature, r);
        let a = i;
        a.kind && this.match(47) && this.raise(ye.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(M.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(ye.AccesorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(M.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(ye.AccesorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(ye.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            ye.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          a[l] && this.raise(ye.SetAccesorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = i;
        s && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let i = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let s = this.tsTryParseIndexSignature(r);
      return s || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let r = this.startNode();
      return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), this.finishNode(r, "TSTypeParameter");
    }
    tsParseMappedType() {
      let r = this.startNode();
      return this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(
      122) && (r.readonly = !0), this.expect(0), r.typeParameter = this.tsParseMappedTypeParameter(), r.nameType = this.eatContextual(93) ? this.
      tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) &&
      (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let s = !1;
      return r.elementTypes.forEach((i) => {
        let {
          type: a
        } = i;
        s && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && i.optional) && this.raise(ye.OptionalTypeBeforeRequired,
        i), s || (s = a === "TSNamedTupleMember" && i.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let {
        startLoc: r
      } = this.state, s = this.eat(21), i, a, o, l, c = zr(this.state.type) ? this.lookaheadCharCode() : null;
      if (c === 58)
        i = !0, o = !1, a = this.parseIdentifier(!0), this.expect(14), l = this.tsParseType();
      else if (c === 63) {
        o = !0;
        let p = this.state.startLoc, f = this.state.value, m = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (i = !0, a = this.createIdentifier(this.startNodeAt(p), f), this.expect(17), this.expect(14), l = this.
        tsParseType()) : (i = !1, l = m, this.expect(17));
      } else
        l = this.tsParseType(), o = this.eat(17), i = this.eat(14);
      if (i) {
        let p;
        a ? (p = this.startNodeAtNode(a), p.optional = o, p.label = a, p.elementType = l, this.eat(17) && (p.optional = !0, this.raise(ye.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (p = this.startNodeAtNode(l), p.optional = o, this.raise(ye.InvalidTupleMemberLabel, l), p.label = l,
        p.elementType = this.tsParseType()), l = this.finishNode(p, "TSNamedTupleMember");
      } else if (o) {
        let p = this.startNodeAtNode(l);
        p.typeAnnotation = l, l = this.finishNode(p, "TSOptionalType");
      }
      if (s) {
        let p = this.startNodeAt(r);
        p.typeAnnotation = l, l = this.finishNode(p, "TSRestType");
      }
      return l;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, s) {
      let i = this.startNode();
      return r === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, i)), this.finishNode(i, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let r = this.startNode();
      return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), s = this.lookahead();
            return s.type !== 134 && s.type !== 135 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (ht(r) || r === 88 || r === 84) {
            let s = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : Kue(this.state.value);
            if (s !== void 0 && this.lookaheadCharCode() !== 46) {
              let i = this.startNode();
              return this.next(), this.finishNode(i, s);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let r = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let s = this.startNodeAtNode(r);
          s.elementType = r, this.expect(3), r = this.finishNode(s, "TSArrayType");
        } else {
          let s = this.startNodeAtNode(r);
          s.objectType = r, s.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(s, "TSIndexedAccessType");
        }
      return r;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), s = this.state.value;
      return this.next(), r.operator = s, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(ye.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let s = this.startNode();
      return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(s, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return lue(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, s, i) {
      let a = this.startNode(), o = this.eat(i), l = [];
      do
        l.push(s());
      while (this.eat(i));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (ht(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === s;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === s;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let s = this.startNode();
        this.expect(r);
        let i = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (i.parameterName = u, i.asserts = !0, i.typeAnnotation = null, u = this.finishNode(i, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, i), u.asserts = !0), s.typeAnnotation = u, this.finishNode(s, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (i.parameterName = this.parseIdentifier(), i.asserts = a, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i,
          "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, s);
        let l = this.tsParseTypeAnnotation(!1);
        return i.parameterName = o, i.typeAnnotation = l, i.asserts = a, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(
        s, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !ht(this.state.type) && !this.match(78) ? !1 : (r && this.raise(M.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, s = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), s.typeAnnotation = this.tsParseType();
      }), this.finishNode(s, "TSTypeAnnotation");
    }
    tsParseType() {
      ev(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let s = this.startNodeAtNode(r);
      return s.checkType = r, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(s, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ye.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let a = this.startNode();
        return a.expression = this.tsParseEntityName(), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
        a, "TSExpressionWithTypeArguments");
      });
      return i.length || this.raise(ye.EmptyHeritageClauseType, s, {
        token: r
      }), i;
    }
    tsParseInterfaceDeclaration(r, s = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), s.declare && (r.declare = !0), ht(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(ye.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let i = this.startNode();
      return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let s = this.startNode();
          return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInNoContext(r) {
      let s = this.state.context;
      this.state.context = [s[0]];
      try {
        return r();
      } finally {
        this.state.context = s;
      }
    }
    tsInType(r) {
      let s = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = s;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, s = {}) {
      return s.const && (r.const = !0), s.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, s = !1) {
      if (r.id = this.parseIdentifier(), s || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let i = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(i, !0), r.body = i;
      } else
        this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.global = !0, r.id = this.parseIdentifier()) : this.match(133) ? r.id = super.parseStringLiteral(this.
      state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(),
      this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(r, s, i) {
      r.isExport = i || !1, r.id = s || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(ye.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let s = this.state.clone(), i = r();
      return this.state = s, i;
    }
    tsTryParseAndCatch(r) {
      let s = this.tryParse((i) => r() || i());
      if (!(s.aborted || !s.node))
        return s.error && (this.state = s.failState), s.node;
    }
    tsTryParse(r) {
      let s = this.state.clone(), i = r();
      if (i !== void 0 && i !== !1)
        return i;
      this.state = s;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let s = this.state.type, i;
      return this.isContextual(100) && (s = 74, i = "let"), this.tsInAmbientContext(() => {
        switch (s) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, i || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (ht(s))
              return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, s, i) {
      switch (s.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(r);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = r;
            return a.global = !0, a.id = s, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a,
            "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, s.name, !1, i);
      }
    }
    tsParseDeclaration(r, s, i, a) {
      switch (s) {
        case "abstract":
          if (this.tsCheckLineTerminator(i) && (this.match(80) || ht(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(i)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (ht(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(i) && ht(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(i) && ht(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let s = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let i = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = s, !!i)
        return super.parseArrowExpression(i, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments",
      this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(ye.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      gt.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return uue(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(r, s) {
      let i = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(r & 4) && (o || u || l) && this.raise(ye.UnexpectedParameterModifier, i);
      let c = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(c, r);
      let p = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let f = this.startNodeAt(i);
        return s.length && (f.decorators = s), o && (f.accessibility = o), u && (f.readonly = u), l && (f.override = l), p.type !== "Identif\
ier" && p.type !== "AssignmentPattern" && this.raise(ye.UnsupportedParameterPropertyKind, f), f.parameter = p, this.finishNode(f, "TSParamet\
erProperty");
      }
      return s.length && (c.decorators = s), p;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let s of r.params)
        s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(ye.PatternIsOptional, s);
    }
    setArrowFunctionParameters(r, s, i) {
      super.setArrowFunctionParameters(r, s, i), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, s, i = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(ye.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, i) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, s, i));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((s) => {
        s?.type === "TSTypeCastExpression" && this.raise(ye.UnexpectedTypeAnnotation, s.typeAnnotation);
      });
    }
    toReferencedList(r, s) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, s, i, a) {
      let o = super.parseArrayLike(r, s, i, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(r, s, i, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(s);
        return l.expression = r, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (i)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!i && this.atPossibleAsyncArrow(r)) {
            let m = this.tsTryParseGenericAsyncArrowFunction(s);
            if (m)
              return m;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if ($u(this.state.type)) {
            let m = super.parseTaggedTemplateExpression(r, s, a);
            return m.typeParameters = c, m;
          }
          if (!i && this.eat(10)) {
            let m = this.startNodeAt(s);
            return m.callee = r, m.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(m.arguments), m.typeParameters =
            c, a.optionalChainMember && (m.optional = o), this.finishCallExpression(m, a.optionalChainMember);
          }
          let p = this.state.type;
          if (p === 48 || p === 52 || p !== 10 && jm(p) && !this.hasPrecedingLineBreak())
            return;
          let f = this.startNodeAt(s);
          return f.expression = r, f.typeParameters = c, this.finishNode(f, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          ye.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(r, s, i, a);
    }
    parseNewCallee(r) {
      var s;
      super.parseNewCallee(r);
      let {
        callee: i
      } = r;
      i.type === "TSInstantiationExpression" && !((s = i.extra) != null && s.parenthesized) && (r.typeParameters = i.typeParameters, r.callee =
      i.expression);
    }
    parseExprOp(r, s, i) {
      let a;
      if (Wu(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(s);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(M.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, s, i);
      }
      return super.parseExprOp(r, s, i);
    }
    checkReservedWord(r, s, i, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, s, i, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(ye.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let s = this.lookaheadCharCode();
        return r ? s === 123 || s === 42 : s !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, i, a) {
      super.applyImportPhase(r, s, i, a), s ? r.exportKind = i === "type" ? "type" : "value" : r.importKind = i === "type" || i === "typeof" ?
      i : "value";
    }
    parseImport(r) {
      if (this.match(133))
        return r.importKind = "value", super.parseImport(r);
      let s;
      if (ht(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let i = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, i);
        s = super.parseImportSpecifiersAndAfter(r, i);
      } else
        s = super.parseImport(r);
      return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ye.TypeImportCannotSpecifyDefaultAndNamed,
      s), s;
    }
    parseExport(r, s) {
      if (this.match(83)) {
        this.next();
        let i = r, a = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(i, !1) : i.importKind = "value", this.
        tsParseImportEqualsDeclaration(i, a, !0);
      } else if (this.eat(29)) {
        let i = r;
        return i.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(i, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let i = r;
        return this.expectContextual(128), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, s);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, s, i = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, s, i || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (s !== "const" || l.typeAnnotation ? this.raise(ye.InitializerNotAllowedInAmbientContext, u) : Xue(u, this.hasPlugin("estree")) ||
        this.raise(ye.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(r, s) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let i = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(i, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let i = this.tsParseInterfaceDeclaration(this.startNode());
        if (i) return i;
      }
      return super.parseStatementContent(r, s);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, s) {
      return s.some((i) => tv(i) ? r.accessibility === i : !!r[i]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, s, i) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: ye.InvalidModifierOnTypeParameterPositions
      }, s);
      let o = /* @__PURE__ */ n(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, a) && this.raise(ye.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, s)) : this.parseClassMemberWithIsStatic(r, s, i, !!s.static);
      }, "callParseClassMemberWithIsStatic");
      s.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, s, i, a) {
      let o = this.tsTryParseIndexSignature(s);
      if (o) {
        r.body.push(o), s.abstract && this.raise(ye.IndexSignatureHasAbstract, s), s.accessibility && this.raise(ye.IndexSignatureHasAccessibility,
        s, {
          modifier: s.accessibility
        }), s.declare && this.raise(ye.IndexSignatureHasDeclare, s), s.override && this.raise(ye.IndexSignatureHasOverride, s);
        return;
      }
      !this.state.inAbstractClass && s.abstract && this.raise(ye.NonAbstractClassHasAbstractMethod, s), s.override && (i.hadSuperClass || this.
      raise(ye.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(r, s, i, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(ye.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(ye.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, s, i) {
      return (s.type === "Identifier" ? this.tsParseExpressionStatement(r, s, i) : void 0) || super.parseExpressionStatement(r, s, i);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, s, i) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(r, s, i);
      let a = this.tryParse(() => super.parseConditional(r, s));
      return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(i, a.error), r);
    }
    parseParenItem(r, s) {
      let i = super.parseParenItem(r, s);
      if (this.eat(17) && (i.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(s);
        return a.expression = r, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let s = this.state.startLoc, i = this.eatContextual(125);
      if (i && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(ye.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = ht(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || i) && (r.exportKind = "type"), i && (this.resetStartLocation(
      o, s), o.declare = !0), o) : null;
    }
    parseClassId(r, s, i, a) {
      if ((!s || i) && this.isContextual(113))
        return;
      super.parseClassId(r, s, i, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let s = this.tsTryParseTypeAnnotation();
      s && (r.typeAnnotation = s);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(ye.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: s
        } = r;
        this.raise(ye.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: s.type === "Identifier" && !r.computed ? s.name : `[${this.input.slice(s.start, s.end)}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(ye.PrivateElementHasAbstract, r), r.accessibility && this.raise(ye.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(ye.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, s, i, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(ye.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: p
      } = s;
      c && (p === "get" || p === "set") && this.raise(ye.DeclareAccessor, s, {
        kind: p
      }), u && (s.typeParameters = u), super.pushClassMethod(r, s, i, a, o, l);
    }
    pushClassPrivateMethod(r, s, i, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (s.typeParameters = o), super.pushClassPrivateMethod(r, s, i, a);
    }
    declareClassPrivateMethodInScope(r, s) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !hasOwnProperty.call(r.value, "body") || super.declareClassPrivateMethodInScope(
      r, s));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, s, i, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (r.typeParameters = c), super.parseObjPropValue(r, s, i, a, o, l, u);
    }
    parseFunctionParams(r, s) {
      let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      i && (r.typeParameters = i), super.parseFunctionParams(r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let i = this.tsTryParseTypeAnnotation();
      i && (r.id.typeAnnotation = i, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, s);
    }
    parseMaybeAssign(r, s) {
      var i, a, o, l, u;
      let c, p, f;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (c = this.state.clone(), p = this.tryParse(() => super.parseMaybeAssign(r, s), c), !p.error) return p.node;
        let {
          context: T
        } = this.state, L = T[T.length - 1];
        (L === gt.j_oTag || L === gt.j_expr) && T.pop();
      }
      if (!((i = p) != null && i.error) && !this.match(47))
        return super.parseMaybeAssign(r, s);
      (!c || c === this.state) && (c = this.state.clone());
      let m, y = this.tryParse((T) => {
        var L, q;
        m = this.tsParseTypeParameters(this.tsParseConstModifier);
        let _ = super.parseMaybeAssign(r, s);
        return (_.type !== "ArrowFunctionExpression" || (L = _.extra) != null && L.parenthesized) && T(), ((q = m) == null ? void 0 : q.params.
        length) !== 0 && this.resetStartLocationFromNode(_, m), _.typeParameters = m, _;
      }, c);
      if (!y.error && !y.aborted)
        return m && this.reportReservedArrowTypeParam(m), y.node;
      if (!p && (ev(!this.hasPlugin("jsx")), f = this.tryParse(() => super.parseMaybeAssign(r, s), c), !f.error))
        return f.node;
      if ((a = p) != null && a.node)
        return this.state = p.failState, p.node;
      if (y.node)
        return this.state = y.failState, m && this.reportReservedArrowTypeParam(m), y.node;
      if ((o = f) != null && o.node)
        return this.state = f.failState, f.node;
      throw ((l = p) == null ? void 0 : l.error) || y.error || ((u = f) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(r) {
      var s;
      r.params.length === 1 && !r.params[0].constraint && !((s = r.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(ye.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, s) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse((i) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && i(), a;
        });
        if (s.aborted) return;
        s.thrown || (s.error && (this.state = s.failState), r.returnType = s.node);
      }
      return super.parseArrow(r);
    }
    parseAssignableListItemTypes(r, s) {
      if (!(s & 2)) return r;
      this.eat(17) && (r.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.resetEndLocation(r), r;
    }
    isAssignable(r, s) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, s);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, s);
      }
    }
    toAssignable(r, s = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, s);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          s ? this.expressionScope.recordArrowParameterBindingError(ye.UnexpectedTypeCastInParameter, r) : this.raise(ye.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, s);
          break;
        case "AssignmentExpression":
          !s && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, s);
      }
    }
    toAssignableParenthesizedExpression(r, s) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, s);
          break;
        default:
          super.toAssignable(r, s);
      }
    }
    checkToRestConversion(r, s) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, s);
      }
    }
    isValidLVal(r, s, i) {
      return que({
        TSTypeCastExpression: !0,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSInstantiationExpression: "expression",
        TSAsExpression: (i !== 64 || !s) && ["expression", !0],
        TSSatisfiesExpression: (i !== 64 || !s) && ["expression", !0],
        TSTypeAssertion: (i !== 64 || !s) && ["expression", !0]
      }, r) || super.isValidLVal(r, s, i);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let i = super.parseMaybeDecoratorArguments(r);
          return i.typeParameters = s, i;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, s) {
      let i = super.parseMaybeDefault(r, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(ye.TypeAnnotationAfterAssign,
      i.typeAnnotation), i;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableList(r, s, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TSTypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, i);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((s) => this.isAssignable(s, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        s && (r.typeParameters = s);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let s = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? s + 1 : s;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
      return s && (r.typeAnnotation = s, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let s = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = s;
      }
    }
    parseClass(r, s, i) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, s, i);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, s) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(s, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return r.abstract = !0, this.raise(ye.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(r, s, i, a, o, l, u) {
      let c = super.parseMethod(r, s, i, a, o, l, u);
      if (c.abstract && (this.hasPlugin("estree") ? !!c.value.body : !!c.body)) {
        let {
          key: f
        } = c;
        this.raise(ye.AbstractMethodHasImplementation, c, {
          methodName: f.type === "Identifier" && !c.computed ? f.name : `[${this.input.slice(f.start, f.end)}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, s, i, a) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, i), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, s, i, a));
    }
    parseImportSpecifier(r, s, i, a, o) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, i), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, s, i, a, i ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, s, i) {
      let a = s ? "imported" : "local", o = s ? "local" : "exported", l = r[a], u, c = !1, p = !0, f = l.loc.start;
      if (this.isContextual(93)) {
        let y = this.parseIdentifier();
        if (this.isContextual(93)) {
          let T = this.parseIdentifier();
          zr(this.state.type) ? (c = !0, l = y, u = s ? this.parseIdentifier() : this.parseModuleExportName(), p = !1) : (u = T, p = !1);
        } else zr(this.state.type) ? (p = !1, u = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = y);
      } else zr(this.state.type) && (c = !0, s ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && i && this.raise(s ? ye.TypeModifierIsUsedInTypeImports : ye.TypeModifierIsUsedInTypeExports, f), r[a] = l, r[o] = u;
      let m = s ? "importKind" : "exportKind";
      r[m] = c ? "type" : "value", p && this.eatContextual(93) && (r[o] = s ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = Ds(r[a])), s && this.checkIdentifier(r[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function Jue(t) {
    if (t.type !== "MemberExpression") return !1;
    let {
      computed: e,
      property: r
    } = t;
    return e && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : gv(t.object);
  }
  n(Jue, "isPossiblyLiteralEnum");
  function Xue(t, e) {
    var r;
    let {
      type: s
    } = t;
    if ((r = t.extra) != null && r.parenthesized)
      return !1;
    if (e) {
      if (s === "Literal") {
        let {
          value: i
        } = t;
        if (typeof i == "string" || typeof i == "boolean")
          return !0;
      }
    } else if (s === "StringLiteral" || s === "BooleanLiteral")
      return !0;
    return !!(Sv(t, e) || $ue(t, e) || s === "TemplateLiteral" && t.expressions.length === 0 || Jue(t));
  }
  n(Xue, "isValidAmbientConstInitializer");
  function Sv(t, e) {
    return e ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLite\
ral";
  }
  n(Sv, "isNumber");
  function $ue(t, e) {
    if (t.type === "UnaryExpression") {
      let {
        operator: r,
        argument: s
      } = t;
      if (r === "-" && Sv(s, e))
        return !0;
    }
    return !1;
  }
  n($ue, "isNegativeNumber");
  function gv(t) {
    return t.type === "Identifier" ? !0 : t.type !== "MemberExpression" || t.computed ? !1 : gv(t.object);
  }
  n(gv, "isUncomputedMemberExpressionChain");
  var rv = ks`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), Hue = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(144)) {
        let s = this.startNode();
        return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(
        s, r);
      }
    }
    finishPlaceholder(r, s) {
      let i = r;
      return (!i.expectedNode || !i.type) && (i = this.finishNode(i, "Placeholder")), i.expectedNode = s, i;
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, s, i, a) {
      r !== void 0 && super.checkReservedWord(r, s, i, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, s, i) {
      return r === "Placeholder" || super.isValidLVal(r, s, i);
    }
    toAssignable(r, s) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, s);
    }
    chStartsBindingIdentifier(r, s) {
      return !!(super.chStartsBindingIdentifier(r, s) || this.lookahead().type === 144);
    }
    verifyBreakContinue(r, s) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, s);
    }
    parseExpressionStatement(r, s) {
      var i;
      if (s.type !== "Placeholder" || (i = s.extra) != null && i.parenthesized)
        return super.parseExpressionStatement(r, s);
      if (this.match(14)) {
        let o = r;
        return o.label = this.finishPlaceholder(s, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(o, "LabeledStatement");
      }
      this.semicolon();
      let a = r;
      return a.name = s.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(r, s, i) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, s, i);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, s, i) {
      let a = s ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(144) || this.match(5))
          r.id = l;
        else {
          if (i || !s)
            return r.id = null, r.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(r, a);
          throw this.raise(rv.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, s, i);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, s) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseExport(r, s);
      let a = r;
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(a, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let o = this.startNode();
      return o.exported = i, a.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(a, s);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(ui(144), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, s) {
      var i;
      return (i = r.specifiers) != null && i.length ? !0 : super.maybeParseExportDefaultSpecifier(r, s);
    }
    checkExport(r) {
      let {
        specifiers: s
      } = r;
      s != null && s.length && (r.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = s;
    }
    parseImport(r) {
      let s = this.parsePlaceholder("Identifier");
      if (!s) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let i = this.startNodeAtNode(s);
      return i.local = s, r.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(rv.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), zue = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, s = this.startNode();
        if (this.next(), ht(this.state.type)) {
          let i = this.parseIdentifierName(), a = this.createIdentifier(s, i);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic");
  function Kt(t, e) {
    let [r, s] = typeof e == "string" ? [e, {}] : e, i = Object.keys(s), a = i.length === 0;
    return t.some((o) => {
      if (typeof o == "string")
        return a && o === r;
      {
        let [l, u] = o;
        if (l !== r)
          return !1;
        for (let c of i)
          if (u[c] !== s[c])
            return !1;
        return !0;
      }
    });
  }
  n(Kt, "hasPlugin");
  function Xi(t, e, r) {
    let s = t.find((i) => Array.isArray(i) ? i[0] === e : i === e);
    return s && Array.isArray(s) && s.length > 1 ? s[1][r] : null;
  }
  n(Xi, "getPluginOption");
  var sv = ["minimal", "fsharp", "hack", "smart"], iv = ["^^", "@@", "^", "%", "#"];
  function Gue(t) {
    if (Kt(t, "decorators")) {
      if (Kt(t, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let e = Xi(t, "decorators", "decoratorsBeforeExport");
      if (e != null && typeof e != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let r = Xi(t, "decorators", "allowCallParenthesized");
      if (r != null && typeof r != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (Kt(t, "flow") && Kt(t, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Kt(t, "placeholders") && Kt(t, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Kt(t, "pipelineOperator")) {
      let e = Xi(t, "pipelineOperator", "proposal");
      if (!sv.includes(e)) {
        let i = sv.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`);
      }
      let r = ["recordAndTuple", {
        syntaxType: "hash"
      }], s = Kt(t, r);
      if (e === "hack") {
        if (Kt(t, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Kt(t, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let i = Xi(t, "pipelineOperator", "topicToken");
        if (!iv.includes(i)) {
          let a = iv.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}\
.`);
        }
        if (i === "#" && s)
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(r)}\
\`.`);
      } else if (e === "smart" && s)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(r)}\`.`);
    }
    if (Kt(t, "moduleAttributes")) {
      if (Kt(t, "importAssertions") || Kt(t, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (Xi(t, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (Kt(t, "importAssertions") && Kt(t, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (Kt(t, "recordAndTuple")) {
      let e = Xi(t, "recordAndTuple", "syntaxType");
      if (e != null) {
        let r = ["hash", "bar"];
        if (!r.includes(e))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + r.map((s) => `'${s}'`).join(", "));
      }
    }
    if (Kt(t, "asyncDoExpressions") && !Kt(t, "doExpressions")) {
      let e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e.missingPlugins = "doExpressions", e;
    }
    if (Kt(t, "optionalChainingAssign") && Xi(t, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  n(Gue, "validatePlugins");
  var Pv = {
    estree: Qle,
    jsx: Rue,
    flow: Fue,
    typescript: Yue,
    v8intrinsic: zue,
    placeholders: Hue
  }, Que = Object.keys(Pv), Mm = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowNewTargetOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createImportExpressions: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1,
    attachComment: !0,
    annexB: !0
  };
  function Zue(t) {
    if (t == null)
      return Object.assign({}, Mm);
    if (t.annexB != null && t.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let e = {};
    for (let s of Object.keys(Mm)) {
      var r;
      e[s] = (r = t[s]) != null ? r : Mm[s];
    }
    return e;
  }
  n(Zue, "getOptions");
  var ry = class extends ty {
    static {
      n(this, "ExpressionParser");
    }
    checkProto(e, r, s, i) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return;
      let a = e.key;
      if ((a.type === "Identifier" ? a.name : a.value) === "__proto__") {
        if (r) {
          this.raise(M.RecordNoProto, a);
          return;
        }
        s.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = a.loc.start) : this.raise(M.DuplicateProto, a)), s.used = !0;
      }
    }
    shouldExitDescending(e, r) {
      return e.type === "ArrowFunctionExpression" && e.start === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let e = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.comments, e.errors = this.state.errors,
      this.options.tokens && (e.tokens = this.tokens), e;
    }
    parseExpression(e, r) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(e) {
      let r = this.state.startLoc, s = this.parseMaybeAssign(e);
      if (this.match(12)) {
        let i = this.startNodeAt(r);
        for (i.expressions = [s]; this.eat(12); )
          i.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
      }
      return s;
    }
    parseMaybeAssignDisallowIn(e, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, r));
    }
    parseMaybeAssignAllowIn(e, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, r));
    }
    setOptionalParametersError(e, r) {
      var s;
      e.optionalParametersLoc = (s = r?.loc) != null ? s : this.state.startLoc;
    }
    parseMaybeAssign(e, r) {
      let s = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let l = this.parseYield();
        return r && (l = r.call(this, l, s)), l;
      }
      let i;
      e ? i = !1 : (e = new Fn(), i = !0);
      let {
        type: a
      } = this.state;
      (a === 10 || ht(a)) && (this.state.potentialArrowAt = this.state.start);
      let o = this.parseMaybeConditional(e);
      if (r && (o = r.call(this, o, s)), sue(this.state.type)) {
        let l = this.startNodeAt(s), u = this.state.value;
        if (l.operator = u, this.match(29)) {
          this.toAssignable(o, !0), l.left = o;
          let c = s.index;
          e.doubleProtoLoc != null && e.doubleProtoLoc.index >= c && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.
          index >= c && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= c && (this.checkDestructuringPrivate(
          e), e.privateKeyLoc = null);
        } else
          l.left = o;
        return this.next(), l.right = this.parseMaybeAssign(), this.checkLVal(o, {
          in: this.finishNode(l, "AssignmentExpression")
        }), l;
      } else i && this.checkExpressionErrors(e, !0);
      return o;
    }
    parseMaybeConditional(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprOps(e);
      return this.shouldExitDescending(i, s) ? i : this.parseConditional(i, r, e);
    }
    parseConditional(e, r, s) {
      if (this.eat(17)) {
        let i = this.startNodeAt(r);
        return i.test = e, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(
        i, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(i, s) ? i : this.parseExprOp(i, r, -1);
    }
    parseExprOp(e, r, s) {
      if (this.isPrivateName(e)) {
        let a = this.getPrivateNameSV(e);
        (s >= Wu(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(M.PrivateInExpectedIn, e, {
          identifierName: a
        }), this.classScope.usePrivateName(a, e.loc.start);
      }
      let i = this.state.type;
      if (nue(i) && (this.prodParam.hasIn || !this.match(58))) {
        let a = Wu(i);
        if (a > s) {
          if (i === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, r);
          }
          let o = this.startNodeAt(r);
          o.left = e, o.operator = this.state.value;
          let l = i === 41 || i === 42, u = i === 40;
          if (u && (a = Wu(42)), this.next(), i === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(M.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(i, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
          if (u && (p === 41 || p === 42) || l && p === 40)
            throw this.raise(M.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, r, s);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, r) {
      let s = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(M.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, r), s);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
        default:
          return this.parseExprOpBaseRightExpr(e, r);
      }
    }
    parseExprOpBaseRightExpr(e, r) {
      let s = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, cue(e) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var e;
      let {
        startLoc: r
      } = this.state, s = this.parseMaybeAssign();
      return Jle.has(s.type) && !((e = s.extra) != null && e.parenthesized) && this.raise(M.PipeUnparenthesizedBody, r, {
        type: s.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(M.PipeTopicUnused, r), s;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(M.UnexpectedTokenUnaryExponentiation, e.argument);
    }
    parseMaybeUnary(e, r) {
      let s = this.state.startLoc, i = this.isContextual(96);
      if (i && this.isAwaitAllowed()) {
        this.next();
        let u = this.parseAwait(s);
        return r || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (oue(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(M.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(M.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, e);
      if (i) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? jm(u) : jm(u) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(M.AwaitNotInAsyncContext, s), this.parseAwait(s);
      }
      return l;
    }
    parseUpdate(e, r, s) {
      if (r) {
        let o = e;
        return this.checkLVal(o.argument, {
          in: this.finishNode(o, "UpdateExpression")
        }), e;
      }
      let i = this.state.startLoc, a = this.parseExprSubscripts(s);
      if (this.checkExpressionErrors(s, !1)) return a;
      for (; aue(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(i);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, {
          in: a = this.finishNode(o, "UpdateExpression")
        });
      }
      return a;
    }
    parseExprSubscripts(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprAtom(e);
      return this.shouldExitDescending(i, s) ? i : this.parseSubscripts(i, r);
    }
    parseSubscripts(e, r, s) {
      let i = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: !1
      };
      do
        e = this.parseSubscript(e, r, s, i), i.maybeAsyncArrow = !1;
      while (!i.stop);
      return e;
    }
    parseSubscript(e, r, s, i) {
      let {
        type: a
      } = this.state;
      if (!s && a === 15)
        return this.parseBind(e, r, s, i);
      if ($u(a))
        return this.parseTaggedTemplateExpression(e, r, i);
      let o = !1;
      if (a === 18) {
        if (s && (this.raise(M.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return i.stop = !0, e;
        i.optionalChainMember = o = !0, this.next();
      }
      if (!s && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, r, i, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(e, r, i, l, o) : (i.stop = !0, e);
      }
    }
    parseMember(e, r, s, i, a) {
      let o = this.startNodeAt(r);
      return o.object = e, o.computed = i, i ? (o.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (e.type === "Super" &&
      this.raise(M.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), s.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(e, r, s, i) {
      let a = this.startNodeAt(r);
      return a.object = e, this.next(), a.callee = this.parseNoCallExpr(), i.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, s);
    }
    parseCoverCallAndAsyncArrowHead(e, r, s, i) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(r);
      l.callee = e;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = s;
      u && (this.expressionScope.enter(Nue()), o = new Fn()), c && (l.optional = i), i ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, e.type === "Import", e.type !== "Super", l, o);
      let p = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !i ? (s.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), p)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = a, p;
    }
    toReferencedArguments(e, r) {
      this.toReferencedListDeep(e.arguments, r);
    }
    parseTaggedTemplateExpression(e, r, s) {
      let i = this.startNodeAt(r);
      return i.tag = e, i.quasi = this.parseTemplate(!0), s.optionalChainMember && this.raise(M.OptionalChainingNoTemplate, r), this.finishNode(
      i, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end -
      e.start === 5 && e.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(e, r) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), e.arguments.length === 0 ||
        e.arguments.length > 2)
          this.raise(M.ImportCallArity, e, {
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ?
            2 : 1
          });
        else
          for (let s of e.arguments)
            s.type === "SpreadElement" && this.raise(M.ImportCallSpreadArgument, s);
      return this.finishNode(e, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, r, s, i, a) {
      let o = [], l = !0, u = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          r && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(
          M.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        o.push(this.parseExprListItem(!1, a, s));
      }
      return this.state.inFSharpPipelineDirectBody = u, o;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, r) {
      var s;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(e, r.arguments, !0, (s = r.extra) == null ?
      void 0 : s.trailingCommaLoc), r.innerComments && To(e, r.innerComments), r.callee.trailingComments && To(e, r.callee.trailingComments),
      e;
    }
    parseNoCallExpr() {
      let e = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, !0);
    }
    parseExprAtom(e) {
      let r, s = null, {
        type: i
      } = this.state;
      switch (i) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.options.createImportExpressions ?
          this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(M.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          s = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(M.UnsupportedBind, a);
        }
        case 138:
          return this.raise(M.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          Os(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (ht(i)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (ht(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, r) {
      let s = this.getPluginOption("pipelineOperator", "proposal");
      if (s)
        return this.state.type = e, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = xr(this.state.endLoc, -1),
        this.parseTopicReference(s);
      this.unexpected();
    }
    parseTopicReference(e) {
      let r = this.startNode(), s = this.state.startLoc, i = this.state.type;
      return this.next(), this.finishTopicReference(r, s, e, i);
    }
    finishTopicReference(e, r, s, i) {
      if (this.testTopicReferenceConfiguration(s, r, i)) {
        let a = s === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s === "smart" ? M.PrimaryTopicNotAllowed : M.PipeTopicUnbound, r),
        this.registerTopicReference(), this.finishNode(e, a);
      } else
        throw this.raise(M.PipeTopicUnconfiguredToken, r, {
          token: ui(i)
        });
    }
    testTopicReferenceConfiguration(e, r, s) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: ui(s)
          }]);
        case "smart":
          return s === 27;
        default:
          throw this.raise(M.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(Ju(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(M.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(e, r, !0);
    }
    parseDo(e, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), e.async = r, this.next();
      let s = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(),
      this.state.labels = s, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      let e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(M.SuperNotAllowed,
      e) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(M.UnexpectedSuper, e), !this.match(10) && !this.match(
      0) && !this.match(16) && this.raise(M.UnsupportedSuper, e), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      let e = this.startNode(), r = this.startNodeAt(xr(this.state.startLoc, 1)), s = this.state.value;
      return this.next(), e.id = this.createIdentifier(r, s), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(e, r, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, r, s) {
      e.meta = r;
      let i = this.state.containsEsc;
      return e.property = this.parseIdentifier(!0), (e.property.name !== s || i) && this.raise(M.UnsupportedMetaProperty, e.property, {
        target: r.name,
        onlyValidPropertyName: s
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      let r = this.createIdentifier(this.startNodeAtNode(e), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(M.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let s = this.isContextual(105);
        if (s || this.unexpected(), this.expectPlugin(s ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(M.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), e.phase = s ? "source" : "defer", this.parseImportCall(e);
      }
      return this.parseMetaProperty(e, r, "meta");
    }
    parseLiteralAtNode(e, r, s) {
      return this.addExtra(s, "rawValue", e), this.addExtra(s, "raw", this.input.slice(s.start, this.state.end)), s.value = e, this.next(), this.
      finishNode(s, r);
    }
    parseLiteral(e, r) {
      let s = this.startNode();
      return this.parseLiteralAtNode(e, r, s);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      let r = this.parseLiteral(e.value, "RegExpLiteral");
      return r.pattern = e.pattern, r.flags = e.flags, r;
    }
    parseBooleanLiteral(e) {
      let r = this.startNode();
      return r.value = e, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      let r = this.state.startLoc, s;
      this.next(), this.expressionScope.enter(wue());
      let i = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new Fn(), c = !0, p, f;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          f = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let T = this.state.startLoc;
          if (p = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), T)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let m = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = a;
      let y = this.startNodeAt(r);
      return e && this.shouldParseArrow(l) && (y = this.parseArrow(y)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(y, l, !1), y) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), f && this.unexpected(f), p && this.unexpected(p), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (s = this.startNodeAt(o), s.expressions = l, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s,
      m)) : s = l[0], this.wrapParenthesis(r, s));
    }
    wrapParenthesis(e, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", e.index), this.takeSurroundingComments(r, e.index, this.
        state.lastTokEndLoc.index), r;
      let s = this.startNodeAt(e);
      return s.expression = r, this.finishNode(s, "ParenthesizedExpression");
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, r) {
      return e;
    }
    parseNewOrNewTarget() {
      let e = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        let s = this.parseMetaProperty(e, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(M.UnexpectedNewTarget,
        s), s;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), e.arguments = r;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      let r = this.match(83), s = this.parseNoCallExpr();
      e.callee = s, r && (s.type === "Import" || s.type === "ImportExpression") && this.raise(M.ImportCallNotNewExpression, s);
    }
    parseTemplateElement(e) {
      let {
        start: r,
        startLoc: s,
        end: i,
        value: a
      } = this.state, o = r + 1, l = this.startNodeAt(xr(s, 1));
      a === null && (e || this.raise(M.InvalidEscapeSequenceTemplate, xr(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, p = i + c;
      l.value = {
        raw: this.input.slice(o, p).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let f = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(f, xr(this.state.lastTokEndLoc, c)), f;
    }
    parseTemplate(e) {
      let r = this.startNode(), s = this.parseTemplateElement(e), i = [s], a = [];
      for (; !s.tail; )
        a.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), i.push(s = this.parseTemplateElement(e));
      return r.expressions = a, r.quasis = i, this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, r, s, i) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = /* @__PURE__ */ Object.create(null), l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let p;
        r ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(i), this.checkProto(p, s, o, i)), s && !this.isObjectProperty(
        p) && p.type !== "SpreadElement" && this.raise(M.InvalidRecordProperty, p), p.shorthand && this.addExtra(p, "shorthand", !0), u.properties.
        push(p);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return r ? c = "ObjectPattern" : s && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(M.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let s = this.startNode(), i = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (s.decorators = r, r = []), s.method = !1, e && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(s);
      let u = this.state.containsEsc;
      if (this.parsePropertyName(s, e), !l && !u && this.maybeAsyncOrAccessorProp(s)) {
        let {
          key: c
        } = s, p = c.name;
        p === "async" && !this.hasPrecedingLineBreak() && (i = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        s)), (p === "get" || p === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), s.kind = p, this.match(55) && (l = !0, this.
        raise(M.AccessorIsGenerator, this.state.curPosition(), {
          kind: p
        }), this.next()), this.parsePropertyName(s));
      }
      return this.parseObjPropValue(s, o, l, i, !1, a, e);
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var r;
      let s = this.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e);
      i.length !== s && this.raise(e.kind === "get" ? M.BadGetterArity : M.BadSetterArity, e), e.kind === "set" && ((r = i[i.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(M.BadSetterRestParameter, e);
    }
    parseObjectMethod(e, r, s, i, a) {
      if (a) {
        let o = this.parseMethod(e, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (s || r || this.match(10))
        return i && this.unexpected(), e.kind = "method", e.method = !0, this.parseMethod(e, r, s, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(e, r, s, i) {
      if (e.shorthand = !1, this.eat(14))
        return e.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(e, "ObjectProper\
ty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), s)
          e.value = this.parseMaybeDefault(r, Ds(e.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = a) : this.raise(M.InvalidCoverInitializedName, a), e.value = this.
          parseMaybeDefault(r, Ds(e.key));
        } else
          e.value = Ds(e.key);
        return e.shorthand = !0, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, r, s, i, a, o, l) {
      let u = this.parseObjectMethod(e, s, i, a, o) || this.parseObjectProperty(e, r, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(e, r) {
      if (this.eat(0))
        e.computed = !0, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: s,
          value: i
        } = this.state, a;
        if (zr(s))
          a = this.parseIdentifier(!0);
        else
          switch (s) {
            case 134:
              a = this.parseNumericLiteral(i);
              break;
            case 133:
              a = this.parseStringLiteral(i);
              break;
            case 135:
              a = this.parseBigIntLiteral(i);
              break;
            case 136:
              a = this.parseDecimalLiteral(i);
              break;
            case 138: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(M.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        e.key = a, s !== 138 && (e.computed = !1);
      }
    }
    initFunction(e, r) {
      e.id = null, e.generator = !1, e.async = r;
    }
    parseMethod(e, r, s, i, a, o, l = !1) {
      this.initFunction(e, s), e.generator = r, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(Ju(s, e.generator)),
      this.parseFunctionParams(e, i);
      let u = this.parseFunctionBodyAndFinish(e, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(e, r, s, i) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(e, !s, i, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, s ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, r, s, i) {
      this.scope.enter(6);
      let a = Ju(s, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(e, s);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e, r, i)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(e, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(e, r, s) {
      this.toAssignableList(r, s, !1), e.params = r;
    }
    parseFunctionBodyAndFinish(e, r, s = !1) {
      return this.parseFunctionBody(e, !1, s), this.finishNode(e, r);
    }
    parseFunctionBody(e, r, s = !1) {
      let i = r && !this.match(5);
      if (this.expressionScope.enter(bv()), i)
        e.body = this.parseMaybeAssign(), this.checkParams(e, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), e.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(e.params);
          l && u && this.raise(M.IllegalLanguageModeDirective, (e.kind === "method" || e.kind === "constructor") && e.key ? e.key.loc.end : e);
          let c = !a && this.state.strict;
          this.checkParams(e, !this.state.strict && !r && !s && !u, r, c), this.state.strict && e.id && this.checkIdentifier(e.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let r = 0, s = e.length; r < s; r++)
        if (!this.isSimpleParameter(e[r])) return !1;
      return !0;
    }
    checkParams(e, r, s, i = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of e.params)
        this.checkLVal(l, {
          in: o,
          binding: 5,
          checkClashes: a,
          strictModeChanged: i
        });
    }
    parseExprList(e, r, s, i) {
      let a = [], o = !0;
      for (; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        a.push(this.parseExprListItem(r, s));
      }
      return a;
    }
    parseExprListItem(e, r, s) {
      let i;
      if (this.match(12))
        e || this.raise(M.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), i = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        i = this.parseParenItem(this.parseSpread(r), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), s || this.raise(M.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), i = this.finishNode(a, "ArgumentPlaceholder");
      } else
        i = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return i;
    }
    parseIdentifier(e) {
      let r = this.startNode(), s = this.parseIdentifierName(e);
      return this.createIdentifier(r, s);
    }
    createIdentifier(e, r) {
      return e.name = r, e.loc.identifierName = r, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e) {
      let r, {
        startLoc: s,
        type: i
      } = this.state;
      zr(i) ? r = this.state.value : this.unexpected();
      let a = tue(i);
      return e ? a && this.replaceToken(132) : this.checkReservedWord(r, s, a, !1), this.next(), r;
    }
    checkReservedWord(e, r, s, i) {
      if (e.length > 10 || !Sue(e))
        return;
      if (s && Tue(e)) {
        this.raise(M.UnexpectedKeyword, r, {
          keyword: e
        });
        return;
      }
      if ((this.state.strict ? i ? hv : pv : cv)(e, this.inModule)) {
        this.raise(M.UnexpectedReservedWord, r, {
          reservedWord: e
        });
        return;
      } else if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(M.YieldBindingIdentifier, r);
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(M.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(M.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(M.ArgumentsInClass, r);
        return;
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(e) {
      let r = this.startNodeAt(e);
      return this.expressionScope.recordParameterInitializerError(M.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(M.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst =
      !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExp\
ression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || $u(e) || e === 102 && !this.state.containsEsc || e === 137 || e === 56 || this.hasPlugin("v8\
intrinsic") && e === 54;
    }
    parseYield() {
      let e = this.startNode();
      this.expressionScope.recordParameterInitializerError(M.YieldInParameter, e), this.next();
      let r = !1, s = null;
      if (!this.hasPrecedingLineBreak())
        switch (r = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!r) break;
          default:
            s = this.parseMaybeAssign();
        }
      return e.delegate = r, e.argument = s, this.finishNode(e, "YieldExpression");
    }
    parseImportCall(e) {
      return this.next(), e.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) &&
      (e.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e.options = this.parseMaybeAssignAllowIn(),
      this.eat(12))), this.expect(11), this.finishNode(e, "ImportExpression");
    }
    checkPipelineAtInfixOperator(e, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(M.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(e, r) {
      if (this.isSimpleReference(e)) {
        let s = this.startNodeAt(r);
        return s.callee = e, this.finishNode(s, "PipelineBareFunction");
      } else {
        let s = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), s.expression = e, this.finishNode(s, "PipelineTopicExpression");
      }
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(M.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(M.PipelineTopicUnused, e);
    }
    withTopicBindingContext(e) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return e();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let s = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, e);
      return this.state.inFSharpPipelineDirectBody = s, i;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let e = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let s = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        e.body = this.parseProgram(r, 8, "module");
      } finally {
        s();
      }
      return this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }, Bm = {
    kind: 1
  }, ece = {
    kind: 2
  }, tce = /[\uD800-\uDFFF]/u, Fm = /in(?:stanceof)?/y;
  function rce(t, e) {
    for (let r = 0; r < t.length; r++) {
      let s = t[r], {
        type: i
      } = s;
      if (typeof i == "number") {
        {
          if (i === 138) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, p = xr(a.start, 1);
            t.splice(r, 1, new ls({
              type: ws(27),
              value: "#",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }), new ls({
              type: ws(132),
              value: l,
              start: c,
              end: u,
              startLoc: p,
              endLoc: a.end
            })), r++;
            continue;
          }
          if ($u(i)) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, p = xr(a.start, 1), f;
            e.charCodeAt(o) === 96 ? f = new ls({
              type: ws(22),
              value: "`",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }) : f = new ls({
              type: ws(8),
              value: "}",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            });
            let m, y, T, L;
            i === 24 ? (y = u - 1, T = xr(a.end, -1), m = l === null ? null : l.slice(1, -1), L = new ls({
              type: ws(22),
              value: "`",
              start: y,
              end: u,
              startLoc: T,
              endLoc: a.end
            })) : (y = u - 2, T = xr(a.end, -2), m = l === null ? null : l.slice(1, -2), L = new ls({
              type: ws(23),
              value: "${",
              start: y,
              end: u,
              startLoc: T,
              endLoc: a.end
            })), t.splice(r, 1, f, new ls({
              type: ws(20),
              value: m,
              start: c,
              end: y,
              startLoc: p,
              endLoc: T
            }), L), r += 2;
            continue;
          }
        }
        s.type = ws(i);
      }
    }
    return t;
  }
  n(rce, "babel7CompatTokens");
  var sy = class extends ry {
    static {
      n(this, "StatementParser");
    }
    parseTopLevel(e, r) {
      return e.program = this.parseProgram(r), e.comments = this.comments, this.options.tokens && (e.tokens = rce(this.tokens, this.input)),
      this.finishNode(e, "File");
    }
    parseProgram(e, r = 139, s = this.options.sourceType) {
      if (e.sourceType = s, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, r), this.inModule && !this.options.
      allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [a, o] of Array.from(this.scope.undefinedExports))
          this.raise(M.ModuleExportUndefined, o, {
            localName: a
          });
      let i;
      return r === 139 ? i = this.finishNode(e, "Program") : i = this.finishNodeAt(e, "Program", xr(this.state.startLoc, -1)), i;
    }
    stmtToDirective(e) {
      let r = e;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let s = r.value, i = s.value, a = this.input.slice(s.start, s.end), o = s.value = a.slice(1, -1);
      return this.addExtra(s, "raw", a), this.addExtra(s, "rawValue", o), this.addExtra(s, "expressionValue", i), s.type = "DirectiveLiteral",
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(e, r) {
      if (Os(e)) {
        if (Fm.lastIndex = r, Fm.test(this.input)) {
          let s = this.codePointAtPos(Fm.lastIndex);
          if (!Bn(s) && s !== 92)
            return !1;
        }
        return !0;
      } else return e === 92;
    }
    chStartsBindingPattern(e) {
      return e === 91 || e === 123;
    }
    hasFollowingBindingAtom() {
      let e = this.nextTokenStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, e);
    }
    hasInLineFollowingBindingIdentifier() {
      let e = this.nextTokenInLineStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingIdentifier(r, e);
    }
    startsUsingForOf() {
      let {
        type: e,
        containsEsc: r
      } = this.lookahead();
      if (e === 102 && !r)
        return !1;
      if (ht(e) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let e = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e, "using")) {
        e = this.nextTokenInLineStartSince(e + 5);
        let r = this.codePointAtPos(e);
        if (this.chStartsBindingIdentifier(r, e))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, e && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(e) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(e, r);
    }
    parseStatementContent(e, r) {
      let s = this.state.type, i = this.startNode(), a = !!(e & 2), o = !!(e & 4), l = e & 1;
      switch (s) {
        case 60:
          return this.parseBreakContinueStatement(i, !0);
        case 63:
          return this.parseBreakContinueStatement(i, !1);
        case 64:
          return this.parseDebuggerStatement(i);
        case 90:
          return this.parseDoWhileStatement(i);
        case 91:
          return this.parseForStatement(i);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? M.StrictFunction : this.options.annexB ? M.SloppyFunctionAnnexB : M.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(i, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, i), !0);
        case 69:
          return this.parseIfStatement(i);
        case 70:
          return this.parseReturnStatement(i);
        case 71:
          return this.parseSwitchStatement(i);
        case 72:
          return this.parseThrowStatement(i);
        case 73:
          return this.parseTryStatement(i);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? a || this.raise(M.UnexpectedLexicalDeclaration, i) : this.raise(M.AwaitUsingNotInAsyncContext, i),
            this.next(), this.parseVarStatement(i, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(M.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(M.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(i, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let p = this.nextTokenStart(), f = this.codePointAtPos(p);
          if (f !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(f, p) && f !== 123))
            break;
        }
        case 75:
          a || this.raise(M.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let p = this.state.value;
          return this.parseVarStatement(i, p);
        }
        case 92:
          return this.parseWhileStatement(i);
        case 76:
          return this.parseWithStatement(i);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(i);
        case 83: {
          let p = this.lookaheadCharCode();
          if (p === 40 || p === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !l && this.raise(M.UnexpectedImportExport, this.state.startLoc), this.next();
          let p;
          return s === 83 ? (p = this.parseImport(i), p.type === "ImportDeclaration" && (!p.importKind || p.importKind === "value") && (this.
          sawUnambiguousESM = !0)) : (p = this.parseExport(i, r), (p.type === "ExportNamedDeclaration" && (!p.exportKind || p.exportKind ===
          "value") || p.type === "ExportAllDeclaration" && (!p.exportKind || p.exportKind === "value") || p.type === "ExportDefaultDeclarati\
on") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(p), p;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(M.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return ht(s) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, u, c, e) : this.parseExpressionStatement(i, c,
      r);
    }
    assertModuleNodeAllowed(e) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(M.ImportOutsideModule, e);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(e, r, s) {
      return e && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolea\
n" && this.raise(M.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...e)) : r.decorators = e, this.resetStartLocationFromNode(
      r, e[0]), s && this.resetStartLocationFromNode(s, r)), r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(M.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(M.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, s;
        if (this.match(10)) {
          let i = this.state.startLoc;
          this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(i, s);
          let a = this.state.startLoc;
          e.expression = this.parseMaybeDecoratorArguments(s), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && e.expression !==
          s && this.raise(M.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (s = this.parseIdentifier(!1); this.eat(16); ) {
            let i = this.startNodeAt(r);
            i.object = s, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i.property = this.parsePrivateName()) :
            i.property = this.parseIdentifier(!0), i.computed = !1, s = this.finishNode(i, "MemberExpression");
          }
          e.expression = this.parseMaybeDecoratorArguments(s);
        }
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e) {
      if (this.eat(10)) {
        let r = this.startNodeAtNode(e);
        return r.callee = e, r.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(r.arguments), this.finishNode(r,
        "CallExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, r) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      e, r), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, r) {
      let s;
      for (s = 0; s < this.state.labels.length; ++s) {
        let i = this.state.labels[s];
        if ((e.label == null || i.name === e.label.name) && (i.kind != null && (r || i.kind === 1) || e.label && r))
          break;
      }
      if (s === this.state.labels.length) {
        let i = r ? "BreakStatement" : "ContinueStatement";
        this.raise(M.IllegalBreakContinue, e, {
          type: i
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoWhileStatement(e) {
      return this.next(), this.state.labels.push(Bm), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(Bm);
      let r = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(
      13))
        return r !== null && this.unexpected(r), this.parseFor(e, null);
      let s = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), c = u || this.isContextual(107) && this.startsUsingForOf(), p = s && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || p) {
          let f = this.startNode(), m;
          u ? (m = "await using", this.isAwaitAllowed() || this.raise(M.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : m =
          this.state.value, this.next(), this.parseVar(f, !0, m);
          let y = this.finishNode(f, "VariableDeclaration"), T = this.match(58);
          return T && c && this.raise(M.ForInUsing, y), (T || this.isContextual(102)) && y.declarations.length === 1 ? this.parseForIn(e, y,
          r) : (r !== null && this.unexpected(r), this.parseFor(e, y));
        }
      }
      let i = this.isContextual(95), a = new Fn(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (s && this.raise(M.ForOfLet, o), r === null && i && o.type === "Identifier" && this.raise(M.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          in: {
            type: u
          }
        }), this.parseForIn(e, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(e, o);
    }
    parseFunctionStatement(e, r, s) {
      return this.next(), this.parseFunction(e, 1 | (s ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(M.IllegalReturn, this.state.startLoc), this.
      next(), this.isLineTerminator() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "Ret\
urnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      let r = e.cases = [];
      this.expect(5), this.state.labels.push(ece), this.scope.enter(0);
      let s;
      for (let i; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          s && this.finishNode(s, "SwitchCase"), r.push(s = this.startNode()), s.consequent = [], this.next(), a ? s.test = this.parseExpression() :
          (i && this.raise(M.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i = !0, s.test = null), this.expect(14);
        } else
          s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchState\
ment");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(M.NewlineAfterThrow, this.state.lastTokEndLoc), e.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let e = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && e.type === "Identifier" ? 8 : 0), this.checkLVal(e, {
        in: {
          type: "CatchClause"
        },
        binding: 9
      }), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), e.handler = this.finishNode(
        r, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(M.NoCatchOrFinally, e), this.finishNode(
      e, "TryStatement");
    }
    parseVarStatement(e, r, s = !1) {
      return this.next(), this.parseVar(e, !1, r, s), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(Bm), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(M.StrictWith, this.state.startLoc), this.next(), e.object = this.parseHeaderExpression(), e.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, r, s, i) {
      for (let o of this.state.labels)
        o.name === r && this.raise(M.LabelRedeclaration, s, {
          labelName: r
        });
      let a = iue(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === e.start)
          l.statementStart = this.state.start, l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.state.start
      }), e.body = i & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e.label =
      s, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, r, s) {
      return e.expression = r, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = !1, r = !0, s) {
      let i = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(i, e, !1, 8, s), r && this.
      scope.exit(), this.finishNode(i, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, r, s, i, a) {
      let o = e.body = [], l = e.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? l : void 0, s, i, a);
    }
    parseBlockOrModuleBlockBody(e, r, s, i, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(i); ) {
        let c = s ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !u) {
          if (this.isValidDirective(c)) {
            let p = this.stmtToDirective(c);
            r.push(p), !l && p.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        e.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(e, r) {
      return e.init = r, this.semicolon(!1), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, r, s) {
      let i = this.match(58);
      return this.next(), i ? s !== null && this.unexpected(s) : e.await = s !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!i || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(M.ForInOfLoopInitializer, r, {
        type: i ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(M.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = r, e.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, i ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, r, s, i = !1) {
      let a = e.declarations = [];
      for (e.kind = s; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, s), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !i && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(M.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(M.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: s
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return e;
    }
    parseVarId(e, r) {
      let s = this.parseBindingAtom();
      this.checkLVal(s, {
        in: {
          type: "VariableDeclarator"
        },
        binding: r === "var" ? 5 : 8201
      }), e.id = s;
    }
    parseAsyncFunctionExpression(e) {
      return this.parseFunction(e, 8);
    }
    parseFunction(e, r = 0) {
      let s = r & 2, i = !!(r & 1), a = i && !(r & 4), o = !!(r & 8);
      this.initFunction(e, o), this.match(55) && (s && this.raise(M.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e.
      generator = !0), i && (e.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(Ju(o, e.generator)), i || (e.id = this.parseFunctionId()),
      this.parseFunctionParams(e, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, i ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), i && !s && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = l, e;
    }
    parseFunctionId(e) {
      return e || ht(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, r) {
      this.expect(10), this.expressionScope.enter(Iue()), e.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, e.id.loc.start);
    }
    parseClass(e, r, s) {
      this.next();
      let i = this.state.strict;
      return this.state.strict = !0, this.parseClassId(e, r, s), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, i), this.
      finishNode(e, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(e) {
      return e.type === "Identifier" && e.name === "constructor" || e.type === "StringLiteral" && e.value === "constructor";
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && this.nameIsConstructor(e.key);
    }
    parseClassBody(e, r) {
      this.classScope.enter();
      let s = {
        hadConstructor: !1,
        hadSuperClass: e
      }, i = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (i.length > 0)
              throw this.raise(M.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            i.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          i.length && (o.decorators = i, this.resetStartLocationFromNode(o, i[0]), i = []), this.parseClassMember(a, o, s), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(M.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), i.length)
        throw this.raise(M.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(e, r) {
      let s = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let i = r;
        return i.kind = "method", i.computed = !1, i.key = s, i.static = !1, this.pushClassMethod(e, i, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let i = r;
        return i.computed = !1, i.key = s, i.static = !1, e.body.push(this.parseClassProperty(i)), !0;
      }
      return this.resetPreviousNodeTrailingComments(s), !1;
    }
    parseClassMember(e, r, s) {
      let i = this.isContextual(106);
      if (i) {
        if (this.parseClassMemberFromModifier(e, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, r, s, i);
    }
    parseClassMemberWithIsStatic(e, r, s, i) {
      let a = r, o = r, l = r, u = r, c = r, p = a, f = a;
      if (r.static = i, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        p.kind = "method";
        let _ = this.match(138);
        if (this.parseClassElementName(p), _) {
          this.pushClassPrivateMethod(e, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(M.ConstructorIsGenerator, a.key), this.pushClassMethod(e, a, !0, !1, !1, !1);
        return;
      }
      let m = !this.state.containsEsc && ht(this.state.type), y = this.parseClassElementName(r), T = m ? y.name : null, L = this.isPrivateName(
      y), q = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(f), this.isClassMethod()) {
        if (p.kind = "method", L) {
          this.pushClassPrivateMethod(e, o, !1, !1);
          return;
        }
        let _ = this.isNonstaticConstructor(a), U = !1;
        _ && (a.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(M.DuplicateConstructor, y), _ && this.
        hasPlugin("typescript") && r.override && this.raise(M.OverrideOnConstructor, y), s.hadConstructor = !0, U = s.hadSuperClass), this.pushClassMethod(
        e, a, !1, !1, _, U);
      } else if (this.isClassProperty())
        L ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l);
      else if (T === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(y);
        let _ = this.eat(55);
        f.optional && this.unexpected(q), p.kind = "method";
        let U = this.match(138);
        this.parseClassElementName(p), this.parsePostMemberNameModifiers(f), U ? this.pushClassPrivateMethod(e, o, _, !0) : (this.isNonstaticConstructor(
        a) && this.raise(M.ConstructorIsAsync, a.key), this.pushClassMethod(e, a, _, !0, !1, !1));
      } else if ((T === "get" || T === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(y), p.kind = T;
        let _ = this.match(138);
        this.parseClassElementName(a), _ ? this.pushClassPrivateMethod(e, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(M.ConstructorIsAccessor,
        a.key), this.pushClassMethod(e, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (T === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(y);
        let _ = this.match(138);
        this.parseClassElementName(l), this.pushClassAccessorProperty(e, c, _);
      } else this.isLineTerminator() ? L ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l) : this.unexpected();
    }
    parseClassElementName(e) {
      let {
        type: r,
        value: s
      } = this.state;
      if ((r === 132 || r === 133) && e.static && s === "prototype" && this.raise(M.StaticPrototype, this.state.startLoc), r === 138) {
        s === "constructor" && this.raise(M.ConstructorClassPrivateField, this.state.startLoc);
        let i = this.parsePrivateName();
        return e.key = i, i;
      }
      return this.parsePropertyName(e), e.key;
    }
    parseClassStaticBlock(e, r) {
      var s;
      this.scope.enter(208);
      let i = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, e.body.push(this.
      finishNode(r, "StaticBlock")), (s = r.decorators) != null && s.length && this.raise(M.DecoratorStaticBlock, r);
    }
    pushClassProperty(e, r) {
      !r.computed && this.nameIsConstructor(r.key) && this.raise(M.ConstructorClassField, r.key), e.body.push(this.parseClassProperty(r));
    }
    pushClassPrivateProperty(e, r) {
      let s = this.parseClassPrivateProperty(r);
      e.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
    }
    pushClassAccessorProperty(e, r, s) {
      !s && !r.computed && this.nameIsConstructor(r.key) && this.raise(M.ConstructorClassField, r.key);
      let i = this.parseClassAccessorProperty(r);
      e.body.push(i), s && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassMethod(e, r, s, i, a, o) {
      e.body.push(this.parseMethod(r, s, i, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(e, r, s, i) {
      let a = this.parseMethod(r, s, i, !1, !1, "ClassPrivateMethod", !0);
      e.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(e, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), r, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(80), this.expressionScope.enter(bv()), this.prodParam.enter(0), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, r, s, i = 8331) {
      if (ht(this.state.type))
        e.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(e.id, i);
      else if (s || !r)
        e.id = null;
      else
        throw this.raise(M.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e, r) {
      let s = this.parseMaybeImportPhase(e, !0), i = this.maybeParseExportDefaultSpecifier(e, s), a = !i || this.eat(12), o = a && this.eatExportStar(
      e), l = o && this.maybeParseExportNamespaceSpecifier(e), u = a && (!l || this.eat(12)), c = i || o;
      if (o && !l) {
        if (i && this.unexpected(), r)
          throw this.raise(M.UnsupportedDecoratorExport, e);
        return this.parseExportFrom(e, !0), this.finishNode(e, "ExportAllDeclaration");
      }
      let p = this.maybeParseExportNamedSpecifiers(e);
      i && a && !o && !p && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let f;
      if (c || p) {
        if (f = !1, r)
          throw this.raise(M.UnsupportedDecoratorExport, e);
        this.parseExportFrom(e, c);
      } else
        f = this.maybeParseExportDeclaration(e);
      if (c || p || f) {
        var m;
        let y = e;
        if (this.checkExport(y, !0, !1, !!y.source), ((m = y.declaration) == null ? void 0 : m.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, y.declaration, y);
        else if (r)
          throw this.raise(M.UnsupportedDecoratorExport, e);
        return this.finishNode(y, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let y = e, T = this.parseExportDefaultExpression();
        if (y.declaration = T, T.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, T, y);
        else if (r)
          throw this.raise(M.UnsupportedDecoratorExport, e);
        return this.checkExport(y, !0, !0), this.finishNode(y, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let s = r || this.parseIdentifier(!0), i = this.startNodeAtNode(s);
        return i.exported = s, e.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        var r, s;
        (s = (r = e).specifiers) != null || (r.specifiers = []);
        let i = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), i.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(i, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        let r = e;
        r.specifiers || (r.specifiers = []);
        let s = r.exportKind === "type";
        return r.specifiers.push(...this.parseExportSpecifiers(s)), r.source = null, r.declaration = null, this.hasPlugin("importAssertions") &&
        (r.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") && (e.assertions =
      []), e.declaration = this.parseExportDeclaration(e), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let e = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      let e = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(e, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(e, 13);
      if (this.match(80))
        return this.parseClass(e, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(M.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(M.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(e) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: e
      } = this.state;
      if (ht(e)) {
        if (e === 95 && !this.state.containsEsc || e === 100)
          return !1;
        if ((e === 130 || e === 129) && !this.state.containsEsc) {
          let {
            type: i
          } = this.lookahead();
          if (ht(i) && i !== 98 || i === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), s = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || ht(this.state.type) && s)
        return !0;
      if (this.match(65) && s) {
        let i = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return i === 34 || i === 39;
      }
      return !1;
    }
    parseExportFrom(e, r) {
      this.eatContextual(98) ? (e.source = this.parseImportSource(), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(
      e)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: e
      } = this.state;
      return e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(M.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.
      raise(M.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(M.UsingDeclarationExport,
      this.state.startLoc), !0) : e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, r, s, i) {
      if (r) {
        var a;
        if (s) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = e.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            M.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = e.specifiers) != null && a.length)
          for (let l of e.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !i && l.local) {
              let {
                local: p
              } = l;
              p.type !== "Identifier" ? this.raise(M.ExportBindingIsString, l, {
                localName: p.value,
                exportName: c
              }) : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p));
            }
          }
        else if (e.declaration) {
          let l = e.declaration;
          if (l.type === "FunctionDeclaration" || l.type === "ClassDeclaration") {
            let {
              id: u
            } = l;
            if (!u) throw new Error("Assertion failure");
            this.checkDuplicateExports(e, u.name);
          } else if (l.type === "VariableDeclaration")
            for (let u of l.declarations)
              this.checkDeclaration(u.id);
        }
      }
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (let r of e.properties)
          this.checkDeclaration(r);
      else if (e.type === "ArrayPattern")
        for (let r of e.elements)
          r && this.checkDeclaration(r);
      else e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type ===
      "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(M.DuplicateDefaultExport, e) : this.raise(M.DuplicateExport, e, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(e) {
      let r = [], s = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (s)
          s = !1;
        else if (this.expect(12), this.eat(8)) break;
        let i = this.isContextual(130), a = this.match(133), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, e, i));
      }
      return r;
    }
    parseExportSpecifier(e, r, s, i) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : r ? e.exported = kue(e.local) : e.exported || (e.exported =
      Ds(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let e = this.parseStringLiteral(this.state.value), r = e.value.match(tce);
        return r && this.raise(M.ModuleExportNameHasLoneSurrogate, e, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: r,
        value: s
      }) => s.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(e) {
      let {
        specifiers: r
      } = e, s = r.length === 1 ? r[0].type : null;
      if (e.phase === "source")
        s !== "ImportDefaultSpecifier" && this.raise(M.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (e.phase === "defer")
        s !== "ImportNamespaceSpecifier" && this.raise(M.DeferImportRequiresNamespace, r[0].loc.start);
      else if (e.module) {
        var i;
        s !== "ImportDefaultSpecifier" && this.raise(M.ImportReflectionNotBinding, r[0].loc.start), ((i = e.assertions) == null ? void 0 : i.
        length) > 0 && this.raise(M.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = e;
        if (r != null) {
          let s = r.find((i) => {
            let a;
            if (i.type === "ExportSpecifier" ? a = i.local : i.type === "ImportSpecifier" && (a = i.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          s !== void 0 && this.raise(M.ImportJSONBindingNotDefault, s.loc.start);
        }
      }
    }
    isPotentialImportPhase(e) {
      return e ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(e, r, s, i) {
      r || (s === "module" ? (this.expectPlugin("importReflection", i), e.module = !0) : this.hasPlugin("importReflection") && (e.module = !1),
      s === "source" ? (this.expectPlugin("sourcePhaseImports", i), e.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", i), e.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
    }
    parseMaybeImportPhase(e, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(e, r, null), null;
      let s = this.parseIdentifier(!0), {
        type: i
      } = this.state;
      return (zr(i) ? i !== 98 || this.lookaheadCharCode() === 102 : i !== 12) ? (this.resetPreviousIdentifierLeadingComments(s), this.applyImportPhase(
      e, r, s.name, s.loc.start), null) : (this.applyImportPhase(e, r, null), s);
    }
    isPrecedingIdImportPhase(e) {
      let {
        type: r
      } = this.state;
      return ht(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(e) {
      return this.match(133) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
    }
    parseImportSpecifiersAndAfter(e, r) {
      e.specifiers = [];
      let i = !this.maybeParseDefaultImportSpecifier(e, r) || this.eat(12), a = i && this.maybeParseStarImportSpecifier(e);
      return i && !a && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
    }
    parseImportSourceAndAttributes(e) {
      var r;
      return (r = e.specifiers) != null || (e.specifiers = []), e.source = this.parseImportSource(), this.maybeParseImportAttributes(e), this.
      checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(e, r, s) {
      r.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(r, s));
    }
    finishImportSpecifier(e, r, s = 8201) {
      return this.checkLVal(e.local, {
        in: {
          type: r
        },
        binding: s
      }), this.finishNode(e, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let s = this.startNode(), i = this.state.value;
        if (r.has(i) && this.raise(M.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: i
        }), r.add(i), this.match(133) ? s.key = this.parseStringLiteral(i) : s.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        133))
          throw this.raise(M.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), e;
    }
    parseModuleAttributes() {
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        let s = this.startNode();
        if (s.key = this.parseIdentifier(!0), s.key.name !== "type" && this.raise(M.ModuleAttributeDifferentFromType, s.key), r.has(s.key.name) &&
        this.raise(M.ModuleAttributesWithDuplicateKeys, s.key, {
          key: s.key.name
        }), r.add(s.key.name), this.expect(14), !this.match(133))
          throw this.raise(M.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAttributes(e) {
      let r, s = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), r = this.
        parseImportAttributes()), s = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(M.ImportAttributesUseAssert,
        this.state.startLoc), this.addExtra(e, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]),
        this.next(), r = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        r = [];
      else if (this.hasPlugin("moduleAttributes"))
        r = [];
      else return;
      !s && this.hasPlugin("importAssertions") ? e.assertions = r : e.attributes = r;
    }
    maybeParseDefaultImportSpecifier(e, r) {
      if (r) {
        let s = this.startNodeAtNode(r);
        return s.local = r, e.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), !0;
      } else if (zr(this.state.type))
        return this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(e) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(M.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let s = this.startNode(), i = this.match(133), a = this.isContextual(130);
        s.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(s, i, e.importKind === "type" || e.importKind === "typeof", a, void 0);
        e.specifiers.push(o);
      }
    }
    parseImportSpecifier(e, r, s, i, a) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = e;
        if (r)
          throw this.raise(M.ImportBindingIsString, e, {
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, !0, !0), e.local || (e.local = Ds(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier", a);
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }, zu = class extends sy {
    static {
      n(this, "Parser");
    }
    constructor(e, r) {
      e = Zue(e), super(e, r), this.options = e, this.initializeScopes(), this.plugins = sce(this.options.plugins), this.filename = e.sourceFilename;
    }
    getScopeHandler() {
      return yo;
    }
    parse() {
      this.enterInitialScopes();
      let e = this.startNode(), r = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, r), e.errors = this.state.errors, e.comments.length = this.state.commentsLen,
      e;
    }
  };
  function sce(t) {
    let e = /* @__PURE__ */ new Map();
    for (let r of t) {
      let [s, i] = Array.isArray(r) ? r : [r, {}];
      e.has(s) || e.set(s, i || {});
    }
    return e;
  }
  n(sce, "pluginsMap");
  function ice(t, e) {
    var r;
    if (((r = e) == null ? void 0 : r.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        let s = po(e, t), i = s.parse();
        if (s.sawUnambiguousESM)
          return i;
        if (s.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", po(e, t).parse();
          } catch {
          }
        else
          i.program.sourceType = "script";
        return i;
      } catch (s) {
        try {
          return e.sourceType = "script", po(e, t).parse();
        } catch {
        }
        throw s;
      }
    } else
      return po(e, t).parse();
  }
  n(ice, "parse");
  function nce(t, e) {
    let r = po(e, t);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  n(nce, "parseExpression");
  function ace(t) {
    let e = {};
    for (let r of Object.keys(t))
      e[r] = ws(t[r]);
    return e;
  }
  n(ace, "generateExportedTokenTypes");
  var oce = ace(eue);
  function po(t, e) {
    let r = zu;
    return t != null && t.plugins && (Gue(t.plugins), r = lce(t.plugins)), new r(t, e);
  }
  n(po, "getParser");
  var nv = {};
  function lce(t) {
    let e = Que.filter((i) => Kt(t, i)), r = e.join("/"), s = nv[r];
    if (!s) {
      s = zu;
      for (let i of e)
        s = Pv[i](s);
      nv[r] = s;
    }
    return s;
  }
  n(lce, "getParserClass");
  bo.parse = ice;
  bo.parseExpression = nce;
  bo.tokTypes = oce;
});

// ../node_modules/@babel/highlight/node_modules/color-name/index.js
var vv = w((A8e, Av) => {
  "use strict";
  Av.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/conversions.js
var dy = w((v8e, Nv) => {
  var Hi = vv(), wv = {};
  for (Gu in Hi)
    Hi.hasOwnProperty(Gu) && (wv[Hi[Gu]] = Gu);
  var Gu, ge = Nv.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (Sr in ge)
    if (ge.hasOwnProperty(Sr)) {
      if (!("channels" in ge[Sr]))
        throw new Error("missing channels property: " + Sr);
      if (!("labels" in ge[Sr]))
        throw new Error("missing channel labels property: " + Sr);
      if (ge[Sr].labels.length !== ge[Sr].channels)
        throw new Error("channel and label counts mismatch: " + Sr);
      Cv = ge[Sr].channels, Iv = ge[Sr].labels, delete ge[Sr].channels, delete ge[Sr].labels, Object.defineProperty(ge[Sr], "channels", { value: Cv }),
      Object.defineProperty(ge[Sr], "labels", { value: Iv });
    }
  var Cv, Iv, Sr;
  ge.rgb.hsl = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255, i = Math.min(e, r, s), a = Math.max(e, r, s), o = a - i, l, u, c;
    return a === i ? l = 0 : e === a ? l = (r - s) / o : r === a ? l = 2 + (s - e) / o : s === a && (l = 4 + (e - r) / o), l = Math.min(l * 60,
    360), l < 0 && (l += 360), c = (i + a) / 2, a === i ? u = 0 : c <= 0.5 ? u = o / (a + i) : u = o / (2 - a - i), [l, u * 100, c * 100];
  };
  ge.rgb.hsv = function(t) {
    var e, r, s, i, a, o = t[0] / 255, l = t[1] / 255, u = t[2] / 255, c = Math.max(o, l, u), p = c - Math.min(o, l, u), f = /* @__PURE__ */ n(
    function(m) {
      return (c - m) / 6 / p + 1 / 2;
    }, "diffc");
    return p === 0 ? i = a = 0 : (a = p / c, e = f(o), r = f(l), s = f(u), o === c ? i = s - r : l === c ? i = 1 / 3 + e - s : u === c && (i =
    2 / 3 + r - e), i < 0 ? i += 1 : i > 1 && (i -= 1)), [
      i * 360,
      a * 100,
      c * 100
    ];
  };
  ge.rgb.hwb = function(t) {
    var e = t[0], r = t[1], s = t[2], i = ge.rgb.hsl(t)[0], a = 1 / 255 * Math.min(e, Math.min(r, s));
    return s = 1 - 1 / 255 * Math.max(e, Math.max(r, s)), [i, a * 100, s * 100];
  };
  ge.rgb.cmyk = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255, i, a, o, l;
    return l = Math.min(1 - e, 1 - r, 1 - s), i = (1 - e - l) / (1 - l) || 0, a = (1 - r - l) / (1 - l) || 0, o = (1 - s - l) / (1 - l) || 0,
    [i * 100, a * 100, o * 100, l * 100];
  };
  function uce(t, e) {
    return Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2) + Math.pow(t[2] - e[2], 2);
  }
  n(uce, "comparativeDistance");
  ge.rgb.keyword = function(t) {
    var e = wv[t];
    if (e)
      return e;
    var r = 1 / 0, s;
    for (var i in Hi)
      if (Hi.hasOwnProperty(i)) {
        var a = Hi[i], o = uce(t, a);
        o < r && (r = o, s = i);
      }
    return s;
  };
  ge.keyword.rgb = function(t) {
    return Hi[t];
  };
  ge.rgb.xyz = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255;
    e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, s = s >
    0.04045 ? Math.pow((s + 0.055) / 1.055, 2.4) : s / 12.92;
    var i = e * 0.4124 + r * 0.3576 + s * 0.1805, a = e * 0.2126 + r * 0.7152 + s * 0.0722, o = e * 0.0193 + r * 0.1192 + s * 0.9505;
    return [i * 100, a * 100, o * 100];
  };
  ge.rgb.lab = function(t) {
    var e = ge.rgb.xyz(t), r = e[0], s = e[1], i = e[2], a, o, l;
    return r /= 95.047, s /= 100, i /= 108.883, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, s = s > 8856e-6 ? Math.pow(s, 1 /
    3) : 7.787 * s + 16 / 116, i = i > 8856e-6 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, a = 116 * s - 16, o = 500 * (r - s), l = 200 * (s -
    i), [a, o, l];
  };
  ge.hsl.rgb = function(t) {
    var e = t[0] / 360, r = t[1] / 100, s = t[2] / 100, i, a, o, l, u;
    if (r === 0)
      return u = s * 255, [u, u, u];
    s < 0.5 ? a = s * (1 + r) : a = s + r - s * r, i = 2 * s - a, l = [0, 0, 0];
    for (var c = 0; c < 3; c++)
      o = e + 1 / 3 * -(c - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? u = i + (a - i) * 6 * o : 2 * o < 1 ? u = a : 3 * o < 2 ? u = i + (a -
      i) * (2 / 3 - o) * 6 : u = i, l[c] = u * 255;
    return l;
  };
  ge.hsl.hsv = function(t) {
    var e = t[0], r = t[1] / 100, s = t[2] / 100, i = r, a = Math.max(s, 0.01), o, l;
    return s *= 2, r *= s <= 1 ? s : 2 - s, i *= a <= 1 ? a : 2 - a, l = (s + r) / 2, o = s === 0 ? 2 * i / (a + i) : 2 * r / (s + r), [e, o *
    100, l * 100];
  };
  ge.hsv.rgb = function(t) {
    var e = t[0] / 60, r = t[1] / 100, s = t[2] / 100, i = Math.floor(e) % 6, a = e - Math.floor(e), o = 255 * s * (1 - r), l = 255 * s * (1 -
    r * a), u = 255 * s * (1 - r * (1 - a));
    switch (s *= 255, i) {
      case 0:
        return [s, u, o];
      case 1:
        return [l, s, o];
      case 2:
        return [o, s, u];
      case 3:
        return [o, l, s];
      case 4:
        return [u, o, s];
      case 5:
        return [s, o, l];
    }
  };
  ge.hsv.hsl = function(t) {
    var e = t[0], r = t[1] / 100, s = t[2] / 100, i = Math.max(s, 0.01), a, o, l;
    return l = (2 - r) * s, a = (2 - r) * i, o = r * i, o /= a <= 1 ? a : 2 - a, o = o || 0, l /= 2, [e, o * 100, l * 100];
  };
  ge.hwb.rgb = function(t) {
    var e = t[0] / 360, r = t[1] / 100, s = t[2] / 100, i = r + s, a, o, l, u;
    i > 1 && (r /= i, s /= i), a = Math.floor(6 * e), o = 1 - s, l = 6 * e - a, a & 1 && (l = 1 - l), u = r + l * (o - r);
    var c, p, f;
    switch (a) {
      default:
      case 6:
      case 0:
        c = o, p = u, f = r;
        break;
      case 1:
        c = u, p = o, f = r;
        break;
      case 2:
        c = r, p = o, f = u;
        break;
      case 3:
        c = r, p = u, f = o;
        break;
      case 4:
        c = u, p = r, f = o;
        break;
      case 5:
        c = o, p = r, f = u;
        break;
    }
    return [c * 255, p * 255, f * 255];
  };
  ge.cmyk.rgb = function(t) {
    var e = t[0] / 100, r = t[1] / 100, s = t[2] / 100, i = t[3] / 100, a, o, l;
    return a = 1 - Math.min(1, e * (1 - i) + i), o = 1 - Math.min(1, r * (1 - i) + i), l = 1 - Math.min(1, s * (1 - i) + i), [a * 255, o * 255,
    l * 255];
  };
  ge.xyz.rgb = function(t) {
    var e = t[0] / 100, r = t[1] / 100, s = t[2] / 100, i, a, o;
    return i = e * 3.2406 + r * -1.5372 + s * -0.4986, a = e * -0.9689 + r * 1.8758 + s * 0.0415, o = e * 0.0557 + r * -0.204 + s * 1.057, i =
    i > 31308e-7 ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055 : i * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a * 12.92, o =
    o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o * 12.92, i = Math.min(Math.max(0, i), 1), a = Math.min(Math.max(0, a), 1), o = Math.
    min(Math.max(0, o), 1), [i * 255, a * 255, o * 255];
  };
  ge.xyz.lab = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    return e /= 95.047, r /= 100, s /= 108.883, e = e > 8856e-6 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, r = r > 8856e-6 ? Math.pow(r, 1 /
    3) : 7.787 * r + 16 / 116, s = s > 8856e-6 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116, i = 116 * r - 16, a = 500 * (e - r), o = 200 * (r -
    s), [i, a, o];
  };
  ge.lab.xyz = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    a = (e + 16) / 116, i = r / 500 + a, o = a - s / 200;
    var l = Math.pow(a, 3), u = Math.pow(i, 3), c = Math.pow(o, 3);
    return a = l > 8856e-6 ? l : (a - 16 / 116) / 7.787, i = u > 8856e-6 ? u : (i - 16 / 116) / 7.787, o = c > 8856e-6 ? c : (o - 16 / 116) /
    7.787, i *= 95.047, a *= 100, o *= 108.883, [i, a, o];
  };
  ge.lab.lch = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    return i = Math.atan2(s, r), a = i * 360 / 2 / Math.PI, a < 0 && (a += 360), o = Math.sqrt(r * r + s * s), [e, o, a];
  };
  ge.lch.lab = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    return o = s / 360 * 2 * Math.PI, i = r * Math.cos(o), a = r * Math.sin(o), [e, i, a];
  };
  ge.rgb.ansi16 = function(t) {
    var e = t[0], r = t[1], s = t[2], i = 1 in arguments ? arguments[1] : ge.rgb.hsv(t)[2];
    if (i = Math.round(i / 50), i === 0)
      return 30;
    var a = 30 + (Math.round(s / 255) << 2 | Math.round(r / 255) << 1 | Math.round(e / 255));
    return i === 2 && (a += 60), a;
  };
  ge.hsv.ansi16 = function(t) {
    return ge.rgb.ansi16(ge.hsv.rgb(t), t[2]);
  };
  ge.rgb.ansi256 = function(t) {
    var e = t[0], r = t[1], s = t[2];
    if (e === r && r === s)
      return e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232;
    var i = 16 + 36 * Math.round(e / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(s / 255 * 5);
    return i;
  };
  ge.ansi16.rgb = function(t) {
    var e = t % 10;
    if (e === 0 || e === 7)
      return t > 50 && (e += 3.5), e = e / 10.5 * 255, [e, e, e];
    var r = (~~(t > 50) + 1) * 0.5, s = (e & 1) * r * 255, i = (e >> 1 & 1) * r * 255, a = (e >> 2 & 1) * r * 255;
    return [s, i, a];
  };
  ge.ansi256.rgb = function(t) {
    if (t >= 232) {
      var e = (t - 232) * 10 + 8;
      return [e, e, e];
    }
    t -= 16;
    var r, s = Math.floor(t / 36) / 5 * 255, i = Math.floor((r = t % 36) / 6) / 5 * 255, a = r % 6 / 5 * 255;
    return [s, i, a];
  };
  ge.rgb.hex = function(t) {
    var e = ((Math.round(t[0]) & 255) << 16) + ((Math.round(t[1]) & 255) << 8) + (Math.round(t[2]) & 255), r = e.toString(16).toUpperCase();
    return "000000".substring(r.length) + r;
  };
  ge.hex.rgb = function(t) {
    var e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!e)
      return [0, 0, 0];
    var r = e[0];
    e[0].length === 3 && (r = r.split("").map(function(l) {
      return l + l;
    }).join(""));
    var s = parseInt(r, 16), i = s >> 16 & 255, a = s >> 8 & 255, o = s & 255;
    return [i, a, o];
  };
  ge.rgb.hcg = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255, i = Math.max(Math.max(e, r), s), a = Math.min(Math.min(e, r), s), o = i - a, l, u;
    return o < 1 ? l = a / (1 - o) : l = 0, o <= 0 ? u = 0 : i === e ? u = (r - s) / o % 6 : i === r ? u = 2 + (s - e) / o : u = 4 + (e - r) /
    o + 4, u /= 6, u %= 1, [u * 360, o * 100, l * 100];
  };
  ge.hsl.hcg = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = 1, i = 0;
    return r < 0.5 ? s = 2 * e * r : s = 2 * e * (1 - r), s < 1 && (i = (r - 0.5 * s) / (1 - s)), [t[0], s * 100, i * 100];
  };
  ge.hsv.hcg = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = e * r, i = 0;
    return s < 1 && (i = (r - s) / (1 - s)), [t[0], s * 100, i * 100];
  };
  ge.hcg.rgb = function(t) {
    var e = t[0] / 360, r = t[1] / 100, s = t[2] / 100;
    if (r === 0)
      return [s * 255, s * 255, s * 255];
    var i = [0, 0, 0], a = e % 1 * 6, o = a % 1, l = 1 - o, u = 0;
    switch (Math.floor(a)) {
      case 0:
        i[0] = 1, i[1] = o, i[2] = 0;
        break;
      case 1:
        i[0] = l, i[1] = 1, i[2] = 0;
        break;
      case 2:
        i[0] = 0, i[1] = 1, i[2] = o;
        break;
      case 3:
        i[0] = 0, i[1] = l, i[2] = 1;
        break;
      case 4:
        i[0] = o, i[1] = 0, i[2] = 1;
        break;
      default:
        i[0] = 1, i[1] = 0, i[2] = l;
    }
    return u = (1 - r) * s, [
      (r * i[0] + u) * 255,
      (r * i[1] + u) * 255,
      (r * i[2] + u) * 255
    ];
  };
  ge.hcg.hsv = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = e + r * (1 - e), i = 0;
    return s > 0 && (i = e / s), [t[0], i * 100, s * 100];
  };
  ge.hcg.hsl = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = r * (1 - e) + 0.5 * e, i = 0;
    return s > 0 && s < 0.5 ? i = e / (2 * s) : s >= 0.5 && s < 1 && (i = e / (2 * (1 - s))), [t[0], i * 100, s * 100];
  };
  ge.hcg.hwb = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = e + r * (1 - e);
    return [t[0], (s - e) * 100, (1 - s) * 100];
  };
  ge.hwb.hcg = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = 1 - r, i = s - e, a = 0;
    return i < 1 && (a = (s - i) / (1 - i)), [t[0], i * 100, a * 100];
  };
  ge.apple.rgb = function(t) {
    return [t[0] / 65535 * 255, t[1] / 65535 * 255, t[2] / 65535 * 255];
  };
  ge.rgb.apple = function(t) {
    return [t[0] / 255 * 65535, t[1] / 255 * 65535, t[2] / 255 * 65535];
  };
  ge.gray.rgb = function(t) {
    return [t[0] / 100 * 255, t[0] / 100 * 255, t[0] / 100 * 255];
  };
  ge.gray.hsl = ge.gray.hsv = function(t) {
    return [0, 0, t[0]];
  };
  ge.gray.hwb = function(t) {
    return [0, 100, t[0]];
  };
  ge.gray.cmyk = function(t) {
    return [0, 0, 0, t[0]];
  };
  ge.gray.lab = function(t) {
    return [t[0], 0, 0];
  };
  ge.gray.hex = function(t) {
    var e = Math.round(t[0] / 100 * 255) & 255, r = (e << 16) + (e << 8) + e, s = r.toString(16).toUpperCase();
    return "000000".substring(s.length) + s;
  };
  ge.rgb.gray = function(t) {
    var e = (t[0] + t[1] + t[2]) / 3;
    return [e / 255 * 100];
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/route.js
var kv = w((I8e, Ov) => {
  var Qu = dy();
  function cce() {
    for (var t = {}, e = Object.keys(Qu), r = e.length, s = 0; s < r; s++)
      t[e[s]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return t;
  }
  n(cce, "buildGraph");
  function pce(t) {
    var e = cce(), r = [t];
    for (e[t].distance = 0; r.length; )
      for (var s = r.pop(), i = Object.keys(Qu[s]), a = i.length, o = 0; o < a; o++) {
        var l = i[o], u = e[l];
        u.distance === -1 && (u.distance = e[s].distance + 1, u.parent = s, r.unshift(l));
      }
    return e;
  }
  n(pce, "deriveBFS");
  function fce(t, e) {
    return function(r) {
      return e(t(r));
    };
  }
  n(fce, "link");
  function hce(t, e) {
    for (var r = [e[t].parent, t], s = Qu[e[t].parent][t], i = e[t].parent; e[i].parent; )
      r.unshift(e[i].parent), s = fce(Qu[e[i].parent][i], s), i = e[i].parent;
    return s.conversion = r, s;
  }
  n(hce, "wrapConversion");
  Ov.exports = function(t) {
    for (var e = pce(t), r = {}, s = Object.keys(e), i = s.length, a = 0; a < i; a++) {
      var o = s[a], l = e[o];
      l.parent !== null && (r[o] = hce(o, e));
    }
    return r;
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/index.js
var _v = w((N8e, Dv) => {
  var my = dy(), dce = kv(), qn = {}, mce = Object.keys(my);
  function yce(t) {
    var e = /* @__PURE__ */ n(function(r) {
      return r == null ? r : (arguments.length > 1 && (r = Array.prototype.slice.call(arguments)), t(r));
    }, "wrappedFn");
    return "conversion" in t && (e.conversion = t.conversion), e;
  }
  n(yce, "wrapRaw");
  function Tce(t) {
    var e = /* @__PURE__ */ n(function(r) {
      if (r == null)
        return r;
      arguments.length > 1 && (r = Array.prototype.slice.call(arguments));
      var s = t(r);
      if (typeof s == "object")
        for (var i = s.length, a = 0; a < i; a++)
          s[a] = Math.round(s[a]);
      return s;
    }, "wrappedFn");
    return "conversion" in t && (e.conversion = t.conversion), e;
  }
  n(Tce, "wrapRounded");
  mce.forEach(function(t) {
    qn[t] = {}, Object.defineProperty(qn[t], "channels", { value: my[t].channels }), Object.defineProperty(qn[t], "labels", { value: my[t].labels });
    var e = dce(t), r = Object.keys(e);
    r.forEach(function(s) {
      var i = e[s];
      qn[t][s] = Tce(i), qn[t][s].raw = yce(i);
    });
  });
  Dv.exports = qn;
});

// ../node_modules/@babel/highlight/node_modules/ansi-styles/index.js
var Mv = w((k8e, Lv) => {
  "use strict";
  var Vn = _v(), Zu = /* @__PURE__ */ n((t, e) => function() {
    return `\x1B[${t.apply(Vn, arguments) + e}m`;
  }, "wrapAnsi16"), ec = /* @__PURE__ */ n((t, e) => function() {
    let r = t.apply(Vn, arguments);
    return `\x1B[${38 + e};5;${r}m`;
  }, "wrapAnsi256"), tc = /* @__PURE__ */ n((t, e) => function() {
    let r = t.apply(Vn, arguments);
    return `\x1B[${38 + e};2;${r[0]};${r[1]};${r[2]}m`;
  }, "wrapAnsi16m");
  function bce() {
    let t = /* @__PURE__ */ new Map(), e = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        // Bright color
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    e.color.grey = e.color.gray;
    for (let i of Object.keys(e)) {
      let a = e[i];
      for (let o of Object.keys(a)) {
        let l = a[o];
        e[o] = {
          open: `\x1B[${l[0]}m`,
          close: `\x1B[${l[1]}m`
        }, a[o] = e[o], t.set(l[0], l[1]);
      }
      Object.defineProperty(e, i, {
        value: a,
        enumerable: !1
      }), Object.defineProperty(e, "codes", {
        value: t,
        enumerable: !1
      });
    }
    let r = /* @__PURE__ */ n((i) => i, "ansi2ansi"), s = /* @__PURE__ */ n((i, a, o) => [i, a, o], "rgb2rgb");
    e.color.close = "\x1B[39m", e.bgColor.close = "\x1B[49m", e.color.ansi = {
      ansi: Zu(r, 0)
    }, e.color.ansi256 = {
      ansi256: ec(r, 0)
    }, e.color.ansi16m = {
      rgb: tc(s, 0)
    }, e.bgColor.ansi = {
      ansi: Zu(r, 10)
    }, e.bgColor.ansi256 = {
      ansi256: ec(r, 10)
    }, e.bgColor.ansi16m = {
      rgb: tc(s, 10)
    };
    for (let i of Object.keys(Vn)) {
      if (typeof Vn[i] != "object")
        continue;
      let a = Vn[i];
      i === "ansi16" && (i = "ansi"), "ansi16" in a && (e.color.ansi[i] = Zu(a.ansi16, 0), e.bgColor.ansi[i] = Zu(a.ansi16, 10)), "ansi256" in
      a && (e.color.ansi256[i] = ec(a.ansi256, 0), e.bgColor.ansi256[i] = ec(a.ansi256, 10)), "rgb" in a && (e.color.ansi16m[i] = tc(a.rgb, 0),
      e.bgColor.ansi16m[i] = tc(a.rgb, 10));
    }
    return e;
  }
  n(bce, "assembleStyles");
  Object.defineProperty(Lv, "exports", {
    enumerable: !0,
    get: bce
  });
});

// ../node_modules/@babel/highlight/node_modules/has-flag/index.js
var Fv = w((_8e, Bv) => {
  "use strict";
  Bv.exports = (t, e) => {
    e = e || process.argv;
    let r = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", s = e.indexOf(r + t), i = e.indexOf("--");
    return s !== -1 && (i === -1 ? !0 : s < i);
  };
});

// ../node_modules/@babel/highlight/node_modules/supports-color/index.js
var Rv = w((L8e, jv) => {
  "use strict";
  var xce = require("os"), Gr = Fv(), ir = process.env, Kn;
  Gr("no-color") || Gr("no-colors") || Gr("color=false") ? Kn = !1 : (Gr("color") || Gr("colors") || Gr("color=true") || Gr("color=always")) &&
  (Kn = !0);
  "FORCE_COLOR" in ir && (Kn = ir.FORCE_COLOR.length === 0 || parseInt(ir.FORCE_COLOR, 10) !== 0);
  function Sce(t) {
    return t === 0 ? !1 : {
      level: t,
      hasBasic: !0,
      has256: t >= 2,
      has16m: t >= 3
    };
  }
  n(Sce, "translateLevel");
  function gce(t) {
    if (Kn === !1)
      return 0;
    if (Gr("color=16m") || Gr("color=full") || Gr("color=truecolor"))
      return 3;
    if (Gr("color=256"))
      return 2;
    if (t && !t.isTTY && Kn !== !0)
      return 0;
    let e = Kn ? 1 : 0;
    if (process.platform === "win32") {
      let r = xce.release().split(".");
      return Number(process.versions.node.split(".")[0]) >= 8 && Number(r[0]) >= 10 && Number(r[2]) >= 10586 ? Number(r[2]) >= 14931 ? 3 : 2 :
      1;
    }
    if ("CI" in ir)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((r) => r in ir) || ir.CI_NAME === "codeship" ? 1 : e;
    if ("TEAMCITY_VERSION" in ir)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(ir.TEAMCITY_VERSION) ? 1 : 0;
    if (ir.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in ir) {
      let r = parseInt((ir.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (ir.TERM_PROGRAM) {
        case "iTerm.app":
          return r >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(ir.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(ir.TERM) || "COLORTERM" in
    ir ? 1 : (ir.TERM === "dumb", e);
  }
  n(gce, "supportsColor");
  function yy(t) {
    let e = gce(t);
    return Sce(e);
  }
  n(yy, "getSupportLevel");
  jv.exports = {
    supportsColor: yy,
    stdout: yy(process.stdout),
    stderr: yy(process.stderr)
  };
});

// ../node_modules/@babel/highlight/node_modules/chalk/templates.js
var Wv = w((B8e, Kv) => {
  "use strict";
  var Pce = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,
  Uv = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Ece = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Ace = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, vce = /* @__PURE__ */ new Map(
  [
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function Vv(t) {
    return t[0] === "u" && t.length === 5 || t[0] === "x" && t.length === 3 ? String.fromCharCode(parseInt(t.slice(1), 16)) : vce.get(t) || t;
  }
  n(Vv, "unescape");
  function Cce(t, e) {
    let r = [], s = e.trim().split(/\s*,\s*/g), i;
    for (let a of s)
      if (!isNaN(a))
        r.push(Number(a));
      else if (i = a.match(Ece))
        r.push(i[2].replace(Ace, (o, l, u) => l ? Vv(l) : u));
      else
        throw new Error(`Invalid Chalk template style argument: ${a} (in style '${t}')`);
    return r;
  }
  n(Cce, "parseArguments");
  function Ice(t) {
    Uv.lastIndex = 0;
    let e = [], r;
    for (; (r = Uv.exec(t)) !== null; ) {
      let s = r[1];
      if (r[2]) {
        let i = Cce(s, r[2]);
        e.push([s].concat(i));
      } else
        e.push([s]);
    }
    return e;
  }
  n(Ice, "parseStyle");
  function qv(t, e) {
    let r = {};
    for (let i of e)
      for (let a of i.styles)
        r[a[0]] = i.inverse ? null : a.slice(1);
    let s = t;
    for (let i of Object.keys(r))
      if (Array.isArray(r[i])) {
        if (!(i in s))
          throw new Error(`Unknown Chalk style: ${i}`);
        r[i].length > 0 ? s = s[i].apply(s, r[i]) : s = s[i];
      }
    return s;
  }
  n(qv, "buildStyle");
  Kv.exports = (t, e) => {
    let r = [], s = [], i = [];
    if (e.replace(Pce, (a, o, l, u, c, p) => {
      if (o)
        i.push(Vv(o));
      else if (u) {
        let f = i.join("");
        i = [], s.push(r.length === 0 ? f : qv(t, r)(f)), r.push({ inverse: l, styles: Ice(u) });
      } else if (c) {
        if (r.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        s.push(qv(t, r)(i.join(""))), i = [], r.pop();
      } else
        i.push(p);
    }), s.push(i.join("")), r.length > 0) {
      let a = `Chalk template literal is missing ${r.length} closing bracket${r.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(a);
    }
    return s.join("");
  };
});

// ../node_modules/@babel/highlight/node_modules/chalk/index.js
var Hv = w((j8e, So) => {
  "use strict";
  var by = Fd(), Wt = Mv(), Ty = Rv().stdout, wce = Wv(), Jv = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith(
  "xterm"), Xv = ["ansi", "ansi", "ansi256", "ansi16m"], $v = /* @__PURE__ */ new Set(["gray"]), Wn = /* @__PURE__ */ Object.create(null);
  function Yv(t, e) {
    e = e || {};
    let r = Ty ? Ty.level : 0;
    t.level = e.level === void 0 ? r : e.level, t.enabled = "enabled" in e ? e.enabled : t.level > 0;
  }
  n(Yv, "applyOptions");
  function xo(t) {
    if (!this || !(this instanceof xo) || this.template) {
      let e = {};
      return Yv(e, t), e.template = function() {
        let r = [].slice.call(arguments);
        return kce.apply(null, [e.template].concat(r));
      }, Object.setPrototypeOf(e, xo.prototype), Object.setPrototypeOf(e.template, e), e.template.constructor = xo, e.template;
    }
    Yv(this, t);
  }
  n(xo, "Chalk");
  Jv && (Wt.blue.open = "\x1B[94m");
  for (let t of Object.keys(Wt))
    Wt[t].closeRe = new RegExp(by(Wt[t].close), "g"), Wn[t] = {
      get() {
        let e = Wt[t];
        return rc.call(this, this._styles ? this._styles.concat(e) : [e], this._empty, t);
      }
    };
  Wn.visible = {
    get() {
      return rc.call(this, this._styles || [], !0, "visible");
    }
  };
  Wt.color.closeRe = new RegExp(by(Wt.color.close), "g");
  for (let t of Object.keys(Wt.color.ansi))
    $v.has(t) || (Wn[t] = {
      get() {
        let e = this.level;
        return function() {
          let s = {
            open: Wt.color[Xv[e]][t].apply(null, arguments),
            close: Wt.color.close,
            closeRe: Wt.color.closeRe
          };
          return rc.call(this, this._styles ? this._styles.concat(s) : [s], this._empty, t);
        };
      }
    });
  Wt.bgColor.closeRe = new RegExp(by(Wt.bgColor.close), "g");
  for (let t of Object.keys(Wt.bgColor.ansi)) {
    if ($v.has(t))
      continue;
    let e = "bg" + t[0].toUpperCase() + t.slice(1);
    Wn[e] = {
      get() {
        let r = this.level;
        return function() {
          let i = {
            open: Wt.bgColor[Xv[r]][t].apply(null, arguments),
            close: Wt.bgColor.close,
            closeRe: Wt.bgColor.closeRe
          };
          return rc.call(this, this._styles ? this._styles.concat(i) : [i], this._empty, t);
        };
      }
    };
  }
  var Nce = Object.defineProperties(() => {
  }, Wn);
  function rc(t, e, r) {
    let s = /* @__PURE__ */ n(function() {
      return Oce.apply(s, arguments);
    }, "builder");
    s._styles = t, s._empty = e;
    let i = this;
    return Object.defineProperty(s, "level", {
      enumerable: !0,
      get() {
        return i.level;
      },
      set(a) {
        i.level = a;
      }
    }), Object.defineProperty(s, "enabled", {
      enumerable: !0,
      get() {
        return i.enabled;
      },
      set(a) {
        i.enabled = a;
      }
    }), s.hasGrey = this.hasGrey || r === "gray" || r === "grey", s.__proto__ = Nce, s;
  }
  n(rc, "build");
  function Oce() {
    let t = arguments, e = t.length, r = String(arguments[0]);
    if (e === 0)
      return "";
    if (e > 1)
      for (let i = 1; i < e; i++)
        r += " " + t[i];
    if (!this.enabled || this.level <= 0 || !r)
      return this._empty ? "" : r;
    let s = Wt.dim.open;
    Jv && this.hasGrey && (Wt.dim.open = "");
    for (let i of this._styles.slice().reverse())
      r = i.open + r.replace(i.closeRe, i.open) + i.close, r = r.replace(/\r?\n/g, `${i.close}$&${i.open}`);
    return Wt.dim.open = s, r;
  }
  n(Oce, "applyStyle");
  function kce(t, e) {
    if (!Array.isArray(e))
      return [].slice.call(arguments, 1).join(" ");
    let r = [].slice.call(arguments, 2), s = [e.raw[0]];
    for (let i = 1; i < e.length; i++)
      s.push(String(r[i - 1]).replace(/[{}\\]/g, "\\$&")), s.push(String(e.raw[i]));
    return wce(t, s.join(""));
  }
  n(kce, "chalkTag");
  Object.defineProperties(xo.prototype, Wn);
  So.exports = xo();
  So.exports.supportsColor = Ty;
  So.exports.default = So.exports;
});

// ../node_modules/@babel/highlight/lib/index.js
var sC = w((go) => {
  "use strict";
  Object.defineProperty(go, "__esModule", {
    value: !0
  });
  go.default = Rce;
  go.shouldHighlight = rC;
  var zv = kd(), Gv = Ta(), Sy = Dce(Ya(), !0);
  function Zv(t) {
    if (typeof WeakMap != "function") return null;
    var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (Zv = /* @__PURE__ */ n(function(s) {
      return s ? r : e;
    }, "_getRequireWildcardCache"))(t);
  }
  n(Zv, "_getRequireWildcardCache");
  function Dce(t, e) {
    if (!e && t && t.__esModule) return t;
    if (t === null || typeof t != "object" && typeof t != "function") return { default: t };
    var r = Zv(e);
    if (r && r.has(t)) return r.get(t);
    var s = { __proto__: null }, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t) if (a !== "default" && {}.hasOwnProperty.call(t, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(t, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(s, a, o) : s[a] = t[a];
    }
    return s.default = t, r && r.set(t, s), s;
  }
  n(Dce, "_interopRequireWildcard");
  var eC = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, Sy.createColors)(!1) :
  Sy.default, Qv = /* @__PURE__ */ n((t, e) => (r) => t(e(r)), "compose"), _ce = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of",
  "set"]);
  function Lce(t) {
    return {
      keyword: t.cyan,
      capitalized: t.yellow,
      jsxIdentifier: t.yellow,
      punctuator: t.yellow,
      number: t.magenta,
      string: t.green,
      regex: t.magenta,
      comment: t.gray,
      invalid: Qv(Qv(t.white, t.bgRed), t.bold)
    };
  }
  n(Lce, "getDefs");
  var Mce = /\r\n|[\n\r\u2028\u2029]/, Bce = /^[()[\]{}]$/, tC;
  {
    let t = /^[a-z][\w-]*$/i, e = /* @__PURE__ */ n(function(r, s, i) {
      if (r.type === "name") {
        if ((0, Gv.isKeyword)(r.value) || (0, Gv.isStrictReservedWord)(r.value, !0) || _ce.has(r.value))
          return "keyword";
        if (t.test(r.value) && (i[s - 1] === "<" || i.slice(s - 2, s) === "</"))
          return "jsxIdentifier";
        if (r.value[0] !== r.value[0].toLowerCase())
          return "capitalized";
      }
      return r.type === "punctuator" && Bce.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punc\
tuator" : r.type;
    }, "getTokenType");
    tC = /* @__PURE__ */ n(function* (r) {
      let s;
      for (; s = zv.default.exec(r); ) {
        let i = zv.matchToToken(s);
        yield {
          type: e(i, s.index, r),
          value: i.value
        };
      }
    }, "tokenize");
  }
  function Fce(t, e) {
    let r = "";
    for (let {
      type: s,
      value: i
    } of tC(e)) {
      let a = t[s];
      a ? r += i.split(Mce).map((o) => a(o)).join(`
`) : r += i;
    }
    return r;
  }
  n(Fce, "highlightTokens");
  function rC(t) {
    return eC.isColorSupported || t.forceColor;
  }
  n(rC, "shouldHighlight");
  var xy;
  function jce(t) {
    if (t) {
      var e;
      return (e = xy) != null || (xy = (0, Sy.createColors)(!0)), xy;
    }
    return eC;
  }
  n(jce, "getColors");
  function Rce(t, e = {}) {
    if (t !== "" && rC(e)) {
      let r = Lce(jce(e.forceColor));
      return Fce(r, t);
    } else
      return t;
  }
  n(Rce, "highlight");
  {
    let t, e;
    go.getChalk = ({
      forceColor: r
    }) => {
      var s;
      if ((s = t) != null || (t = Hv()), r) {
        var i;
        return (i = e) != null || (e = new t.constructor({
          enabled: !0,
          level: 1
        })), e;
      }
      return t;
    };
  }
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/node_modules/@babel/code-frame/lib/index.js
var cC = w((sc) => {
  "use strict";
  Object.defineProperty(sc, "__esModule", {
    value: !0
  });
  sc.codeFrameColumns = uC;
  sc.default = Yce;
  var iC = sC(), Py = Uce(Ya(), !0);
  function lC(t) {
    if (typeof WeakMap != "function") return null;
    var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (lC = /* @__PURE__ */ n(function(s) {
      return s ? r : e;
    }, "_getRequireWildcardCache"))(t);
  }
  n(lC, "_getRequireWildcardCache");
  function Uce(t, e) {
    if (!e && t && t.__esModule) return t;
    if (t === null || typeof t != "object" && typeof t != "function") return { default: t };
    var r = lC(e);
    if (r && r.has(t)) return r.get(t);
    var s = { __proto__: null }, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t) if (a !== "default" && {}.hasOwnProperty.call(t, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(t, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(s, a, o) : s[a] = t[a];
    }
    return s.default = t, r && r.set(t, s), s;
  }
  n(Uce, "_interopRequireWildcard");
  var qce = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, Py.createColors)(!1) :
  Py.default, nC = /* @__PURE__ */ n((t, e) => (r) => t(e(r)), "compose"), gy;
  function Vce(t) {
    if (t) {
      var e;
      return (e = gy) != null || (gy = (0, Py.createColors)(!0)), gy;
    }
    return qce;
  }
  n(Vce, "getColors");
  var aC = !1;
  function Kce(t) {
    return {
      gutter: t.gray,
      marker: nC(t.red, t.bold),
      message: nC(t.red, t.bold)
    };
  }
  n(Kce, "getDefs");
  var oC = /\r\n|[\n\r\u2028\u2029]/;
  function Wce(t, e, r) {
    let s = Object.assign({
      column: 0,
      line: -1
    }, t.start), i = Object.assign({}, s, t.end), {
      linesAbove: a = 2,
      linesBelow: o = 3
    } = r || {}, l = s.line, u = s.column, c = i.line, p = i.column, f = Math.max(l - (a + 1), 0), m = Math.min(e.length, c + o);
    l === -1 && (f = 0), c === -1 && (m = e.length);
    let y = c - l, T = {};
    if (y)
      for (let L = 0; L <= y; L++) {
        let q = L + l;
        if (!u)
          T[q] = !0;
        else if (L === 0) {
          let _ = e[q - 1].length;
          T[q] = [u, _ - u + 1];
        } else if (L === y)
          T[q] = [0, p];
        else {
          let _ = e[q - L].length;
          T[q] = [0, _];
        }
      }
    else
      u === p ? u ? T[l] = [u, 0] : T[l] = !0 : T[l] = [u, p - u];
    return {
      start: f,
      end: m,
      markerLines: T
    };
  }
  n(Wce, "getMarkerLines");
  function uC(t, e, r = {}) {
    let s = (r.highlightCode || r.forceColor) && (0, iC.shouldHighlight)(r), i = Vce(r.forceColor), a = Kce(i), o = /* @__PURE__ */ n((L, q) => s ?
    L(q) : q, "maybeHighlight"), l = t.split(oC), {
      start: u,
      end: c,
      markerLines: p
    } = Wce(e, l, r), f = e.start && typeof e.start.column == "number", m = String(c).length, T = (s ? (0, iC.default)(t, r) : t).split(oC, c).
    slice(u, c).map((L, q) => {
      let _ = u + 1 + q, J = ` ${` ${_}`.slice(-m)} |`, ie = p[_], de = !p[_ + 1];
      if (ie) {
        let ne = "";
        if (Array.isArray(ie)) {
          let Be = L.slice(0, Math.max(ie[0] - 1, 0)).replace(/[^\t]/g, " "), bt = ie[1] || 1;
          ne = [`
 `, o(a.gutter, J.replace(/\d/g, " ")), " ", Be, o(a.marker, "^").repeat(bt)].join(""), de && r.message && (ne += " " + o(a.message, r.message));
        }
        return [o(a.marker, ">"), o(a.gutter, J), L.length > 0 ? ` ${L}` : "", ne].join("");
      } else
        return ` ${o(a.gutter, J)}${L.length > 0 ? ` ${L}` : ""}`;
    }).join(`
`);
    return r.message && !f && (T = `${" ".repeat(m + 1)}${r.message}
${T}`), s ? i.reset(T) : T;
  }
  n(uC, "codeFrameColumns");
  function Yce(t, e, r, s = {}) {
    if (!aC) {
      aC = !0;
      let a = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning)
        process.emitWarning(a, "DeprecationWarning");
      else {
        let o = new Error(a);
        o.name = "DeprecationWarning", console.warn(new Error(a));
      }
    }
    return r = Math.max(r, 0), uC(t, {
      start: {
        column: r,
        line: e
      }
    }, s);
  }
  n(Yce, "_default");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/parse.js
var Ay = w((Ey) => {
  "use strict";
  Object.defineProperty(Ey, "__esModule", {
    value: !0
  });
  Ey.default = npe;
  var Jce = Ce(), Xce = Ev(), $ce = cC(), {
    isCallExpression: Hce,
    isExpressionStatement: zce,
    isFunction: Gce,
    isIdentifier: Qce,
    isJSXIdentifier: Zce,
    isNewExpression: epe,
    isPlaceholder: ic,
    isStatement: tpe,
    isStringLiteral: pC,
    removePropertiesDeep: rpe,
    traverse: spe
  } = Jce, ipe = /^[_$A-Z0-9]+$/;
  function npe(t, e, r) {
    let {
      placeholderWhitelist: s,
      placeholderPattern: i,
      preserveComments: a,
      syntacticPlaceholders: o
    } = r, l = lpe(e, r.parser, o);
    rpe(l, {
      preserveComments: a
    }), t.validate(l);
    let u = {
      syntactic: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      placeholderWhitelist: s,
      placeholderPattern: i,
      syntacticPlaceholders: o
    };
    return spe(l, ape, u), Object.assign({
      ast: l
    }, u.syntactic.placeholders.length ? u.syntactic : u.legacy);
  }
  n(npe, "parseAndBuildMetadata");
  function ape(t, e, r) {
    var s;
    let i, a = r.syntactic.placeholders.length > 0;
    if (ic(t)) {
      if (r.syntacticPlaceholders === !1)
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      i = t.name.name, a = !0;
    } else {
      if (a || r.syntacticPlaceholders)
        return;
      if (Qce(t) || Zce(t))
        i = t.name;
      else if (pC(t))
        i = t.value;
      else
        return;
    }
    if (a && (r.placeholderPattern != null || r.placeholderWhitelist != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (!a && (r.placeholderPattern === !1 || !(r.placeholderPattern || ipe).test(i)) && !((s = r.placeholderWhitelist) != null && s.has(i)))
      return;
    e = e.slice();
    let {
      node: o,
      key: l
    } = e[e.length - 1], u;
    pC(t) || ic(t, {
      expectedNode: "StringLiteral"
    }) ? u = "string" : epe(o) && l === "arguments" || Hce(o) && l === "arguments" || Gce(o) && l === "params" ? u = "param" : zce(o) && !ic(
    t) ? (u = "statement", e = e.slice(0, -1)) : tpe(t) && ic(t) ? u = "statement" : u = "other";
    let {
      placeholders: c,
      placeholderNames: p
    } = a ? r.syntactic : r.legacy;
    c.push({
      name: i,
      type: u,
      resolve: /* @__PURE__ */ n((f) => ope(f, e), "resolve"),
      isDuplicate: p.has(i)
    }), p.add(i);
  }
  n(ape, "placeholderVisitorHandler");
  function ope(t, e) {
    let r = t;
    for (let a = 0; a < e.length - 1; a++) {
      let {
        key: o,
        index: l
      } = e[a];
      l === void 0 ? r = r[o] : r = r[o][l];
    }
    let {
      key: s,
      index: i
    } = e[e.length - 1];
    return {
      parent: r,
      key: s,
      index: i
    };
  }
  n(ope, "resolveAncestors");
  function lpe(t, e, r) {
    let s = (e.plugins || []).slice();
    r !== !1 && s.push("placeholders"), e = Object.assign({
      allowReturnOutsideFunction: !0,
      allowSuperOutsideMethod: !0,
      sourceType: "module"
    }, e, {
      plugins: s
    });
    try {
      return (0, Xce.parse)(t, e);
    } catch (i) {
      let a = i.loc;
      throw a && (i.message += `
` + (0, $ce.codeFrameColumns)(t, {
        start: a
      }), i.code = "BABEL_TEMPLATE_PARSE_ERROR"), i;
    }
  }
  n(lpe, "parseWithCodeFrame");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/populate.js
var wy = w((Iy) => {
  "use strict";
  Object.defineProperty(Iy, "__esModule", {
    value: !0
  });
  Iy.default = dpe;
  var upe = Ce(), {
    blockStatement: cpe,
    cloneNode: Cy,
    emptyStatement: ppe,
    expressionStatement: vy,
    identifier: nc,
    isStatement: fC,
    isStringLiteral: fpe,
    stringLiteral: hpe,
    validate: hC
  } = upe;
  function dpe(t, e) {
    let r = Cy(t.ast);
    return e && (t.placeholders.forEach((s) => {
      if (!hasOwnProperty.call(e, s.name)) {
        let i = s.name;
        throw new Error(`Error: No substitution given for "${i}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${i}'])}
            - { placeholderPattern: /^${i}$/ }`);
      }
    }), Object.keys(e).forEach((s) => {
      if (!t.placeholderNames.has(s))
        throw new Error(`Unknown substitution "${s}" given`);
    })), t.placeholders.slice().reverse().forEach((s) => {
      try {
        mpe(s, r, e && e[s.name] || null);
      } catch (i) {
        throw i.message = `@babel/template placeholder "${s.name}": ${i.message}`, i;
      }
    }), r;
  }
  n(dpe, "populatePlaceholders");
  function mpe(t, e, r) {
    t.isDuplicate && (Array.isArray(r) ? r = r.map((o) => Cy(o)) : typeof r == "object" && (r = Cy(r)));
    let {
      parent: s,
      key: i,
      index: a
    } = t.resolve(e);
    if (t.type === "string") {
      if (typeof r == "string" && (r = hpe(r)), !r || !fpe(r))
        throw new Error("Expected string substitution");
    } else if (t.type === "statement")
      a === void 0 ? r ? Array.isArray(r) ? r = cpe(r) : typeof r == "string" ? r = vy(nc(r)) : fC(r) || (r = vy(r)) : r = ppe() : r && !Array.
      isArray(r) && (typeof r == "string" && (r = nc(r)), fC(r) || (r = vy(r)));
    else if (t.type === "param") {
      if (typeof r == "string" && (r = nc(r)), a === void 0) throw new Error("Assertion failure.");
    } else if (typeof r == "string" && (r = nc(r)), Array.isArray(r))
      throw new Error("Cannot replace single expression with an array.");
    if (a === void 0)
      hC(s, i, r), s[i] = r;
    else {
      let o = s[i].slice();
      t.type === "statement" || t.type === "param" ? r == null ? o.splice(a, 1) : Array.isArray(r) ? o.splice(a, 1, ...r) : o[a] = r : o[a] =
      r, hC(s, i, o), s[i] = o;
    }
  }
  n(mpe, "applyReplacement");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/string.js
var dC = w((Ny) => {
  "use strict";
  Object.defineProperty(Ny, "__esModule", {
    value: !0
  });
  Ny.default = xpe;
  var ype = Uu(), Tpe = Ay(), bpe = wy();
  function xpe(t, e, r) {
    e = t.code(e);
    let s;
    return (i) => {
      let a = (0, ype.normalizeReplacements)(i);
      return s || (s = (0, Tpe.default)(t, e, r)), t.unwrap((0, bpe.default)(s, a));
    };
  }
  n(xpe, "stringTemplate");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/literal.js
var mC = w((Oy) => {
  "use strict";
  Object.defineProperty(Oy, "__esModule", {
    value: !0
  });
  Oy.default = Epe;
  var Spe = Uu(), gpe = Ay(), Ppe = wy();
  function Epe(t, e, r) {
    let {
      metadata: s,
      names: i
    } = Ape(t, e, r);
    return (a) => {
      let o = {};
      return a.forEach((l, u) => {
        o[i[u]] = l;
      }), (l) => {
        let u = (0, Spe.normalizeReplacements)(l);
        return u && Object.keys(u).forEach((c) => {
          if (hasOwnProperty.call(o, c))
            throw new Error("Unexpected replacement overlap.");
        }), t.unwrap((0, Ppe.default)(s, u ? Object.assign(u, o) : o));
      };
    };
  }
  n(Epe, "literalTemplate");
  function Ape(t, e, r) {
    let s = "BABEL_TPL$", i = e.join("");
    do
      s = "$$" + s;
    while (i.includes(s));
    let {
      names: a,
      code: o
    } = vpe(e, s);
    return {
      metadata: (0, gpe.default)(t, t.code(o), {
        parser: r.parser,
        placeholderWhitelist: new Set(a.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
        placeholderPattern: r.placeholderPattern,
        preserveComments: r.preserveComments,
        syntacticPlaceholders: r.syntacticPlaceholders
      }),
      names: a
    };
  }
  n(Ape, "buildLiteralData");
  function vpe(t, e) {
    let r = [], s = t[0];
    for (let i = 1; i < t.length; i++) {
      let a = `${e}${i - 1}`;
      r.push(a), s += a + t[i];
    }
    return {
      names: r,
      code: s
    };
  }
  n(vpe, "buildTemplateCode");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/builder.js
var gC = w((ky) => {
  "use strict";
  Object.defineProperty(ky, "__esModule", {
    value: !0
  });
  ky.default = SC;
  var cs = Uu(), yC = dC(), TC = mC(), bC = (0, cs.validate)({
    placeholderPattern: !1
  });
  function SC(t, e) {
    let r = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap(), i = e || (0, cs.validate)(null);
    return Object.assign((a, ...o) => {
      if (typeof a == "string") {
        if (o.length > 1) throw new Error("Unexpected extra params.");
        return xC((0, yC.default)(t, a, (0, cs.merge)(i, (0, cs.validate)(o[0]))));
      } else if (Array.isArray(a)) {
        let l = r.get(a);
        return l || (l = (0, TC.default)(t, a, i), r.set(a, l)), xC(l(o));
      } else if (typeof a == "object" && a) {
        if (o.length > 0) throw new Error("Unexpected extra params.");
        return SC(t, (0, cs.merge)(i, (0, cs.validate)(a)));
      }
      throw new Error(`Unexpected template param ${typeof a}`);
    }, {
      ast: /* @__PURE__ */ n((a, ...o) => {
        if (typeof a == "string") {
          if (o.length > 1) throw new Error("Unexpected extra params.");
          return (0, yC.default)(t, a, (0, cs.merge)((0, cs.merge)(i, (0, cs.validate)(o[0])), bC))();
        } else if (Array.isArray(a)) {
          let l = s.get(a);
          return l || (l = (0, TC.default)(t, a, (0, cs.merge)(i, bC)), s.set(a, l)), l(o)();
        }
        throw new Error(`Unexpected template param ${typeof a}`);
      }, "ast")
    });
  }
  n(SC, "createTemplateBuilder");
  function xC(t) {
    let e = "";
    try {
      throw new Error();
    } catch (r) {
      r.stack && (e = r.stack.split(`
`).slice(3).join(`
`));
    }
    return (r) => {
      try {
        return t(r);
      } catch (s) {
        throw s.stack += `
    =============
${e}`, s;
      }
    };
  }
  n(xC, "extendedTrace");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/index.js
var PC = w((Or) => {
  "use strict";
  Object.defineProperty(Or, "__esModule", {
    value: !0
  });
  Or.statements = Or.statement = Or.smart = Or.program = Or.expression = Or.default = void 0;
  var Po = W1(), Eo = gC(), Dy = Or.smart = (0, Eo.default)(Po.smart), Cpe = Or.statement = (0, Eo.default)(Po.statement), Ipe = Or.statements =
  (0, Eo.default)(Po.statements), wpe = Or.expression = (0, Eo.default)(Po.expression), Npe = Or.program = (0, Eo.default)(Po.program), e6e = Or.
  default = Object.assign(Dy.bind(void 0), {
    smart: Dy,
    statement: Cpe,
    statements: Ipe,
    expression: wpe,
    program: Npe,
    ast: Dy.ast
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/utils/shallowEqual.js
var ac = w((_y) => {
  "use strict";
  Object.defineProperty(_y, "__esModule", {
    value: !0
  });
  _y.default = Ope;
  function Ope(t, e) {
    let r = Object.keys(e);
    for (let s of r)
      if (t[s] !== e[s])
        return !1;
    return !0;
  }
  n(Ope, "shallowEqual");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/utils/deprecationWarning.js
var Ao = w((Ly) => {
  "use strict";
  Object.defineProperty(Ly, "__esModule", {
    value: !0
  });
  Ly.default = kpe;
  var EC = /* @__PURE__ */ new Set();
  function kpe(t, e, r = "") {
    if (EC.has(t)) return;
    EC.add(t);
    let {
      internal: s,
      trace: i
    } = Dpe(1, 2);
    s || console.warn(`${r}\`${t}\` has been deprecated, please migrate to \`${e}\`
${i}`);
  }
  n(kpe, "deprecationWarning");
  function Dpe(t, e) {
    let {
      stackTraceLimit: r,
      prepareStackTrace: s
    } = Error, i;
    if (Error.stackTraceLimit = 1 + t + e, Error.prepareStackTrace = function(o, l) {
      i = l;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = s, !i) return {
      internal: !1,
      trace: ""
    };
    let a = i.slice(1 + t, 1 + t + e);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  n(Dpe, "captureShortStackTrace");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/generated/index.js
var Rt = w((P) => {
  "use strict";
  Object.defineProperty(P, "__esModule", {
    value: !0
  });
  P.isAccessor = Jye;
  P.isAnyTypeAnnotation = hhe;
  P.isArgumentPlaceholder = Vde;
  P.isArrayExpression = _pe;
  P.isArrayPattern = kfe;
  P.isArrayTypeAnnotation = dhe;
  P.isArrowFunctionExpression = Dfe;
  P.isAssignmentExpression = Lpe;
  P.isAssignmentPattern = Ofe;
  P.isAwaitExpression = the;
  P.isBigIntLiteral = she;
  P.isBinary = mye;
  P.isBinaryExpression = Mpe;
  P.isBindExpression = Kde;
  P.isBlock = bye;
  P.isBlockParent = Tye;
  P.isBlockStatement = Rpe;
  P.isBooleanLiteral = afe;
  P.isBooleanLiteralTypeAnnotation = yhe;
  P.isBooleanTypeAnnotation = mhe;
  P.isBreakStatement = Upe;
  P.isCallExpression = qpe;
  P.isCatchClause = Vpe;
  P.isClass = Kye;
  P.isClassAccessorProperty = lhe;
  P.isClassBody = _fe;
  P.isClassDeclaration = Mfe;
  P.isClassExpression = Lfe;
  P.isClassImplements = bhe;
  P.isClassMethod = Xfe;
  P.isClassPrivateMethod = che;
  P.isClassPrivateProperty = uhe;
  P.isClassProperty = ohe;
  P.isCompletionStatement = gye;
  P.isConditional = Pye;
  P.isConditionalExpression = Kpe;
  P.isContinueStatement = Wpe;
  P.isDebuggerStatement = Ype;
  P.isDecimalLiteral = zde;
  P.isDeclaration = kye;
  P.isDeclareClass = xhe;
  P.isDeclareExportAllDeclaration = whe;
  P.isDeclareExportDeclaration = Ihe;
  P.isDeclareFunction = She;
  P.isDeclareInterface = ghe;
  P.isDeclareModule = Phe;
  P.isDeclareModuleExports = Ehe;
  P.isDeclareOpaqueType = vhe;
  P.isDeclareTypeAlias = Ahe;
  P.isDeclareVariable = Che;
  P.isDeclaredPredicate = Nhe;
  P.isDecorator = Yde;
  P.isDirective = Fpe;
  P.isDirectiveLiteral = jpe;
  P.isDoExpression = Jde;
  P.isDoWhileStatement = Jpe;
  P.isEmptyStatement = Xpe;
  P.isEmptyTypeAnnotation = Uhe;
  P.isEnumBody = Zye;
  P.isEnumBooleanBody = dde;
  P.isEnumBooleanMember = bde;
  P.isEnumDeclaration = hde;
  P.isEnumDefaultedMember = gde;
  P.isEnumMember = eTe;
  P.isEnumNumberBody = mde;
  P.isEnumNumberMember = xde;
  P.isEnumStringBody = yde;
  P.isEnumStringMember = Sde;
  P.isEnumSymbolBody = Tde;
  P.isExistsTypeAnnotation = Ohe;
  P.isExportAllDeclaration = Bfe;
  P.isExportDeclaration = Wye;
  P.isExportDefaultDeclaration = Ffe;
  P.isExportDefaultSpecifier = Xde;
  P.isExportNamedDeclaration = jfe;
  P.isExportNamespaceSpecifier = ihe;
  P.isExportSpecifier = Rfe;
  P.isExpression = dye;
  P.isExpressionStatement = $pe;
  P.isExpressionWrapper = vye;
  P.isFile = Hpe;
  P.isFlow = $ye;
  P.isFlowBaseAnnotation = zye;
  P.isFlowDeclaration = Gye;
  P.isFlowPredicate = Qye;
  P.isFlowType = Hye;
  P.isFor = Cye;
  P.isForInStatement = zpe;
  P.isForOfStatement = Ufe;
  P.isForStatement = Gpe;
  P.isForXStatement = Iye;
  P.isFunction = wye;
  P.isFunctionDeclaration = Qpe;
  P.isFunctionExpression = Zpe;
  P.isFunctionParent = Nye;
  P.isFunctionTypeAnnotation = khe;
  P.isFunctionTypeParam = Dhe;
  P.isGenericTypeAnnotation = _he;
  P.isIdentifier = efe;
  P.isIfStatement = tfe;
  P.isImmutable = Bye;
  P.isImport = rhe;
  P.isImportAttribute = Wde;
  P.isImportDeclaration = qfe;
  P.isImportDefaultSpecifier = Vfe;
  P.isImportExpression = Yfe;
  P.isImportNamespaceSpecifier = Kfe;
  P.isImportOrExportDeclaration = AC;
  P.isImportSpecifier = Wfe;
  P.isIndexedAccessType = Pde;
  P.isInferredPredicate = Lhe;
  P.isInterfaceDeclaration = Bhe;
  P.isInterfaceExtends = Mhe;
  P.isInterfaceTypeAnnotation = Fhe;
  P.isInterpreterDirective = Bpe;
  P.isIntersectionTypeAnnotation = jhe;
  P.isJSX = tTe;
  P.isJSXAttribute = Ade;
  P.isJSXClosingElement = vde;
  P.isJSXClosingFragment = jde;
  P.isJSXElement = Cde;
  P.isJSXEmptyExpression = Ide;
  P.isJSXExpressionContainer = wde;
  P.isJSXFragment = Bde;
  P.isJSXIdentifier = Ode;
  P.isJSXMemberExpression = kde;
  P.isJSXNamespacedName = Dde;
  P.isJSXOpeningElement = _de;
  P.isJSXOpeningFragment = Fde;
  P.isJSXSpreadAttribute = Lde;
  P.isJSXSpreadChild = Nde;
  P.isJSXText = Mde;
  P.isLVal = _ye;
  P.isLabeledStatement = rfe;
  P.isLiteral = Mye;
  P.isLogicalExpression = lfe;
  P.isLoop = Eye;
  P.isMemberExpression = ufe;
  P.isMetaProperty = Jfe;
  P.isMethod = jye;
  P.isMiscellaneous = rTe;
  P.isMixedTypeAnnotation = Rhe;
  P.isModuleDeclaration = pTe;
  P.isModuleExpression = Gde;
  P.isModuleSpecifier = Yye;
  P.isNewExpression = cfe;
  P.isNoop = Rde;
  P.isNullLiteral = nfe;
  P.isNullLiteralTypeAnnotation = The;
  P.isNullableTypeAnnotation = qhe;
  P.isNumberLiteral = oTe;
  P.isNumberLiteralTypeAnnotation = Vhe;
  P.isNumberTypeAnnotation = Khe;
  P.isNumericLiteral = ife;
  P.isObjectExpression = ffe;
  P.isObjectMember = Rye;
  P.isObjectMethod = hfe;
  P.isObjectPattern = $fe;
  P.isObjectProperty = dfe;
  P.isObjectTypeAnnotation = Whe;
  P.isObjectTypeCallProperty = Jhe;
  P.isObjectTypeIndexer = Xhe;
  P.isObjectTypeInternalSlot = Yhe;
  P.isObjectTypeProperty = $he;
  P.isObjectTypeSpreadProperty = Hhe;
  P.isOpaqueType = zhe;
  P.isOptionalCallExpression = ahe;
  P.isOptionalIndexedAccessType = Ede;
  P.isOptionalMemberExpression = nhe;
  P.isParenthesizedExpression = bfe;
  P.isPattern = Vye;
  P.isPatternLike = Dye;
  P.isPipelineBareFunction = eme;
  P.isPipelinePrimaryTopicReference = tme;
  P.isPipelineTopicExpression = Zde;
  P.isPlaceholder = Ude;
  P.isPrivate = Xye;
  P.isPrivateName = phe;
  P.isProgram = pfe;
  P.isProperty = Uye;
  P.isPureish = Oye;
  P.isQualifiedTypeIdentifier = Ghe;
  P.isRecordExpression = $de;
  P.isRegExpLiteral = ofe;
  P.isRegexLiteral = lTe;
  P.isRestElement = mfe;
  P.isRestProperty = uTe;
  P.isReturnStatement = yfe;
  P.isScopable = yye;
  P.isSequenceExpression = Tfe;
  P.isSpreadElement = Hfe;
  P.isSpreadProperty = cTe;
  P.isStandardized = hye;
  P.isStatement = xye;
  P.isStaticBlock = fhe;
  P.isStringLiteral = sfe;
  P.isStringLiteralTypeAnnotation = Qhe;
  P.isStringTypeAnnotation = Zhe;
  P.isSuper = zfe;
  P.isSwitchCase = xfe;
  P.isSwitchStatement = Sfe;
  P.isSymbolTypeAnnotation = ede;
  P.isTSAnyKeyword = pme;
  P.isTSArrayType = kme;
  P.isTSAsExpression = zme;
  P.isTSBaseType = aTe;
  P.isTSBigIntKeyword = hme;
  P.isTSBooleanKeyword = fme;
  P.isTSCallSignatureDeclaration = ame;
  P.isTSConditionalType = jme;
  P.isTSConstructSignatureDeclaration = ome;
  P.isTSConstructorType = Cme;
  P.isTSDeclareFunction = sme;
  P.isTSDeclareMethod = ime;
  P.isTSEntityName = Lye;
  P.isTSEnumDeclaration = Zme;
  P.isTSEnumMember = eye;
  P.isTSExportAssignment = oye;
  P.isTSExpressionWithTypeArguments = Yme;
  P.isTSExternalModuleReference = nye;
  P.isTSFunctionType = vme;
  P.isTSImportEqualsDeclaration = iye;
  P.isTSImportType = sye;
  P.isTSIndexSignature = cme;
  P.isTSIndexedAccessType = Vme;
  P.isTSInferType = Rme;
  P.isTSInstantiationExpression = Hme;
  P.isTSInterfaceBody = Xme;
  P.isTSInterfaceDeclaration = Jme;
  P.isTSIntersectionType = Fme;
  P.isTSIntrinsicKeyword = dme;
  P.isTSLiteralType = Wme;
  P.isTSMappedType = Kme;
  P.isTSMethodSignature = ume;
  P.isTSModuleBlock = rye;
  P.isTSModuleDeclaration = tye;
  P.isTSNamedTupleMember = Mme;
  P.isTSNamespaceExportDeclaration = lye;
  P.isTSNeverKeyword = mme;
  P.isTSNonNullExpression = aye;
  P.isTSNullKeyword = yme;
  P.isTSNumberKeyword = Tme;
  P.isTSObjectKeyword = bme;
  P.isTSOptionalType = _me;
  P.isTSParameterProperty = rme;
  P.isTSParenthesizedType = Ume;
  P.isTSPropertySignature = lme;
  P.isTSQualifiedName = nme;
  P.isTSRestType = Lme;
  P.isTSSatisfiesExpression = Gme;
  P.isTSStringKeyword = xme;
  P.isTSSymbolKeyword = Sme;
  P.isTSThisType = Ame;
  P.isTSTupleType = Dme;
  P.isTSType = nTe;
  P.isTSTypeAliasDeclaration = $me;
  P.isTSTypeAnnotation = uye;
  P.isTSTypeAssertion = Qme;
  P.isTSTypeElement = iTe;
  P.isTSTypeLiteral = Ome;
  P.isTSTypeOperator = qme;
  P.isTSTypeParameter = fye;
  P.isTSTypeParameterDeclaration = pye;
  P.isTSTypeParameterInstantiation = cye;
  P.isTSTypePredicate = wme;
  P.isTSTypeQuery = Nme;
  P.isTSTypeReference = Ime;
  P.isTSUndefinedKeyword = gme;
  P.isTSUnionType = Bme;
  P.isTSUnknownKeyword = Pme;
  P.isTSVoidKeyword = Eme;
  P.isTaggedTemplateExpression = Gfe;
  P.isTemplateElement = Qfe;
  P.isTemplateLiteral = Zfe;
  P.isTerminatorless = Sye;
  P.isThisExpression = gfe;
  P.isThisTypeAnnotation = tde;
  P.isThrowStatement = Pfe;
  P.isTopicReference = Qde;
  P.isTryStatement = Efe;
  P.isTupleExpression = Hde;
  P.isTupleTypeAnnotation = rde;
  P.isTypeAlias = ide;
  P.isTypeAnnotation = nde;
  P.isTypeCastExpression = ade;
  P.isTypeParameter = ode;
  P.isTypeParameterDeclaration = lde;
  P.isTypeParameterInstantiation = ude;
  P.isTypeScript = sTe;
  P.isTypeofTypeAnnotation = sde;
  P.isUnaryExpression = Afe;
  P.isUnaryLike = qye;
  P.isUnionTypeAnnotation = cde;
  P.isUpdateExpression = vfe;
  P.isUserWhitespacable = Fye;
  P.isV8IntrinsicIdentifier = qde;
  P.isVariableDeclaration = Cfe;
  P.isVariableDeclarator = Ife;
  P.isVariance = pde;
  P.isVoidTypeAnnotation = fde;
  P.isWhile = Aye;
  P.isWhileStatement = wfe;
  P.isWithStatement = Nfe;
  P.isYieldExpression = ehe;
  var I = ac(), vo = Ao();
  function _pe(t, e) {
    return !t || t.type !== "ArrayExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(_pe, "isArrayExpression");
  function Lpe(t, e) {
    return !t || t.type !== "AssignmentExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Lpe, "isAssignmentExpression");
  function Mpe(t, e) {
    return !t || t.type !== "BinaryExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Mpe, "isBinaryExpression");
  function Bpe(t, e) {
    return !t || t.type !== "InterpreterDirective" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Bpe, "isInterpreterDirective");
  function Fpe(t, e) {
    return !t || t.type !== "Directive" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Fpe, "isDirective");
  function jpe(t, e) {
    return !t || t.type !== "DirectiveLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(jpe, "isDirectiveLiteral");
  function Rpe(t, e) {
    return !t || t.type !== "BlockStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Rpe, "isBlockStatement");
  function Upe(t, e) {
    return !t || t.type !== "BreakStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Upe, "isBreakStatement");
  function qpe(t, e) {
    return !t || t.type !== "CallExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(qpe, "isCallExpression");
  function Vpe(t, e) {
    return !t || t.type !== "CatchClause" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Vpe, "isCatchClause");
  function Kpe(t, e) {
    return !t || t.type !== "ConditionalExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Kpe, "isConditionalExpression");
  function Wpe(t, e) {
    return !t || t.type !== "ContinueStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Wpe, "isContinueStatement");
  function Ype(t, e) {
    return !t || t.type !== "DebuggerStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ype, "isDebuggerStatement");
  function Jpe(t, e) {
    return !t || t.type !== "DoWhileStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Jpe, "isDoWhileStatement");
  function Xpe(t, e) {
    return !t || t.type !== "EmptyStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Xpe, "isEmptyStatement");
  function $pe(t, e) {
    return !t || t.type !== "ExpressionStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n($pe, "isExpressionStatement");
  function Hpe(t, e) {
    return !t || t.type !== "File" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Hpe, "isFile");
  function zpe(t, e) {
    return !t || t.type !== "ForInStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(zpe, "isForInStatement");
  function Gpe(t, e) {
    return !t || t.type !== "ForStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Gpe, "isForStatement");
  function Qpe(t, e) {
    return !t || t.type !== "FunctionDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Qpe, "isFunctionDeclaration");
  function Zpe(t, e) {
    return !t || t.type !== "FunctionExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Zpe, "isFunctionExpression");
  function efe(t, e) {
    return !t || t.type !== "Identifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(efe, "isIdentifier");
  function tfe(t, e) {
    return !t || t.type !== "IfStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(tfe, "isIfStatement");
  function rfe(t, e) {
    return !t || t.type !== "LabeledStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(rfe, "isLabeledStatement");
  function sfe(t, e) {
    return !t || t.type !== "StringLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(sfe, "isStringLiteral");
  function ife(t, e) {
    return !t || t.type !== "NumericLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ife, "isNumericLiteral");
  function nfe(t, e) {
    return !t || t.type !== "NullLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(nfe, "isNullLiteral");
  function afe(t, e) {
    return !t || t.type !== "BooleanLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(afe, "isBooleanLiteral");
  function ofe(t, e) {
    return !t || t.type !== "RegExpLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ofe, "isRegExpLiteral");
  function lfe(t, e) {
    return !t || t.type !== "LogicalExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(lfe, "isLogicalExpression");
  function ufe(t, e) {
    return !t || t.type !== "MemberExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ufe, "isMemberExpression");
  function cfe(t, e) {
    return !t || t.type !== "NewExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(cfe, "isNewExpression");
  function pfe(t, e) {
    return !t || t.type !== "Program" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(pfe, "isProgram");
  function ffe(t, e) {
    return !t || t.type !== "ObjectExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ffe, "isObjectExpression");
  function hfe(t, e) {
    return !t || t.type !== "ObjectMethod" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(hfe, "isObjectMethod");
  function dfe(t, e) {
    return !t || t.type !== "ObjectProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(dfe, "isObjectProperty");
  function mfe(t, e) {
    return !t || t.type !== "RestElement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(mfe, "isRestElement");
  function yfe(t, e) {
    return !t || t.type !== "ReturnStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(yfe, "isReturnStatement");
  function Tfe(t, e) {
    return !t || t.type !== "SequenceExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Tfe, "isSequenceExpression");
  function bfe(t, e) {
    return !t || t.type !== "ParenthesizedExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(bfe, "isParenthesizedExpression");
  function xfe(t, e) {
    return !t || t.type !== "SwitchCase" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(xfe, "isSwitchCase");
  function Sfe(t, e) {
    return !t || t.type !== "SwitchStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Sfe, "isSwitchStatement");
  function gfe(t, e) {
    return !t || t.type !== "ThisExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(gfe, "isThisExpression");
  function Pfe(t, e) {
    return !t || t.type !== "ThrowStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Pfe, "isThrowStatement");
  function Efe(t, e) {
    return !t || t.type !== "TryStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Efe, "isTryStatement");
  function Afe(t, e) {
    return !t || t.type !== "UnaryExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Afe, "isUnaryExpression");
  function vfe(t, e) {
    return !t || t.type !== "UpdateExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(vfe, "isUpdateExpression");
  function Cfe(t, e) {
    return !t || t.type !== "VariableDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Cfe, "isVariableDeclaration");
  function Ife(t, e) {
    return !t || t.type !== "VariableDeclarator" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ife, "isVariableDeclarator");
  function wfe(t, e) {
    return !t || t.type !== "WhileStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(wfe, "isWhileStatement");
  function Nfe(t, e) {
    return !t || t.type !== "WithStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Nfe, "isWithStatement");
  function Ofe(t, e) {
    return !t || t.type !== "AssignmentPattern" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ofe, "isAssignmentPattern");
  function kfe(t, e) {
    return !t || t.type !== "ArrayPattern" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(kfe, "isArrayPattern");
  function Dfe(t, e) {
    return !t || t.type !== "ArrowFunctionExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Dfe, "isArrowFunctionExpression");
  function _fe(t, e) {
    return !t || t.type !== "ClassBody" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(_fe, "isClassBody");
  function Lfe(t, e) {
    return !t || t.type !== "ClassExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Lfe, "isClassExpression");
  function Mfe(t, e) {
    return !t || t.type !== "ClassDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Mfe, "isClassDeclaration");
  function Bfe(t, e) {
    return !t || t.type !== "ExportAllDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Bfe, "isExportAllDeclaration");
  function Ffe(t, e) {
    return !t || t.type !== "ExportDefaultDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ffe, "isExportDefaultDeclaration");
  function jfe(t, e) {
    return !t || t.type !== "ExportNamedDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(jfe, "isExportNamedDeclaration");
  function Rfe(t, e) {
    return !t || t.type !== "ExportSpecifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Rfe, "isExportSpecifier");
  function Ufe(t, e) {
    return !t || t.type !== "ForOfStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ufe, "isForOfStatement");
  function qfe(t, e) {
    return !t || t.type !== "ImportDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(qfe, "isImportDeclaration");
  function Vfe(t, e) {
    return !t || t.type !== "ImportDefaultSpecifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Vfe, "isImportDefaultSpecifier");
  function Kfe(t, e) {
    return !t || t.type !== "ImportNamespaceSpecifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Kfe, "isImportNamespaceSpecifier");
  function Wfe(t, e) {
    return !t || t.type !== "ImportSpecifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Wfe, "isImportSpecifier");
  function Yfe(t, e) {
    return !t || t.type !== "ImportExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Yfe, "isImportExpression");
  function Jfe(t, e) {
    return !t || t.type !== "MetaProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Jfe, "isMetaProperty");
  function Xfe(t, e) {
    return !t || t.type !== "ClassMethod" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Xfe, "isClassMethod");
  function $fe(t, e) {
    return !t || t.type !== "ObjectPattern" ? !1 : e == null || (0, I.default)(t, e);
  }
  n($fe, "isObjectPattern");
  function Hfe(t, e) {
    return !t || t.type !== "SpreadElement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Hfe, "isSpreadElement");
  function zfe(t, e) {
    return !t || t.type !== "Super" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(zfe, "isSuper");
  function Gfe(t, e) {
    return !t || t.type !== "TaggedTemplateExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Gfe, "isTaggedTemplateExpression");
  function Qfe(t, e) {
    return !t || t.type !== "TemplateElement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Qfe, "isTemplateElement");
  function Zfe(t, e) {
    return !t || t.type !== "TemplateLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Zfe, "isTemplateLiteral");
  function ehe(t, e) {
    return !t || t.type !== "YieldExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ehe, "isYieldExpression");
  function the(t, e) {
    return !t || t.type !== "AwaitExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(the, "isAwaitExpression");
  function rhe(t, e) {
    return !t || t.type !== "Import" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(rhe, "isImport");
  function she(t, e) {
    return !t || t.type !== "BigIntLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(she, "isBigIntLiteral");
  function ihe(t, e) {
    return !t || t.type !== "ExportNamespaceSpecifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ihe, "isExportNamespaceSpecifier");
  function nhe(t, e) {
    return !t || t.type !== "OptionalMemberExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(nhe, "isOptionalMemberExpression");
  function ahe(t, e) {
    return !t || t.type !== "OptionalCallExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ahe, "isOptionalCallExpression");
  function ohe(t, e) {
    return !t || t.type !== "ClassProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ohe, "isClassProperty");
  function lhe(t, e) {
    return !t || t.type !== "ClassAccessorProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(lhe, "isClassAccessorProperty");
  function uhe(t, e) {
    return !t || t.type !== "ClassPrivateProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(uhe, "isClassPrivateProperty");
  function che(t, e) {
    return !t || t.type !== "ClassPrivateMethod" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(che, "isClassPrivateMethod");
  function phe(t, e) {
    return !t || t.type !== "PrivateName" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(phe, "isPrivateName");
  function fhe(t, e) {
    return !t || t.type !== "StaticBlock" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(fhe, "isStaticBlock");
  function hhe(t, e) {
    return !t || t.type !== "AnyTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(hhe, "isAnyTypeAnnotation");
  function dhe(t, e) {
    return !t || t.type !== "ArrayTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(dhe, "isArrayTypeAnnotation");
  function mhe(t, e) {
    return !t || t.type !== "BooleanTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(mhe, "isBooleanTypeAnnotation");
  function yhe(t, e) {
    return !t || t.type !== "BooleanLiteralTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(yhe, "isBooleanLiteralTypeAnnotation");
  function The(t, e) {
    return !t || t.type !== "NullLiteralTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(The, "isNullLiteralTypeAnnotation");
  function bhe(t, e) {
    return !t || t.type !== "ClassImplements" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(bhe, "isClassImplements");
  function xhe(t, e) {
    return !t || t.type !== "DeclareClass" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(xhe, "isDeclareClass");
  function She(t, e) {
    return !t || t.type !== "DeclareFunction" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(She, "isDeclareFunction");
  function ghe(t, e) {
    return !t || t.type !== "DeclareInterface" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ghe, "isDeclareInterface");
  function Phe(t, e) {
    return !t || t.type !== "DeclareModule" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Phe, "isDeclareModule");
  function Ehe(t, e) {
    return !t || t.type !== "DeclareModuleExports" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ehe, "isDeclareModuleExports");
  function Ahe(t, e) {
    return !t || t.type !== "DeclareTypeAlias" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ahe, "isDeclareTypeAlias");
  function vhe(t, e) {
    return !t || t.type !== "DeclareOpaqueType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(vhe, "isDeclareOpaqueType");
  function Che(t, e) {
    return !t || t.type !== "DeclareVariable" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Che, "isDeclareVariable");
  function Ihe(t, e) {
    return !t || t.type !== "DeclareExportDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ihe, "isDeclareExportDeclaration");
  function whe(t, e) {
    return !t || t.type !== "DeclareExportAllDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(whe, "isDeclareExportAllDeclaration");
  function Nhe(t, e) {
    return !t || t.type !== "DeclaredPredicate" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Nhe, "isDeclaredPredicate");
  function Ohe(t, e) {
    return !t || t.type !== "ExistsTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ohe, "isExistsTypeAnnotation");
  function khe(t, e) {
    return !t || t.type !== "FunctionTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(khe, "isFunctionTypeAnnotation");
  function Dhe(t, e) {
    return !t || t.type !== "FunctionTypeParam" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Dhe, "isFunctionTypeParam");
  function _he(t, e) {
    return !t || t.type !== "GenericTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(_he, "isGenericTypeAnnotation");
  function Lhe(t, e) {
    return !t || t.type !== "InferredPredicate" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Lhe, "isInferredPredicate");
  function Mhe(t, e) {
    return !t || t.type !== "InterfaceExtends" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Mhe, "isInterfaceExtends");
  function Bhe(t, e) {
    return !t || t.type !== "InterfaceDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Bhe, "isInterfaceDeclaration");
  function Fhe(t, e) {
    return !t || t.type !== "InterfaceTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Fhe, "isInterfaceTypeAnnotation");
  function jhe(t, e) {
    return !t || t.type !== "IntersectionTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(jhe, "isIntersectionTypeAnnotation");
  function Rhe(t, e) {
    return !t || t.type !== "MixedTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Rhe, "isMixedTypeAnnotation");
  function Uhe(t, e) {
    return !t || t.type !== "EmptyTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Uhe, "isEmptyTypeAnnotation");
  function qhe(t, e) {
    return !t || t.type !== "NullableTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(qhe, "isNullableTypeAnnotation");
  function Vhe(t, e) {
    return !t || t.type !== "NumberLiteralTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Vhe, "isNumberLiteralTypeAnnotation");
  function Khe(t, e) {
    return !t || t.type !== "NumberTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Khe, "isNumberTypeAnnotation");
  function Whe(t, e) {
    return !t || t.type !== "ObjectTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Whe, "isObjectTypeAnnotation");
  function Yhe(t, e) {
    return !t || t.type !== "ObjectTypeInternalSlot" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Yhe, "isObjectTypeInternalSlot");
  function Jhe(t, e) {
    return !t || t.type !== "ObjectTypeCallProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Jhe, "isObjectTypeCallProperty");
  function Xhe(t, e) {
    return !t || t.type !== "ObjectTypeIndexer" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Xhe, "isObjectTypeIndexer");
  function $he(t, e) {
    return !t || t.type !== "ObjectTypeProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n($he, "isObjectTypeProperty");
  function Hhe(t, e) {
    return !t || t.type !== "ObjectTypeSpreadProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Hhe, "isObjectTypeSpreadProperty");
  function zhe(t, e) {
    return !t || t.type !== "OpaqueType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(zhe, "isOpaqueType");
  function Ghe(t, e) {
    return !t || t.type !== "QualifiedTypeIdentifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ghe, "isQualifiedTypeIdentifier");
  function Qhe(t, e) {
    return !t || t.type !== "StringLiteralTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Qhe, "isStringLiteralTypeAnnotation");
  function Zhe(t, e) {
    return !t || t.type !== "StringTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Zhe, "isStringTypeAnnotation");
  function ede(t, e) {
    return !t || t.type !== "SymbolTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ede, "isSymbolTypeAnnotation");
  function tde(t, e) {
    return !t || t.type !== "ThisTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(tde, "isThisTypeAnnotation");
  function rde(t, e) {
    return !t || t.type !== "TupleTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(rde, "isTupleTypeAnnotation");
  function sde(t, e) {
    return !t || t.type !== "TypeofTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(sde, "isTypeofTypeAnnotation");
  function ide(t, e) {
    return !t || t.type !== "TypeAlias" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ide, "isTypeAlias");
  function nde(t, e) {
    return !t || t.type !== "TypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(nde, "isTypeAnnotation");
  function ade(t, e) {
    return !t || t.type !== "TypeCastExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ade, "isTypeCastExpression");
  function ode(t, e) {
    return !t || t.type !== "TypeParameter" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ode, "isTypeParameter");
  function lde(t, e) {
    return !t || t.type !== "TypeParameterDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(lde, "isTypeParameterDeclaration");
  function ude(t, e) {
    return !t || t.type !== "TypeParameterInstantiation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ude, "isTypeParameterInstantiation");
  function cde(t, e) {
    return !t || t.type !== "UnionTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(cde, "isUnionTypeAnnotation");
  function pde(t, e) {
    return !t || t.type !== "Variance" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(pde, "isVariance");
  function fde(t, e) {
    return !t || t.type !== "VoidTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(fde, "isVoidTypeAnnotation");
  function hde(t, e) {
    return !t || t.type !== "EnumDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(hde, "isEnumDeclaration");
  function dde(t, e) {
    return !t || t.type !== "EnumBooleanBody" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(dde, "isEnumBooleanBody");
  function mde(t, e) {
    return !t || t.type !== "EnumNumberBody" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(mde, "isEnumNumberBody");
  function yde(t, e) {
    return !t || t.type !== "EnumStringBody" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(yde, "isEnumStringBody");
  function Tde(t, e) {
    return !t || t.type !== "EnumSymbolBody" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Tde, "isEnumSymbolBody");
  function bde(t, e) {
    return !t || t.type !== "EnumBooleanMember" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(bde, "isEnumBooleanMember");
  function xde(t, e) {
    return !t || t.type !== "EnumNumberMember" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(xde, "isEnumNumberMember");
  function Sde(t, e) {
    return !t || t.type !== "EnumStringMember" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Sde, "isEnumStringMember");
  function gde(t, e) {
    return !t || t.type !== "EnumDefaultedMember" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(gde, "isEnumDefaultedMember");
  function Pde(t, e) {
    return !t || t.type !== "IndexedAccessType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Pde, "isIndexedAccessType");
  function Ede(t, e) {
    return !t || t.type !== "OptionalIndexedAccessType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ede, "isOptionalIndexedAccessType");
  function Ade(t, e) {
    return !t || t.type !== "JSXAttribute" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ade, "isJSXAttribute");
  function vde(t, e) {
    return !t || t.type !== "JSXClosingElement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(vde, "isJSXClosingElement");
  function Cde(t, e) {
    return !t || t.type !== "JSXElement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Cde, "isJSXElement");
  function Ide(t, e) {
    return !t || t.type !== "JSXEmptyExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ide, "isJSXEmptyExpression");
  function wde(t, e) {
    return !t || t.type !== "JSXExpressionContainer" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(wde, "isJSXExpressionContainer");
  function Nde(t, e) {
    return !t || t.type !== "JSXSpreadChild" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Nde, "isJSXSpreadChild");
  function Ode(t, e) {
    return !t || t.type !== "JSXIdentifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ode, "isJSXIdentifier");
  function kde(t, e) {
    return !t || t.type !== "JSXMemberExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(kde, "isJSXMemberExpression");
  function Dde(t, e) {
    return !t || t.type !== "JSXNamespacedName" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Dde, "isJSXNamespacedName");
  function _de(t, e) {
    return !t || t.type !== "JSXOpeningElement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(_de, "isJSXOpeningElement");
  function Lde(t, e) {
    return !t || t.type !== "JSXSpreadAttribute" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Lde, "isJSXSpreadAttribute");
  function Mde(t, e) {
    return !t || t.type !== "JSXText" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Mde, "isJSXText");
  function Bde(t, e) {
    return !t || t.type !== "JSXFragment" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Bde, "isJSXFragment");
  function Fde(t, e) {
    return !t || t.type !== "JSXOpeningFragment" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Fde, "isJSXOpeningFragment");
  function jde(t, e) {
    return !t || t.type !== "JSXClosingFragment" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(jde, "isJSXClosingFragment");
  function Rde(t, e) {
    return !t || t.type !== "Noop" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Rde, "isNoop");
  function Ude(t, e) {
    return !t || t.type !== "Placeholder" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ude, "isPlaceholder");
  function qde(t, e) {
    return !t || t.type !== "V8IntrinsicIdentifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(qde, "isV8IntrinsicIdentifier");
  function Vde(t, e) {
    return !t || t.type !== "ArgumentPlaceholder" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Vde, "isArgumentPlaceholder");
  function Kde(t, e) {
    return !t || t.type !== "BindExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Kde, "isBindExpression");
  function Wde(t, e) {
    return !t || t.type !== "ImportAttribute" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Wde, "isImportAttribute");
  function Yde(t, e) {
    return !t || t.type !== "Decorator" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Yde, "isDecorator");
  function Jde(t, e) {
    return !t || t.type !== "DoExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Jde, "isDoExpression");
  function Xde(t, e) {
    return !t || t.type !== "ExportDefaultSpecifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Xde, "isExportDefaultSpecifier");
  function $de(t, e) {
    return !t || t.type !== "RecordExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n($de, "isRecordExpression");
  function Hde(t, e) {
    return !t || t.type !== "TupleExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Hde, "isTupleExpression");
  function zde(t, e) {
    return !t || t.type !== "DecimalLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(zde, "isDecimalLiteral");
  function Gde(t, e) {
    return !t || t.type !== "ModuleExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Gde, "isModuleExpression");
  function Qde(t, e) {
    return !t || t.type !== "TopicReference" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Qde, "isTopicReference");
  function Zde(t, e) {
    return !t || t.type !== "PipelineTopicExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Zde, "isPipelineTopicExpression");
  function eme(t, e) {
    return !t || t.type !== "PipelineBareFunction" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(eme, "isPipelineBareFunction");
  function tme(t, e) {
    return !t || t.type !== "PipelinePrimaryTopicReference" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(tme, "isPipelinePrimaryTopicReference");
  function rme(t, e) {
    return !t || t.type !== "TSParameterProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(rme, "isTSParameterProperty");
  function sme(t, e) {
    return !t || t.type !== "TSDeclareFunction" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(sme, "isTSDeclareFunction");
  function ime(t, e) {
    return !t || t.type !== "TSDeclareMethod" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ime, "isTSDeclareMethod");
  function nme(t, e) {
    return !t || t.type !== "TSQualifiedName" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(nme, "isTSQualifiedName");
  function ame(t, e) {
    return !t || t.type !== "TSCallSignatureDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ame, "isTSCallSignatureDeclaration");
  function ome(t, e) {
    return !t || t.type !== "TSConstructSignatureDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ome, "isTSConstructSignatureDeclaration");
  function lme(t, e) {
    return !t || t.type !== "TSPropertySignature" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(lme, "isTSPropertySignature");
  function ume(t, e) {
    return !t || t.type !== "TSMethodSignature" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ume, "isTSMethodSignature");
  function cme(t, e) {
    return !t || t.type !== "TSIndexSignature" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(cme, "isTSIndexSignature");
  function pme(t, e) {
    return !t || t.type !== "TSAnyKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(pme, "isTSAnyKeyword");
  function fme(t, e) {
    return !t || t.type !== "TSBooleanKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(fme, "isTSBooleanKeyword");
  function hme(t, e) {
    return !t || t.type !== "TSBigIntKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(hme, "isTSBigIntKeyword");
  function dme(t, e) {
    return !t || t.type !== "TSIntrinsicKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(dme, "isTSIntrinsicKeyword");
  function mme(t, e) {
    return !t || t.type !== "TSNeverKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(mme, "isTSNeverKeyword");
  function yme(t, e) {
    return !t || t.type !== "TSNullKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(yme, "isTSNullKeyword");
  function Tme(t, e) {
    return !t || t.type !== "TSNumberKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Tme, "isTSNumberKeyword");
  function bme(t, e) {
    return !t || t.type !== "TSObjectKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(bme, "isTSObjectKeyword");
  function xme(t, e) {
    return !t || t.type !== "TSStringKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(xme, "isTSStringKeyword");
  function Sme(t, e) {
    return !t || t.type !== "TSSymbolKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Sme, "isTSSymbolKeyword");
  function gme(t, e) {
    return !t || t.type !== "TSUndefinedKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(gme, "isTSUndefinedKeyword");
  function Pme(t, e) {
    return !t || t.type !== "TSUnknownKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Pme, "isTSUnknownKeyword");
  function Eme(t, e) {
    return !t || t.type !== "TSVoidKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Eme, "isTSVoidKeyword");
  function Ame(t, e) {
    return !t || t.type !== "TSThisType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ame, "isTSThisType");
  function vme(t, e) {
    return !t || t.type !== "TSFunctionType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(vme, "isTSFunctionType");
  function Cme(t, e) {
    return !t || t.type !== "TSConstructorType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Cme, "isTSConstructorType");
  function Ime(t, e) {
    return !t || t.type !== "TSTypeReference" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ime, "isTSTypeReference");
  function wme(t, e) {
    return !t || t.type !== "TSTypePredicate" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(wme, "isTSTypePredicate");
  function Nme(t, e) {
    return !t || t.type !== "TSTypeQuery" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Nme, "isTSTypeQuery");
  function Ome(t, e) {
    return !t || t.type !== "TSTypeLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ome, "isTSTypeLiteral");
  function kme(t, e) {
    return !t || t.type !== "TSArrayType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(kme, "isTSArrayType");
  function Dme(t, e) {
    return !t || t.type !== "TSTupleType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Dme, "isTSTupleType");
  function _me(t, e) {
    return !t || t.type !== "TSOptionalType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(_me, "isTSOptionalType");
  function Lme(t, e) {
    return !t || t.type !== "TSRestType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Lme, "isTSRestType");
  function Mme(t, e) {
    return !t || t.type !== "TSNamedTupleMember" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Mme, "isTSNamedTupleMember");
  function Bme(t, e) {
    return !t || t.type !== "TSUnionType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Bme, "isTSUnionType");
  function Fme(t, e) {
    return !t || t.type !== "TSIntersectionType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Fme, "isTSIntersectionType");
  function jme(t, e) {
    return !t || t.type !== "TSConditionalType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(jme, "isTSConditionalType");
  function Rme(t, e) {
    return !t || t.type !== "TSInferType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Rme, "isTSInferType");
  function Ume(t, e) {
    return !t || t.type !== "TSParenthesizedType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ume, "isTSParenthesizedType");
  function qme(t, e) {
    return !t || t.type !== "TSTypeOperator" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(qme, "isTSTypeOperator");
  function Vme(t, e) {
    return !t || t.type !== "TSIndexedAccessType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Vme, "isTSIndexedAccessType");
  function Kme(t, e) {
    return !t || t.type !== "TSMappedType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Kme, "isTSMappedType");
  function Wme(t, e) {
    return !t || t.type !== "TSLiteralType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Wme, "isTSLiteralType");
  function Yme(t, e) {
    return !t || t.type !== "TSExpressionWithTypeArguments" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Yme, "isTSExpressionWithTypeArguments");
  function Jme(t, e) {
    return !t || t.type !== "TSInterfaceDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Jme, "isTSInterfaceDeclaration");
  function Xme(t, e) {
    return !t || t.type !== "TSInterfaceBody" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Xme, "isTSInterfaceBody");
  function $me(t, e) {
    return !t || t.type !== "TSTypeAliasDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n($me, "isTSTypeAliasDeclaration");
  function Hme(t, e) {
    return !t || t.type !== "TSInstantiationExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Hme, "isTSInstantiationExpression");
  function zme(t, e) {
    return !t || t.type !== "TSAsExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(zme, "isTSAsExpression");
  function Gme(t, e) {
    return !t || t.type !== "TSSatisfiesExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Gme, "isTSSatisfiesExpression");
  function Qme(t, e) {
    return !t || t.type !== "TSTypeAssertion" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Qme, "isTSTypeAssertion");
  function Zme(t, e) {
    return !t || t.type !== "TSEnumDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Zme, "isTSEnumDeclaration");
  function eye(t, e) {
    return !t || t.type !== "TSEnumMember" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(eye, "isTSEnumMember");
  function tye(t, e) {
    return !t || t.type !== "TSModuleDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(tye, "isTSModuleDeclaration");
  function rye(t, e) {
    return !t || t.type !== "TSModuleBlock" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(rye, "isTSModuleBlock");
  function sye(t, e) {
    return !t || t.type !== "TSImportType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(sye, "isTSImportType");
  function iye(t, e) {
    return !t || t.type !== "TSImportEqualsDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(iye, "isTSImportEqualsDeclaration");
  function nye(t, e) {
    return !t || t.type !== "TSExternalModuleReference" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(nye, "isTSExternalModuleReference");
  function aye(t, e) {
    return !t || t.type !== "TSNonNullExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(aye, "isTSNonNullExpression");
  function oye(t, e) {
    return !t || t.type !== "TSExportAssignment" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(oye, "isTSExportAssignment");
  function lye(t, e) {
    return !t || t.type !== "TSNamespaceExportDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(lye, "isTSNamespaceExportDeclaration");
  function uye(t, e) {
    return !t || t.type !== "TSTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(uye, "isTSTypeAnnotation");
  function cye(t, e) {
    return !t || t.type !== "TSTypeParameterInstantiation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(cye, "isTSTypeParameterInstantiation");
  function pye(t, e) {
    return !t || t.type !== "TSTypeParameterDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(pye, "isTSTypeParameterDeclaration");
  function fye(t, e) {
    return !t || t.type !== "TSTypeParameter" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(fye, "isTSTypeParameter");
  function hye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(hye, "isStandardized");
  function dye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(dye, "isExpression");
  function mye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(mye, "isBinary");
  function yye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(yye, "isScopable");
  function Tye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Tye, "isBlockParent");
  function bye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(bye, "isBlock");
  function xye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(xye, "isStatement");
  function Sye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Sye, "isTerminatorless");
  function gye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(gye, "isCompletionStatement");
  function Pye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Pye, "isConditional");
  function Eye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Eye, "isLoop");
  function Aye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Aye, "isWhile");
  function vye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(vye, "isExpressionWrapper");
  function Cye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Cye, "isFor");
  function Iye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Iye, "isForXStatement");
  function wye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(wye, "isFunction");
  function Nye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Nye, "isFunctionParent");
  function Oye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Oye, "isPureish");
  function kye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if (t.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(kye, "isDeclaration");
  function Dye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Dye, "isPatternLike");
  function _ye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(_ye, "isLVal");
  function Lye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (t.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Lye, "isTSEntityName");
  function Mye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Mye, "isLiteral");
  function Bye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Bye, "isImmutable");
  function Fye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Fye, "isUserWhitespacable");
  function jye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(jye, "isMethod");
  function Rye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Rye, "isObjectMember");
  function Uye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Uye, "isProperty");
  function qye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(qye, "isUnaryLike");
  function Vye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (t.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Vye, "isPattern");
  function Kye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Kye, "isClass");
  function AC(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(AC, "isImportOrExportDeclaration");
  function Wye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Wye, "isExportDeclaration");
  function Yye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Yye, "isModuleSpecifier");
  function Jye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Jye, "isAccessor");
  function Xye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Xye, "isPrivate");
  function $ye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n($ye, "isFlow");
  function Hye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Hye, "isFlowType");
  function zye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(zye, "isFlowBaseAnnotation");
  function Gye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Gye, "isFlowDeclaration");
  function Qye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Qye, "isFlowPredicate");
  function Zye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Zye, "isEnumBody");
  function eTe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(eTe, "isEnumMember");
  function tTe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(tTe, "isJSX");
  function rTe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(rTe, "isMiscellaneous");
  function sTe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(sTe, "isTypeScript");
  function iTe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(iTe, "isTSTypeElement");
  function nTe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(nTe, "isTSType");
  function aTe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(aTe, "isTSBaseType");
  function oTe(t, e) {
    return (0, vo.default)("isNumberLiteral", "isNumericLiteral"), !t || t.type !== "NumberLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(oTe, "isNumberLiteral");
  function lTe(t, e) {
    return (0, vo.default)("isRegexLiteral", "isRegExpLiteral"), !t || t.type !== "RegexLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(lTe, "isRegexLiteral");
  function uTe(t, e) {
    return (0, vo.default)("isRestProperty", "isRestElement"), !t || t.type !== "RestProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(uTe, "isRestProperty");
  function cTe(t, e) {
    return (0, vo.default)("isSpreadProperty", "isSpreadElement"), !t || t.type !== "SpreadProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(cTe, "isSpreadProperty");
  function pTe(t, e) {
    return (0, vo.default)("isModuleDeclaration", "isImportOrExportDeclaration"), AC(t, e);
  }
  n(pTe, "isModuleDeclaration");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/matchesPattern.js
var By = w((My) => {
  "use strict";
  Object.defineProperty(My, "__esModule", {
    value: !0
  });
  My.default = fTe;
  var Co = Rt();
  function fTe(t, e, r) {
    if (!(0, Co.isMemberExpression)(t)) return !1;
    let s = Array.isArray(e) ? e : e.split("."), i = [], a;
    for (a = t; (0, Co.isMemberExpression)(a); a = a.object)
      i.push(a.property);
    if (i.push(a), i.length < s.length || !r && i.length > s.length) return !1;
    for (let o = 0, l = i.length - 1; o < s.length; o++, l--) {
      let u = i[l], c;
      if ((0, Co.isIdentifier)(u))
        c = u.name;
      else if ((0, Co.isStringLiteral)(u))
        c = u.value;
      else if ((0, Co.isThisExpression)(u))
        c = "this";
      else
        return !1;
      if (s[o] !== c) return !1;
    }
    return !0;
  }
  n(fTe, "matchesPattern");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var jy = w((Fy) => {
  "use strict";
  Object.defineProperty(Fy, "__esModule", {
    value: !0
  });
  Fy.default = dTe;
  var hTe = By();
  function dTe(t, e) {
    let r = t.split(".");
    return (s) => (0, hTe.default)(s, r, e);
  }
  n(dTe, "buildMatchMemberExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/react/isReactComponent.js
var vC = w((oc) => {
  "use strict";
  Object.defineProperty(oc, "__esModule", {
    value: !0
  });
  oc.default = void 0;
  var mTe = jy(), yTe = (0, mTe.default)("React.Component"), f6e = oc.default = yTe;
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/react/isCompatTag.js
var CC = w((Ry) => {
  "use strict";
  Object.defineProperty(Ry, "__esModule", {
    value: !0
  });
  Ry.default = TTe;
  function TTe(t) {
    return !!t && /^[a-z]/.test(t);
  }
  n(TTe, "isCompatTag");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isType.js
var lc = w((Uy) => {
  "use strict";
  Object.defineProperty(Uy, "__esModule", {
    value: !0
  });
  Uy.default = bTe;
  var IC = Vr();
  function bTe(t, e) {
    if (t === e) return !0;
    if (t == null || IC.ALIAS_KEYS[e]) return !1;
    let r = IC.FLIPPED_ALIAS_KEYS[e];
    if (r) {
      if (r[0] === t) return !0;
      for (let s of r)
        if (t === s) return !0;
    }
    return !1;
  }
  n(bTe, "isType");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isPlaceholderType.js
var Vy = w((qy) => {
  "use strict";
  Object.defineProperty(qy, "__esModule", {
    value: !0
  });
  qy.default = STe;
  var xTe = Vr();
  function STe(t, e) {
    if (t === e) return !0;
    let r = xTe.PLACEHOLDERS_ALIAS[t];
    if (r) {
      for (let s of r)
        if (e === s) return !0;
    }
    return !1;
  }
  n(STe, "isPlaceholderType");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/is.js
var Yn = w((Ky) => {
  "use strict";
  Object.defineProperty(Ky, "__esModule", {
    value: !0
  });
  Ky.default = vTe;
  var gTe = ac(), PTe = lc(), ETe = Vy(), ATe = Vr();
  function vTe(t, e, r) {
    return e ? (0, PTe.default)(e.type, t) ? typeof r > "u" ? !0 : (0, gTe.default)(e, r) : !r && e.type === "Placeholder" && t in ATe.FLIPPED_ALIAS_KEYS ?
    (0, ETe.default)(e.expectedNode, t) : !1 : !1;
  }
  n(vTe, "is");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isValidIdentifier.js
var Jn = w((Yy) => {
  "use strict";
  Object.defineProperty(Yy, "__esModule", {
    value: !0
  });
  Yy.default = CTe;
  var Wy = Wa();
  function CTe(t, e = !0) {
    return typeof t != "string" || e && ((0, Wy.isKeyword)(t) || (0, Wy.isStrictReservedWord)(t, !0)) ? !1 : (0, Wy.isIdentifierName)(t);
  }
  n(CTe, "isValidIdentifier");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-string-parser/lib/index.js
var kC = w((Io) => {
  "use strict";
  Object.defineProperty(Io, "__esModule", {
    value: !0
  });
  Io.readCodePoint = OC;
  Io.readInt = NC;
  Io.readStringContents = wTe;
  var ITe = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), wC = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, uc = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function wTe(t, e, r, s, i, a) {
    let o = r, l = s, u = i, c = "", p = null, f = r, {
      length: m
    } = e;
    for (; ; ) {
      if (r >= m) {
        a.unterminated(o, l, u), c += e.slice(f, r);
        break;
      }
      let y = e.charCodeAt(r);
      if (NTe(t, y, e, r)) {
        c += e.slice(f, r);
        break;
      }
      if (y === 92) {
        c += e.slice(f, r);
        let T = OTe(e, r, s, i, t === "template", a);
        T.ch === null && !p ? p = {
          pos: r,
          lineStart: s,
          curLine: i
        } : c += T.ch, {
          pos: r,
          lineStart: s,
          curLine: i
        } = T, f = r;
      } else y === 8232 || y === 8233 ? (++r, ++i, s = r) : y === 10 || y === 13 ? t === "template" ? (c += e.slice(f, r) + `
`, ++r, y === 13 && e.charCodeAt(r) === 10 && ++r, ++i, f = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: s,
      curLine: i,
      containsInvalid: !!p
    };
  }
  n(wTe, "readStringContents");
  function NTe(t, e, r, s) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(s + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(NTe, "isStringEnd");
  function OTe(t, e, r, s, i, a) {
    let o = !i;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = Jy(t, e, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = OC(t, e, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (i)
          return l(null);
        a.strictNumericEscape(e - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, f = t.slice(c, e + 2).match(/^[0-7]+/)[0], m = parseInt(f, 8);
          m > 255 && (f = f.slice(0, -1), m = parseInt(f, 8)), e += f.length - 1;
          let y = t.charCodeAt(e);
          if (f !== "0" || y === 56 || y === 57) {
            if (i)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(m));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(OTe, "readEscapedChar");
  function Jy(t, e, r, s, i, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = NC(t, e, r, s, 16, i, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(Jy, "readHexChar");
  function NC(t, e, r, s, i, a, o, l, u, c) {
    let p = e, f = i === 16 ? wC.hex : wC.decBinOct, m = i === 16 ? uc.hex : i === 10 ? uc.dec : i === 8 ? uc.oct : uc.bin, y = !1, T = 0;
    for (let L = 0, q = a ?? 1 / 0; L < q; ++L) {
      let _ = t.charCodeAt(e), U;
      if (_ === 95 && l !== "bail") {
        let J = t.charCodeAt(e - 1), ie = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(ie) || !m(ie) || f.has(J) || f.has(ie)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, s);
        }
        ++e;
        continue;
      }
      if (_ >= 97 ? U = _ - 97 + 10 : _ >= 65 ? U = _ - 65 + 10 : ITe(_) ? U = _ - 48 : U = 1 / 0, U >= i) {
        if (U <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (U <= 9 && u.invalidDigit(e, r, s, i))
          U = 0;
        else if (o)
          U = 0, y = !0;
        else
          break;
      }
      ++e, T = T * i + U;
    }
    return e === p || a != null && e - p !== a || y ? {
      n: null,
      pos: e
    } : {
      n: T,
      pos: e
    };
  }
  n(NC, "readInt");
  function OC(t, e, r, s, i, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = Jy(t, e, r, s, t.indexOf("}", e) - e, !0, i, a), ++e, l !== null && l > 1114111)
        if (i)
          a.invalidCodePoint(e, r, s);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = Jy(t, e, r, s, 4, !1, i, a));
    return {
      code: l,
      pos: e
    };
  }
  n(OC, "readCodePoint");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/constants/index.js
var ci = w((Ve) => {
  "use strict";
  Object.defineProperty(Ve, "__esModule", {
    value: !0
  });
  Ve.UPDATE_OPERATORS = Ve.UNARY_OPERATORS = Ve.STRING_UNARY_OPERATORS = Ve.STATEMENT_OR_BLOCK_KEYS = Ve.NUMBER_UNARY_OPERATORS = Ve.NUMBER_BINARY_OPERATORS =
  Ve.NOT_LOCAL_BINDING = Ve.LOGICAL_OPERATORS = Ve.INHERIT_KEYS = Ve.FOR_INIT_KEYS = Ve.FLATTENABLE_KEYS = Ve.EQUALITY_BINARY_OPERATORS = Ve.
  COMPARISON_BINARY_OPERATORS = Ve.COMMENT_KEYS = Ve.BOOLEAN_UNARY_OPERATORS = Ve.BOOLEAN_NUMBER_BINARY_OPERATORS = Ve.BOOLEAN_BINARY_OPERATORS =
  Ve.BLOCK_SCOPED_SYMBOL = Ve.BINARY_OPERATORS = Ve.ASSIGNMENT_OPERATORS = void 0;
  var C6e = Ve.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], I6e = Ve.FLATTENABLE_KEYS = ["body", "expressions"], w6e = Ve.
  FOR_INIT_KEYS = ["left", "init"], N6e = Ve.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], kTe = Ve.LOGICAL_OPERATORS =
  ["||", "&&", "??"], O6e = Ve.UPDATE_OPERATORS = ["++", "--"], DTe = Ve.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], _Te = Ve.
  EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], LTe = Ve.COMPARISON_BINARY_OPERATORS = [..._Te, "in", "instanceof"], MTe = Ve.BOOLEAN_BINARY_OPERATORS =
  [...LTe, ...DTe], DC = Ve.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], k6e = Ve.BINARY_OPERATORS =
  ["+", ...DC, ...MTe, "|>"], D6e = Ve.ASSIGNMENT_OPERATORS = ["=", "+=", ...DC.map((t) => t + "="), ...kTe.map((t) => t + "=")], BTe = Ve.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], FTe = Ve.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], jTe = Ve.STRING_UNARY_OPERATORS = ["typeof"], _6e = Ve.UNARY_OPERATORS =
  ["void", "throw", ...BTe, ...FTe, ...jTe], L6e = Ve.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  }, M6e = Ve.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), B6e = Ve.NOT_LOCAL_BINDING = Symbol.for("should not be consid\
ered a local binding");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/utils.js
var _s = w((it) => {
  "use strict";
  Object.defineProperty(it, "__esModule", {
    value: !0
  });
  it.VISITOR_KEYS = it.NODE_PARENT_VALIDATIONS = it.NODE_FIELDS = it.FLIPPED_ALIAS_KEYS = it.DEPRECATED_KEYS = it.BUILDER_KEYS = it.ALIAS_KEYS =
  void 0;
  it.arrayOf = LC;
  it.arrayOfType = MC;
  it.assertEach = BC;
  it.assertNodeOrValueType = zTe;
  it.assertNodeType = $y;
  it.assertOneOf = HTe;
  it.assertOptionalChainStart = QTe;
  it.assertShape = GTe;
  it.assertValueType = Gy;
  it.chain = FC;
  it.default = jC;
  it.defineAliasedType = t0e;
  it.typeIs = fc;
  it.validate = zy;
  it.validateArrayOfType = $Te;
  it.validateOptional = JTe;
  it.validateOptionalType = XTe;
  it.validateType = YTe;
  var _C = Yn(), pc = hc(), RTe = it.VISITOR_KEYS = {}, UTe = it.ALIAS_KEYS = {}, Xy = it.FLIPPED_ALIAS_KEYS = {}, qTe = it.NODE_FIELDS = {},
  VTe = it.BUILDER_KEYS = {}, KTe = it.DEPRECATED_KEYS = {}, WTe = it.NODE_PARENT_VALIDATIONS = {};
  function cc(t) {
    return Array.isArray(t) ? "array" : t === null ? "null" : typeof t;
  }
  n(cc, "getType");
  function zy(t) {
    return {
      validate: t
    };
  }
  n(zy, "validate");
  function fc(t) {
    return typeof t == "string" ? $y(t) : $y(...t);
  }
  n(fc, "typeIs");
  function YTe(t) {
    return zy(fc(t));
  }
  n(YTe, "validateType");
  function JTe(t) {
    return {
      validate: t,
      optional: !0
    };
  }
  n(JTe, "validateOptional");
  function XTe(t) {
    return {
      validate: fc(t),
      optional: !0
    };
  }
  n(XTe, "validateOptionalType");
  function LC(t) {
    return FC(Gy("array"), BC(t));
  }
  n(LC, "arrayOf");
  function MC(t) {
    return LC(fc(t));
  }
  n(MC, "arrayOfType");
  function $Te(t) {
    return zy(MC(t));
  }
  n($Te, "validateArrayOfType");
  function BC(t) {
    function e(r, s, i) {
      if (Array.isArray(i))
        for (let a = 0; a < i.length; a++) {
          let o = `${s}[${a}]`, l = i[a];
          t(r, o, l), process.env.BABEL_TYPES_8_BREAKING && (0, pc.validateChild)(r, o, l);
        }
    }
    return n(e, "validator"), e.each = t, e;
  }
  n(BC, "assertEach");
  function HTe(...t) {
    function e(r, s, i) {
      if (t.indexOf(i) < 0)
        throw new TypeError(`Property ${s} expected value to be one of ${JSON.stringify(t)} but got ${JSON.stringify(i)}`);
    }
    return n(e, "validate"), e.oneOf = t, e;
  }
  n(HTe, "assertOneOf");
  function $y(...t) {
    function e(r, s, i) {
      for (let a of t)
        if ((0, _C.default)(a, i)) {
          (0, pc.validateChild)(r, s, i);
          return;
        }
      throw new TypeError(`Property ${s} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(i?.
      type)}`);
    }
    return n(e, "validate"), e.oneOfNodeTypes = t, e;
  }
  n($y, "assertNodeType");
  function zTe(...t) {
    function e(r, s, i) {
      for (let a of t)
        if (cc(i) === a || (0, _C.default)(a, i)) {
          (0, pc.validateChild)(r, s, i);
          return;
        }
      throw new TypeError(`Property ${s} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(i?.
      type)}`);
    }
    return n(e, "validate"), e.oneOfNodeOrValueTypes = t, e;
  }
  n(zTe, "assertNodeOrValueType");
  function Gy(t) {
    function e(r, s, i) {
      if (!(cc(i) === t))
        throw new TypeError(`Property ${s} expected type of ${t} but got ${cc(i)}`);
    }
    return n(e, "validate"), e.type = t, e;
  }
  n(Gy, "assertValueType");
  function GTe(t) {
    function e(r, s, i) {
      let a = [];
      for (let o of Object.keys(t))
        try {
          (0, pc.validateField)(r, o, i[o], t[o]);
        } catch (l) {
          if (l instanceof TypeError) {
            a.push(l.message);
            continue;
          }
          throw l;
        }
      if (a.length)
        throw new TypeError(`Property ${s} of ${r.type} expected to have the following:
${a.join(`
`)}`);
    }
    return n(e, "validate"), e.shapeOf = t, e;
  }
  n(GTe, "assertShape");
  function QTe() {
    function t(e) {
      var r;
      let s = e;
      for (; e; ) {
        let {
          type: i
        } = s;
        if (i === "OptionalCallExpression") {
          if (s.optional) return;
          s = s.callee;
          continue;
        }
        if (i === "OptionalMemberExpression") {
          if (s.optional) return;
          s = s.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${e.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(r = s) == null ? void 0 : r.type}`);
    }
    return n(t, "validate"), t;
  }
  n(QTe, "assertOptionalChainStart");
  function FC(...t) {
    function e(...r) {
      for (let s of t)
        s(...r);
    }
    if (n(e, "validate"), e.chainOf = t, t.length >= 2 && "type" in t[0] && t[0].type === "array" && !("each" in t[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return e;
  }
  n(FC, "chain");
  var ZTe = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], e0e = ["default", "optional", "deprecate\
d", "validate"], Hy = {};
  function t0e(...t) {
    return (e, r = {}) => {
      let s = r.aliases;
      if (!s) {
        var i, a;
        r.inherits && (s = (i = Hy[r.inherits].aliases) == null ? void 0 : i.slice()), (a = s) != null || (s = []), r.aliases = s;
      }
      let o = t.filter((l) => !s.includes(l));
      s.unshift(...o), jC(e, r);
    };
  }
  n(t0e, "defineAliasedType");
  function jC(t, e = {}) {
    let r = e.inherits && Hy[e.inherits] || {}, s = e.fields;
    if (!s && (s = {}, r.fields)) {
      let l = Object.getOwnPropertyNames(r.fields);
      for (let u of l) {
        let c = r.fields[u], p = c.default;
        if (Array.isArray(p) ? p.length > 0 : p && typeof p == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        s[u] = {
          default: Array.isArray(p) ? [] : p,
          optional: c.optional,
          deprecated: c.deprecated,
          validate: c.validate
        };
      }
    }
    let i = e.visitor || r.visitor || [], a = e.aliases || r.aliases || [], o = e.builder || r.builder || e.visitor || [];
    for (let l of Object.keys(e))
      if (ZTe.indexOf(l) === -1)
        throw new Error(`Unknown type option "${l}" on ${t}`);
    e.deprecatedAlias && (KTe[e.deprecatedAlias] = t);
    for (let l of i.concat(o))
      s[l] = s[l] || {};
    for (let l of Object.keys(s)) {
      let u = s[l];
      u.default !== void 0 && o.indexOf(l) === -1 && (u.optional = !0), u.default === void 0 ? u.default = null : !u.validate && u.default !=
      null && (u.validate = Gy(cc(u.default)));
      for (let c of Object.keys(u))
        if (e0e.indexOf(c) === -1)
          throw new Error(`Unknown field key "${c}" on ${t}.${l}`);
    }
    RTe[t] = e.visitor = i, VTe[t] = e.builder = o, qTe[t] = e.fields = s, UTe[t] = e.aliases = a, a.forEach((l) => {
      Xy[l] = Xy[l] || [], Xy[l].push(t);
    }), e.validate && (WTe[t] = e.validate), Hy[t] = e;
  }
  n(jC, "defineType");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/core.js
var Zy = w((kr) => {
  "use strict";
  Object.defineProperty(kr, "__esModule", {
    value: !0
  });
  kr.patternLikeCommon = kr.functionTypeAnnotationCommon = kr.functionDeclarationCommon = kr.functionCommon = kr.classMethodOrPropertyCommon =
  kr.classMethodOrDeclareMethodCommon = void 0;
  var gr = Yn(), r0e = Jn(), RC = Wa(), s0e = kC(), wo = ci(), d = _s(), re = (0, d.defineAliasedType)("Standardized");
  re("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeOrValueType)("null", "Expression", "Spread\
Element"))),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  re("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, d.assertValueType)("string");
          let t = (0, d.assertOneOf)(...wo.ASSIGNMENT_OPERATORS), e = (0, d.assertOneOf)("=");
          return function(r, s, i) {
            ((0, gr.default)("Pattern", r.left) ? e : t)(r, s, i);
          };
        }()
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, d.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, d.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  re("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, d.assertOneOf)(...wo.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let t = (0, d.assertNodeType)("Expression"), e = (0, d.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(s, i, a) {
            (s.operator === "in" ? e : t)(s, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, d.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  re("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, d.assertValueType)("string")
      }
    }
  });
  re("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, d.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  re("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, d.assertValueType)("string")
      }
    }
  });
  re("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  re("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, d.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  re("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, d.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Expression", "SpreadElement", "JSXN\
amespacedName", "ArgumentPlaceholder")))
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, d.assertOneOf)(!0, !1),
        optional: !0
      }
    }, {
      typeArguments: {
        validate: (0, d.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, d.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  re("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, d.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, d.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  re("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, d.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, d.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, d.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  re("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, d.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  re("DebuggerStatement", {
    aliases: ["Statement"]
  });
  re("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, d.assertNodeType)("Expression")
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  re("EmptyStatement", {
    aliases: ["Statement"]
  });
  re("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, d.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  re("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, d.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.assertEach)((0, d.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, d.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  re("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, d.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, d.assertNodeType)("Expression")
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      }
    }
  });
  re("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, d.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      }
    }
  });
  var Xn = /* @__PURE__ */ n(() => ({
    params: {
      validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  kr.functionCommon = Xn;
  var zi = /* @__PURE__ */ n(() => ({
    returnType: {
      validate: (0, d.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, d.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  kr.functionTypeAnnotationCommon = zi;
  var UC = /* @__PURE__ */ n(() => Object.assign({}, Xn(), {
    declare: {
      validate: (0, d.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, d.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  kr.functionDeclarationCommon = UC;
  re("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, UC(), zi(), {
      body: {
        validate: (0, d.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, d.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING) return () => {
      };
      let t = (0, d.assertNodeType)("Identifier");
      return function(e, r, s) {
        (0, gr.default)("ExportDefaultDeclaration", e) || t(s, "id", s.id);
      };
    }()
  });
  re("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Xn(), zi(), {
      id: {
        validate: (0, d.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, d.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, d.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var $n = /* @__PURE__ */ n(() => ({
    typeAnnotation: {
      validate: (0, d.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, d.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "patternLikeCommon");
  kr.patternLikeCommon = $n;
  re("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, $n(), {
      name: {
        validate: (0, d.chain)((0, d.assertValueType)("string"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && !(0, r0e.default)(r, !1))
            throw new TypeError(`"${r}" is not a valid identifier name`);
        }, {
          type: "string"
        }))
      }
    }),
    validate(t, e, r) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let s = /\.(\w+)$/.exec(e);
      if (!s) return;
      let [, i] = s, a = {
        computed: !1
      };
      if (i === "property") {
        if ((0, gr.default)("MemberExpression", t, a) || (0, gr.default)("OptionalMemberExpression", t, a)) return;
      } else if (i === "key") {
        if ((0, gr.default)("Property", t, a) || (0, gr.default)("Method", t, a)) return;
      } else if (i === "exported") {
        if ((0, gr.default)("ExportSpecifier", t)) return;
      } else if (i === "imported") {
        if ((0, gr.default)("ImportSpecifier", t, {
          imported: r
        })) return;
      } else if (i === "meta" && (0, gr.default)("MetaProperty", t, {
        meta: r
      }))
        return;
      if (((0, RC.isKeyword)(r.name) || (0, RC.isReservedWord)(r.name, !1)) && r.name !== "this")
        throw new TypeError(`"${r.name}" is not a valid identifier`);
    }
  });
  re("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, d.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, d.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, d.assertNodeType)("Statement")
      }
    }
  });
  re("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, d.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      }
    }
  });
  re("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, d.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  re("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, d.chain)((0, d.assertValueType)("number"), Object.assign(function(t, e, r) {
          if (1 / r < 0 || !Number.isFinite(r)) {
            let s = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  re("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  re("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, d.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  re("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, d.assertValueType)("string")
      },
      flags: {
        validate: (0, d.chain)((0, d.assertValueType)("string"), Object.assign(function(t, e, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let s = /[^gimsuy]/.exec(r);
          if (s)
            throw new TypeError(`"${s[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  });
  re("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, d.assertOneOf)(...wo.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, d.assertNodeType)("Expression")
      },
      right: {
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, d.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let t = (0, d.assertNodeType)("Identifier", "PrivateName"), e = (0, d.assertNodeType)("Expression"), r = /* @__PURE__ */ n(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, d.assertOneOf)(!0, !1),
        optional: !0
      }
    })
  });
  re("NewExpression", {
    inherits: "CallExpression"
  });
  re("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, d.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, d.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  re("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ObjectMethod", "ObjectProperty", "S\
preadElement")))
      }
    }
  });
  re("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, Xn(), zi(), {
      kind: Object.assign({
        validate: (0, d.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, d.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, d.assertNodeType)("Expres\
sion"), r = /* @__PURE__ */ n(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
        }()
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      },
      body: {
        validate: (0, d.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  re("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, d.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), e = (0, d.
          assertNodeType)("Expression");
          return Object.assign(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, d.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, d.chain)((0, d.assertValueType)("boolean"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && t.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, {
          type: "boolean"
        }), function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !(0, gr.default)("Identifier", t.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }),
        default: !1
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      let t = (0, d.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), e = (0, d.assertNodeType)("Expression");
      return function(r, s, i) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        ((0, gr.default)("ObjectPattern", r) ? t : e)(i, "value", i.value);
      };
    }()
  });
  re("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, $n(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, d.assertNodeType)("LVal")
      }
    }),
    validate(t, e) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let r = /(\w+)\[(\d+)\]/.exec(e);
      if (!r) throw new Error("Internal Babel error: malformed key.");
      let [, s, i] = r;
      if (t[s].length > +i + 1)
        throw new TypeError(`RestElement must be last element of ${s}`);
    }
  });
  re("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  re("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  re("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Statement")))
      }
    }
  });
  re("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, d.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("SwitchCase")))
      }
    }
  });
  re("ThisExpression", {
    aliases: ["Expression"]
  });
  re("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, d.chain)((0, d.assertNodeType)("BlockStatement"), Object.assign(function(t) {
          if (process.env.BABEL_TYPES_8_BREAKING && !t.handler && !t.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: !0,
        validate: (0, d.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, d.assertNodeType)("BlockStatement")
      }
    }
  });
  re("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, d.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, d.assertOneOf)(...wo.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  re("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.assertNodeType)("Identifier", "MemberExpression") : (0, d.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, d.assertOneOf)(...wo.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  re("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, d.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(t, e, r) {
      if (process.env.BABEL_TYPES_8_BREAKING && (0, gr.default)("ForXStatement", t, {
        left: r
      }) && r.declarations.length !== 1)
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${t.type}`);
    }
  });
  re("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, d.assertNodeType)("LVal");
          let t = (0, d.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), e = (0, d.assertNodeType)("Identifier");
          return function(r, s, i) {
            (r.init ? t : e)(r, s, i);
          };
        }()
      },
      definite: {
        optional: !0,
        validate: (0, d.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, d.assertNodeType)("Expression")
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      }
    }
  });
  re("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, d.assertNodeType)("Expression")
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      }
    }
  });
  re("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, $n(), {
      left: {
        validate: (0, d.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, d.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      }
    })
  });
  re("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, $n(), {
      elements: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  re("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Xn(), zi(), {
      expression: {
        validate: (0, d.assertValueType)("boolean")
      },
      body: {
        validate: (0, d.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, d.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  re("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ClassMethod", "ClassPrivateMethod",
        "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  });
  re("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, d.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, d.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, d.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, d.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, d.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, d.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  re("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, d.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, d.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, d.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, d.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, d.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, d.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: function() {
      let t = (0, d.assertNodeType)("Identifier");
      return function(e, r, s) {
        process.env.BABEL_TYPES_8_BREAKING && ((0, gr.default)("ExportDefaultDeclaration", e) || t(s, "id", s.id));
      };
    }()
  });
  re("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, d.assertNodeType)("StringLiteral")
      },
      exportKind: (0, d.validateOptional)((0, d.assertOneOf)("type", "value")),
      attributes: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportAttribute")))
      }
    }
  });
  re("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, d.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, d.validateOptional)((0, d.assertOneOf)("value"))
    }
  });
  re("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertNodeType)("Declaration"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && t.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && t.source)
            throw new TypeError("Cannot export a declaration from a source");
        })
      },
      attributes: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)(function() {
          let t = (0, d.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), e = (0, d.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(r, s, i) {
            (r.source ? t : e)(r, s, i);
          } : t;
        }()))
      },
      source: {
        validate: (0, d.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, d.validateOptional)((0, d.assertOneOf)("type", "value"))
    }
  });
  re("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, d.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, d.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, d.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  re("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, d.assertNodeType)("VariableDeclaration", "LVal");
          let t = (0, d.assertNodeType)("VariableDeclaration"), e = (0, d.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(r, s, i) {
            (0, gr.default)("VariableDeclaration", i) ? t(r, s, i) : e(r, s, i);
          };
        }()
      },
      right: {
        validate: (0, d.assertNodeType)("Expression")
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  re("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportAttribute")))
      },
      module: {
        optional: !0,
        validate: (0, d.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, d.assertOneOf)("source", "defer")
      },
      specifiers: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportSpecifier", "ImportDefaultSpe\
cifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, d.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, d.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  re("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, d.assertNodeType)("Identifier")
      }
    }
  });
  re("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, d.assertNodeType)("Identifier")
      }
    }
  });
  re("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, d.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, d.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, d.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  re("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, d.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, d.assertNodeType)("Expression")
      },
      options: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  re("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, d.chain)((0, d.assertNodeType)("Identifier"), Object.assign(function(t, e, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let s;
          switch (r.name) {
            case "function":
              s = "sent";
              break;
            case "new":
              s = "target";
              break;
            case "import":
              s = "meta";
              break;
          }
          if (!(0, gr.default)("Identifier", t.property, {
            name: s
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, d.assertNodeType)("Identifier")
      }
    }
  });
  var dc = /* @__PURE__ */ n(() => ({
    abstract: {
      validate: (0, d.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, d.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, d.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, d.chain)(function() {
        let t = (0, d.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, d.assertNodeType)("Expressi\
on");
        return function(r, s, i) {
          (r.computed ? e : t)(r, s, i);
        };
      }(), (0, d.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  kr.classMethodOrPropertyCommon = dc;
  var Qy = /* @__PURE__ */ n(() => Object.assign({}, Xn(), dc(), {
    params: {
      validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Identifier", "Pattern", "RestElement",
      "TSParameterProperty")))
    },
    kind: {
      validate: (0, d.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, d.chain)((0, d.assertValueType)("string"), (0, d.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  kr.classMethodOrDeclareMethodCommon = Qy;
  re("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, Qy(), zi(), {
      body: {
        validate: (0, d.assertNodeType)("BlockStatement")
      }
    })
  });
  re("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, $n(), {
      properties: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  });
  re("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("Super", {
    aliases: ["Expression"]
  });
  re("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, d.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, d.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, d.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  re("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, d.chain)((0, d.assertShape)({
          raw: {
            validate: (0, d.assertValueType)("string")
          },
          cooked: {
            validate: (0, d.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ n(function(e) {
          let r = e.value.raw, s = !1, i = /* @__PURE__ */ n(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, s0e.readStringContents)("template", r, 0, 0, 0, {
            unterminated() {
              s = !0;
            },
            strictNumericEscape: i,
            invalidEscapeSequence: i,
            numericSeparatorInEscapeSequence: i,
            unexpectedNumericSeparator: i,
            invalidDigit: i,
            invalidCodePoint: i
          });
          if (!s) throw new Error("Invalid raw");
          e.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  re("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Expression", "TSType")), function(t, e, r) {
          if (t.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${t.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${t.quasis.length}`);
        })
      }
    }
  });
  re("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, d.chain)((0, d.assertValueType)("boolean"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !t.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("Import", {
    aliases: ["Expression"]
  });
  re("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, d.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  re("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, d.assertNodeType)("Identifier")
      }
    }
  });
  re("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, d.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let t = (0, d.assertNodeType)("Identifier"), e = (0, d.assertNodeType)("Expression");
          return Object.assign(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.chain)((0, d.assertValueType)("boolean"), (0, d.assertOptionalChainStart)()) : (0, d.
        assertValueType)("boolean")
      }
    }
  });
  re("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, d.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Expression", "SpreadElement", "JSXN\
amespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.chain)((0, d.assertValueType)("boolean"), (0, d.assertOptionalChainStart)()) : (0, d.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, d.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, d.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  re("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, dc(), {
      value: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, d.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, d.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  re("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, dc(), {
      key: {
        validate: (0, d.chain)(function() {
          let t = (0, d.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), e = (0, d.assertNodeType)(
          "Expression");
          return function(r, s, i) {
            (r.computed ? e : t)(r, s, i);
          };
        }(), (0, d.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, d.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, d.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  re("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, d.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, d.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      },
      static: {
        validate: (0, d.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, d.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  re("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, Qy(), zi(), {
      kind: {
        validate: (0, d.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, d.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, d.assertNodeType)("BlockStatement")
      }
    })
  });
  re("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, d.assertNodeType)("Identifier")
      }
    }
  });
  re("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/flow.js
var qC = w(() => {
  "use strict";
  var K = _s(), xe = (0, K.defineAliasedType)("Flow"), eT = /* @__PURE__ */ n((t) => {
    let e = t === "DeclareClass";
    xe(t, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...e ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, K.validateType)("Identifier"),
        typeParameters: (0, K.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, K.validateOptional)((0, K.arrayOfType)("InterfaceExtends"))
      }, e ? {
        mixins: (0, K.validateOptional)((0, K.arrayOfType)("InterfaceExtends")),
        implements: (0, K.validateOptional)((0, K.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, K.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  xe("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, K.validateType)("FlowType")
    }
  });
  xe("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      typeParameters: (0, K.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  eT("DeclareClass");
  xe("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      predicate: (0, K.validateOptionalType)("DeclaredPredicate")
    }
  });
  eT("DeclareInterface");
  xe("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)(["Identifier", "StringLiteral"]),
      body: (0, K.validateType)("BlockStatement"),
      kind: (0, K.validateOptional)((0, K.assertOneOf)("CommonJS", "ES"))
    }
  });
  xe("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, K.validateType)("TypeAnnotation")
    }
  });
  xe("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      typeParameters: (0, K.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, K.validateType)("FlowType")
    }
  });
  xe("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      typeParameters: (0, K.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, K.validateOptionalType)("FlowType"),
      impltype: (0, K.validateOptionalType)("FlowType")
    }
  });
  xe("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)("Identifier")
    }
  });
  xe("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, K.validateOptionalType)("Flow"),
      specifiers: (0, K.validateOptional)((0, K.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, K.validateOptionalType)("StringLiteral"),
      default: (0, K.validateOptional)((0, K.assertValueType)("boolean"))
    }
  });
  xe("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, K.validateType)("StringLiteral"),
      exportKind: (0, K.validateOptional)((0, K.assertOneOf)("type", "value"))
    }
  });
  xe("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, K.validateType)("Flow")
    }
  });
  xe("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  xe("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, K.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, K.validate)((0, K.arrayOfType)("FunctionTypeParam")),
      rest: (0, K.validateOptionalType)("FunctionTypeParam"),
      this: (0, K.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, K.validateType)("FlowType")
    }
  });
  xe("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, K.validateOptionalType)("Identifier"),
      typeAnnotation: (0, K.validateType)("FlowType"),
      optional: (0, K.validateOptional)((0, K.assertValueType)("boolean"))
    }
  });
  xe("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, K.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, K.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  xe("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  xe("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, K.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, K.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  eT("InterfaceDeclaration");
  xe("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, K.validateOptional)((0, K.arrayOfType)("InterfaceExtends")),
      body: (0, K.validateType)("ObjectTypeAnnotation")
    }
  });
  xe("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, K.validate)((0, K.arrayOfType)("FlowType"))
    }
  });
  xe("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, K.validateType)("FlowType")
    }
  });
  xe("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, K.validate)((0, K.assertValueType)("number"))
    }
  });
  xe("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, K.validate)((0, K.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, K.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, K.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, K.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, K.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, K.validateOptional)((0, K.assertValueType)("boolean"))
    }
  });
  xe("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      value: (0, K.validateType)("FlowType"),
      optional: (0, K.validate)((0, K.assertValueType)("boolean")),
      static: (0, K.validate)((0, K.assertValueType)("boolean")),
      method: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, K.validateType)("FlowType"),
      static: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, K.validateOptionalType)("Identifier"),
      key: (0, K.validateType)("FlowType"),
      value: (0, K.validateType)("FlowType"),
      static: (0, K.validate)((0, K.assertValueType)("boolean")),
      variance: (0, K.validateOptionalType)("Variance")
    }
  });
  xe("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, K.validateType)(["Identifier", "StringLiteral"]),
      value: (0, K.validateType)("FlowType"),
      kind: (0, K.validate)((0, K.assertOneOf)("init", "get", "set")),
      static: (0, K.validate)((0, K.assertValueType)("boolean")),
      proto: (0, K.validate)((0, K.assertValueType)("boolean")),
      optional: (0, K.validate)((0, K.assertValueType)("boolean")),
      variance: (0, K.validateOptionalType)("Variance"),
      method: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, K.validateType)("FlowType")
    }
  });
  xe("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      typeParameters: (0, K.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, K.validateOptionalType)("FlowType"),
      impltype: (0, K.validateType)("FlowType")
    }
  });
  xe("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      qualification: (0, K.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  xe("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, K.validate)((0, K.assertValueType)("string"))
    }
  });
  xe("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, K.validate)((0, K.arrayOfType)("FlowType"))
    }
  });
  xe("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, K.validateType)("FlowType")
    }
  });
  xe("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      typeParameters: (0, K.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, K.validateType)("FlowType")
    }
  });
  xe("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, K.validateType)("FlowType")
    }
  });
  xe("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, K.validateType)("Expression"),
      typeAnnotation: (0, K.validateType)("TypeAnnotation")
    }
  });
  xe("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, K.validate)((0, K.assertValueType)("string")),
      bound: (0, K.validateOptionalType)("TypeAnnotation"),
      default: (0, K.validateOptionalType)("FlowType"),
      variance: (0, K.validateOptionalType)("Variance")
    }
  });
  xe("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, K.validate)((0, K.arrayOfType)("TypeParameter"))
    }
  });
  xe("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, K.validate)((0, K.arrayOfType)("FlowType"))
    }
  });
  xe("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, K.validate)((0, K.arrayOfType)("FlowType"))
    }
  });
  xe("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, K.validate)((0, K.assertOneOf)("minus", "plus"))
    }
  });
  xe("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      body: (0, K.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  xe("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, K.validate)((0, K.assertValueType)("boolean")),
      members: (0, K.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, K.validate)((0, K.assertValueType)("boolean")),
      members: (0, K.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, K.validate)((0, K.assertValueType)("boolean")),
      members: (0, K.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, K.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      init: (0, K.validateType)("BooleanLiteral")
    }
  });
  xe("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      init: (0, K.validateType)("NumericLiteral")
    }
  });
  xe("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      init: (0, K.validateType)("StringLiteral")
    }
  });
  xe("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, K.validateType)("Identifier")
    }
  });
  xe("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, K.validateType)("FlowType"),
      indexType: (0, K.validateType)("FlowType")
    }
  });
  xe("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, K.validateType)("FlowType"),
      indexType: (0, K.validateType)("FlowType"),
      optional: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/jsx.js
var VC = w(() => {
  "use strict";
  var dt = _s(), Pr = (0, dt.defineAliasedType)("JSX");
  Pr("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, dt.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, dt.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  Pr("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, dt.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  Pr("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, dt.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, dt.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, dt.chain)((0, dt.assertValueType)("array"), (0, dt.assertEach)((0, dt.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, dt.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  Pr("JSXEmptyExpression", {});
  Pr("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, dt.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  Pr("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, dt.assertNodeType)("Expression")
      }
    }
  });
  Pr("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, dt.assertValueType)("string")
      }
    }
  });
  Pr("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, dt.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, dt.assertNodeType)("JSXIdentifier")
      }
    }
  });
  Pr("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, dt.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, dt.assertNodeType)("JSXIdentifier")
      }
    }
  });
  Pr("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, dt.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: {
        validate: (0, dt.chain)((0, dt.assertValueType)("array"), (0, dt.assertEach)((0, dt.assertNodeType)("JSXAttribute", "JSXSpreadAttrib\
ute")))
      },
      typeParameters: {
        validate: (0, dt.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  Pr("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, dt.assertNodeType)("Expression")
      }
    }
  });
  Pr("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, dt.assertValueType)("string")
      }
    }
  });
  Pr("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, dt.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, dt.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, dt.chain)((0, dt.assertValueType)("array"), (0, dt.assertEach)((0, dt.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  Pr("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  Pr("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/placeholders.js
var sT = w((pi) => {
  "use strict";
  Object.defineProperty(pi, "__esModule", {
    value: !0
  });
  pi.PLACEHOLDERS_FLIPPED_ALIAS = pi.PLACEHOLDERS_ALIAS = pi.PLACEHOLDERS = void 0;
  var i0e = _s(), n0e = pi.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "Class\
Body", "Pattern"], rT = pi.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let t of n0e) {
    let e = i0e.ALIAS_KEYS[t];
    e != null && e.length && (rT[t] = e);
  }
  var tT = pi.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(rT).forEach((t) => {
    rT[t].forEach((e) => {
      hasOwnProperty.call(tT, e) || (tT[e] = []), tT[e].push(t);
    });
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/misc.js
var KC = w(() => {
  "use strict";
  var mc = _s(), a0e = sT(), iT = (0, mc.defineAliasedType)("Miscellaneous");
  iT("Noop", {
    visitor: []
  });
  iT("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, mc.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, mc.assertOneOf)(...a0e.PLACEHOLDERS)
      }
    }
  });
  iT("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, mc.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/experimental.js
var WC = w(() => {
  "use strict";
  var nt = _s();
  (0, nt.default)("ArgumentPlaceholder", {});
  (0, nt.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, nt.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, nt.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, nt.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, nt.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, nt.assertNodeType)("StringLiteral")
      }
    }
  });
  (0, nt.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, nt.assertNodeType)("Expression")
      }
    }
  });
  (0, nt.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, nt.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, nt.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, nt.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, nt.assertNodeType)("Identifier")
      }
    }
  });
  (0, nt.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, nt.chain)((0, nt.assertValueType)("array"), (0, nt.assertEach)((0, nt.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  });
  (0, nt.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, nt.chain)((0, nt.assertValueType)("array"), (0, nt.assertEach)((0, nt.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, nt.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, nt.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, nt.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, nt.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, nt.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, nt.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, nt.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, nt.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, nt.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, nt.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/typescript.js
var QC = w(() => {
  "use strict";
  var $ = _s(), YC = Zy(), o0e = Yn(), Le = (0, $.defineAliasedType)("TypeScript"), Dr = (0, $.assertValueType)("boolean"), JC = /* @__PURE__ */ n(
  () => ({
    returnType: {
      validate: (0, $.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, $.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  Le("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, $.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, $.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, $.chain)((0, $.assertValueType)("array"), (0, $.assertEach)((0, $.assertNodeType)("Decorator"))),
        optional: !0
      }
    }
  });
  Le("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, YC.functionDeclarationCommon)(), JC())
  });
  Le("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, YC.classMethodOrDeclareMethodCommon)(), JC())
  });
  Le("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, $.validateType)("TSEntityName"),
      right: (0, $.validateType)("Identifier")
    }
  });
  var yc = /* @__PURE__ */ n(() => ({
    typeParameters: (0, $.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, $.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    typeAnnotation: (0, $.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), XC = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: yc()
  };
  Le("TSCallSignatureDeclaration", XC);
  Le("TSConstructSignatureDeclaration", XC);
  var $C = /* @__PURE__ */ n(() => ({
    key: (0, $.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, $.validateOptional)(Dr)
  }), "namedTypeElementCommon");
  Le("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, $C(), {
      readonly: (0, $.validateOptional)(Dr),
      typeAnnotation: (0, $.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        validate: (0, $.assertOneOf)("get", "set")
      }
    })
  });
  Le("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, yc(), $C(), {
      kind: {
        validate: (0, $.assertOneOf)("method", "get", "set")
      }
    })
  });
  Le("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, $.validateOptional)(Dr),
      static: (0, $.validateOptional)(Dr),
      parameters: (0, $.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, $.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var l0e = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeywor\
d", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let t of l0e)
    Le(t, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  Le("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var HC = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  Le("TSFunctionType", Object.assign({}, HC, {
    fields: yc()
  }));
  Le("TSConstructorType", Object.assign({}, HC, {
    fields: Object.assign({}, yc(), {
      abstract: (0, $.validateOptional)(Dr)
    })
  }));
  Le("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, $.validateType)("TSEntityName"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Le("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, $.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, $.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, $.validateOptional)(Dr)
    }
  });
  Le("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, $.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Le("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, $.validateArrayOfType)("TSTypeElement")
    }
  });
  Le("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, $.validateType)("TSType")
    }
  });
  Le("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, $.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  });
  Le("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  Le("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  Le("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, $.validateType)("Identifier"),
      optional: {
        validate: Dr,
        default: !1
      },
      elementType: (0, $.validateType)("TSType")
    }
  });
  var zC = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, $.validateArrayOfType)("TSType")
    }
  };
  Le("TSUnionType", zC);
  Le("TSIntersectionType", zC);
  Le("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, $.validateType)("TSType"),
      extendsType: (0, $.validateType)("TSType"),
      trueType: (0, $.validateType)("TSType"),
      falseType: (0, $.validateType)("TSType")
    }
  });
  Le("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, $.validateType)("TSTypeParameter")
    }
  });
  Le("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  Le("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, $.validate)((0, $.assertValueType)("string")),
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  Le("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, $.validateType)("TSType"),
      indexType: (0, $.validateType)("TSType")
    }
  });
  Le("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, $.validateOptional)((0, $.assertOneOf)(!0, !1, "+", "-")),
      typeParameter: (0, $.validateType)("TSTypeParameter"),
      optional: (0, $.validateOptional)((0, $.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, $.validateOptionalType)("TSType"),
      nameType: (0, $.validateOptionalType)("TSType")
    }
  });
  Le("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let t = (0, $.assertNodeType)("NumericLiteral", "BigIntLiteral"), e = (0, $.assertOneOf)("-"), r = (0, $.assertNodeType)("NumericL\
iteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function s(i, a, o) {
            (0, o0e.default)("UnaryExpression", o) ? (e(o, "operator", o.operator), t(o, "argument", o.argument)) : r(i, a, o);
          }
          return n(s, "validator"), s.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiter\
al", "UnaryExpression"], s;
        }()
      }
    }
  });
  Le("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, $.validateType)("TSEntityName"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Le("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, $.validateOptional)(Dr),
      id: (0, $.validateType)("Identifier"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, $.validateOptional)((0, $.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, $.validateType)("TSInterfaceBody")
    }
  });
  Le("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, $.validateArrayOfType)("TSTypeElement")
    }
  });
  Le("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, $.validateOptional)(Dr),
      id: (0, $.validateType)("Identifier"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  Le("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, $.validateType)("Expression"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var GC = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, $.validateType)("Expression"),
      typeAnnotation: (0, $.validateType)("TSType")
    }
  };
  Le("TSAsExpression", GC);
  Le("TSSatisfiesExpression", GC);
  Le("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, $.validateType)("TSType"),
      expression: (0, $.validateType)("Expression")
    }
  });
  Le("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, $.validateOptional)(Dr),
      const: (0, $.validateOptional)(Dr),
      id: (0, $.validateType)("Identifier"),
      members: (0, $.validateArrayOfType)("TSEnumMember"),
      initializer: (0, $.validateOptionalType)("Expression")
    }
  });
  Le("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, $.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, $.validateOptionalType)("Expression")
    }
  });
  Le("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, $.validateOptional)(Dr),
      global: (0, $.validateOptional)(Dr),
      id: (0, $.validateType)(["Identifier", "StringLiteral"]),
      body: (0, $.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  Le("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, $.validateArrayOfType)("Statement")
    }
  });
  Le("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, $.validateType)("StringLiteral"),
      qualifier: (0, $.validateOptionalType)("TSEntityName"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, $.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  Le("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, $.validate)(Dr),
      id: (0, $.validateType)("Identifier"),
      moduleReference: (0, $.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, $.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  Le("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, $.validateType)("StringLiteral")
    }
  });
  Le("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, $.validateType)("Expression")
    }
  });
  Le("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, $.validateType)("Expression")
    }
  });
  Le("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, $.validateType)("Identifier")
    }
  });
  Le("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, $.assertNodeType)("TSType")
      }
    }
  });
  Le("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, $.chain)((0, $.assertValueType)("array"), (0, $.assertEach)((0, $.assertNodeType)("TSType")))
      }
    }
  });
  Le("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, $.chain)((0, $.assertValueType)("array"), (0, $.assertEach)((0, $.assertNodeType)("TSTypeParameter")))
      }
    }
  });
  Le("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, $.assertValueType)("string")
      },
      in: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, $.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, $.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var ZC = w((Tc) => {
  "use strict";
  Object.defineProperty(Tc, "__esModule", {
    value: !0
  });
  Tc.DEPRECATED_ALIASES = void 0;
  var tRe = Tc.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/index.js
var Vr = w((Er) => {
  "use strict";
  Object.defineProperty(Er, "__esModule", {
    value: !0
  });
  Object.defineProperty(Er, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qt.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(Er, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qt.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty(Er, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return nT.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty(Er, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qt.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty(Er, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qt.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(Er, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qt.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty(Er, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qt.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty(Er, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return No.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty(Er, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return No.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty(Er, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return No.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  Er.TYPES = void 0;
  Object.defineProperty(Er, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qt.VISITOR_KEYS;
    }, "get")
  });
  var fi = lp();
  Zy();
  qC();
  VC();
  KC();
  WC();
  QC();
  var Qt = _s(), No = sT(), nT = ZC();
  Object.keys(nT.DEPRECATED_ALIASES).forEach((t) => {
    Qt.FLIPPED_ALIAS_KEYS[t] = Qt.FLIPPED_ALIAS_KEYS[nT.DEPRECATED_ALIASES[t]];
  });
  fi(Qt.VISITOR_KEYS);
  fi(Qt.ALIAS_KEYS);
  fi(Qt.FLIPPED_ALIAS_KEYS);
  fi(Qt.NODE_FIELDS);
  fi(Qt.BUILDER_KEYS);
  fi(Qt.DEPRECATED_KEYS);
  fi(No.PLACEHOLDERS_ALIAS);
  fi(No.PLACEHOLDERS_FLIPPED_ALIAS);
  var sRe = Er.TYPES = [].concat(Object.keys(Qt.VISITOR_KEYS), Object.keys(Qt.FLIPPED_ALIAS_KEYS), Object.keys(Qt.DEPRECATED_KEYS));
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/validate.js
var hc = w((Oo) => {
  "use strict";
  Object.defineProperty(Oo, "__esModule", {
    value: !0
  });
  Oo.default = u0e;
  Oo.validateChild = rI;
  Oo.validateField = tI;
  var eI = Vr();
  function u0e(t, e, r) {
    if (!t) return;
    let s = eI.NODE_FIELDS[t.type];
    if (!s) return;
    let i = s[e];
    tI(t, e, r, i), rI(t, e, r);
  }
  n(u0e, "validate");
  function tI(t, e, r, s) {
    s != null && s.validate && (s.optional && r == null || s.validate(t, e, r));
  }
  n(tI, "validateField");
  function rI(t, e, r) {
    if (r == null) return;
    let s = eI.NODE_PARENT_VALIDATIONS[r.type];
    s && s(t, e, r);
  }
  n(rI, "validateChild");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/validateNode.js
var sI = w((aT) => {
  "use strict";
  Object.defineProperty(aT, "__esModule", {
    value: !0
  });
  aT.default = f0e;
  var c0e = hc(), p0e = ko();
  function f0e(t) {
    let e = p0e.BUILDER_KEYS[t.type];
    for (let r of e)
      (0, c0e.default)(t, r, t[r]);
    return t;
  }
  n(f0e, "validateNode");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/generated/index.js
var Ar = w((x) => {
  "use strict";
  Object.defineProperty(x, "__esModule", {
    value: !0
  });
  x.anyTypeAnnotation = Kbe;
  x.argumentPlaceholder = bSe;
  x.arrayExpression = h0e;
  x.arrayPattern = lbe;
  x.arrayTypeAnnotation = Wbe;
  x.arrowFunctionExpression = ube;
  x.assignmentExpression = d0e;
  x.assignmentPattern = obe;
  x.awaitExpression = kbe;
  x.bigIntLiteral = _be;
  x.binaryExpression = m0e;
  x.bindExpression = xSe;
  x.blockStatement = x0e;
  x.booleanLiteral = R0e;
  x.booleanLiteralTypeAnnotation = Jbe;
  x.booleanTypeAnnotation = Ybe;
  x.breakStatement = S0e;
  x.callExpression = g0e;
  x.catchClause = P0e;
  x.classAccessorProperty = jbe;
  x.classBody = cbe;
  x.classDeclaration = fbe;
  x.classExpression = pbe;
  x.classImplements = $be;
  x.classMethod = Abe;
  x.classPrivateMethod = Ube;
  x.classPrivateProperty = Rbe;
  x.classProperty = Fbe;
  x.conditionalExpression = E0e;
  x.continueStatement = A0e;
  x.debuggerStatement = v0e;
  x.decimalLiteral = CSe;
  x.declareClass = Hbe;
  x.declareExportAllDeclaration = ixe;
  x.declareExportDeclaration = sxe;
  x.declareFunction = zbe;
  x.declareInterface = Gbe;
  x.declareModule = Qbe;
  x.declareModuleExports = Zbe;
  x.declareOpaqueType = txe;
  x.declareTypeAlias = exe;
  x.declareVariable = rxe;
  x.declaredPredicate = nxe;
  x.decorator = gSe;
  x.directive = T0e;
  x.directiveLiteral = b0e;
  x.doExpression = PSe;
  x.doWhileStatement = C0e;
  x.emptyStatement = I0e;
  x.emptyTypeAnnotation = yxe;
  x.enumBooleanBody = Wxe;
  x.enumBooleanMember = $xe;
  x.enumDeclaration = Kxe;
  x.enumDefaultedMember = Gxe;
  x.enumNumberBody = Yxe;
  x.enumNumberMember = Hxe;
  x.enumStringBody = Jxe;
  x.enumStringMember = zxe;
  x.enumSymbolBody = Xxe;
  x.existsTypeAnnotation = axe;
  x.exportAllDeclaration = hbe;
  x.exportDefaultDeclaration = dbe;
  x.exportDefaultSpecifier = ESe;
  x.exportNamedDeclaration = mbe;
  x.exportNamespaceSpecifier = Lbe;
  x.exportSpecifier = ybe;
  x.expressionStatement = w0e;
  x.file = N0e;
  x.forInStatement = O0e;
  x.forOfStatement = Tbe;
  x.forStatement = k0e;
  x.functionDeclaration = D0e;
  x.functionExpression = _0e;
  x.functionTypeAnnotation = oxe;
  x.functionTypeParam = lxe;
  x.genericTypeAnnotation = uxe;
  x.identifier = L0e;
  x.ifStatement = M0e;
  x.import = Dbe;
  x.importAttribute = SSe;
  x.importDeclaration = bbe;
  x.importDefaultSpecifier = xbe;
  x.importExpression = Pbe;
  x.importNamespaceSpecifier = Sbe;
  x.importSpecifier = gbe;
  x.indexedAccessType = Qxe;
  x.inferredPredicate = cxe;
  x.interfaceDeclaration = fxe;
  x.interfaceExtends = pxe;
  x.interfaceTypeAnnotation = hxe;
  x.interpreterDirective = y0e;
  x.intersectionTypeAnnotation = dxe;
  x.jSXAttribute = x.jsxAttribute = eSe;
  x.jSXClosingElement = x.jsxClosingElement = tSe;
  x.jSXClosingFragment = x.jsxClosingFragment = dSe;
  x.jSXElement = x.jsxElement = rSe;
  x.jSXEmptyExpression = x.jsxEmptyExpression = sSe;
  x.jSXExpressionContainer = x.jsxExpressionContainer = iSe;
  x.jSXFragment = x.jsxFragment = fSe;
  x.jSXIdentifier = x.jsxIdentifier = aSe;
  x.jSXMemberExpression = x.jsxMemberExpression = oSe;
  x.jSXNamespacedName = x.jsxNamespacedName = lSe;
  x.jSXOpeningElement = x.jsxOpeningElement = uSe;
  x.jSXOpeningFragment = x.jsxOpeningFragment = hSe;
  x.jSXSpreadAttribute = x.jsxSpreadAttribute = cSe;
  x.jSXSpreadChild = x.jsxSpreadChild = nSe;
  x.jSXText = x.jsxText = pSe;
  x.labeledStatement = B0e;
  x.logicalExpression = U0e;
  x.memberExpression = q0e;
  x.metaProperty = Ebe;
  x.mixedTypeAnnotation = mxe;
  x.moduleExpression = ISe;
  x.newExpression = V0e;
  x.noop = mSe;
  x.nullLiteral = j0e;
  x.nullLiteralTypeAnnotation = Xbe;
  x.nullableTypeAnnotation = Txe;
  x.numberLiteral = Kge;
  x.numberLiteralTypeAnnotation = bxe;
  x.numberTypeAnnotation = xxe;
  x.numericLiteral = iI;
  x.objectExpression = W0e;
  x.objectMethod = Y0e;
  x.objectPattern = vbe;
  x.objectProperty = J0e;
  x.objectTypeAnnotation = Sxe;
  x.objectTypeCallProperty = Pxe;
  x.objectTypeIndexer = Exe;
  x.objectTypeInternalSlot = gxe;
  x.objectTypeProperty = Axe;
  x.objectTypeSpreadProperty = vxe;
  x.opaqueType = Cxe;
  x.optionalCallExpression = Bbe;
  x.optionalIndexedAccessType = Zxe;
  x.optionalMemberExpression = Mbe;
  x.parenthesizedExpression = H0e;
  x.pipelineBareFunction = OSe;
  x.pipelinePrimaryTopicReference = kSe;
  x.pipelineTopicExpression = NSe;
  x.placeholder = ySe;
  x.privateName = qbe;
  x.program = K0e;
  x.qualifiedTypeIdentifier = Ixe;
  x.recordExpression = ASe;
  x.regExpLiteral = nI;
  x.regexLiteral = Wge;
  x.restElement = aI;
  x.restProperty = Yge;
  x.returnStatement = X0e;
  x.sequenceExpression = $0e;
  x.spreadElement = oI;
  x.spreadProperty = Jge;
  x.staticBlock = Vbe;
  x.stringLiteral = F0e;
  x.stringLiteralTypeAnnotation = wxe;
  x.stringTypeAnnotation = Nxe;
  x.super = Cbe;
  x.switchCase = z0e;
  x.switchStatement = G0e;
  x.symbolTypeAnnotation = Oxe;
  x.taggedTemplateExpression = Ibe;
  x.templateElement = wbe;
  x.templateLiteral = Nbe;
  x.thisExpression = Q0e;
  x.thisTypeAnnotation = kxe;
  x.throwStatement = Z0e;
  x.topicReference = wSe;
  x.tryStatement = ebe;
  x.tSAnyKeyword = x.tsAnyKeyword = qSe;
  x.tSArrayType = x.tsArrayType = oge;
  x.tSAsExpression = x.tsAsExpression = Cge;
  x.tSBigIntKeyword = x.tsBigIntKeyword = KSe;
  x.tSBooleanKeyword = x.tsBooleanKeyword = VSe;
  x.tSCallSignatureDeclaration = x.tsCallSignatureDeclaration = BSe;
  x.tSConditionalType = x.tsConditionalType = dge;
  x.tSConstructSignatureDeclaration = x.tsConstructSignatureDeclaration = FSe;
  x.tSConstructorType = x.tsConstructorType = rge;
  x.tSDeclareFunction = x.tsDeclareFunction = _Se;
  x.tSDeclareMethod = x.tsDeclareMethod = LSe;
  x.tSEnumDeclaration = x.tsEnumDeclaration = Nge;
  x.tSEnumMember = x.tsEnumMember = Oge;
  x.tSExportAssignment = x.tsExportAssignment = Fge;
  x.tSExpressionWithTypeArguments = x.tsExpressionWithTypeArguments = gge;
  x.tSExternalModuleReference = x.tsExternalModuleReference = Mge;
  x.tSFunctionType = x.tsFunctionType = tge;
  x.tSImportEqualsDeclaration = x.tsImportEqualsDeclaration = Lge;
  x.tSImportType = x.tsImportType = _ge;
  x.tSIndexSignature = x.tsIndexSignature = USe;
  x.tSIndexedAccessType = x.tsIndexedAccessType = bge;
  x.tSInferType = x.tsInferType = mge;
  x.tSInstantiationExpression = x.tsInstantiationExpression = vge;
  x.tSInterfaceBody = x.tsInterfaceBody = Ege;
  x.tSInterfaceDeclaration = x.tsInterfaceDeclaration = Pge;
  x.tSIntersectionType = x.tsIntersectionType = hge;
  x.tSIntrinsicKeyword = x.tsIntrinsicKeyword = WSe;
  x.tSLiteralType = x.tsLiteralType = Sge;
  x.tSMappedType = x.tsMappedType = xge;
  x.tSMethodSignature = x.tsMethodSignature = RSe;
  x.tSModuleBlock = x.tsModuleBlock = Dge;
  x.tSModuleDeclaration = x.tsModuleDeclaration = kge;
  x.tSNamedTupleMember = x.tsNamedTupleMember = pge;
  x.tSNamespaceExportDeclaration = x.tsNamespaceExportDeclaration = jge;
  x.tSNeverKeyword = x.tsNeverKeyword = YSe;
  x.tSNonNullExpression = x.tsNonNullExpression = Bge;
  x.tSNullKeyword = x.tsNullKeyword = JSe;
  x.tSNumberKeyword = x.tsNumberKeyword = XSe;
  x.tSObjectKeyword = x.tsObjectKeyword = $Se;
  x.tSOptionalType = x.tsOptionalType = uge;
  x.tSParameterProperty = x.tsParameterProperty = DSe;
  x.tSParenthesizedType = x.tsParenthesizedType = yge;
  x.tSPropertySignature = x.tsPropertySignature = jSe;
  x.tSQualifiedName = x.tsQualifiedName = MSe;
  x.tSRestType = x.tsRestType = cge;
  x.tSSatisfiesExpression = x.tsSatisfiesExpression = Ige;
  x.tSStringKeyword = x.tsStringKeyword = HSe;
  x.tSSymbolKeyword = x.tsSymbolKeyword = zSe;
  x.tSThisType = x.tsThisType = ege;
  x.tSTupleType = x.tsTupleType = lge;
  x.tSTypeAliasDeclaration = x.tsTypeAliasDeclaration = Age;
  x.tSTypeAnnotation = x.tsTypeAnnotation = Rge;
  x.tSTypeAssertion = x.tsTypeAssertion = wge;
  x.tSTypeLiteral = x.tsTypeLiteral = age;
  x.tSTypeOperator = x.tsTypeOperator = Tge;
  x.tSTypeParameter = x.tsTypeParameter = Vge;
  x.tSTypeParameterDeclaration = x.tsTypeParameterDeclaration = qge;
  x.tSTypeParameterInstantiation = x.tsTypeParameterInstantiation = Uge;
  x.tSTypePredicate = x.tsTypePredicate = ige;
  x.tSTypeQuery = x.tsTypeQuery = nge;
  x.tSTypeReference = x.tsTypeReference = sge;
  x.tSUndefinedKeyword = x.tsUndefinedKeyword = GSe;
  x.tSUnionType = x.tsUnionType = fge;
  x.tSUnknownKeyword = x.tsUnknownKeyword = QSe;
  x.tSVoidKeyword = x.tsVoidKeyword = ZSe;
  x.tupleExpression = vSe;
  x.tupleTypeAnnotation = Dxe;
  x.typeAlias = Lxe;
  x.typeAnnotation = Mxe;
  x.typeCastExpression = Bxe;
  x.typeParameter = Fxe;
  x.typeParameterDeclaration = jxe;
  x.typeParameterInstantiation = Rxe;
  x.typeofTypeAnnotation = _xe;
  x.unaryExpression = tbe;
  x.unionTypeAnnotation = Uxe;
  x.updateExpression = rbe;
  x.v8IntrinsicIdentifier = TSe;
  x.variableDeclaration = sbe;
  x.variableDeclarator = ibe;
  x.variance = qxe;
  x.voidTypeAnnotation = Vxe;
  x.whileStatement = nbe;
  x.withStatement = abe;
  x.yieldExpression = Obe;
  var R = sI(), bc = Ao();
  function h0e(t = []) {
    return (0, R.default)({
      type: "ArrayExpression",
      elements: t
    });
  }
  n(h0e, "arrayExpression");
  function d0e(t, e, r) {
    return (0, R.default)({
      type: "AssignmentExpression",
      operator: t,
      left: e,
      right: r
    });
  }
  n(d0e, "assignmentExpression");
  function m0e(t, e, r) {
    return (0, R.default)({
      type: "BinaryExpression",
      operator: t,
      left: e,
      right: r
    });
  }
  n(m0e, "binaryExpression");
  function y0e(t) {
    return (0, R.default)({
      type: "InterpreterDirective",
      value: t
    });
  }
  n(y0e, "interpreterDirective");
  function T0e(t) {
    return (0, R.default)({
      type: "Directive",
      value: t
    });
  }
  n(T0e, "directive");
  function b0e(t) {
    return (0, R.default)({
      type: "DirectiveLiteral",
      value: t
    });
  }
  n(b0e, "directiveLiteral");
  function x0e(t, e = []) {
    return (0, R.default)({
      type: "BlockStatement",
      body: t,
      directives: e
    });
  }
  n(x0e, "blockStatement");
  function S0e(t = null) {
    return (0, R.default)({
      type: "BreakStatement",
      label: t
    });
  }
  n(S0e, "breakStatement");
  function g0e(t, e) {
    return (0, R.default)({
      type: "CallExpression",
      callee: t,
      arguments: e
    });
  }
  n(g0e, "callExpression");
  function P0e(t = null, e) {
    return (0, R.default)({
      type: "CatchClause",
      param: t,
      body: e
    });
  }
  n(P0e, "catchClause");
  function E0e(t, e, r) {
    return (0, R.default)({
      type: "ConditionalExpression",
      test: t,
      consequent: e,
      alternate: r
    });
  }
  n(E0e, "conditionalExpression");
  function A0e(t = null) {
    return (0, R.default)({
      type: "ContinueStatement",
      label: t
    });
  }
  n(A0e, "continueStatement");
  function v0e() {
    return {
      type: "DebuggerStatement"
    };
  }
  n(v0e, "debuggerStatement");
  function C0e(t, e) {
    return (0, R.default)({
      type: "DoWhileStatement",
      test: t,
      body: e
    });
  }
  n(C0e, "doWhileStatement");
  function I0e() {
    return {
      type: "EmptyStatement"
    };
  }
  n(I0e, "emptyStatement");
  function w0e(t) {
    return (0, R.default)({
      type: "ExpressionStatement",
      expression: t
    });
  }
  n(w0e, "expressionStatement");
  function N0e(t, e = null, r = null) {
    return (0, R.default)({
      type: "File",
      program: t,
      comments: e,
      tokens: r
    });
  }
  n(N0e, "file");
  function O0e(t, e, r) {
    return (0, R.default)({
      type: "ForInStatement",
      left: t,
      right: e,
      body: r
    });
  }
  n(O0e, "forInStatement");
  function k0e(t = null, e = null, r = null, s) {
    return (0, R.default)({
      type: "ForStatement",
      init: t,
      test: e,
      update: r,
      body: s
    });
  }
  n(k0e, "forStatement");
  function D0e(t = null, e, r, s = !1, i = !1) {
    return (0, R.default)({
      type: "FunctionDeclaration",
      id: t,
      params: e,
      body: r,
      generator: s,
      async: i
    });
  }
  n(D0e, "functionDeclaration");
  function _0e(t = null, e, r, s = !1, i = !1) {
    return (0, R.default)({
      type: "FunctionExpression",
      id: t,
      params: e,
      body: r,
      generator: s,
      async: i
    });
  }
  n(_0e, "functionExpression");
  function L0e(t) {
    return (0, R.default)({
      type: "Identifier",
      name: t
    });
  }
  n(L0e, "identifier");
  function M0e(t, e, r = null) {
    return (0, R.default)({
      type: "IfStatement",
      test: t,
      consequent: e,
      alternate: r
    });
  }
  n(M0e, "ifStatement");
  function B0e(t, e) {
    return (0, R.default)({
      type: "LabeledStatement",
      label: t,
      body: e
    });
  }
  n(B0e, "labeledStatement");
  function F0e(t) {
    return (0, R.default)({
      type: "StringLiteral",
      value: t
    });
  }
  n(F0e, "stringLiteral");
  function iI(t) {
    return (0, R.default)({
      type: "NumericLiteral",
      value: t
    });
  }
  n(iI, "numericLiteral");
  function j0e() {
    return {
      type: "NullLiteral"
    };
  }
  n(j0e, "nullLiteral");
  function R0e(t) {
    return (0, R.default)({
      type: "BooleanLiteral",
      value: t
    });
  }
  n(R0e, "booleanLiteral");
  function nI(t, e = "") {
    return (0, R.default)({
      type: "RegExpLiteral",
      pattern: t,
      flags: e
    });
  }
  n(nI, "regExpLiteral");
  function U0e(t, e, r) {
    return (0, R.default)({
      type: "LogicalExpression",
      operator: t,
      left: e,
      right: r
    });
  }
  n(U0e, "logicalExpression");
  function q0e(t, e, r = !1, s = null) {
    return (0, R.default)({
      type: "MemberExpression",
      object: t,
      property: e,
      computed: r,
      optional: s
    });
  }
  n(q0e, "memberExpression");
  function V0e(t, e) {
    return (0, R.default)({
      type: "NewExpression",
      callee: t,
      arguments: e
    });
  }
  n(V0e, "newExpression");
  function K0e(t, e = [], r = "script", s = null) {
    return (0, R.default)({
      type: "Program",
      body: t,
      directives: e,
      sourceType: r,
      interpreter: s
    });
  }
  n(K0e, "program");
  function W0e(t) {
    return (0, R.default)({
      type: "ObjectExpression",
      properties: t
    });
  }
  n(W0e, "objectExpression");
  function Y0e(t = "method", e, r, s, i = !1, a = !1, o = !1) {
    return (0, R.default)({
      type: "ObjectMethod",
      kind: t,
      key: e,
      params: r,
      body: s,
      computed: i,
      generator: a,
      async: o
    });
  }
  n(Y0e, "objectMethod");
  function J0e(t, e, r = !1, s = !1, i = null) {
    return (0, R.default)({
      type: "ObjectProperty",
      key: t,
      value: e,
      computed: r,
      shorthand: s,
      decorators: i
    });
  }
  n(J0e, "objectProperty");
  function aI(t) {
    return (0, R.default)({
      type: "RestElement",
      argument: t
    });
  }
  n(aI, "restElement");
  function X0e(t = null) {
    return (0, R.default)({
      type: "ReturnStatement",
      argument: t
    });
  }
  n(X0e, "returnStatement");
  function $0e(t) {
    return (0, R.default)({
      type: "SequenceExpression",
      expressions: t
    });
  }
  n($0e, "sequenceExpression");
  function H0e(t) {
    return (0, R.default)({
      type: "ParenthesizedExpression",
      expression: t
    });
  }
  n(H0e, "parenthesizedExpression");
  function z0e(t = null, e) {
    return (0, R.default)({
      type: "SwitchCase",
      test: t,
      consequent: e
    });
  }
  n(z0e, "switchCase");
  function G0e(t, e) {
    return (0, R.default)({
      type: "SwitchStatement",
      discriminant: t,
      cases: e
    });
  }
  n(G0e, "switchStatement");
  function Q0e() {
    return {
      type: "ThisExpression"
    };
  }
  n(Q0e, "thisExpression");
  function Z0e(t) {
    return (0, R.default)({
      type: "ThrowStatement",
      argument: t
    });
  }
  n(Z0e, "throwStatement");
  function ebe(t, e = null, r = null) {
    return (0, R.default)({
      type: "TryStatement",
      block: t,
      handler: e,
      finalizer: r
    });
  }
  n(ebe, "tryStatement");
  function tbe(t, e, r = !0) {
    return (0, R.default)({
      type: "UnaryExpression",
      operator: t,
      argument: e,
      prefix: r
    });
  }
  n(tbe, "unaryExpression");
  function rbe(t, e, r = !1) {
    return (0, R.default)({
      type: "UpdateExpression",
      operator: t,
      argument: e,
      prefix: r
    });
  }
  n(rbe, "updateExpression");
  function sbe(t, e) {
    return (0, R.default)({
      type: "VariableDeclaration",
      kind: t,
      declarations: e
    });
  }
  n(sbe, "variableDeclaration");
  function ibe(t, e = null) {
    return (0, R.default)({
      type: "VariableDeclarator",
      id: t,
      init: e
    });
  }
  n(ibe, "variableDeclarator");
  function nbe(t, e) {
    return (0, R.default)({
      type: "WhileStatement",
      test: t,
      body: e
    });
  }
  n(nbe, "whileStatement");
  function abe(t, e) {
    return (0, R.default)({
      type: "WithStatement",
      object: t,
      body: e
    });
  }
  n(abe, "withStatement");
  function obe(t, e) {
    return (0, R.default)({
      type: "AssignmentPattern",
      left: t,
      right: e
    });
  }
  n(obe, "assignmentPattern");
  function lbe(t) {
    return (0, R.default)({
      type: "ArrayPattern",
      elements: t
    });
  }
  n(lbe, "arrayPattern");
  function ube(t, e, r = !1) {
    return (0, R.default)({
      type: "ArrowFunctionExpression",
      params: t,
      body: e,
      async: r,
      expression: null
    });
  }
  n(ube, "arrowFunctionExpression");
  function cbe(t) {
    return (0, R.default)({
      type: "ClassBody",
      body: t
    });
  }
  n(cbe, "classBody");
  function pbe(t = null, e = null, r, s = null) {
    return (0, R.default)({
      type: "ClassExpression",
      id: t,
      superClass: e,
      body: r,
      decorators: s
    });
  }
  n(pbe, "classExpression");
  function fbe(t = null, e = null, r, s = null) {
    return (0, R.default)({
      type: "ClassDeclaration",
      id: t,
      superClass: e,
      body: r,
      decorators: s
    });
  }
  n(fbe, "classDeclaration");
  function hbe(t) {
    return (0, R.default)({
      type: "ExportAllDeclaration",
      source: t
    });
  }
  n(hbe, "exportAllDeclaration");
  function dbe(t) {
    return (0, R.default)({
      type: "ExportDefaultDeclaration",
      declaration: t
    });
  }
  n(dbe, "exportDefaultDeclaration");
  function mbe(t = null, e = [], r = null) {
    return (0, R.default)({
      type: "ExportNamedDeclaration",
      declaration: t,
      specifiers: e,
      source: r
    });
  }
  n(mbe, "exportNamedDeclaration");
  function ybe(t, e) {
    return (0, R.default)({
      type: "ExportSpecifier",
      local: t,
      exported: e
    });
  }
  n(ybe, "exportSpecifier");
  function Tbe(t, e, r, s = !1) {
    return (0, R.default)({
      type: "ForOfStatement",
      left: t,
      right: e,
      body: r,
      await: s
    });
  }
  n(Tbe, "forOfStatement");
  function bbe(t, e) {
    return (0, R.default)({
      type: "ImportDeclaration",
      specifiers: t,
      source: e
    });
  }
  n(bbe, "importDeclaration");
  function xbe(t) {
    return (0, R.default)({
      type: "ImportDefaultSpecifier",
      local: t
    });
  }
  n(xbe, "importDefaultSpecifier");
  function Sbe(t) {
    return (0, R.default)({
      type: "ImportNamespaceSpecifier",
      local: t
    });
  }
  n(Sbe, "importNamespaceSpecifier");
  function gbe(t, e) {
    return (0, R.default)({
      type: "ImportSpecifier",
      local: t,
      imported: e
    });
  }
  n(gbe, "importSpecifier");
  function Pbe(t, e = null) {
    return (0, R.default)({
      type: "ImportExpression",
      source: t,
      options: e
    });
  }
  n(Pbe, "importExpression");
  function Ebe(t, e) {
    return (0, R.default)({
      type: "MetaProperty",
      meta: t,
      property: e
    });
  }
  n(Ebe, "metaProperty");
  function Abe(t = "method", e, r, s, i = !1, a = !1, o = !1, l = !1) {
    return (0, R.default)({
      type: "ClassMethod",
      kind: t,
      key: e,
      params: r,
      body: s,
      computed: i,
      static: a,
      generator: o,
      async: l
    });
  }
  n(Abe, "classMethod");
  function vbe(t) {
    return (0, R.default)({
      type: "ObjectPattern",
      properties: t
    });
  }
  n(vbe, "objectPattern");
  function oI(t) {
    return (0, R.default)({
      type: "SpreadElement",
      argument: t
    });
  }
  n(oI, "spreadElement");
  function Cbe() {
    return {
      type: "Super"
    };
  }
  n(Cbe, "_super");
  function Ibe(t, e) {
    return (0, R.default)({
      type: "TaggedTemplateExpression",
      tag: t,
      quasi: e
    });
  }
  n(Ibe, "taggedTemplateExpression");
  function wbe(t, e = !1) {
    return (0, R.default)({
      type: "TemplateElement",
      value: t,
      tail: e
    });
  }
  n(wbe, "templateElement");
  function Nbe(t, e) {
    return (0, R.default)({
      type: "TemplateLiteral",
      quasis: t,
      expressions: e
    });
  }
  n(Nbe, "templateLiteral");
  function Obe(t = null, e = !1) {
    return (0, R.default)({
      type: "YieldExpression",
      argument: t,
      delegate: e
    });
  }
  n(Obe, "yieldExpression");
  function kbe(t) {
    return (0, R.default)({
      type: "AwaitExpression",
      argument: t
    });
  }
  n(kbe, "awaitExpression");
  function Dbe() {
    return {
      type: "Import"
    };
  }
  n(Dbe, "_import");
  function _be(t) {
    return (0, R.default)({
      type: "BigIntLiteral",
      value: t
    });
  }
  n(_be, "bigIntLiteral");
  function Lbe(t) {
    return (0, R.default)({
      type: "ExportNamespaceSpecifier",
      exported: t
    });
  }
  n(Lbe, "exportNamespaceSpecifier");
  function Mbe(t, e, r = !1, s) {
    return (0, R.default)({
      type: "OptionalMemberExpression",
      object: t,
      property: e,
      computed: r,
      optional: s
    });
  }
  n(Mbe, "optionalMemberExpression");
  function Bbe(t, e, r) {
    return (0, R.default)({
      type: "OptionalCallExpression",
      callee: t,
      arguments: e,
      optional: r
    });
  }
  n(Bbe, "optionalCallExpression");
  function Fbe(t, e = null, r = null, s = null, i = !1, a = !1) {
    return (0, R.default)({
      type: "ClassProperty",
      key: t,
      value: e,
      typeAnnotation: r,
      decorators: s,
      computed: i,
      static: a
    });
  }
  n(Fbe, "classProperty");
  function jbe(t, e = null, r = null, s = null, i = !1, a = !1) {
    return (0, R.default)({
      type: "ClassAccessorProperty",
      key: t,
      value: e,
      typeAnnotation: r,
      decorators: s,
      computed: i,
      static: a
    });
  }
  n(jbe, "classAccessorProperty");
  function Rbe(t, e = null, r = null, s = !1) {
    return (0, R.default)({
      type: "ClassPrivateProperty",
      key: t,
      value: e,
      decorators: r,
      static: s
    });
  }
  n(Rbe, "classPrivateProperty");
  function Ube(t = "method", e, r, s, i = !1) {
    return (0, R.default)({
      type: "ClassPrivateMethod",
      kind: t,
      key: e,
      params: r,
      body: s,
      static: i
    });
  }
  n(Ube, "classPrivateMethod");
  function qbe(t) {
    return (0, R.default)({
      type: "PrivateName",
      id: t
    });
  }
  n(qbe, "privateName");
  function Vbe(t) {
    return (0, R.default)({
      type: "StaticBlock",
      body: t
    });
  }
  n(Vbe, "staticBlock");
  function Kbe() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  n(Kbe, "anyTypeAnnotation");
  function Wbe(t) {
    return (0, R.default)({
      type: "ArrayTypeAnnotation",
      elementType: t
    });
  }
  n(Wbe, "arrayTypeAnnotation");
  function Ybe() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  n(Ybe, "booleanTypeAnnotation");
  function Jbe(t) {
    return (0, R.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: t
    });
  }
  n(Jbe, "booleanLiteralTypeAnnotation");
  function Xbe() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  n(Xbe, "nullLiteralTypeAnnotation");
  function $be(t, e = null) {
    return (0, R.default)({
      type: "ClassImplements",
      id: t,
      typeParameters: e
    });
  }
  n($be, "classImplements");
  function Hbe(t, e = null, r = null, s) {
    return (0, R.default)({
      type: "DeclareClass",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(Hbe, "declareClass");
  function zbe(t) {
    return (0, R.default)({
      type: "DeclareFunction",
      id: t
    });
  }
  n(zbe, "declareFunction");
  function Gbe(t, e = null, r = null, s) {
    return (0, R.default)({
      type: "DeclareInterface",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(Gbe, "declareInterface");
  function Qbe(t, e, r = null) {
    return (0, R.default)({
      type: "DeclareModule",
      id: t,
      body: e,
      kind: r
    });
  }
  n(Qbe, "declareModule");
  function Zbe(t) {
    return (0, R.default)({
      type: "DeclareModuleExports",
      typeAnnotation: t
    });
  }
  n(Zbe, "declareModuleExports");
  function exe(t, e = null, r) {
    return (0, R.default)({
      type: "DeclareTypeAlias",
      id: t,
      typeParameters: e,
      right: r
    });
  }
  n(exe, "declareTypeAlias");
  function txe(t, e = null, r = null) {
    return (0, R.default)({
      type: "DeclareOpaqueType",
      id: t,
      typeParameters: e,
      supertype: r
    });
  }
  n(txe, "declareOpaqueType");
  function rxe(t) {
    return (0, R.default)({
      type: "DeclareVariable",
      id: t
    });
  }
  n(rxe, "declareVariable");
  function sxe(t = null, e = null, r = null) {
    return (0, R.default)({
      type: "DeclareExportDeclaration",
      declaration: t,
      specifiers: e,
      source: r
    });
  }
  n(sxe, "declareExportDeclaration");
  function ixe(t) {
    return (0, R.default)({
      type: "DeclareExportAllDeclaration",
      source: t
    });
  }
  n(ixe, "declareExportAllDeclaration");
  function nxe(t) {
    return (0, R.default)({
      type: "DeclaredPredicate",
      value: t
    });
  }
  n(nxe, "declaredPredicate");
  function axe() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  n(axe, "existsTypeAnnotation");
  function oxe(t = null, e, r = null, s) {
    return (0, R.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: t,
      params: e,
      rest: r,
      returnType: s
    });
  }
  n(oxe, "functionTypeAnnotation");
  function lxe(t = null, e) {
    return (0, R.default)({
      type: "FunctionTypeParam",
      name: t,
      typeAnnotation: e
    });
  }
  n(lxe, "functionTypeParam");
  function uxe(t, e = null) {
    return (0, R.default)({
      type: "GenericTypeAnnotation",
      id: t,
      typeParameters: e
    });
  }
  n(uxe, "genericTypeAnnotation");
  function cxe() {
    return {
      type: "InferredPredicate"
    };
  }
  n(cxe, "inferredPredicate");
  function pxe(t, e = null) {
    return (0, R.default)({
      type: "InterfaceExtends",
      id: t,
      typeParameters: e
    });
  }
  n(pxe, "interfaceExtends");
  function fxe(t, e = null, r = null, s) {
    return (0, R.default)({
      type: "InterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(fxe, "interfaceDeclaration");
  function hxe(t = null, e) {
    return (0, R.default)({
      type: "InterfaceTypeAnnotation",
      extends: t,
      body: e
    });
  }
  n(hxe, "interfaceTypeAnnotation");
  function dxe(t) {
    return (0, R.default)({
      type: "IntersectionTypeAnnotation",
      types: t
    });
  }
  n(dxe, "intersectionTypeAnnotation");
  function mxe() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  n(mxe, "mixedTypeAnnotation");
  function yxe() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  n(yxe, "emptyTypeAnnotation");
  function Txe(t) {
    return (0, R.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: t
    });
  }
  n(Txe, "nullableTypeAnnotation");
  function bxe(t) {
    return (0, R.default)({
      type: "NumberLiteralTypeAnnotation",
      value: t
    });
  }
  n(bxe, "numberLiteralTypeAnnotation");
  function xxe() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  n(xxe, "numberTypeAnnotation");
  function Sxe(t, e = [], r = [], s = [], i = !1) {
    return (0, R.default)({
      type: "ObjectTypeAnnotation",
      properties: t,
      indexers: e,
      callProperties: r,
      internalSlots: s,
      exact: i
    });
  }
  n(Sxe, "objectTypeAnnotation");
  function gxe(t, e, r, s, i) {
    return (0, R.default)({
      type: "ObjectTypeInternalSlot",
      id: t,
      value: e,
      optional: r,
      static: s,
      method: i
    });
  }
  n(gxe, "objectTypeInternalSlot");
  function Pxe(t) {
    return (0, R.default)({
      type: "ObjectTypeCallProperty",
      value: t,
      static: null
    });
  }
  n(Pxe, "objectTypeCallProperty");
  function Exe(t = null, e, r, s = null) {
    return (0, R.default)({
      type: "ObjectTypeIndexer",
      id: t,
      key: e,
      value: r,
      variance: s,
      static: null
    });
  }
  n(Exe, "objectTypeIndexer");
  function Axe(t, e, r = null) {
    return (0, R.default)({
      type: "ObjectTypeProperty",
      key: t,
      value: e,
      variance: r,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  }
  n(Axe, "objectTypeProperty");
  function vxe(t) {
    return (0, R.default)({
      type: "ObjectTypeSpreadProperty",
      argument: t
    });
  }
  n(vxe, "objectTypeSpreadProperty");
  function Cxe(t, e = null, r = null, s) {
    return (0, R.default)({
      type: "OpaqueType",
      id: t,
      typeParameters: e,
      supertype: r,
      impltype: s
    });
  }
  n(Cxe, "opaqueType");
  function Ixe(t, e) {
    return (0, R.default)({
      type: "QualifiedTypeIdentifier",
      id: t,
      qualification: e
    });
  }
  n(Ixe, "qualifiedTypeIdentifier");
  function wxe(t) {
    return (0, R.default)({
      type: "StringLiteralTypeAnnotation",
      value: t
    });
  }
  n(wxe, "stringLiteralTypeAnnotation");
  function Nxe() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  n(Nxe, "stringTypeAnnotation");
  function Oxe() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  n(Oxe, "symbolTypeAnnotation");
  function kxe() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  n(kxe, "thisTypeAnnotation");
  function Dxe(t) {
    return (0, R.default)({
      type: "TupleTypeAnnotation",
      types: t
    });
  }
  n(Dxe, "tupleTypeAnnotation");
  function _xe(t) {
    return (0, R.default)({
      type: "TypeofTypeAnnotation",
      argument: t
    });
  }
  n(_xe, "typeofTypeAnnotation");
  function Lxe(t, e = null, r) {
    return (0, R.default)({
      type: "TypeAlias",
      id: t,
      typeParameters: e,
      right: r
    });
  }
  n(Lxe, "typeAlias");
  function Mxe(t) {
    return (0, R.default)({
      type: "TypeAnnotation",
      typeAnnotation: t
    });
  }
  n(Mxe, "typeAnnotation");
  function Bxe(t, e) {
    return (0, R.default)({
      type: "TypeCastExpression",
      expression: t,
      typeAnnotation: e
    });
  }
  n(Bxe, "typeCastExpression");
  function Fxe(t = null, e = null, r = null) {
    return (0, R.default)({
      type: "TypeParameter",
      bound: t,
      default: e,
      variance: r,
      name: null
    });
  }
  n(Fxe, "typeParameter");
  function jxe(t) {
    return (0, R.default)({
      type: "TypeParameterDeclaration",
      params: t
    });
  }
  n(jxe, "typeParameterDeclaration");
  function Rxe(t) {
    return (0, R.default)({
      type: "TypeParameterInstantiation",
      params: t
    });
  }
  n(Rxe, "typeParameterInstantiation");
  function Uxe(t) {
    return (0, R.default)({
      type: "UnionTypeAnnotation",
      types: t
    });
  }
  n(Uxe, "unionTypeAnnotation");
  function qxe(t) {
    return (0, R.default)({
      type: "Variance",
      kind: t
    });
  }
  n(qxe, "variance");
  function Vxe() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  n(Vxe, "voidTypeAnnotation");
  function Kxe(t, e) {
    return (0, R.default)({
      type: "EnumDeclaration",
      id: t,
      body: e
    });
  }
  n(Kxe, "enumDeclaration");
  function Wxe(t) {
    return (0, R.default)({
      type: "EnumBooleanBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  n(Wxe, "enumBooleanBody");
  function Yxe(t) {
    return (0, R.default)({
      type: "EnumNumberBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  n(Yxe, "enumNumberBody");
  function Jxe(t) {
    return (0, R.default)({
      type: "EnumStringBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  n(Jxe, "enumStringBody");
  function Xxe(t) {
    return (0, R.default)({
      type: "EnumSymbolBody",
      members: t,
      hasUnknownMembers: null
    });
  }
  n(Xxe, "enumSymbolBody");
  function $xe(t) {
    return (0, R.default)({
      type: "EnumBooleanMember",
      id: t,
      init: null
    });
  }
  n($xe, "enumBooleanMember");
  function Hxe(t, e) {
    return (0, R.default)({
      type: "EnumNumberMember",
      id: t,
      init: e
    });
  }
  n(Hxe, "enumNumberMember");
  function zxe(t, e) {
    return (0, R.default)({
      type: "EnumStringMember",
      id: t,
      init: e
    });
  }
  n(zxe, "enumStringMember");
  function Gxe(t) {
    return (0, R.default)({
      type: "EnumDefaultedMember",
      id: t
    });
  }
  n(Gxe, "enumDefaultedMember");
  function Qxe(t, e) {
    return (0, R.default)({
      type: "IndexedAccessType",
      objectType: t,
      indexType: e
    });
  }
  n(Qxe, "indexedAccessType");
  function Zxe(t, e) {
    return (0, R.default)({
      type: "OptionalIndexedAccessType",
      objectType: t,
      indexType: e,
      optional: null
    });
  }
  n(Zxe, "optionalIndexedAccessType");
  function eSe(t, e = null) {
    return (0, R.default)({
      type: "JSXAttribute",
      name: t,
      value: e
    });
  }
  n(eSe, "jsxAttribute");
  function tSe(t) {
    return (0, R.default)({
      type: "JSXClosingElement",
      name: t
    });
  }
  n(tSe, "jsxClosingElement");
  function rSe(t, e = null, r, s = null) {
    return (0, R.default)({
      type: "JSXElement",
      openingElement: t,
      closingElement: e,
      children: r,
      selfClosing: s
    });
  }
  n(rSe, "jsxElement");
  function sSe() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  n(sSe, "jsxEmptyExpression");
  function iSe(t) {
    return (0, R.default)({
      type: "JSXExpressionContainer",
      expression: t
    });
  }
  n(iSe, "jsxExpressionContainer");
  function nSe(t) {
    return (0, R.default)({
      type: "JSXSpreadChild",
      expression: t
    });
  }
  n(nSe, "jsxSpreadChild");
  function aSe(t) {
    return (0, R.default)({
      type: "JSXIdentifier",
      name: t
    });
  }
  n(aSe, "jsxIdentifier");
  function oSe(t, e) {
    return (0, R.default)({
      type: "JSXMemberExpression",
      object: t,
      property: e
    });
  }
  n(oSe, "jsxMemberExpression");
  function lSe(t, e) {
    return (0, R.default)({
      type: "JSXNamespacedName",
      namespace: t,
      name: e
    });
  }
  n(lSe, "jsxNamespacedName");
  function uSe(t, e, r = !1) {
    return (0, R.default)({
      type: "JSXOpeningElement",
      name: t,
      attributes: e,
      selfClosing: r
    });
  }
  n(uSe, "jsxOpeningElement");
  function cSe(t) {
    return (0, R.default)({
      type: "JSXSpreadAttribute",
      argument: t
    });
  }
  n(cSe, "jsxSpreadAttribute");
  function pSe(t) {
    return (0, R.default)({
      type: "JSXText",
      value: t
    });
  }
  n(pSe, "jsxText");
  function fSe(t, e, r) {
    return (0, R.default)({
      type: "JSXFragment",
      openingFragment: t,
      closingFragment: e,
      children: r
    });
  }
  n(fSe, "jsxFragment");
  function hSe() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  n(hSe, "jsxOpeningFragment");
  function dSe() {
    return {
      type: "JSXClosingFragment"
    };
  }
  n(dSe, "jsxClosingFragment");
  function mSe() {
    return {
      type: "Noop"
    };
  }
  n(mSe, "noop");
  function ySe(t, e) {
    return (0, R.default)({
      type: "Placeholder",
      expectedNode: t,
      name: e
    });
  }
  n(ySe, "placeholder");
  function TSe(t) {
    return (0, R.default)({
      type: "V8IntrinsicIdentifier",
      name: t
    });
  }
  n(TSe, "v8IntrinsicIdentifier");
  function bSe() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  n(bSe, "argumentPlaceholder");
  function xSe(t, e) {
    return (0, R.default)({
      type: "BindExpression",
      object: t,
      callee: e
    });
  }
  n(xSe, "bindExpression");
  function SSe(t, e) {
    return (0, R.default)({
      type: "ImportAttribute",
      key: t,
      value: e
    });
  }
  n(SSe, "importAttribute");
  function gSe(t) {
    return (0, R.default)({
      type: "Decorator",
      expression: t
    });
  }
  n(gSe, "decorator");
  function PSe(t, e = !1) {
    return (0, R.default)({
      type: "DoExpression",
      body: t,
      async: e
    });
  }
  n(PSe, "doExpression");
  function ESe(t) {
    return (0, R.default)({
      type: "ExportDefaultSpecifier",
      exported: t
    });
  }
  n(ESe, "exportDefaultSpecifier");
  function ASe(t) {
    return (0, R.default)({
      type: "RecordExpression",
      properties: t
    });
  }
  n(ASe, "recordExpression");
  function vSe(t = []) {
    return (0, R.default)({
      type: "TupleExpression",
      elements: t
    });
  }
  n(vSe, "tupleExpression");
  function CSe(t) {
    return (0, R.default)({
      type: "DecimalLiteral",
      value: t
    });
  }
  n(CSe, "decimalLiteral");
  function ISe(t) {
    return (0, R.default)({
      type: "ModuleExpression",
      body: t
    });
  }
  n(ISe, "moduleExpression");
  function wSe() {
    return {
      type: "TopicReference"
    };
  }
  n(wSe, "topicReference");
  function NSe(t) {
    return (0, R.default)({
      type: "PipelineTopicExpression",
      expression: t
    });
  }
  n(NSe, "pipelineTopicExpression");
  function OSe(t) {
    return (0, R.default)({
      type: "PipelineBareFunction",
      callee: t
    });
  }
  n(OSe, "pipelineBareFunction");
  function kSe() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  n(kSe, "pipelinePrimaryTopicReference");
  function DSe(t) {
    return (0, R.default)({
      type: "TSParameterProperty",
      parameter: t
    });
  }
  n(DSe, "tsParameterProperty");
  function _Se(t = null, e = null, r, s = null) {
    return (0, R.default)({
      type: "TSDeclareFunction",
      id: t,
      typeParameters: e,
      params: r,
      returnType: s
    });
  }
  n(_Se, "tsDeclareFunction");
  function LSe(t = null, e, r = null, s, i = null) {
    return (0, R.default)({
      type: "TSDeclareMethod",
      decorators: t,
      key: e,
      typeParameters: r,
      params: s,
      returnType: i
    });
  }
  n(LSe, "tsDeclareMethod");
  function MSe(t, e) {
    return (0, R.default)({
      type: "TSQualifiedName",
      left: t,
      right: e
    });
  }
  n(MSe, "tsQualifiedName");
  function BSe(t = null, e, r = null) {
    return (0, R.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(BSe, "tsCallSignatureDeclaration");
  function FSe(t = null, e, r = null) {
    return (0, R.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(FSe, "tsConstructSignatureDeclaration");
  function jSe(t, e = null) {
    return (0, R.default)({
      type: "TSPropertySignature",
      key: t,
      typeAnnotation: e,
      kind: null
    });
  }
  n(jSe, "tsPropertySignature");
  function RSe(t, e = null, r, s = null) {
    return (0, R.default)({
      type: "TSMethodSignature",
      key: t,
      typeParameters: e,
      parameters: r,
      typeAnnotation: s,
      kind: null
    });
  }
  n(RSe, "tsMethodSignature");
  function USe(t, e = null) {
    return (0, R.default)({
      type: "TSIndexSignature",
      parameters: t,
      typeAnnotation: e
    });
  }
  n(USe, "tsIndexSignature");
  function qSe() {
    return {
      type: "TSAnyKeyword"
    };
  }
  n(qSe, "tsAnyKeyword");
  function VSe() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  n(VSe, "tsBooleanKeyword");
  function KSe() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  n(KSe, "tsBigIntKeyword");
  function WSe() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  n(WSe, "tsIntrinsicKeyword");
  function YSe() {
    return {
      type: "TSNeverKeyword"
    };
  }
  n(YSe, "tsNeverKeyword");
  function JSe() {
    return {
      type: "TSNullKeyword"
    };
  }
  n(JSe, "tsNullKeyword");
  function XSe() {
    return {
      type: "TSNumberKeyword"
    };
  }
  n(XSe, "tsNumberKeyword");
  function $Se() {
    return {
      type: "TSObjectKeyword"
    };
  }
  n($Se, "tsObjectKeyword");
  function HSe() {
    return {
      type: "TSStringKeyword"
    };
  }
  n(HSe, "tsStringKeyword");
  function zSe() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  n(zSe, "tsSymbolKeyword");
  function GSe() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  n(GSe, "tsUndefinedKeyword");
  function QSe() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  n(QSe, "tsUnknownKeyword");
  function ZSe() {
    return {
      type: "TSVoidKeyword"
    };
  }
  n(ZSe, "tsVoidKeyword");
  function ege() {
    return {
      type: "TSThisType"
    };
  }
  n(ege, "tsThisType");
  function tge(t = null, e, r = null) {
    return (0, R.default)({
      type: "TSFunctionType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(tge, "tsFunctionType");
  function rge(t = null, e, r = null) {
    return (0, R.default)({
      type: "TSConstructorType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(rge, "tsConstructorType");
  function sge(t, e = null) {
    return (0, R.default)({
      type: "TSTypeReference",
      typeName: t,
      typeParameters: e
    });
  }
  n(sge, "tsTypeReference");
  function ige(t, e = null, r = null) {
    return (0, R.default)({
      type: "TSTypePredicate",
      parameterName: t,
      typeAnnotation: e,
      asserts: r
    });
  }
  n(ige, "tsTypePredicate");
  function nge(t, e = null) {
    return (0, R.default)({
      type: "TSTypeQuery",
      exprName: t,
      typeParameters: e
    });
  }
  n(nge, "tsTypeQuery");
  function age(t) {
    return (0, R.default)({
      type: "TSTypeLiteral",
      members: t
    });
  }
  n(age, "tsTypeLiteral");
  function oge(t) {
    return (0, R.default)({
      type: "TSArrayType",
      elementType: t
    });
  }
  n(oge, "tsArrayType");
  function lge(t) {
    return (0, R.default)({
      type: "TSTupleType",
      elementTypes: t
    });
  }
  n(lge, "tsTupleType");
  function uge(t) {
    return (0, R.default)({
      type: "TSOptionalType",
      typeAnnotation: t
    });
  }
  n(uge, "tsOptionalType");
  function cge(t) {
    return (0, R.default)({
      type: "TSRestType",
      typeAnnotation: t
    });
  }
  n(cge, "tsRestType");
  function pge(t, e, r = !1) {
    return (0, R.default)({
      type: "TSNamedTupleMember",
      label: t,
      elementType: e,
      optional: r
    });
  }
  n(pge, "tsNamedTupleMember");
  function fge(t) {
    return (0, R.default)({
      type: "TSUnionType",
      types: t
    });
  }
  n(fge, "tsUnionType");
  function hge(t) {
    return (0, R.default)({
      type: "TSIntersectionType",
      types: t
    });
  }
  n(hge, "tsIntersectionType");
  function dge(t, e, r, s) {
    return (0, R.default)({
      type: "TSConditionalType",
      checkType: t,
      extendsType: e,
      trueType: r,
      falseType: s
    });
  }
  n(dge, "tsConditionalType");
  function mge(t) {
    return (0, R.default)({
      type: "TSInferType",
      typeParameter: t
    });
  }
  n(mge, "tsInferType");
  function yge(t) {
    return (0, R.default)({
      type: "TSParenthesizedType",
      typeAnnotation: t
    });
  }
  n(yge, "tsParenthesizedType");
  function Tge(t) {
    return (0, R.default)({
      type: "TSTypeOperator",
      typeAnnotation: t,
      operator: null
    });
  }
  n(Tge, "tsTypeOperator");
  function bge(t, e) {
    return (0, R.default)({
      type: "TSIndexedAccessType",
      objectType: t,
      indexType: e
    });
  }
  n(bge, "tsIndexedAccessType");
  function xge(t, e = null, r = null) {
    return (0, R.default)({
      type: "TSMappedType",
      typeParameter: t,
      typeAnnotation: e,
      nameType: r
    });
  }
  n(xge, "tsMappedType");
  function Sge(t) {
    return (0, R.default)({
      type: "TSLiteralType",
      literal: t
    });
  }
  n(Sge, "tsLiteralType");
  function gge(t, e = null) {
    return (0, R.default)({
      type: "TSExpressionWithTypeArguments",
      expression: t,
      typeParameters: e
    });
  }
  n(gge, "tsExpressionWithTypeArguments");
  function Pge(t, e = null, r = null, s) {
    return (0, R.default)({
      type: "TSInterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(Pge, "tsInterfaceDeclaration");
  function Ege(t) {
    return (0, R.default)({
      type: "TSInterfaceBody",
      body: t
    });
  }
  n(Ege, "tsInterfaceBody");
  function Age(t, e = null, r) {
    return (0, R.default)({
      type: "TSTypeAliasDeclaration",
      id: t,
      typeParameters: e,
      typeAnnotation: r
    });
  }
  n(Age, "tsTypeAliasDeclaration");
  function vge(t, e = null) {
    return (0, R.default)({
      type: "TSInstantiationExpression",
      expression: t,
      typeParameters: e
    });
  }
  n(vge, "tsInstantiationExpression");
  function Cge(t, e) {
    return (0, R.default)({
      type: "TSAsExpression",
      expression: t,
      typeAnnotation: e
    });
  }
  n(Cge, "tsAsExpression");
  function Ige(t, e) {
    return (0, R.default)({
      type: "TSSatisfiesExpression",
      expression: t,
      typeAnnotation: e
    });
  }
  n(Ige, "tsSatisfiesExpression");
  function wge(t, e) {
    return (0, R.default)({
      type: "TSTypeAssertion",
      typeAnnotation: t,
      expression: e
    });
  }
  n(wge, "tsTypeAssertion");
  function Nge(t, e) {
    return (0, R.default)({
      type: "TSEnumDeclaration",
      id: t,
      members: e
    });
  }
  n(Nge, "tsEnumDeclaration");
  function Oge(t, e = null) {
    return (0, R.default)({
      type: "TSEnumMember",
      id: t,
      initializer: e
    });
  }
  n(Oge, "tsEnumMember");
  function kge(t, e) {
    return (0, R.default)({
      type: "TSModuleDeclaration",
      id: t,
      body: e
    });
  }
  n(kge, "tsModuleDeclaration");
  function Dge(t) {
    return (0, R.default)({
      type: "TSModuleBlock",
      body: t
    });
  }
  n(Dge, "tsModuleBlock");
  function _ge(t, e = null, r = null) {
    return (0, R.default)({
      type: "TSImportType",
      argument: t,
      qualifier: e,
      typeParameters: r
    });
  }
  n(_ge, "tsImportType");
  function Lge(t, e) {
    return (0, R.default)({
      type: "TSImportEqualsDeclaration",
      id: t,
      moduleReference: e,
      isExport: null
    });
  }
  n(Lge, "tsImportEqualsDeclaration");
  function Mge(t) {
    return (0, R.default)({
      type: "TSExternalModuleReference",
      expression: t
    });
  }
  n(Mge, "tsExternalModuleReference");
  function Bge(t) {
    return (0, R.default)({
      type: "TSNonNullExpression",
      expression: t
    });
  }
  n(Bge, "tsNonNullExpression");
  function Fge(t) {
    return (0, R.default)({
      type: "TSExportAssignment",
      expression: t
    });
  }
  n(Fge, "tsExportAssignment");
  function jge(t) {
    return (0, R.default)({
      type: "TSNamespaceExportDeclaration",
      id: t
    });
  }
  n(jge, "tsNamespaceExportDeclaration");
  function Rge(t) {
    return (0, R.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: t
    });
  }
  n(Rge, "tsTypeAnnotation");
  function Uge(t) {
    return (0, R.default)({
      type: "TSTypeParameterInstantiation",
      params: t
    });
  }
  n(Uge, "tsTypeParameterInstantiation");
  function qge(t) {
    return (0, R.default)({
      type: "TSTypeParameterDeclaration",
      params: t
    });
  }
  n(qge, "tsTypeParameterDeclaration");
  function Vge(t = null, e = null, r) {
    return (0, R.default)({
      type: "TSTypeParameter",
      constraint: t,
      default: e,
      name: r
    });
  }
  n(Vge, "tsTypeParameter");
  function Kge(t) {
    return (0, bc.default)("NumberLiteral", "NumericLiteral", "The node type "), iI(t);
  }
  n(Kge, "NumberLiteral");
  function Wge(t, e = "") {
    return (0, bc.default)("RegexLiteral", "RegExpLiteral", "The node type "), nI(t, e);
  }
  n(Wge, "RegexLiteral");
  function Yge(t) {
    return (0, bc.default)("RestProperty", "RestElement", "The node type "), aI(t);
  }
  n(Yge, "RestProperty");
  function Jge(t) {
    return (0, bc.default)("SpreadProperty", "SpreadElement", "The node type "), oI(t);
  }
  n(Jge, "SpreadProperty");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var lI = w((oT) => {
  "use strict";
  Object.defineProperty(oT, "__esModule", {
    value: !0
  });
  oT.default = Hge;
  var Xge = Ar(), $ge = ko();
  function Hge(t, e) {
    let r = t.value.split(/\r\n|\n|\r/), s = 0;
    for (let a = 0; a < r.length; a++)
      r[a].match(/[^ \t]/) && (s = a);
    let i = "";
    for (let a = 0; a < r.length; a++) {
      let o = r[a], l = a === 0, u = a === r.length - 1, c = a === s, p = o.replace(/\t/g, " ");
      l || (p = p.replace(/^[ ]+/, "")), u || (p = p.replace(/[ ]+$/, "")), p && (c || (p += " "), i += p);
    }
    i && e.push((0, $ge.inherits)((0, Xge.stringLiteral)(i), t));
  }
  n(Hge, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/react/buildChildren.js
var uI = w((uT) => {
  "use strict";
  Object.defineProperty(uT, "__esModule", {
    value: !0
  });
  uT.default = Gge;
  var lT = Rt(), zge = lI();
  function Gge(t) {
    let e = [];
    for (let r = 0; r < t.children.length; r++) {
      let s = t.children[r];
      if ((0, lT.isJSXText)(s)) {
        (0, zge.default)(s, e);
        continue;
      }
      (0, lT.isJSXExpressionContainer)(s) && (s = s.expression), !(0, lT.isJSXEmptyExpression)(s) && e.push(s);
    }
    return e;
  }
  n(Gge, "buildChildren");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isNode.js
var pT = w((cT) => {
  "use strict";
  Object.defineProperty(cT, "__esModule", {
    value: !0
  });
  cT.default = Zge;
  var Qge = Vr();
  function Zge(t) {
    return !!(t && Qge.VISITOR_KEYS[t.type]);
  }
  n(Zge, "isNode");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/asserts/assertNode.js
var cI = w((fT) => {
  "use strict";
  Object.defineProperty(fT, "__esModule", {
    value: !0
  });
  fT.default = tPe;
  var ePe = pT();
  function tPe(t) {
    if (!(0, ePe.default)(t)) {
      var e;
      let r = (e = t?.type) != null ? e : JSON.stringify(t);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
  n(tPe, "assertNode");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/asserts/generated/index.js
var pI = w((E) => {
  "use strict";
  Object.defineProperty(E, "__esModule", {
    value: !0
  });
  E.assertAccessor = TCe;
  E.assertAnyTypeAnnotation = FEe;
  E.assertArgumentPlaceholder = f1e;
  E.assertArrayExpression = sPe;
  E.assertArrayPattern = tEe;
  E.assertArrayTypeAnnotation = jEe;
  E.assertArrowFunctionExpression = rEe;
  E.assertAssignmentExpression = iPe;
  E.assertAssignmentPattern = eEe;
  E.assertAwaitExpression = vEe;
  E.assertBigIntLiteral = IEe;
  E.assertBinary = Rve;
  E.assertBinaryExpression = nPe;
  E.assertBindExpression = h1e;
  E.assertBlock = Vve;
  E.assertBlockParent = qve;
  E.assertBlockStatement = uPe;
  E.assertBooleanLiteral = OPe;
  E.assertBooleanLiteralTypeAnnotation = UEe;
  E.assertBooleanTypeAnnotation = REe;
  E.assertBreakStatement = cPe;
  E.assertCallExpression = pPe;
  E.assertCatchClause = fPe;
  E.assertClass = hCe;
  E.assertClassAccessorProperty = DEe;
  E.assertClassBody = sEe;
  E.assertClassDeclaration = nEe;
  E.assertClassExpression = iEe;
  E.assertClassImplements = VEe;
  E.assertClassMethod = TEe;
  E.assertClassPrivateMethod = LEe;
  E.assertClassPrivateProperty = _Ee;
  E.assertClassProperty = kEe;
  E.assertCompletionStatement = Yve;
  E.assertConditional = Jve;
  E.assertConditionalExpression = hPe;
  E.assertContinueStatement = dPe;
  E.assertDebuggerStatement = mPe;
  E.assertDecimalLiteral = S1e;
  E.assertDeclaration = tCe;
  E.assertDeclareClass = KEe;
  E.assertDeclareExportAllDeclaration = QEe;
  E.assertDeclareExportDeclaration = GEe;
  E.assertDeclareFunction = WEe;
  E.assertDeclareInterface = YEe;
  E.assertDeclareModule = JEe;
  E.assertDeclareModuleExports = XEe;
  E.assertDeclareOpaqueType = HEe;
  E.assertDeclareTypeAlias = $Ee;
  E.assertDeclareVariable = zEe;
  E.assertDeclaredPredicate = ZEe;
  E.assertDecorator = m1e;
  E.assertDirective = oPe;
  E.assertDirectiveLiteral = lPe;
  E.assertDoExpression = y1e;
  E.assertDoWhileStatement = yPe;
  E.assertEmptyStatement = TPe;
  E.assertEmptyTypeAnnotation = cAe;
  E.assertEnumBody = ACe;
  E.assertEnumBooleanBody = jAe;
  E.assertEnumBooleanMember = VAe;
  E.assertEnumDeclaration = FAe;
  E.assertEnumDefaultedMember = YAe;
  E.assertEnumMember = vCe;
  E.assertEnumNumberBody = RAe;
  E.assertEnumNumberMember = KAe;
  E.assertEnumStringBody = UAe;
  E.assertEnumStringMember = WAe;
  E.assertEnumSymbolBody = qAe;
  E.assertExistsTypeAnnotation = eAe;
  E.assertExportAllDeclaration = aEe;
  E.assertExportDeclaration = mCe;
  E.assertExportDefaultDeclaration = oEe;
  E.assertExportDefaultSpecifier = T1e;
  E.assertExportNamedDeclaration = lEe;
  E.assertExportNamespaceSpecifier = wEe;
  E.assertExportSpecifier = uEe;
  E.assertExpression = jve;
  E.assertExpressionStatement = bPe;
  E.assertExpressionWrapper = Hve;
  E.assertFile = xPe;
  E.assertFlow = xCe;
  E.assertFlowBaseAnnotation = gCe;
  E.assertFlowDeclaration = PCe;
  E.assertFlowPredicate = ECe;
  E.assertFlowType = SCe;
  E.assertFor = zve;
  E.assertForInStatement = SPe;
  E.assertForOfStatement = cEe;
  E.assertForStatement = gPe;
  E.assertForXStatement = Gve;
  E.assertFunction = Qve;
  E.assertFunctionDeclaration = PPe;
  E.assertFunctionExpression = EPe;
  E.assertFunctionParent = Zve;
  E.assertFunctionTypeAnnotation = tAe;
  E.assertFunctionTypeParam = rAe;
  E.assertGenericTypeAnnotation = sAe;
  E.assertIdentifier = APe;
  E.assertIfStatement = vPe;
  E.assertImmutable = aCe;
  E.assertImport = CEe;
  E.assertImportAttribute = d1e;
  E.assertImportDeclaration = pEe;
  E.assertImportDefaultSpecifier = fEe;
  E.assertImportExpression = mEe;
  E.assertImportNamespaceSpecifier = hEe;
  E.assertImportOrExportDeclaration = dCe;
  E.assertImportSpecifier = dEe;
  E.assertIndexedAccessType = JAe;
  E.assertInferredPredicate = iAe;
  E.assertInterfaceDeclaration = aAe;
  E.assertInterfaceExtends = nAe;
  E.assertInterfaceTypeAnnotation = oAe;
  E.assertInterpreterDirective = aPe;
  E.assertIntersectionTypeAnnotation = lAe;
  E.assertJSX = CCe;
  E.assertJSXAttribute = $Ae;
  E.assertJSXClosingElement = HAe;
  E.assertJSXClosingFragment = l1e;
  E.assertJSXElement = zAe;
  E.assertJSXEmptyExpression = GAe;
  E.assertJSXExpressionContainer = QAe;
  E.assertJSXFragment = a1e;
  E.assertJSXIdentifier = e1e;
  E.assertJSXMemberExpression = t1e;
  E.assertJSXNamespacedName = r1e;
  E.assertJSXOpeningElement = s1e;
  E.assertJSXOpeningFragment = o1e;
  E.assertJSXSpreadAttribute = i1e;
  E.assertJSXSpreadChild = ZAe;
  E.assertJSXText = n1e;
  E.assertLVal = sCe;
  E.assertLabeledStatement = CPe;
  E.assertLiteral = nCe;
  E.assertLogicalExpression = DPe;
  E.assertLoop = Xve;
  E.assertMemberExpression = _Pe;
  E.assertMetaProperty = yEe;
  E.assertMethod = lCe;
  E.assertMiscellaneous = ICe;
  E.assertMixedTypeAnnotation = uAe;
  E.assertModuleDeclaration = BCe;
  E.assertModuleExpression = g1e;
  E.assertModuleSpecifier = yCe;
  E.assertNewExpression = LPe;
  E.assertNoop = u1e;
  E.assertNullLiteral = NPe;
  E.assertNullLiteralTypeAnnotation = qEe;
  E.assertNullableTypeAnnotation = pAe;
  E.assertNumberLiteral = DCe;
  E.assertNumberLiteralTypeAnnotation = fAe;
  E.assertNumberTypeAnnotation = hAe;
  E.assertNumericLiteral = wPe;
  E.assertObjectExpression = BPe;
  E.assertObjectMember = uCe;
  E.assertObjectMethod = FPe;
  E.assertObjectPattern = bEe;
  E.assertObjectProperty = jPe;
  E.assertObjectTypeAnnotation = dAe;
  E.assertObjectTypeCallProperty = yAe;
  E.assertObjectTypeIndexer = TAe;
  E.assertObjectTypeInternalSlot = mAe;
  E.assertObjectTypeProperty = bAe;
  E.assertObjectTypeSpreadProperty = xAe;
  E.assertOpaqueType = SAe;
  E.assertOptionalCallExpression = OEe;
  E.assertOptionalIndexedAccessType = XAe;
  E.assertOptionalMemberExpression = NEe;
  E.assertParenthesizedExpression = VPe;
  E.assertPattern = fCe;
  E.assertPatternLike = rCe;
  E.assertPipelineBareFunction = A1e;
  E.assertPipelinePrimaryTopicReference = v1e;
  E.assertPipelineTopicExpression = E1e;
  E.assertPlaceholder = c1e;
  E.assertPrivate = bCe;
  E.assertPrivateName = MEe;
  E.assertProgram = MPe;
  E.assertProperty = cCe;
  E.assertPureish = eCe;
  E.assertQualifiedTypeIdentifier = gAe;
  E.assertRecordExpression = b1e;
  E.assertRegExpLiteral = kPe;
  E.assertRegexLiteral = _Ce;
  E.assertRestElement = RPe;
  E.assertRestProperty = LCe;
  E.assertReturnStatement = UPe;
  E.assertScopable = Uve;
  E.assertSequenceExpression = qPe;
  E.assertSpreadElement = xEe;
  E.assertSpreadProperty = MCe;
  E.assertStandardized = Fve;
  E.assertStatement = Kve;
  E.assertStaticBlock = BEe;
  E.assertStringLiteral = IPe;
  E.assertStringLiteralTypeAnnotation = PAe;
  E.assertStringTypeAnnotation = EAe;
  E.assertSuper = SEe;
  E.assertSwitchCase = KPe;
  E.assertSwitchStatement = WPe;
  E.assertSymbolTypeAnnotation = AAe;
  E.assertTSAnyKeyword = M1e;
  E.assertTSArrayType = tve;
  E.assertTSAsExpression = Sve;
  E.assertTSBaseType = kCe;
  E.assertTSBigIntKeyword = F1e;
  E.assertTSBooleanKeyword = B1e;
  E.assertTSCallSignatureDeclaration = O1e;
  E.assertTSConditionalType = lve;
  E.assertTSConstructSignatureDeclaration = k1e;
  E.assertTSConstructorType = z1e;
  E.assertTSDeclareFunction = I1e;
  E.assertTSDeclareMethod = w1e;
  E.assertTSEntityName = iCe;
  E.assertTSEnumDeclaration = Eve;
  E.assertTSEnumMember = Ave;
  E.assertTSExportAssignment = kve;
  E.assertTSExpressionWithTypeArguments = mve;
  E.assertTSExternalModuleReference = Nve;
  E.assertTSFunctionType = H1e;
  E.assertTSImportEqualsDeclaration = wve;
  E.assertTSImportType = Ive;
  E.assertTSIndexSignature = L1e;
  E.assertTSIndexedAccessType = fve;
  E.assertTSInferType = uve;
  E.assertTSInstantiationExpression = xve;
  E.assertTSInterfaceBody = Tve;
  E.assertTSInterfaceDeclaration = yve;
  E.assertTSIntersectionType = ove;
  E.assertTSIntrinsicKeyword = j1e;
  E.assertTSLiteralType = dve;
  E.assertTSMappedType = hve;
  E.assertTSMethodSignature = _1e;
  E.assertTSModuleBlock = Cve;
  E.assertTSModuleDeclaration = vve;
  E.assertTSNamedTupleMember = nve;
  E.assertTSNamespaceExportDeclaration = Dve;
  E.assertTSNeverKeyword = R1e;
  E.assertTSNonNullExpression = Ove;
  E.assertTSNullKeyword = U1e;
  E.assertTSNumberKeyword = q1e;
  E.assertTSObjectKeyword = V1e;
  E.assertTSOptionalType = sve;
  E.assertTSParameterProperty = C1e;
  E.assertTSParenthesizedType = cve;
  E.assertTSPropertySignature = D1e;
  E.assertTSQualifiedName = N1e;
  E.assertTSRestType = ive;
  E.assertTSSatisfiesExpression = gve;
  E.assertTSStringKeyword = K1e;
  E.assertTSSymbolKeyword = W1e;
  E.assertTSThisType = $1e;
  E.assertTSTupleType = rve;
  E.assertTSType = OCe;
  E.assertTSTypeAliasDeclaration = bve;
  E.assertTSTypeAnnotation = _ve;
  E.assertTSTypeAssertion = Pve;
  E.assertTSTypeElement = NCe;
  E.assertTSTypeLiteral = eve;
  E.assertTSTypeOperator = pve;
  E.assertTSTypeParameter = Bve;
  E.assertTSTypeParameterDeclaration = Mve;
  E.assertTSTypeParameterInstantiation = Lve;
  E.assertTSTypePredicate = Q1e;
  E.assertTSTypeQuery = Z1e;
  E.assertTSTypeReference = G1e;
  E.assertTSUndefinedKeyword = Y1e;
  E.assertTSUnionType = ave;
  E.assertTSUnknownKeyword = J1e;
  E.assertTSVoidKeyword = X1e;
  E.assertTaggedTemplateExpression = gEe;
  E.assertTemplateElement = PEe;
  E.assertTemplateLiteral = EEe;
  E.assertTerminatorless = Wve;
  E.assertThisExpression = YPe;
  E.assertThisTypeAnnotation = vAe;
  E.assertThrowStatement = JPe;
  E.assertTopicReference = P1e;
  E.assertTryStatement = XPe;
  E.assertTupleExpression = x1e;
  E.assertTupleTypeAnnotation = CAe;
  E.assertTypeAlias = wAe;
  E.assertTypeAnnotation = NAe;
  E.assertTypeCastExpression = OAe;
  E.assertTypeParameter = kAe;
  E.assertTypeParameterDeclaration = DAe;
  E.assertTypeParameterInstantiation = _Ae;
  E.assertTypeScript = wCe;
  E.assertTypeofTypeAnnotation = IAe;
  E.assertUnaryExpression = $Pe;
  E.assertUnaryLike = pCe;
  E.assertUnionTypeAnnotation = LAe;
  E.assertUpdateExpression = HPe;
  E.assertUserWhitespacable = oCe;
  E.assertV8IntrinsicIdentifier = p1e;
  E.assertVariableDeclaration = zPe;
  E.assertVariableDeclarator = GPe;
  E.assertVariance = MAe;
  E.assertVoidTypeAnnotation = BAe;
  E.assertWhile = $ve;
  E.assertWhileStatement = QPe;
  E.assertWithStatement = ZPe;
  E.assertYieldExpression = AEe;
  var rPe = Yn(), Do = Ao();
  function v(t, e, r) {
    if (!(0, rPe.default)(t, e, r))
      throw new Error(`Expected type "${t}" with option ${JSON.stringify(r)}, but instead got "${e.type}".`);
  }
  n(v, "assert");
  function sPe(t, e) {
    v("ArrayExpression", t, e);
  }
  n(sPe, "assertArrayExpression");
  function iPe(t, e) {
    v("AssignmentExpression", t, e);
  }
  n(iPe, "assertAssignmentExpression");
  function nPe(t, e) {
    v("BinaryExpression", t, e);
  }
  n(nPe, "assertBinaryExpression");
  function aPe(t, e) {
    v("InterpreterDirective", t, e);
  }
  n(aPe, "assertInterpreterDirective");
  function oPe(t, e) {
    v("Directive", t, e);
  }
  n(oPe, "assertDirective");
  function lPe(t, e) {
    v("DirectiveLiteral", t, e);
  }
  n(lPe, "assertDirectiveLiteral");
  function uPe(t, e) {
    v("BlockStatement", t, e);
  }
  n(uPe, "assertBlockStatement");
  function cPe(t, e) {
    v("BreakStatement", t, e);
  }
  n(cPe, "assertBreakStatement");
  function pPe(t, e) {
    v("CallExpression", t, e);
  }
  n(pPe, "assertCallExpression");
  function fPe(t, e) {
    v("CatchClause", t, e);
  }
  n(fPe, "assertCatchClause");
  function hPe(t, e) {
    v("ConditionalExpression", t, e);
  }
  n(hPe, "assertConditionalExpression");
  function dPe(t, e) {
    v("ContinueStatement", t, e);
  }
  n(dPe, "assertContinueStatement");
  function mPe(t, e) {
    v("DebuggerStatement", t, e);
  }
  n(mPe, "assertDebuggerStatement");
  function yPe(t, e) {
    v("DoWhileStatement", t, e);
  }
  n(yPe, "assertDoWhileStatement");
  function TPe(t, e) {
    v("EmptyStatement", t, e);
  }
  n(TPe, "assertEmptyStatement");
  function bPe(t, e) {
    v("ExpressionStatement", t, e);
  }
  n(bPe, "assertExpressionStatement");
  function xPe(t, e) {
    v("File", t, e);
  }
  n(xPe, "assertFile");
  function SPe(t, e) {
    v("ForInStatement", t, e);
  }
  n(SPe, "assertForInStatement");
  function gPe(t, e) {
    v("ForStatement", t, e);
  }
  n(gPe, "assertForStatement");
  function PPe(t, e) {
    v("FunctionDeclaration", t, e);
  }
  n(PPe, "assertFunctionDeclaration");
  function EPe(t, e) {
    v("FunctionExpression", t, e);
  }
  n(EPe, "assertFunctionExpression");
  function APe(t, e) {
    v("Identifier", t, e);
  }
  n(APe, "assertIdentifier");
  function vPe(t, e) {
    v("IfStatement", t, e);
  }
  n(vPe, "assertIfStatement");
  function CPe(t, e) {
    v("LabeledStatement", t, e);
  }
  n(CPe, "assertLabeledStatement");
  function IPe(t, e) {
    v("StringLiteral", t, e);
  }
  n(IPe, "assertStringLiteral");
  function wPe(t, e) {
    v("NumericLiteral", t, e);
  }
  n(wPe, "assertNumericLiteral");
  function NPe(t, e) {
    v("NullLiteral", t, e);
  }
  n(NPe, "assertNullLiteral");
  function OPe(t, e) {
    v("BooleanLiteral", t, e);
  }
  n(OPe, "assertBooleanLiteral");
  function kPe(t, e) {
    v("RegExpLiteral", t, e);
  }
  n(kPe, "assertRegExpLiteral");
  function DPe(t, e) {
    v("LogicalExpression", t, e);
  }
  n(DPe, "assertLogicalExpression");
  function _Pe(t, e) {
    v("MemberExpression", t, e);
  }
  n(_Pe, "assertMemberExpression");
  function LPe(t, e) {
    v("NewExpression", t, e);
  }
  n(LPe, "assertNewExpression");
  function MPe(t, e) {
    v("Program", t, e);
  }
  n(MPe, "assertProgram");
  function BPe(t, e) {
    v("ObjectExpression", t, e);
  }
  n(BPe, "assertObjectExpression");
  function FPe(t, e) {
    v("ObjectMethod", t, e);
  }
  n(FPe, "assertObjectMethod");
  function jPe(t, e) {
    v("ObjectProperty", t, e);
  }
  n(jPe, "assertObjectProperty");
  function RPe(t, e) {
    v("RestElement", t, e);
  }
  n(RPe, "assertRestElement");
  function UPe(t, e) {
    v("ReturnStatement", t, e);
  }
  n(UPe, "assertReturnStatement");
  function qPe(t, e) {
    v("SequenceExpression", t, e);
  }
  n(qPe, "assertSequenceExpression");
  function VPe(t, e) {
    v("ParenthesizedExpression", t, e);
  }
  n(VPe, "assertParenthesizedExpression");
  function KPe(t, e) {
    v("SwitchCase", t, e);
  }
  n(KPe, "assertSwitchCase");
  function WPe(t, e) {
    v("SwitchStatement", t, e);
  }
  n(WPe, "assertSwitchStatement");
  function YPe(t, e) {
    v("ThisExpression", t, e);
  }
  n(YPe, "assertThisExpression");
  function JPe(t, e) {
    v("ThrowStatement", t, e);
  }
  n(JPe, "assertThrowStatement");
  function XPe(t, e) {
    v("TryStatement", t, e);
  }
  n(XPe, "assertTryStatement");
  function $Pe(t, e) {
    v("UnaryExpression", t, e);
  }
  n($Pe, "assertUnaryExpression");
  function HPe(t, e) {
    v("UpdateExpression", t, e);
  }
  n(HPe, "assertUpdateExpression");
  function zPe(t, e) {
    v("VariableDeclaration", t, e);
  }
  n(zPe, "assertVariableDeclaration");
  function GPe(t, e) {
    v("VariableDeclarator", t, e);
  }
  n(GPe, "assertVariableDeclarator");
  function QPe(t, e) {
    v("WhileStatement", t, e);
  }
  n(QPe, "assertWhileStatement");
  function ZPe(t, e) {
    v("WithStatement", t, e);
  }
  n(ZPe, "assertWithStatement");
  function eEe(t, e) {
    v("AssignmentPattern", t, e);
  }
  n(eEe, "assertAssignmentPattern");
  function tEe(t, e) {
    v("ArrayPattern", t, e);
  }
  n(tEe, "assertArrayPattern");
  function rEe(t, e) {
    v("ArrowFunctionExpression", t, e);
  }
  n(rEe, "assertArrowFunctionExpression");
  function sEe(t, e) {
    v("ClassBody", t, e);
  }
  n(sEe, "assertClassBody");
  function iEe(t, e) {
    v("ClassExpression", t, e);
  }
  n(iEe, "assertClassExpression");
  function nEe(t, e) {
    v("ClassDeclaration", t, e);
  }
  n(nEe, "assertClassDeclaration");
  function aEe(t, e) {
    v("ExportAllDeclaration", t, e);
  }
  n(aEe, "assertExportAllDeclaration");
  function oEe(t, e) {
    v("ExportDefaultDeclaration", t, e);
  }
  n(oEe, "assertExportDefaultDeclaration");
  function lEe(t, e) {
    v("ExportNamedDeclaration", t, e);
  }
  n(lEe, "assertExportNamedDeclaration");
  function uEe(t, e) {
    v("ExportSpecifier", t, e);
  }
  n(uEe, "assertExportSpecifier");
  function cEe(t, e) {
    v("ForOfStatement", t, e);
  }
  n(cEe, "assertForOfStatement");
  function pEe(t, e) {
    v("ImportDeclaration", t, e);
  }
  n(pEe, "assertImportDeclaration");
  function fEe(t, e) {
    v("ImportDefaultSpecifier", t, e);
  }
  n(fEe, "assertImportDefaultSpecifier");
  function hEe(t, e) {
    v("ImportNamespaceSpecifier", t, e);
  }
  n(hEe, "assertImportNamespaceSpecifier");
  function dEe(t, e) {
    v("ImportSpecifier", t, e);
  }
  n(dEe, "assertImportSpecifier");
  function mEe(t, e) {
    v("ImportExpression", t, e);
  }
  n(mEe, "assertImportExpression");
  function yEe(t, e) {
    v("MetaProperty", t, e);
  }
  n(yEe, "assertMetaProperty");
  function TEe(t, e) {
    v("ClassMethod", t, e);
  }
  n(TEe, "assertClassMethod");
  function bEe(t, e) {
    v("ObjectPattern", t, e);
  }
  n(bEe, "assertObjectPattern");
  function xEe(t, e) {
    v("SpreadElement", t, e);
  }
  n(xEe, "assertSpreadElement");
  function SEe(t, e) {
    v("Super", t, e);
  }
  n(SEe, "assertSuper");
  function gEe(t, e) {
    v("TaggedTemplateExpression", t, e);
  }
  n(gEe, "assertTaggedTemplateExpression");
  function PEe(t, e) {
    v("TemplateElement", t, e);
  }
  n(PEe, "assertTemplateElement");
  function EEe(t, e) {
    v("TemplateLiteral", t, e);
  }
  n(EEe, "assertTemplateLiteral");
  function AEe(t, e) {
    v("YieldExpression", t, e);
  }
  n(AEe, "assertYieldExpression");
  function vEe(t, e) {
    v("AwaitExpression", t, e);
  }
  n(vEe, "assertAwaitExpression");
  function CEe(t, e) {
    v("Import", t, e);
  }
  n(CEe, "assertImport");
  function IEe(t, e) {
    v("BigIntLiteral", t, e);
  }
  n(IEe, "assertBigIntLiteral");
  function wEe(t, e) {
    v("ExportNamespaceSpecifier", t, e);
  }
  n(wEe, "assertExportNamespaceSpecifier");
  function NEe(t, e) {
    v("OptionalMemberExpression", t, e);
  }
  n(NEe, "assertOptionalMemberExpression");
  function OEe(t, e) {
    v("OptionalCallExpression", t, e);
  }
  n(OEe, "assertOptionalCallExpression");
  function kEe(t, e) {
    v("ClassProperty", t, e);
  }
  n(kEe, "assertClassProperty");
  function DEe(t, e) {
    v("ClassAccessorProperty", t, e);
  }
  n(DEe, "assertClassAccessorProperty");
  function _Ee(t, e) {
    v("ClassPrivateProperty", t, e);
  }
  n(_Ee, "assertClassPrivateProperty");
  function LEe(t, e) {
    v("ClassPrivateMethod", t, e);
  }
  n(LEe, "assertClassPrivateMethod");
  function MEe(t, e) {
    v("PrivateName", t, e);
  }
  n(MEe, "assertPrivateName");
  function BEe(t, e) {
    v("StaticBlock", t, e);
  }
  n(BEe, "assertStaticBlock");
  function FEe(t, e) {
    v("AnyTypeAnnotation", t, e);
  }
  n(FEe, "assertAnyTypeAnnotation");
  function jEe(t, e) {
    v("ArrayTypeAnnotation", t, e);
  }
  n(jEe, "assertArrayTypeAnnotation");
  function REe(t, e) {
    v("BooleanTypeAnnotation", t, e);
  }
  n(REe, "assertBooleanTypeAnnotation");
  function UEe(t, e) {
    v("BooleanLiteralTypeAnnotation", t, e);
  }
  n(UEe, "assertBooleanLiteralTypeAnnotation");
  function qEe(t, e) {
    v("NullLiteralTypeAnnotation", t, e);
  }
  n(qEe, "assertNullLiteralTypeAnnotation");
  function VEe(t, e) {
    v("ClassImplements", t, e);
  }
  n(VEe, "assertClassImplements");
  function KEe(t, e) {
    v("DeclareClass", t, e);
  }
  n(KEe, "assertDeclareClass");
  function WEe(t, e) {
    v("DeclareFunction", t, e);
  }
  n(WEe, "assertDeclareFunction");
  function YEe(t, e) {
    v("DeclareInterface", t, e);
  }
  n(YEe, "assertDeclareInterface");
  function JEe(t, e) {
    v("DeclareModule", t, e);
  }
  n(JEe, "assertDeclareModule");
  function XEe(t, e) {
    v("DeclareModuleExports", t, e);
  }
  n(XEe, "assertDeclareModuleExports");
  function $Ee(t, e) {
    v("DeclareTypeAlias", t, e);
  }
  n($Ee, "assertDeclareTypeAlias");
  function HEe(t, e) {
    v("DeclareOpaqueType", t, e);
  }
  n(HEe, "assertDeclareOpaqueType");
  function zEe(t, e) {
    v("DeclareVariable", t, e);
  }
  n(zEe, "assertDeclareVariable");
  function GEe(t, e) {
    v("DeclareExportDeclaration", t, e);
  }
  n(GEe, "assertDeclareExportDeclaration");
  function QEe(t, e) {
    v("DeclareExportAllDeclaration", t, e);
  }
  n(QEe, "assertDeclareExportAllDeclaration");
  function ZEe(t, e) {
    v("DeclaredPredicate", t, e);
  }
  n(ZEe, "assertDeclaredPredicate");
  function eAe(t, e) {
    v("ExistsTypeAnnotation", t, e);
  }
  n(eAe, "assertExistsTypeAnnotation");
  function tAe(t, e) {
    v("FunctionTypeAnnotation", t, e);
  }
  n(tAe, "assertFunctionTypeAnnotation");
  function rAe(t, e) {
    v("FunctionTypeParam", t, e);
  }
  n(rAe, "assertFunctionTypeParam");
  function sAe(t, e) {
    v("GenericTypeAnnotation", t, e);
  }
  n(sAe, "assertGenericTypeAnnotation");
  function iAe(t, e) {
    v("InferredPredicate", t, e);
  }
  n(iAe, "assertInferredPredicate");
  function nAe(t, e) {
    v("InterfaceExtends", t, e);
  }
  n(nAe, "assertInterfaceExtends");
  function aAe(t, e) {
    v("InterfaceDeclaration", t, e);
  }
  n(aAe, "assertInterfaceDeclaration");
  function oAe(t, e) {
    v("InterfaceTypeAnnotation", t, e);
  }
  n(oAe, "assertInterfaceTypeAnnotation");
  function lAe(t, e) {
    v("IntersectionTypeAnnotation", t, e);
  }
  n(lAe, "assertIntersectionTypeAnnotation");
  function uAe(t, e) {
    v("MixedTypeAnnotation", t, e);
  }
  n(uAe, "assertMixedTypeAnnotation");
  function cAe(t, e) {
    v("EmptyTypeAnnotation", t, e);
  }
  n(cAe, "assertEmptyTypeAnnotation");
  function pAe(t, e) {
    v("NullableTypeAnnotation", t, e);
  }
  n(pAe, "assertNullableTypeAnnotation");
  function fAe(t, e) {
    v("NumberLiteralTypeAnnotation", t, e);
  }
  n(fAe, "assertNumberLiteralTypeAnnotation");
  function hAe(t, e) {
    v("NumberTypeAnnotation", t, e);
  }
  n(hAe, "assertNumberTypeAnnotation");
  function dAe(t, e) {
    v("ObjectTypeAnnotation", t, e);
  }
  n(dAe, "assertObjectTypeAnnotation");
  function mAe(t, e) {
    v("ObjectTypeInternalSlot", t, e);
  }
  n(mAe, "assertObjectTypeInternalSlot");
  function yAe(t, e) {
    v("ObjectTypeCallProperty", t, e);
  }
  n(yAe, "assertObjectTypeCallProperty");
  function TAe(t, e) {
    v("ObjectTypeIndexer", t, e);
  }
  n(TAe, "assertObjectTypeIndexer");
  function bAe(t, e) {
    v("ObjectTypeProperty", t, e);
  }
  n(bAe, "assertObjectTypeProperty");
  function xAe(t, e) {
    v("ObjectTypeSpreadProperty", t, e);
  }
  n(xAe, "assertObjectTypeSpreadProperty");
  function SAe(t, e) {
    v("OpaqueType", t, e);
  }
  n(SAe, "assertOpaqueType");
  function gAe(t, e) {
    v("QualifiedTypeIdentifier", t, e);
  }
  n(gAe, "assertQualifiedTypeIdentifier");
  function PAe(t, e) {
    v("StringLiteralTypeAnnotation", t, e);
  }
  n(PAe, "assertStringLiteralTypeAnnotation");
  function EAe(t, e) {
    v("StringTypeAnnotation", t, e);
  }
  n(EAe, "assertStringTypeAnnotation");
  function AAe(t, e) {
    v("SymbolTypeAnnotation", t, e);
  }
  n(AAe, "assertSymbolTypeAnnotation");
  function vAe(t, e) {
    v("ThisTypeAnnotation", t, e);
  }
  n(vAe, "assertThisTypeAnnotation");
  function CAe(t, e) {
    v("TupleTypeAnnotation", t, e);
  }
  n(CAe, "assertTupleTypeAnnotation");
  function IAe(t, e) {
    v("TypeofTypeAnnotation", t, e);
  }
  n(IAe, "assertTypeofTypeAnnotation");
  function wAe(t, e) {
    v("TypeAlias", t, e);
  }
  n(wAe, "assertTypeAlias");
  function NAe(t, e) {
    v("TypeAnnotation", t, e);
  }
  n(NAe, "assertTypeAnnotation");
  function OAe(t, e) {
    v("TypeCastExpression", t, e);
  }
  n(OAe, "assertTypeCastExpression");
  function kAe(t, e) {
    v("TypeParameter", t, e);
  }
  n(kAe, "assertTypeParameter");
  function DAe(t, e) {
    v("TypeParameterDeclaration", t, e);
  }
  n(DAe, "assertTypeParameterDeclaration");
  function _Ae(t, e) {
    v("TypeParameterInstantiation", t, e);
  }
  n(_Ae, "assertTypeParameterInstantiation");
  function LAe(t, e) {
    v("UnionTypeAnnotation", t, e);
  }
  n(LAe, "assertUnionTypeAnnotation");
  function MAe(t, e) {
    v("Variance", t, e);
  }
  n(MAe, "assertVariance");
  function BAe(t, e) {
    v("VoidTypeAnnotation", t, e);
  }
  n(BAe, "assertVoidTypeAnnotation");
  function FAe(t, e) {
    v("EnumDeclaration", t, e);
  }
  n(FAe, "assertEnumDeclaration");
  function jAe(t, e) {
    v("EnumBooleanBody", t, e);
  }
  n(jAe, "assertEnumBooleanBody");
  function RAe(t, e) {
    v("EnumNumberBody", t, e);
  }
  n(RAe, "assertEnumNumberBody");
  function UAe(t, e) {
    v("EnumStringBody", t, e);
  }
  n(UAe, "assertEnumStringBody");
  function qAe(t, e) {
    v("EnumSymbolBody", t, e);
  }
  n(qAe, "assertEnumSymbolBody");
  function VAe(t, e) {
    v("EnumBooleanMember", t, e);
  }
  n(VAe, "assertEnumBooleanMember");
  function KAe(t, e) {
    v("EnumNumberMember", t, e);
  }
  n(KAe, "assertEnumNumberMember");
  function WAe(t, e) {
    v("EnumStringMember", t, e);
  }
  n(WAe, "assertEnumStringMember");
  function YAe(t, e) {
    v("EnumDefaultedMember", t, e);
  }
  n(YAe, "assertEnumDefaultedMember");
  function JAe(t, e) {
    v("IndexedAccessType", t, e);
  }
  n(JAe, "assertIndexedAccessType");
  function XAe(t, e) {
    v("OptionalIndexedAccessType", t, e);
  }
  n(XAe, "assertOptionalIndexedAccessType");
  function $Ae(t, e) {
    v("JSXAttribute", t, e);
  }
  n($Ae, "assertJSXAttribute");
  function HAe(t, e) {
    v("JSXClosingElement", t, e);
  }
  n(HAe, "assertJSXClosingElement");
  function zAe(t, e) {
    v("JSXElement", t, e);
  }
  n(zAe, "assertJSXElement");
  function GAe(t, e) {
    v("JSXEmptyExpression", t, e);
  }
  n(GAe, "assertJSXEmptyExpression");
  function QAe(t, e) {
    v("JSXExpressionContainer", t, e);
  }
  n(QAe, "assertJSXExpressionContainer");
  function ZAe(t, e) {
    v("JSXSpreadChild", t, e);
  }
  n(ZAe, "assertJSXSpreadChild");
  function e1e(t, e) {
    v("JSXIdentifier", t, e);
  }
  n(e1e, "assertJSXIdentifier");
  function t1e(t, e) {
    v("JSXMemberExpression", t, e);
  }
  n(t1e, "assertJSXMemberExpression");
  function r1e(t, e) {
    v("JSXNamespacedName", t, e);
  }
  n(r1e, "assertJSXNamespacedName");
  function s1e(t, e) {
    v("JSXOpeningElement", t, e);
  }
  n(s1e, "assertJSXOpeningElement");
  function i1e(t, e) {
    v("JSXSpreadAttribute", t, e);
  }
  n(i1e, "assertJSXSpreadAttribute");
  function n1e(t, e) {
    v("JSXText", t, e);
  }
  n(n1e, "assertJSXText");
  function a1e(t, e) {
    v("JSXFragment", t, e);
  }
  n(a1e, "assertJSXFragment");
  function o1e(t, e) {
    v("JSXOpeningFragment", t, e);
  }
  n(o1e, "assertJSXOpeningFragment");
  function l1e(t, e) {
    v("JSXClosingFragment", t, e);
  }
  n(l1e, "assertJSXClosingFragment");
  function u1e(t, e) {
    v("Noop", t, e);
  }
  n(u1e, "assertNoop");
  function c1e(t, e) {
    v("Placeholder", t, e);
  }
  n(c1e, "assertPlaceholder");
  function p1e(t, e) {
    v("V8IntrinsicIdentifier", t, e);
  }
  n(p1e, "assertV8IntrinsicIdentifier");
  function f1e(t, e) {
    v("ArgumentPlaceholder", t, e);
  }
  n(f1e, "assertArgumentPlaceholder");
  function h1e(t, e) {
    v("BindExpression", t, e);
  }
  n(h1e, "assertBindExpression");
  function d1e(t, e) {
    v("ImportAttribute", t, e);
  }
  n(d1e, "assertImportAttribute");
  function m1e(t, e) {
    v("Decorator", t, e);
  }
  n(m1e, "assertDecorator");
  function y1e(t, e) {
    v("DoExpression", t, e);
  }
  n(y1e, "assertDoExpression");
  function T1e(t, e) {
    v("ExportDefaultSpecifier", t, e);
  }
  n(T1e, "assertExportDefaultSpecifier");
  function b1e(t, e) {
    v("RecordExpression", t, e);
  }
  n(b1e, "assertRecordExpression");
  function x1e(t, e) {
    v("TupleExpression", t, e);
  }
  n(x1e, "assertTupleExpression");
  function S1e(t, e) {
    v("DecimalLiteral", t, e);
  }
  n(S1e, "assertDecimalLiteral");
  function g1e(t, e) {
    v("ModuleExpression", t, e);
  }
  n(g1e, "assertModuleExpression");
  function P1e(t, e) {
    v("TopicReference", t, e);
  }
  n(P1e, "assertTopicReference");
  function E1e(t, e) {
    v("PipelineTopicExpression", t, e);
  }
  n(E1e, "assertPipelineTopicExpression");
  function A1e(t, e) {
    v("PipelineBareFunction", t, e);
  }
  n(A1e, "assertPipelineBareFunction");
  function v1e(t, e) {
    v("PipelinePrimaryTopicReference", t, e);
  }
  n(v1e, "assertPipelinePrimaryTopicReference");
  function C1e(t, e) {
    v("TSParameterProperty", t, e);
  }
  n(C1e, "assertTSParameterProperty");
  function I1e(t, e) {
    v("TSDeclareFunction", t, e);
  }
  n(I1e, "assertTSDeclareFunction");
  function w1e(t, e) {
    v("TSDeclareMethod", t, e);
  }
  n(w1e, "assertTSDeclareMethod");
  function N1e(t, e) {
    v("TSQualifiedName", t, e);
  }
  n(N1e, "assertTSQualifiedName");
  function O1e(t, e) {
    v("TSCallSignatureDeclaration", t, e);
  }
  n(O1e, "assertTSCallSignatureDeclaration");
  function k1e(t, e) {
    v("TSConstructSignatureDeclaration", t, e);
  }
  n(k1e, "assertTSConstructSignatureDeclaration");
  function D1e(t, e) {
    v("TSPropertySignature", t, e);
  }
  n(D1e, "assertTSPropertySignature");
  function _1e(t, e) {
    v("TSMethodSignature", t, e);
  }
  n(_1e, "assertTSMethodSignature");
  function L1e(t, e) {
    v("TSIndexSignature", t, e);
  }
  n(L1e, "assertTSIndexSignature");
  function M1e(t, e) {
    v("TSAnyKeyword", t, e);
  }
  n(M1e, "assertTSAnyKeyword");
  function B1e(t, e) {
    v("TSBooleanKeyword", t, e);
  }
  n(B1e, "assertTSBooleanKeyword");
  function F1e(t, e) {
    v("TSBigIntKeyword", t, e);
  }
  n(F1e, "assertTSBigIntKeyword");
  function j1e(t, e) {
    v("TSIntrinsicKeyword", t, e);
  }
  n(j1e, "assertTSIntrinsicKeyword");
  function R1e(t, e) {
    v("TSNeverKeyword", t, e);
  }
  n(R1e, "assertTSNeverKeyword");
  function U1e(t, e) {
    v("TSNullKeyword", t, e);
  }
  n(U1e, "assertTSNullKeyword");
  function q1e(t, e) {
    v("TSNumberKeyword", t, e);
  }
  n(q1e, "assertTSNumberKeyword");
  function V1e(t, e) {
    v("TSObjectKeyword", t, e);
  }
  n(V1e, "assertTSObjectKeyword");
  function K1e(t, e) {
    v("TSStringKeyword", t, e);
  }
  n(K1e, "assertTSStringKeyword");
  function W1e(t, e) {
    v("TSSymbolKeyword", t, e);
  }
  n(W1e, "assertTSSymbolKeyword");
  function Y1e(t, e) {
    v("TSUndefinedKeyword", t, e);
  }
  n(Y1e, "assertTSUndefinedKeyword");
  function J1e(t, e) {
    v("TSUnknownKeyword", t, e);
  }
  n(J1e, "assertTSUnknownKeyword");
  function X1e(t, e) {
    v("TSVoidKeyword", t, e);
  }
  n(X1e, "assertTSVoidKeyword");
  function $1e(t, e) {
    v("TSThisType", t, e);
  }
  n($1e, "assertTSThisType");
  function H1e(t, e) {
    v("TSFunctionType", t, e);
  }
  n(H1e, "assertTSFunctionType");
  function z1e(t, e) {
    v("TSConstructorType", t, e);
  }
  n(z1e, "assertTSConstructorType");
  function G1e(t, e) {
    v("TSTypeReference", t, e);
  }
  n(G1e, "assertTSTypeReference");
  function Q1e(t, e) {
    v("TSTypePredicate", t, e);
  }
  n(Q1e, "assertTSTypePredicate");
  function Z1e(t, e) {
    v("TSTypeQuery", t, e);
  }
  n(Z1e, "assertTSTypeQuery");
  function eve(t, e) {
    v("TSTypeLiteral", t, e);
  }
  n(eve, "assertTSTypeLiteral");
  function tve(t, e) {
    v("TSArrayType", t, e);
  }
  n(tve, "assertTSArrayType");
  function rve(t, e) {
    v("TSTupleType", t, e);
  }
  n(rve, "assertTSTupleType");
  function sve(t, e) {
    v("TSOptionalType", t, e);
  }
  n(sve, "assertTSOptionalType");
  function ive(t, e) {
    v("TSRestType", t, e);
  }
  n(ive, "assertTSRestType");
  function nve(t, e) {
    v("TSNamedTupleMember", t, e);
  }
  n(nve, "assertTSNamedTupleMember");
  function ave(t, e) {
    v("TSUnionType", t, e);
  }
  n(ave, "assertTSUnionType");
  function ove(t, e) {
    v("TSIntersectionType", t, e);
  }
  n(ove, "assertTSIntersectionType");
  function lve(t, e) {
    v("TSConditionalType", t, e);
  }
  n(lve, "assertTSConditionalType");
  function uve(t, e) {
    v("TSInferType", t, e);
  }
  n(uve, "assertTSInferType");
  function cve(t, e) {
    v("TSParenthesizedType", t, e);
  }
  n(cve, "assertTSParenthesizedType");
  function pve(t, e) {
    v("TSTypeOperator", t, e);
  }
  n(pve, "assertTSTypeOperator");
  function fve(t, e) {
    v("TSIndexedAccessType", t, e);
  }
  n(fve, "assertTSIndexedAccessType");
  function hve(t, e) {
    v("TSMappedType", t, e);
  }
  n(hve, "assertTSMappedType");
  function dve(t, e) {
    v("TSLiteralType", t, e);
  }
  n(dve, "assertTSLiteralType");
  function mve(t, e) {
    v("TSExpressionWithTypeArguments", t, e);
  }
  n(mve, "assertTSExpressionWithTypeArguments");
  function yve(t, e) {
    v("TSInterfaceDeclaration", t, e);
  }
  n(yve, "assertTSInterfaceDeclaration");
  function Tve(t, e) {
    v("TSInterfaceBody", t, e);
  }
  n(Tve, "assertTSInterfaceBody");
  function bve(t, e) {
    v("TSTypeAliasDeclaration", t, e);
  }
  n(bve, "assertTSTypeAliasDeclaration");
  function xve(t, e) {
    v("TSInstantiationExpression", t, e);
  }
  n(xve, "assertTSInstantiationExpression");
  function Sve(t, e) {
    v("TSAsExpression", t, e);
  }
  n(Sve, "assertTSAsExpression");
  function gve(t, e) {
    v("TSSatisfiesExpression", t, e);
  }
  n(gve, "assertTSSatisfiesExpression");
  function Pve(t, e) {
    v("TSTypeAssertion", t, e);
  }
  n(Pve, "assertTSTypeAssertion");
  function Eve(t, e) {
    v("TSEnumDeclaration", t, e);
  }
  n(Eve, "assertTSEnumDeclaration");
  function Ave(t, e) {
    v("TSEnumMember", t, e);
  }
  n(Ave, "assertTSEnumMember");
  function vve(t, e) {
    v("TSModuleDeclaration", t, e);
  }
  n(vve, "assertTSModuleDeclaration");
  function Cve(t, e) {
    v("TSModuleBlock", t, e);
  }
  n(Cve, "assertTSModuleBlock");
  function Ive(t, e) {
    v("TSImportType", t, e);
  }
  n(Ive, "assertTSImportType");
  function wve(t, e) {
    v("TSImportEqualsDeclaration", t, e);
  }
  n(wve, "assertTSImportEqualsDeclaration");
  function Nve(t, e) {
    v("TSExternalModuleReference", t, e);
  }
  n(Nve, "assertTSExternalModuleReference");
  function Ove(t, e) {
    v("TSNonNullExpression", t, e);
  }
  n(Ove, "assertTSNonNullExpression");
  function kve(t, e) {
    v("TSExportAssignment", t, e);
  }
  n(kve, "assertTSExportAssignment");
  function Dve(t, e) {
    v("TSNamespaceExportDeclaration", t, e);
  }
  n(Dve, "assertTSNamespaceExportDeclaration");
  function _ve(t, e) {
    v("TSTypeAnnotation", t, e);
  }
  n(_ve, "assertTSTypeAnnotation");
  function Lve(t, e) {
    v("TSTypeParameterInstantiation", t, e);
  }
  n(Lve, "assertTSTypeParameterInstantiation");
  function Mve(t, e) {
    v("TSTypeParameterDeclaration", t, e);
  }
  n(Mve, "assertTSTypeParameterDeclaration");
  function Bve(t, e) {
    v("TSTypeParameter", t, e);
  }
  n(Bve, "assertTSTypeParameter");
  function Fve(t, e) {
    v("Standardized", t, e);
  }
  n(Fve, "assertStandardized");
  function jve(t, e) {
    v("Expression", t, e);
  }
  n(jve, "assertExpression");
  function Rve(t, e) {
    v("Binary", t, e);
  }
  n(Rve, "assertBinary");
  function Uve(t, e) {
    v("Scopable", t, e);
  }
  n(Uve, "assertScopable");
  function qve(t, e) {
    v("BlockParent", t, e);
  }
  n(qve, "assertBlockParent");
  function Vve(t, e) {
    v("Block", t, e);
  }
  n(Vve, "assertBlock");
  function Kve(t, e) {
    v("Statement", t, e);
  }
  n(Kve, "assertStatement");
  function Wve(t, e) {
    v("Terminatorless", t, e);
  }
  n(Wve, "assertTerminatorless");
  function Yve(t, e) {
    v("CompletionStatement", t, e);
  }
  n(Yve, "assertCompletionStatement");
  function Jve(t, e) {
    v("Conditional", t, e);
  }
  n(Jve, "assertConditional");
  function Xve(t, e) {
    v("Loop", t, e);
  }
  n(Xve, "assertLoop");
  function $ve(t, e) {
    v("While", t, e);
  }
  n($ve, "assertWhile");
  function Hve(t, e) {
    v("ExpressionWrapper", t, e);
  }
  n(Hve, "assertExpressionWrapper");
  function zve(t, e) {
    v("For", t, e);
  }
  n(zve, "assertFor");
  function Gve(t, e) {
    v("ForXStatement", t, e);
  }
  n(Gve, "assertForXStatement");
  function Qve(t, e) {
    v("Function", t, e);
  }
  n(Qve, "assertFunction");
  function Zve(t, e) {
    v("FunctionParent", t, e);
  }
  n(Zve, "assertFunctionParent");
  function eCe(t, e) {
    v("Pureish", t, e);
  }
  n(eCe, "assertPureish");
  function tCe(t, e) {
    v("Declaration", t, e);
  }
  n(tCe, "assertDeclaration");
  function rCe(t, e) {
    v("PatternLike", t, e);
  }
  n(rCe, "assertPatternLike");
  function sCe(t, e) {
    v("LVal", t, e);
  }
  n(sCe, "assertLVal");
  function iCe(t, e) {
    v("TSEntityName", t, e);
  }
  n(iCe, "assertTSEntityName");
  function nCe(t, e) {
    v("Literal", t, e);
  }
  n(nCe, "assertLiteral");
  function aCe(t, e) {
    v("Immutable", t, e);
  }
  n(aCe, "assertImmutable");
  function oCe(t, e) {
    v("UserWhitespacable", t, e);
  }
  n(oCe, "assertUserWhitespacable");
  function lCe(t, e) {
    v("Method", t, e);
  }
  n(lCe, "assertMethod");
  function uCe(t, e) {
    v("ObjectMember", t, e);
  }
  n(uCe, "assertObjectMember");
  function cCe(t, e) {
    v("Property", t, e);
  }
  n(cCe, "assertProperty");
  function pCe(t, e) {
    v("UnaryLike", t, e);
  }
  n(pCe, "assertUnaryLike");
  function fCe(t, e) {
    v("Pattern", t, e);
  }
  n(fCe, "assertPattern");
  function hCe(t, e) {
    v("Class", t, e);
  }
  n(hCe, "assertClass");
  function dCe(t, e) {
    v("ImportOrExportDeclaration", t, e);
  }
  n(dCe, "assertImportOrExportDeclaration");
  function mCe(t, e) {
    v("ExportDeclaration", t, e);
  }
  n(mCe, "assertExportDeclaration");
  function yCe(t, e) {
    v("ModuleSpecifier", t, e);
  }
  n(yCe, "assertModuleSpecifier");
  function TCe(t, e) {
    v("Accessor", t, e);
  }
  n(TCe, "assertAccessor");
  function bCe(t, e) {
    v("Private", t, e);
  }
  n(bCe, "assertPrivate");
  function xCe(t, e) {
    v("Flow", t, e);
  }
  n(xCe, "assertFlow");
  function SCe(t, e) {
    v("FlowType", t, e);
  }
  n(SCe, "assertFlowType");
  function gCe(t, e) {
    v("FlowBaseAnnotation", t, e);
  }
  n(gCe, "assertFlowBaseAnnotation");
  function PCe(t, e) {
    v("FlowDeclaration", t, e);
  }
  n(PCe, "assertFlowDeclaration");
  function ECe(t, e) {
    v("FlowPredicate", t, e);
  }
  n(ECe, "assertFlowPredicate");
  function ACe(t, e) {
    v("EnumBody", t, e);
  }
  n(ACe, "assertEnumBody");
  function vCe(t, e) {
    v("EnumMember", t, e);
  }
  n(vCe, "assertEnumMember");
  function CCe(t, e) {
    v("JSX", t, e);
  }
  n(CCe, "assertJSX");
  function ICe(t, e) {
    v("Miscellaneous", t, e);
  }
  n(ICe, "assertMiscellaneous");
  function wCe(t, e) {
    v("TypeScript", t, e);
  }
  n(wCe, "assertTypeScript");
  function NCe(t, e) {
    v("TSTypeElement", t, e);
  }
  n(NCe, "assertTSTypeElement");
  function OCe(t, e) {
    v("TSType", t, e);
  }
  n(OCe, "assertTSType");
  function kCe(t, e) {
    v("TSBaseType", t, e);
  }
  n(kCe, "assertTSBaseType");
  function DCe(t, e) {
    (0, Do.default)("assertNumberLiteral", "assertNumericLiteral"), v("NumberLiteral", t, e);
  }
  n(DCe, "assertNumberLiteral");
  function _Ce(t, e) {
    (0, Do.default)("assertRegexLiteral", "assertRegExpLiteral"), v("RegexLiteral", t, e);
  }
  n(_Ce, "assertRegexLiteral");
  function LCe(t, e) {
    (0, Do.default)("assertRestProperty", "assertRestElement"), v("RestProperty", t, e);
  }
  n(LCe, "assertRestProperty");
  function MCe(t, e) {
    (0, Do.default)("assertSpreadProperty", "assertSpreadElement"), v("SpreadProperty", t, e);
  }
  n(MCe, "assertSpreadProperty");
  function BCe(t, e) {
    (0, Do.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), v("ModuleDeclaration", t, e);
  }
  n(BCe, "assertModuleDeclaration");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var fI = w((xc) => {
  "use strict";
  Object.defineProperty(xc, "__esModule", {
    value: !0
  });
  xc.default = void 0;
  var Qr = Ar(), PRe = xc.default = FCe;
  function FCe(t) {
    switch (t) {
      case "string":
        return (0, Qr.stringTypeAnnotation)();
      case "number":
        return (0, Qr.numberTypeAnnotation)();
      case "undefined":
        return (0, Qr.voidTypeAnnotation)();
      case "boolean":
        return (0, Qr.booleanTypeAnnotation)();
      case "function":
        return (0, Qr.genericTypeAnnotation)((0, Qr.identifier)("Function"));
      case "object":
        return (0, Qr.genericTypeAnnotation)((0, Qr.identifier)("Object"));
      case "symbol":
        return (0, Qr.genericTypeAnnotation)((0, Qr.identifier)("Symbol"));
      case "bigint":
        return (0, Qr.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + t);
  }
  n(FCe, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var dT = w((hT) => {
  "use strict";
  Object.defineProperty(hT, "__esModule", {
    value: !0
  });
  hT.default = dI;
  var _o = Rt();
  function hI(t) {
    return (0, _o.isIdentifier)(t) ? t.name : `${t.id.name}.${hI(t.qualification)}`;
  }
  n(hI, "getQualifiedName");
  function dI(t) {
    let e = Array.from(t), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, _o.isAnyTypeAnnotation)(l))
          return [l];
        if ((0, _o.isFlowBaseAnnotation)(l)) {
          s.set(l.type, l);
          continue;
        }
        if ((0, _o.isUnionTypeAnnotation)(l)) {
          i.has(l.types) || (e.push(...l.types), i.add(l.types));
          continue;
        }
        if ((0, _o.isGenericTypeAnnotation)(l)) {
          let u = hI(l.id);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = dI(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of s)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  n(dI, "removeTypeDuplicates");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var mI = w((mT) => {
  "use strict";
  Object.defineProperty(mT, "__esModule", {
    value: !0
  });
  mT.default = UCe;
  var jCe = Ar(), RCe = dT();
  function UCe(t) {
    let e = (0, RCe.default)(t);
    return e.length === 1 ? e[0] : (0, jCe.unionTypeAnnotation)(e);
  }
  n(UCe, "createFlowUnionType");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var bI = w((yT) => {
  "use strict";
  Object.defineProperty(yT, "__esModule", {
    value: !0
  });
  yT.default = TI;
  var Lo = Rt();
  function yI(t) {
    return (0, Lo.isIdentifier)(t) ? t.name : `${t.right.name}.${yI(t.left)}`;
  }
  n(yI, "getQualifiedName");
  function TI(t) {
    let e = Array.from(t), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, Lo.isTSAnyKeyword)(l))
          return [l];
        if ((0, Lo.isTSBaseType)(l)) {
          s.set(l.type, l);
          continue;
        }
        if ((0, Lo.isTSUnionType)(l)) {
          i.has(l.types) || (e.push(...l.types), i.add(l.types));
          continue;
        }
        if ((0, Lo.isTSTypeReference)(l) && l.typeParameters) {
          let u = yI(l.typeName);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = TI(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of s)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  n(TI, "removeTypeDuplicates");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var xI = w((TT) => {
  "use strict";
  Object.defineProperty(TT, "__esModule", {
    value: !0
  });
  TT.default = WCe;
  var qCe = Ar(), VCe = bI(), KCe = Rt();
  function WCe(t) {
    let e = t.map((s) => (0, KCe.isTSTypeAnnotation)(s) ? s.typeAnnotation : s), r = (0, VCe.default)(e);
    return r.length === 1 ? r[0] : (0, qCe.tsUnionType)(r);
  }
  n(WCe, "createTSUnionType");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/generated/uppercase.js
var SI = w((O) => {
  "use strict";
  Object.defineProperty(O, "__esModule", {
    value: !0
  });
  Object.defineProperty(O, "AnyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.anyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "ArgumentPlaceholder", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.argumentPlaceholder;
    }, "get")
  });
  Object.defineProperty(O, "ArrayExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.arrayExpression;
    }, "get")
  });
  Object.defineProperty(O, "ArrayPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.arrayPattern;
    }, "get")
  });
  Object.defineProperty(O, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.arrayTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "ArrowFunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.arrowFunctionExpression;
    }, "get")
  });
  Object.defineProperty(O, "AssignmentExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.assignmentExpression;
    }, "get")
  });
  Object.defineProperty(O, "AssignmentPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.assignmentPattern;
    }, "get")
  });
  Object.defineProperty(O, "AwaitExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.awaitExpression;
    }, "get")
  });
  Object.defineProperty(O, "BigIntLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.bigIntLiteral;
    }, "get")
  });
  Object.defineProperty(O, "BinaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.binaryExpression;
    }, "get")
  });
  Object.defineProperty(O, "BindExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.bindExpression;
    }, "get")
  });
  Object.defineProperty(O, "BlockStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.blockStatement;
    }, "get")
  });
  Object.defineProperty(O, "BooleanLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.booleanLiteral;
    }, "get")
  });
  Object.defineProperty(O, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.booleanLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.booleanTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "BreakStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.breakStatement;
    }, "get")
  });
  Object.defineProperty(O, "CallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.callExpression;
    }, "get")
  });
  Object.defineProperty(O, "CatchClause", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.catchClause;
    }, "get")
  });
  Object.defineProperty(O, "ClassAccessorProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classAccessorProperty;
    }, "get")
  });
  Object.defineProperty(O, "ClassBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classBody;
    }, "get")
  });
  Object.defineProperty(O, "ClassDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "ClassExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classExpression;
    }, "get")
  });
  Object.defineProperty(O, "ClassImplements", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classImplements;
    }, "get")
  });
  Object.defineProperty(O, "ClassMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classMethod;
    }, "get")
  });
  Object.defineProperty(O, "ClassPrivateMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classPrivateMethod;
    }, "get")
  });
  Object.defineProperty(O, "ClassPrivateProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classPrivateProperty;
    }, "get")
  });
  Object.defineProperty(O, "ClassProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classProperty;
    }, "get")
  });
  Object.defineProperty(O, "ConditionalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.conditionalExpression;
    }, "get")
  });
  Object.defineProperty(O, "ContinueStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.continueStatement;
    }, "get")
  });
  Object.defineProperty(O, "DebuggerStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.debuggerStatement;
    }, "get")
  });
  Object.defineProperty(O, "DecimalLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.decimalLiteral;
    }, "get")
  });
  Object.defineProperty(O, "DeclareClass", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareClass;
    }, "get")
  });
  Object.defineProperty(O, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareExportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "DeclareExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareExportDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "DeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareFunction;
    }, "get")
  });
  Object.defineProperty(O, "DeclareInterface", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareInterface;
    }, "get")
  });
  Object.defineProperty(O, "DeclareModule", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareModule;
    }, "get")
  });
  Object.defineProperty(O, "DeclareModuleExports", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareModuleExports;
    }, "get")
  });
  Object.defineProperty(O, "DeclareOpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareOpaqueType;
    }, "get")
  });
  Object.defineProperty(O, "DeclareTypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareTypeAlias;
    }, "get")
  });
  Object.defineProperty(O, "DeclareVariable", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareVariable;
    }, "get")
  });
  Object.defineProperty(O, "DeclaredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declaredPredicate;
    }, "get")
  });
  Object.defineProperty(O, "Decorator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.decorator;
    }, "get")
  });
  Object.defineProperty(O, "Directive", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.directive;
    }, "get")
  });
  Object.defineProperty(O, "DirectiveLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.directiveLiteral;
    }, "get")
  });
  Object.defineProperty(O, "DoExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.doExpression;
    }, "get")
  });
  Object.defineProperty(O, "DoWhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.doWhileStatement;
    }, "get")
  });
  Object.defineProperty(O, "EmptyStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.emptyStatement;
    }, "get")
  });
  Object.defineProperty(O, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.emptyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "EnumBooleanBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumBooleanBody;
    }, "get")
  });
  Object.defineProperty(O, "EnumBooleanMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumBooleanMember;
    }, "get")
  });
  Object.defineProperty(O, "EnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "EnumDefaultedMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumDefaultedMember;
    }, "get")
  });
  Object.defineProperty(O, "EnumNumberBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumNumberBody;
    }, "get")
  });
  Object.defineProperty(O, "EnumNumberMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumNumberMember;
    }, "get")
  });
  Object.defineProperty(O, "EnumStringBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumStringBody;
    }, "get")
  });
  Object.defineProperty(O, "EnumStringMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumStringMember;
    }, "get")
  });
  Object.defineProperty(O, "EnumSymbolBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumSymbolBody;
    }, "get")
  });
  Object.defineProperty(O, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.existsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "ExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.exportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.exportDefaultDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.exportDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(O, "ExportNamedDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.exportNamedDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.exportNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(O, "ExportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.exportSpecifier;
    }, "get")
  });
  Object.defineProperty(O, "ExpressionStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.expressionStatement;
    }, "get")
  });
  Object.defineProperty(O, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.file;
    }, "get")
  });
  Object.defineProperty(O, "ForInStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.forInStatement;
    }, "get")
  });
  Object.defineProperty(O, "ForOfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.forOfStatement;
    }, "get")
  });
  Object.defineProperty(O, "ForStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.forStatement;
    }, "get")
  });
  Object.defineProperty(O, "FunctionDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.functionDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "FunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.functionExpression;
    }, "get")
  });
  Object.defineProperty(O, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.functionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "FunctionTypeParam", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.functionTypeParam;
    }, "get")
  });
  Object.defineProperty(O, "GenericTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.genericTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.identifier;
    }, "get")
  });
  Object.defineProperty(O, "IfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.ifStatement;
    }, "get")
  });
  Object.defineProperty(O, "Import", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.import;
    }, "get")
  });
  Object.defineProperty(O, "ImportAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.importAttribute;
    }, "get")
  });
  Object.defineProperty(O, "ImportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.importDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.importDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(O, "ImportExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.importExpression;
    }, "get")
  });
  Object.defineProperty(O, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.importNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(O, "ImportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.importSpecifier;
    }, "get")
  });
  Object.defineProperty(O, "IndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.indexedAccessType;
    }, "get")
  });
  Object.defineProperty(O, "InferredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.inferredPredicate;
    }, "get")
  });
  Object.defineProperty(O, "InterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.interfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "InterfaceExtends", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.interfaceExtends;
    }, "get")
  });
  Object.defineProperty(O, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.interfaceTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "InterpreterDirective", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.interpreterDirective;
    }, "get")
  });
  Object.defineProperty(O, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.intersectionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "JSXAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxAttribute;
    }, "get")
  });
  Object.defineProperty(O, "JSXClosingElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxClosingElement;
    }, "get")
  });
  Object.defineProperty(O, "JSXClosingFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxClosingFragment;
    }, "get")
  });
  Object.defineProperty(O, "JSXElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxElement;
    }, "get")
  });
  Object.defineProperty(O, "JSXEmptyExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxEmptyExpression;
    }, "get")
  });
  Object.defineProperty(O, "JSXExpressionContainer", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxExpressionContainer;
    }, "get")
  });
  Object.defineProperty(O, "JSXFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxFragment;
    }, "get")
  });
  Object.defineProperty(O, "JSXIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxIdentifier;
    }, "get")
  });
  Object.defineProperty(O, "JSXMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxMemberExpression;
    }, "get")
  });
  Object.defineProperty(O, "JSXNamespacedName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxNamespacedName;
    }, "get")
  });
  Object.defineProperty(O, "JSXOpeningElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxOpeningElement;
    }, "get")
  });
  Object.defineProperty(O, "JSXOpeningFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxOpeningFragment;
    }, "get")
  });
  Object.defineProperty(O, "JSXSpreadAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxSpreadAttribute;
    }, "get")
  });
  Object.defineProperty(O, "JSXSpreadChild", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxSpreadChild;
    }, "get")
  });
  Object.defineProperty(O, "JSXText", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxText;
    }, "get")
  });
  Object.defineProperty(O, "LabeledStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.labeledStatement;
    }, "get")
  });
  Object.defineProperty(O, "LogicalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.logicalExpression;
    }, "get")
  });
  Object.defineProperty(O, "MemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.memberExpression;
    }, "get")
  });
  Object.defineProperty(O, "MetaProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.metaProperty;
    }, "get")
  });
  Object.defineProperty(O, "MixedTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.mixedTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "ModuleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.moduleExpression;
    }, "get")
  });
  Object.defineProperty(O, "NewExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.newExpression;
    }, "get")
  });
  Object.defineProperty(O, "Noop", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.noop;
    }, "get")
  });
  Object.defineProperty(O, "NullLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.nullLiteral;
    }, "get")
  });
  Object.defineProperty(O, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.nullLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "NullableTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.nullableTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "NumberLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.numberLiteral;
    }, "get")
  });
  Object.defineProperty(O, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.numberLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "NumberTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.numberTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "NumericLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.numericLiteral;
    }, "get")
  });
  Object.defineProperty(O, "ObjectExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectExpression;
    }, "get")
  });
  Object.defineProperty(O, "ObjectMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectMethod;
    }, "get")
  });
  Object.defineProperty(O, "ObjectPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectPattern;
    }, "get")
  });
  Object.defineProperty(O, "ObjectProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectProperty;
    }, "get")
  });
  Object.defineProperty(O, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectTypeCallProperty;
    }, "get")
  });
  Object.defineProperty(O, "ObjectTypeIndexer", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectTypeIndexer;
    }, "get")
  });
  Object.defineProperty(O, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectTypeInternalSlot;
    }, "get")
  });
  Object.defineProperty(O, "ObjectTypeProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectTypeProperty;
    }, "get")
  });
  Object.defineProperty(O, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectTypeSpreadProperty;
    }, "get")
  });
  Object.defineProperty(O, "OpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.opaqueType;
    }, "get")
  });
  Object.defineProperty(O, "OptionalCallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.optionalCallExpression;
    }, "get")
  });
  Object.defineProperty(O, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.optionalIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(O, "OptionalMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.optionalMemberExpression;
    }, "get")
  });
  Object.defineProperty(O, "ParenthesizedExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.parenthesizedExpression;
    }, "get")
  });
  Object.defineProperty(O, "PipelineBareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.pipelineBareFunction;
    }, "get")
  });
  Object.defineProperty(O, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.pipelinePrimaryTopicReference;
    }, "get")
  });
  Object.defineProperty(O, "PipelineTopicExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.pipelineTopicExpression;
    }, "get")
  });
  Object.defineProperty(O, "Placeholder", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.placeholder;
    }, "get")
  });
  Object.defineProperty(O, "PrivateName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.privateName;
    }, "get")
  });
  Object.defineProperty(O, "Program", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.program;
    }, "get")
  });
  Object.defineProperty(O, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.qualifiedTypeIdentifier;
    }, "get")
  });
  Object.defineProperty(O, "RecordExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.recordExpression;
    }, "get")
  });
  Object.defineProperty(O, "RegExpLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.regExpLiteral;
    }, "get")
  });
  Object.defineProperty(O, "RegexLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.regexLiteral;
    }, "get")
  });
  Object.defineProperty(O, "RestElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.restElement;
    }, "get")
  });
  Object.defineProperty(O, "RestProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.restProperty;
    }, "get")
  });
  Object.defineProperty(O, "ReturnStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.returnStatement;
    }, "get")
  });
  Object.defineProperty(O, "SequenceExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.sequenceExpression;
    }, "get")
  });
  Object.defineProperty(O, "SpreadElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.spreadElement;
    }, "get")
  });
  Object.defineProperty(O, "SpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.spreadProperty;
    }, "get")
  });
  Object.defineProperty(O, "StaticBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.staticBlock;
    }, "get")
  });
  Object.defineProperty(O, "StringLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.stringLiteral;
    }, "get")
  });
  Object.defineProperty(O, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.stringLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "StringTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.stringTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "Super", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.super;
    }, "get")
  });
  Object.defineProperty(O, "SwitchCase", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.switchCase;
    }, "get")
  });
  Object.defineProperty(O, "SwitchStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.switchStatement;
    }, "get")
  });
  Object.defineProperty(O, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.symbolTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "TSAnyKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsAnyKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSArrayType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsArrayType;
    }, "get")
  });
  Object.defineProperty(O, "TSAsExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsAsExpression;
    }, "get")
  });
  Object.defineProperty(O, "TSBigIntKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsBigIntKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSBooleanKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsBooleanKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsCallSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSConditionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsConditionalType;
    }, "get")
  });
  Object.defineProperty(O, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsConstructSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSConstructorType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsConstructorType;
    }, "get")
  });
  Object.defineProperty(O, "TSDeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsDeclareFunction;
    }, "get")
  });
  Object.defineProperty(O, "TSDeclareMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsDeclareMethod;
    }, "get")
  });
  Object.defineProperty(O, "TSEnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsEnumDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSEnumMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsEnumMember;
    }, "get")
  });
  Object.defineProperty(O, "TSExportAssignment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsExportAssignment;
    }, "get")
  });
  Object.defineProperty(O, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsExpressionWithTypeArguments;
    }, "get")
  });
  Object.defineProperty(O, "TSExternalModuleReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsExternalModuleReference;
    }, "get")
  });
  Object.defineProperty(O, "TSFunctionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsFunctionType;
    }, "get")
  });
  Object.defineProperty(O, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsImportEqualsDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSImportType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsImportType;
    }, "get")
  });
  Object.defineProperty(O, "TSIndexSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsIndexSignature;
    }, "get")
  });
  Object.defineProperty(O, "TSIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(O, "TSInferType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsInferType;
    }, "get")
  });
  Object.defineProperty(O, "TSInstantiationExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsInstantiationExpression;
    }, "get")
  });
  Object.defineProperty(O, "TSInterfaceBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsInterfaceBody;
    }, "get")
  });
  Object.defineProperty(O, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsInterfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSIntersectionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsIntersectionType;
    }, "get")
  });
  Object.defineProperty(O, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsIntrinsicKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsLiteralType;
    }, "get")
  });
  Object.defineProperty(O, "TSMappedType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsMappedType;
    }, "get")
  });
  Object.defineProperty(O, "TSMethodSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsMethodSignature;
    }, "get")
  });
  Object.defineProperty(O, "TSModuleBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsModuleBlock;
    }, "get")
  });
  Object.defineProperty(O, "TSModuleDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsModuleDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSNamedTupleMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsNamedTupleMember;
    }, "get")
  });
  Object.defineProperty(O, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsNamespaceExportDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSNeverKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsNeverKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSNonNullExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsNonNullExpression;
    }, "get")
  });
  Object.defineProperty(O, "TSNullKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsNullKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSNumberKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsNumberKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSObjectKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsObjectKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSOptionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsOptionalType;
    }, "get")
  });
  Object.defineProperty(O, "TSParameterProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsParameterProperty;
    }, "get")
  });
  Object.defineProperty(O, "TSParenthesizedType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsParenthesizedType;
    }, "get")
  });
  Object.defineProperty(O, "TSPropertySignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsPropertySignature;
    }, "get")
  });
  Object.defineProperty(O, "TSQualifiedName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsQualifiedName;
    }, "get")
  });
  Object.defineProperty(O, "TSRestType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsRestType;
    }, "get")
  });
  Object.defineProperty(O, "TSSatisfiesExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsSatisfiesExpression;
    }, "get")
  });
  Object.defineProperty(O, "TSStringKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsStringKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSSymbolKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsSymbolKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSThisType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsThisType;
    }, "get")
  });
  Object.defineProperty(O, "TSTupleType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTupleType;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeAliasDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeAssertion", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeAssertion;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeLiteral;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeOperator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeOperator;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeParameter;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(O, "TSTypePredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypePredicate;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeQuery", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeQuery;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeReference;
    }, "get")
  });
  Object.defineProperty(O, "TSUndefinedKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsUndefinedKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsUnionType;
    }, "get")
  });
  Object.defineProperty(O, "TSUnknownKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsUnknownKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSVoidKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsVoidKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TaggedTemplateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.taggedTemplateExpression;
    }, "get")
  });
  Object.defineProperty(O, "TemplateElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.templateElement;
    }, "get")
  });
  Object.defineProperty(O, "TemplateLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.templateLiteral;
    }, "get")
  });
  Object.defineProperty(O, "ThisExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.thisExpression;
    }, "get")
  });
  Object.defineProperty(O, "ThisTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.thisTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "ThrowStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.throwStatement;
    }, "get")
  });
  Object.defineProperty(O, "TopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.topicReference;
    }, "get")
  });
  Object.defineProperty(O, "TryStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tryStatement;
    }, "get")
  });
  Object.defineProperty(O, "TupleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tupleExpression;
    }, "get")
  });
  Object.defineProperty(O, "TupleTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tupleTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "TypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeAlias;
    }, "get")
  });
  Object.defineProperty(O, "TypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "TypeCastExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeCastExpression;
    }, "get")
  });
  Object.defineProperty(O, "TypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeParameter;
    }, "get")
  });
  Object.defineProperty(O, "TypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(O, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeofTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "UnaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.unaryExpression;
    }, "get")
  });
  Object.defineProperty(O, "UnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.unionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "UpdateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.updateExpression;
    }, "get")
  });
  Object.defineProperty(O, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.v8IntrinsicIdentifier;
    }, "get")
  });
  Object.defineProperty(O, "VariableDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.variableDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "VariableDeclarator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.variableDeclarator;
    }, "get")
  });
  Object.defineProperty(O, "Variance", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.variance;
    }, "get")
  });
  Object.defineProperty(O, "VoidTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.voidTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "WhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.whileStatement;
    }, "get")
  });
  Object.defineProperty(O, "WithStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.withStatement;
    }, "get")
  });
  Object.defineProperty(O, "YieldExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.yieldExpression;
    }, "get")
  });
  var D = Ar();
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/productions.js
var PI = w((bT) => {
  "use strict";
  Object.defineProperty(bT, "__esModule", {
    value: !0
  });
  bT.buildUndefinedNode = YCe;
  var gI = Ar();
  function YCe() {
    return (0, gI.unaryExpression)("void", (0, gI.numericLiteral)(0), !0);
  }
  n(YCe, "buildUndefinedNode");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/clone/cloneNode.js
var hi = w((xT) => {
  "use strict";
  Object.defineProperty(xT, "__esModule", {
    value: !0
  });
  xT.default = JCe;
  var EI = Vr(), AI = Rt(), {
    hasOwn: Ls
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function vI(t, e, r, s) {
    return t && typeof t.type == "string" ? II(t, e, r, s) : t;
  }
  n(vI, "cloneIfNode");
  function CI(t, e, r, s) {
    return Array.isArray(t) ? t.map((i) => vI(i, e, r, s)) : vI(t, e, r, s);
  }
  n(CI, "cloneIfNodeOrArray");
  function JCe(t, e = !0, r = !1) {
    return II(t, e, r, /* @__PURE__ */ new Map());
  }
  n(JCe, "cloneNode");
  function II(t, e = !0, r = !1, s) {
    if (!t) return t;
    let {
      type: i
    } = t, a = {
      type: t.type
    };
    if ((0, AI.isIdentifier)(t))
      a.name = t.name, Ls(t, "optional") && typeof t.optional == "boolean" && (a.optional = t.optional), Ls(t, "typeAnnotation") && (a.typeAnnotation =
      e ? CI(t.typeAnnotation, !0, r, s) : t.typeAnnotation);
    else if (Ls(EI.NODE_FIELDS, i))
      for (let o of Object.keys(EI.NODE_FIELDS[i]))
        Ls(t, o) && (e ? a[o] = (0, AI.isFile)(t) && o === "comments" ? Sc(t.comments, e, r, s) : CI(t[o], !0, r, s) : a[o] = t[o]);
    else
      throw new Error(`Unknown node type: "${i}"`);
    return Ls(t, "loc") && (r ? a.loc = null : a.loc = t.loc), Ls(t, "leadingComments") && (a.leadingComments = Sc(t.leadingComments, e, r, s)),
    Ls(t, "innerComments") && (a.innerComments = Sc(t.innerComments, e, r, s)), Ls(t, "trailingComments") && (a.trailingComments = Sc(t.trailingComments,
    e, r, s)), Ls(t, "extra") && (a.extra = Object.assign({}, t.extra)), a;
  }
  n(II, "cloneNodeInternal");
  function Sc(t, e, r, s) {
    return !t || !e ? t : t.map((i) => {
      let a = s.get(i);
      if (a) return a;
      let {
        type: o,
        value: l,
        loc: u
      } = i, c = {
        type: o,
        value: l,
        loc: u
      };
      return r && (c.loc = null), s.set(i, c), c;
    });
  }
  n(Sc, "maybeCloneComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/clone/clone.js
var wI = w((ST) => {
  "use strict";
  Object.defineProperty(ST, "__esModule", {
    value: !0
  });
  ST.default = $Ce;
  var XCe = hi();
  function $Ce(t) {
    return (0, XCe.default)(t, !1);
  }
  n($Ce, "clone");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/clone/cloneDeep.js
var NI = w((gT) => {
  "use strict";
  Object.defineProperty(gT, "__esModule", {
    value: !0
  });
  gT.default = zCe;
  var HCe = hi();
  function zCe(t) {
    return (0, HCe.default)(t);
  }
  n(zCe, "cloneDeep");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var OI = w((PT) => {
  "use strict";
  Object.defineProperty(PT, "__esModule", {
    value: !0
  });
  PT.default = QCe;
  var GCe = hi();
  function QCe(t) {
    return (0, GCe.default)(t, !0, !0);
  }
  n(QCe, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var kI = w((ET) => {
  "use strict";
  Object.defineProperty(ET, "__esModule", {
    value: !0
  });
  ET.default = eIe;
  var ZCe = hi();
  function eIe(t) {
    return (0, ZCe.default)(t, !1, !0);
  }
  n(eIe, "cloneWithoutLoc");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/addComments.js
var vT = w((AT) => {
  "use strict";
  Object.defineProperty(AT, "__esModule", {
    value: !0
  });
  AT.default = tIe;
  function tIe(t, e, r) {
    if (!r || !t) return t;
    let s = `${e}Comments`;
    return t[s] ? e === "leading" ? t[s] = r.concat(t[s]) : t[s].push(...r) : t[s] = r, t;
  }
  n(tIe, "addComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/addComment.js
var DI = w((CT) => {
  "use strict";
  Object.defineProperty(CT, "__esModule", {
    value: !0
  });
  CT.default = sIe;
  var rIe = vT();
  function sIe(t, e, r, s) {
    return (0, rIe.default)(t, e, [{
      type: s ? "CommentLine" : "CommentBlock",
      value: r
    }]);
  }
  n(sIe, "addComment");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/utils/inherit.js
var gc = w((IT) => {
  "use strict";
  Object.defineProperty(IT, "__esModule", {
    value: !0
  });
  IT.default = iIe;
  function iIe(t, e, r) {
    e && r && (e[t] = Array.from(new Set([].concat(e[t], r[t]).filter(Boolean))));
  }
  n(iIe, "inherit");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/inheritInnerComments.js
var NT = w((wT) => {
  "use strict";
  Object.defineProperty(wT, "__esModule", {
    value: !0
  });
  wT.default = aIe;
  var nIe = gc();
  function aIe(t, e) {
    (0, nIe.default)("innerComments", t, e);
  }
  n(aIe, "inheritInnerComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var kT = w((OT) => {
  "use strict";
  Object.defineProperty(OT, "__esModule", {
    value: !0
  });
  OT.default = lIe;
  var oIe = gc();
  function lIe(t, e) {
    (0, oIe.default)("leadingComments", t, e);
  }
  n(lIe, "inheritLeadingComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var _T = w((DT) => {
  "use strict";
  Object.defineProperty(DT, "__esModule", {
    value: !0
  });
  DT.default = cIe;
  var uIe = gc();
  function cIe(t, e) {
    (0, uIe.default)("trailingComments", t, e);
  }
  n(cIe, "inheritTrailingComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/inheritsComments.js
var MT = w((LT) => {
  "use strict";
  Object.defineProperty(LT, "__esModule", {
    value: !0
  });
  LT.default = dIe;
  var pIe = _T(), fIe = kT(), hIe = NT();
  function dIe(t, e) {
    return (0, pIe.default)(t, e), (0, fIe.default)(t, e), (0, hIe.default)(t, e), t;
  }
  n(dIe, "inheritsComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/removeComments.js
var _I = w((BT) => {
  "use strict";
  Object.defineProperty(BT, "__esModule", {
    value: !0
  });
  BT.default = yIe;
  var mIe = ci();
  function yIe(t) {
    return mIe.COMMENT_KEYS.forEach((e) => {
      t[e] = null;
    }), t;
  }
  n(yIe, "removeComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/constants/generated/index.js
var LI = w((z) => {
  "use strict";
  Object.defineProperty(z, "__esModule", {
    value: !0
  });
  z.WHILE_TYPES = z.USERWHITESPACABLE_TYPES = z.UNARYLIKE_TYPES = z.TYPESCRIPT_TYPES = z.TSTYPE_TYPES = z.TSTYPEELEMENT_TYPES = z.TSENTITYNAME_TYPES =
  z.TSBASETYPE_TYPES = z.TERMINATORLESS_TYPES = z.STATEMENT_TYPES = z.STANDARDIZED_TYPES = z.SCOPABLE_TYPES = z.PUREISH_TYPES = z.PROPERTY_TYPES =
  z.PRIVATE_TYPES = z.PATTERN_TYPES = z.PATTERNLIKE_TYPES = z.OBJECTMEMBER_TYPES = z.MODULESPECIFIER_TYPES = z.MODULEDECLARATION_TYPES = z.MISCELLANEOUS_TYPES =
  z.METHOD_TYPES = z.LVAL_TYPES = z.LOOP_TYPES = z.LITERAL_TYPES = z.JSX_TYPES = z.IMPORTOREXPORTDECLARATION_TYPES = z.IMMUTABLE_TYPES = z.FUNCTION_TYPES =
  z.FUNCTIONPARENT_TYPES = z.FOR_TYPES = z.FORXSTATEMENT_TYPES = z.FLOW_TYPES = z.FLOWTYPE_TYPES = z.FLOWPREDICATE_TYPES = z.FLOWDECLARATION_TYPES =
  z.FLOWBASEANNOTATION_TYPES = z.EXPRESSION_TYPES = z.EXPRESSIONWRAPPER_TYPES = z.EXPORTDECLARATION_TYPES = z.ENUMMEMBER_TYPES = z.ENUMBODY_TYPES =
  z.DECLARATION_TYPES = z.CONDITIONAL_TYPES = z.COMPLETIONSTATEMENT_TYPES = z.CLASS_TYPES = z.BLOCK_TYPES = z.BLOCKPARENT_TYPES = z.BINARY_TYPES =
  z.ACCESSOR_TYPES = void 0;
  var je = Vr(), u9e = z.STANDARDIZED_TYPES = je.FLIPPED_ALIAS_KEYS.Standardized, c9e = z.EXPRESSION_TYPES = je.FLIPPED_ALIAS_KEYS.Expression,
  p9e = z.BINARY_TYPES = je.FLIPPED_ALIAS_KEYS.Binary, f9e = z.SCOPABLE_TYPES = je.FLIPPED_ALIAS_KEYS.Scopable, h9e = z.BLOCKPARENT_TYPES = je.
  FLIPPED_ALIAS_KEYS.BlockParent, d9e = z.BLOCK_TYPES = je.FLIPPED_ALIAS_KEYS.Block, m9e = z.STATEMENT_TYPES = je.FLIPPED_ALIAS_KEYS.Statement,
  y9e = z.TERMINATORLESS_TYPES = je.FLIPPED_ALIAS_KEYS.Terminatorless, T9e = z.COMPLETIONSTATEMENT_TYPES = je.FLIPPED_ALIAS_KEYS.CompletionStatement,
  b9e = z.CONDITIONAL_TYPES = je.FLIPPED_ALIAS_KEYS.Conditional, x9e = z.LOOP_TYPES = je.FLIPPED_ALIAS_KEYS.Loop, S9e = z.WHILE_TYPES = je.FLIPPED_ALIAS_KEYS.
  While, g9e = z.EXPRESSIONWRAPPER_TYPES = je.FLIPPED_ALIAS_KEYS.ExpressionWrapper, P9e = z.FOR_TYPES = je.FLIPPED_ALIAS_KEYS.For, E9e = z.FORXSTATEMENT_TYPES =
  je.FLIPPED_ALIAS_KEYS.ForXStatement, A9e = z.FUNCTION_TYPES = je.FLIPPED_ALIAS_KEYS.Function, v9e = z.FUNCTIONPARENT_TYPES = je.FLIPPED_ALIAS_KEYS.
  FunctionParent, C9e = z.PUREISH_TYPES = je.FLIPPED_ALIAS_KEYS.Pureish, I9e = z.DECLARATION_TYPES = je.FLIPPED_ALIAS_KEYS.Declaration, w9e = z.
  PATTERNLIKE_TYPES = je.FLIPPED_ALIAS_KEYS.PatternLike, N9e = z.LVAL_TYPES = je.FLIPPED_ALIAS_KEYS.LVal, O9e = z.TSENTITYNAME_TYPES = je.FLIPPED_ALIAS_KEYS.
  TSEntityName, k9e = z.LITERAL_TYPES = je.FLIPPED_ALIAS_KEYS.Literal, D9e = z.IMMUTABLE_TYPES = je.FLIPPED_ALIAS_KEYS.Immutable, _9e = z.USERWHITESPACABLE_TYPES =
  je.FLIPPED_ALIAS_KEYS.UserWhitespacable, L9e = z.METHOD_TYPES = je.FLIPPED_ALIAS_KEYS.Method, M9e = z.OBJECTMEMBER_TYPES = je.FLIPPED_ALIAS_KEYS.
  ObjectMember, B9e = z.PROPERTY_TYPES = je.FLIPPED_ALIAS_KEYS.Property, F9e = z.UNARYLIKE_TYPES = je.FLIPPED_ALIAS_KEYS.UnaryLike, j9e = z.
  PATTERN_TYPES = je.FLIPPED_ALIAS_KEYS.Pattern, R9e = z.CLASS_TYPES = je.FLIPPED_ALIAS_KEYS.Class, TIe = z.IMPORTOREXPORTDECLARATION_TYPES =
  je.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration, U9e = z.EXPORTDECLARATION_TYPES = je.FLIPPED_ALIAS_KEYS.ExportDeclaration, q9e = z.MODULESPECIFIER_TYPES =
  je.FLIPPED_ALIAS_KEYS.ModuleSpecifier, V9e = z.ACCESSOR_TYPES = je.FLIPPED_ALIAS_KEYS.Accessor, K9e = z.PRIVATE_TYPES = je.FLIPPED_ALIAS_KEYS.
  Private, W9e = z.FLOW_TYPES = je.FLIPPED_ALIAS_KEYS.Flow, Y9e = z.FLOWTYPE_TYPES = je.FLIPPED_ALIAS_KEYS.FlowType, J9e = z.FLOWBASEANNOTATION_TYPES =
  je.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, X9e = z.FLOWDECLARATION_TYPES = je.FLIPPED_ALIAS_KEYS.FlowDeclaration, $9e = z.FLOWPREDICATE_TYPES =
  je.FLIPPED_ALIAS_KEYS.FlowPredicate, H9e = z.ENUMBODY_TYPES = je.FLIPPED_ALIAS_KEYS.EnumBody, z9e = z.ENUMMEMBER_TYPES = je.FLIPPED_ALIAS_KEYS.
  EnumMember, G9e = z.JSX_TYPES = je.FLIPPED_ALIAS_KEYS.JSX, Q9e = z.MISCELLANEOUS_TYPES = je.FLIPPED_ALIAS_KEYS.Miscellaneous, Z9e = z.TYPESCRIPT_TYPES =
  je.FLIPPED_ALIAS_KEYS.TypeScript, e7e = z.TSTYPEELEMENT_TYPES = je.FLIPPED_ALIAS_KEYS.TSTypeElement, t7e = z.TSTYPE_TYPES = je.FLIPPED_ALIAS_KEYS.
  TSType, r7e = z.TSBASETYPE_TYPES = je.FLIPPED_ALIAS_KEYS.TSBaseType, s7e = z.MODULEDECLARATION_TYPES = TIe;
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toBlock.js
var RT = w((jT) => {
  "use strict";
  Object.defineProperty(jT, "__esModule", {
    value: !0
  });
  jT.default = bIe;
  var Pc = Rt(), FT = Ar();
  function bIe(t, e) {
    if ((0, Pc.isBlockStatement)(t))
      return t;
    let r = [];
    return (0, Pc.isEmptyStatement)(t) ? r = [] : ((0, Pc.isStatement)(t) || ((0, Pc.isFunction)(e) ? t = (0, FT.returnStatement)(t) : t = (0, FT.
    expressionStatement)(t)), r = [t]), (0, FT.blockStatement)(r);
  }
  n(bIe, "toBlock");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/ensureBlock.js
var MI = w((UT) => {
  "use strict";
  Object.defineProperty(UT, "__esModule", {
    value: !0
  });
  UT.default = SIe;
  var xIe = RT();
  function SIe(t, e = "body") {
    let r = (0, xIe.default)(t[e], t);
    return t[e] = r, r;
  }
  n(SIe, "ensureBlock");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toIdentifier.js
var VT = w((qT) => {
  "use strict";
  Object.defineProperty(qT, "__esModule", {
    value: !0
  });
  qT.default = EIe;
  var gIe = Jn(), PIe = Wa();
  function EIe(t) {
    t = t + "";
    let e = "";
    for (let r of t)
      e += (0, PIe.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return e = e.replace(/^[-0-9]+/, ""), e = e.replace(/[-\s]+(.)?/g, function(r, s) {
      return s ? s.toUpperCase() : "";
    }), (0, gIe.default)(e) || (e = `_${e}`), e || "_";
  }
  n(EIe, "toIdentifier");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var BI = w((KT) => {
  "use strict";
  Object.defineProperty(KT, "__esModule", {
    value: !0
  });
  KT.default = vIe;
  var AIe = VT();
  function vIe(t) {
    return t = (0, AIe.default)(t), (t === "eval" || t === "arguments") && (t = "_" + t), t;
  }
  n(vIe, "toBindingIdentifierName");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toComputedKey.js
var FI = w((WT) => {
  "use strict";
  Object.defineProperty(WT, "__esModule", {
    value: !0
  });
  WT.default = wIe;
  var CIe = Rt(), IIe = Ar();
  function wIe(t, e = t.key || t.property) {
    return !t.computed && (0, CIe.isIdentifier)(e) && (e = (0, IIe.stringLiteral)(e.name)), e;
  }
  n(wIe, "toComputedKey");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toExpression.js
var jI = w((Ec) => {
  "use strict";
  Object.defineProperty(Ec, "__esModule", {
    value: !0
  });
  Ec.default = void 0;
  var Mo = Rt(), m7e = Ec.default = NIe;
  function NIe(t) {
    if ((0, Mo.isExpressionStatement)(t) && (t = t.expression), (0, Mo.isExpression)(t))
      return t;
    if ((0, Mo.isClass)(t) ? t.type = "ClassExpression" : (0, Mo.isFunction)(t) && (t.type = "FunctionExpression"), !(0, Mo.isExpression)(t))
      throw new Error(`cannot turn ${t.type} to an expression`);
    return t;
  }
  n(NIe, "toExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/traverse/traverseFast.js
var XT = w((JT) => {
  "use strict";
  Object.defineProperty(JT, "__esModule", {
    value: !0
  });
  JT.default = YT;
  var OIe = Vr();
  function YT(t, e, r) {
    if (!t) return;
    let s = OIe.VISITOR_KEYS[t.type];
    if (s) {
      r = r || {}, e(t, r);
      for (let i of s) {
        let a = t[i];
        if (Array.isArray(a))
          for (let o of a)
            YT(o, e, r);
        else
          YT(a, e, r);
      }
    }
  }
  n(YT, "traverseFast");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/removeProperties.js
var HT = w(($T) => {
  "use strict";
  Object.defineProperty($T, "__esModule", {
    value: !0
  });
  $T.default = _Ie;
  var kIe = ci(), RI = ["tokens", "start", "end", "loc", "raw", "rawValue"], DIe = [...kIe.COMMENT_KEYS, "comments", ...RI];
  function _Ie(t, e = {}) {
    let r = e.preserveComments ? RI : DIe;
    for (let i of r)
      t[i] != null && (t[i] = void 0);
    for (let i of Object.keys(t))
      i[0] === "_" && t[i] != null && (t[i] = void 0);
    let s = Object.getOwnPropertySymbols(t);
    for (let i of s)
      t[i] = null;
  }
  n(_Ie, "removeProperties");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var GT = w((zT) => {
  "use strict";
  Object.defineProperty(zT, "__esModule", {
    value: !0
  });
  zT.default = BIe;
  var LIe = XT(), MIe = HT();
  function BIe(t, e) {
    return (0, LIe.default)(t, MIe.default, e), t;
  }
  n(BIe, "removePropertiesDeep");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toKeyAlias.js
var qI = w((QT) => {
  "use strict";
  Object.defineProperty(QT, "__esModule", {
    value: !0
  });
  QT.default = Gi;
  var UI = Rt(), FIe = hi(), jIe = GT();
  function Gi(t, e = t.key) {
    let r;
    return t.kind === "method" ? Gi.increment() + "" : ((0, UI.isIdentifier)(e) ? r = e.name : (0, UI.isStringLiteral)(e) ? r = JSON.stringify(
    e.value) : r = JSON.stringify((0, jIe.default)((0, FIe.default)(e))), t.computed && (r = `[${r}]`), t.static && (r = `static:${r}`), r);
  }
  n(Gi, "toKeyAlias");
  Gi.uid = 0;
  Gi.increment = function() {
    return Gi.uid >= Number.MAX_SAFE_INTEGER ? Gi.uid = 0 : Gi.uid++;
  };
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toStatement.js
var VI = w((vc) => {
  "use strict";
  Object.defineProperty(vc, "__esModule", {
    value: !0
  });
  vc.default = void 0;
  var Ac = Rt(), RIe = Ar(), C7e = vc.default = UIe;
  function UIe(t, e) {
    if ((0, Ac.isStatement)(t))
      return t;
    let r = !1, s;
    if ((0, Ac.isClass)(t))
      r = !0, s = "ClassDeclaration";
    else if ((0, Ac.isFunction)(t))
      r = !0, s = "FunctionDeclaration";
    else if ((0, Ac.isAssignmentExpression)(t))
      return (0, RIe.expressionStatement)(t);
    if (r && !t.id && (s = !1), !s) {
      if (e)
        return !1;
      throw new Error(`cannot turn ${t.type} to a statement`);
    }
    return t.type = s, t;
  }
  n(UIe, "toStatement");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/valueToNode.js
var KI = w((Cc) => {
  "use strict";
  Object.defineProperty(Cc, "__esModule", {
    value: !0
  });
  Cc.default = void 0;
  var qIe = Jn(), nr = Ar(), N7e = Cc.default = ZT, VIe = Function.call.bind(Object.prototype.toString);
  function KIe(t) {
    return VIe(t) === "[object RegExp]";
  }
  n(KIe, "isRegExp");
  function WIe(t) {
    if (typeof t != "object" || t === null || Object.prototype.toString.call(t) !== "[object Object]")
      return !1;
    let e = Object.getPrototypeOf(t);
    return e === null || Object.getPrototypeOf(e) === null;
  }
  n(WIe, "isPlainObject");
  function ZT(t) {
    if (t === void 0)
      return (0, nr.identifier)("undefined");
    if (t === !0 || t === !1)
      return (0, nr.booleanLiteral)(t);
    if (t === null)
      return (0, nr.nullLiteral)();
    if (typeof t == "string")
      return (0, nr.stringLiteral)(t);
    if (typeof t == "number") {
      let e;
      if (Number.isFinite(t))
        e = (0, nr.numericLiteral)(Math.abs(t));
      else {
        let r;
        Number.isNaN(t) ? r = (0, nr.numericLiteral)(0) : r = (0, nr.numericLiteral)(1), e = (0, nr.binaryExpression)("/", r, (0, nr.numericLiteral)(
        0));
      }
      return (t < 0 || Object.is(t, -0)) && (e = (0, nr.unaryExpression)("-", e)), e;
    }
    if (KIe(t)) {
      let e = t.source, r = t.toString().match(/\/([a-z]+|)$/)[1];
      return (0, nr.regExpLiteral)(e, r);
    }
    if (Array.isArray(t))
      return (0, nr.arrayExpression)(t.map(ZT));
    if (WIe(t)) {
      let e = [];
      for (let r of Object.keys(t)) {
        let s;
        (0, qIe.default)(r) ? s = (0, nr.identifier)(r) : s = (0, nr.stringLiteral)(r), e.push((0, nr.objectProperty)(s, ZT(t[r])));
      }
      return (0, nr.objectExpression)(e);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  n(ZT, "valueToNode");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var WI = w((e0) => {
  "use strict";
  Object.defineProperty(e0, "__esModule", {
    value: !0
  });
  e0.default = JIe;
  var YIe = Ar();
  function JIe(t, e, r = !1) {
    return t.object = (0, YIe.memberExpression)(t.object, t.property, t.computed), t.property = e, t.computed = !!r, t;
  }
  n(JIe, "appendToMemberExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/inherits.js
var JI = w((t0) => {
  "use strict";
  Object.defineProperty(t0, "__esModule", {
    value: !0
  });
  t0.default = $Ie;
  var YI = ci(), XIe = MT();
  function $Ie(t, e) {
    if (!t || !e) return t;
    for (let r of YI.INHERIT_KEYS.optional)
      t[r] == null && (t[r] = e[r]);
    for (let r of Object.keys(e))
      r[0] === "_" && r !== "__clone" && (t[r] = e[r]);
    for (let r of YI.INHERIT_KEYS.force)
      t[r] = e[r];
    return (0, XIe.default)(t, e), t;
  }
  n($Ie, "inherits");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var XI = w((r0) => {
  "use strict";
  Object.defineProperty(r0, "__esModule", {
    value: !0
  });
  r0.default = GIe;
  var HIe = Ar(), zIe = ko();
  function GIe(t, e) {
    if ((0, zIe.isSuper)(t.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return t.object = (0, HIe.memberExpression)(e, t.object), t;
  }
  n(GIe, "prependToMemberExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var Bo = w((i0) => {
  "use strict";
  Object.defineProperty(i0, "__esModule", {
    value: !0
  });
  i0.default = s0;
  var di = Rt();
  function s0(t, e, r, s) {
    let i = [].concat(t), a = /* @__PURE__ */ Object.create(null);
    for (; i.length; ) {
      let o = i.shift();
      if (!o || s && ((0, di.isAssignmentExpression)(o) || (0, di.isUnaryExpression)(o)))
        continue;
      let l = s0.keys[o.type];
      if ((0, di.isIdentifier)(o)) {
        e ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, di.isExportDeclaration)(o) && !(0, di.isExportAllDeclaration)(o)) {
        (0, di.isDeclaration)(o.declaration) && i.push(o.declaration);
        continue;
      }
      if (r) {
        if ((0, di.isFunctionDeclaration)(o)) {
          i.push(o.id);
          continue;
        }
        if ((0, di.isFunctionExpression)(o))
          continue;
      }
      if (l)
        for (let u = 0; u < l.length; u++) {
          let c = l[u], p = o[c];
          p && (Array.isArray(p) ? i.push(...p) : i.push(p));
        }
    }
    return a;
  }
  n(s0, "getBindingIdentifiers");
  s0.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var $I = w((Ic) => {
  "use strict";
  Object.defineProperty(Ic, "__esModule", {
    value: !0
  });
  Ic.default = void 0;
  var QIe = Bo(), U7e = Ic.default = ZIe;
  function ZIe(t, e) {
    return (0, QIe.default)(t, e, !0);
  }
  n(ZIe, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/traverse/traverse.js
var HI = w((a0) => {
  "use strict";
  Object.defineProperty(a0, "__esModule", {
    value: !0
  });
  a0.default = twe;
  var ewe = Vr();
  function twe(t, e, r) {
    typeof e == "function" && (e = {
      enter: e
    });
    let {
      enter: s,
      exit: i
    } = e;
    n0(t, s, i, r, []);
  }
  n(twe, "traverse");
  function n0(t, e, r, s, i) {
    let a = ewe.VISITOR_KEYS[t.type];
    if (a) {
      e && e(t, i, s);
      for (let o of a) {
        let l = t[o];
        if (Array.isArray(l))
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c && (i.push({
              node: t,
              key: o,
              index: u
            }), n0(c, e, r, s, i), i.pop());
          }
        else l && (i.push({
          node: t,
          key: o
        }), n0(l, e, r, s, i), i.pop());
      }
      r && r(t, i, s);
    }
  }
  n(n0, "traverseSimpleImpl");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isBinding.js
var zI = w((o0) => {
  "use strict";
  Object.defineProperty(o0, "__esModule", {
    value: !0
  });
  o0.default = swe;
  var rwe = Bo();
  function swe(t, e, r) {
    if (r && t.type === "Identifier" && e.type === "ObjectProperty" && r.type === "ObjectExpression")
      return !1;
    let s = rwe.default.keys[e.type];
    if (s)
      for (let i = 0; i < s.length; i++) {
        let a = s[i], o = e[a];
        if (Array.isArray(o)) {
          if (o.indexOf(t) >= 0) return !0;
        } else if (o === t) return !0;
      }
    return !1;
  }
  n(swe, "isBinding");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isLet.js
var u0 = w((l0) => {
  "use strict";
  Object.defineProperty(l0, "__esModule", {
    value: !0
  });
  l0.default = awe;
  var iwe = Rt(), nwe = ci();
  function awe(t) {
    return (0, iwe.isVariableDeclaration)(t) && (t.kind !== "var" || t[nwe.BLOCK_SCOPED_SYMBOL]);
  }
  n(awe, "isLet");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isBlockScoped.js
var QI = w((c0) => {
  "use strict";
  Object.defineProperty(c0, "__esModule", {
    value: !0
  });
  c0.default = lwe;
  var GI = Rt(), owe = u0();
  function lwe(t) {
    return (0, GI.isFunctionDeclaration)(t) || (0, GI.isClassDeclaration)(t) || (0, owe.default)(t);
  }
  n(lwe, "isBlockScoped");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isImmutable.js
var ZI = w((p0) => {
  "use strict";
  Object.defineProperty(p0, "__esModule", {
    value: !0
  });
  p0.default = pwe;
  var uwe = lc(), cwe = Rt();
  function pwe(t) {
    return (0, uwe.default)(t.type, "Immutable") ? !0 : (0, cwe.isIdentifier)(t) ? t.name === "undefined" : !1;
  }
  n(pwe, "isImmutable");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var tw = w((h0) => {
  "use strict";
  Object.defineProperty(h0, "__esModule", {
    value: !0
  });
  h0.default = f0;
  var ew = Vr();
  function f0(t, e) {
    if (typeof t != "object" || typeof e != "object" || t == null || e == null)
      return t === e;
    if (t.type !== e.type)
      return !1;
    let r = Object.keys(ew.NODE_FIELDS[t.type] || t.type), s = ew.VISITOR_KEYS[t.type];
    for (let i of r) {
      let a = t[i], o = e[i];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let l = 0; l < a.length; l++)
            if (!f0(a[l], o[l]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(s != null && s.includes(i))) {
          for (let l of Object.keys(a))
            if (a[l] !== o[l])
              return !1;
          continue;
        }
        if (!f0(a, o))
          return !1;
      }
    }
    return !0;
  }
  n(f0, "isNodesEquivalent");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isReferenced.js
var rw = w((d0) => {
  "use strict";
  Object.defineProperty(d0, "__esModule", {
    value: !0
  });
  d0.default = fwe;
  function fwe(t, e, r) {
    switch (e.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return e.property === t ? !!e.computed : e.object === t;
      case "JSXMemberExpression":
        return e.object === t;
      case "VariableDeclarator":
        return e.init === t;
      case "ArrowFunctionExpression":
        return e.body === t;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return e.key === t ? !!e.computed : !1;
      case "ObjectProperty":
        return e.key === t ? !!e.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return e.key === t ? !!e.computed : !0;
      case "ClassPrivateProperty":
        return e.key !== t;
      case "ClassDeclaration":
      case "ClassExpression":
        return e.superClass === t;
      case "AssignmentExpression":
        return e.right === t;
      case "AssignmentPattern":
        return e.right === t;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return r != null && r.source ? !1 : e.local === t;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return e.key !== t;
      case "TSEnumMember":
        return e.id !== t;
      case "TSPropertySignature":
        return e.key === t ? !!e.computed : !0;
    }
    return !0;
  }
  n(fwe, "isReferenced");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isScope.js
var sw = w((m0) => {
  "use strict";
  Object.defineProperty(m0, "__esModule", {
    value: !0
  });
  m0.default = hwe;
  var Qi = Rt();
  function hwe(t, e) {
    return (0, Qi.isBlockStatement)(t) && ((0, Qi.isFunction)(e) || (0, Qi.isCatchClause)(e)) ? !1 : (0, Qi.isPattern)(t) && ((0, Qi.isFunction)(
    e) || (0, Qi.isCatchClause)(e)) ? !0 : (0, Qi.isScopable)(t);
  }
  n(hwe, "isScope");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var nw = w((y0) => {
  "use strict";
  Object.defineProperty(y0, "__esModule", {
    value: !0
  });
  y0.default = dwe;
  var iw = Rt();
  function dwe(t) {
    return (0, iw.isImportDefaultSpecifier)(t) || (0, iw.isIdentifier)(t.imported || t.exported, {
      name: "default"
    });
  }
  n(dwe, "isSpecifierDefault");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var aw = w((T0) => {
  "use strict";
  Object.defineProperty(T0, "__esModule", {
    value: !0
  });
  T0.default = Twe;
  var mwe = Jn(), ywe = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "impleme\
nts", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "trans\
ient", "volatile"]);
  function Twe(t) {
    return (0, mwe.default)(t) && !ywe.has(t);
  }
  n(Twe, "isValidES3Identifier");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isVar.js
var ow = w((b0) => {
  "use strict";
  Object.defineProperty(b0, "__esModule", {
    value: !0
  });
  b0.default = Swe;
  var bwe = Rt(), xwe = ci();
  function Swe(t) {
    return (0, bwe.isVariableDeclaration)(t, {
      kind: "var"
    }) && !t[xwe.BLOCK_SCOPED_SYMBOL];
  }
  n(Swe, "isVar");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var lw = w((S0) => {
  "use strict";
  Object.defineProperty(S0, "__esModule", {
    value: !0
  });
  S0.default = wc;
  var gwe = Bo(), Zi = Rt(), x0 = Ar(), Pwe = hi();
  function wc(t, e, r) {
    let s = [], i = !0;
    for (let a of t)
      if ((0, Zi.isEmptyStatement)(a) || (i = !1), (0, Zi.isExpression)(a))
        s.push(a);
      else if ((0, Zi.isExpressionStatement)(a))
        s.push(a.expression);
      else if ((0, Zi.isVariableDeclaration)(a)) {
        if (a.kind !== "var") return;
        for (let o of a.declarations) {
          let l = (0, gwe.default)(o);
          for (let u of Object.keys(l))
            r.push({
              kind: a.kind,
              id: (0, Pwe.default)(l[u])
            });
          o.init && s.push((0, x0.assignmentExpression)("=", o.id, o.init));
        }
        i = !0;
      } else if ((0, Zi.isIfStatement)(a)) {
        let o = a.consequent ? wc([a.consequent], e, r) : e.buildUndefinedNode(), l = a.alternate ? wc([a.alternate], e, r) : e.buildUndefinedNode();
        if (!o || !l) return;
        s.push((0, x0.conditionalExpression)(a.test, o, l));
      } else if ((0, Zi.isBlockStatement)(a)) {
        let o = wc(a.body, e, r);
        if (!o) return;
        s.push(o);
      } else if ((0, Zi.isEmptyStatement)(a))
        t.indexOf(a) === 0 && (i = !0);
      else
        return;
    return i && s.push(e.buildUndefinedNode()), s.length === 1 ? s[0] : (0, x0.sequenceExpression)(s);
  }
  n(wc, "gatherSequenceExpressions");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toSequenceExpression.js
var uw = w((g0) => {
  "use strict";
  Object.defineProperty(g0, "__esModule", {
    value: !0
  });
  g0.default = Awe;
  var Ewe = lw();
  function Awe(t, e) {
    if (!(t != null && t.length)) return;
    let r = [], s = (0, Ewe.default)(t, e, r);
    if (s) {
      for (let i of r)
        e.push(i);
      return s;
    }
  }
  n(Awe, "toSequenceExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/index.js
var ko = w((se) => {
  "use strict";
  Object.defineProperty(se, "__esModule", {
    value: !0
  });
  var Ms = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(se, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return CNe.default;
    }, "get")
  });
  Object.defineProperty(se, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Bwe.default;
    }, "get")
  });
  Object.defineProperty(se, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Fwe.default;
    }, "get")
  });
  Object.defineProperty(se, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qwe.default;
    }, "get")
  });
  Object.defineProperty(se, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return wwe.default;
    }, "get")
  });
  Object.defineProperty(se, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return vNe.default;
    }, "get")
  });
  Object.defineProperty(se, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Dwe.default;
    }, "get")
  });
  Object.defineProperty(se, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return _we.default;
    }, "get")
  });
  Object.defineProperty(se, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Lwe.default;
    }, "get")
  });
  Object.defineProperty(se, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return kwe.default;
    }, "get")
  });
  Object.defineProperty(se, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Mwe.default;
    }, "get")
  });
  Object.defineProperty(se, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return cw.default;
    }, "get")
  });
  Object.defineProperty(se, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Owe.default;
    }, "get")
  });
  Object.defineProperty(se, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Nwe.default;
    }, "get")
  });
  Object.defineProperty(se, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return cw.default;
    }, "get")
  });
  Object.defineProperty(se, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Kwe.default;
    }, "get")
  });
  Object.defineProperty(se, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return iNe.default;
    }, "get")
  });
  Object.defineProperty(se, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return nNe.default;
    }, "get")
  });
  Object.defineProperty(se, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return jwe.default;
    }, "get")
  });
  Object.defineProperty(se, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Rwe.default;
    }, "get")
  });
  Object.defineProperty(se, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return qwe.default;
    }, "get")
  });
  Object.defineProperty(se, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Zwe.default;
    }, "get")
  });
  Object.defineProperty(se, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Uwe.default;
    }, "get")
  });
  Object.defineProperty(se, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return lNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return uNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return cNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return pNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return fNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return hNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return dNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return mNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return yNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return TNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return bNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return xNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return SNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return gNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return PNe.default;
    }, "get")
  });
  Object.defineProperty(se, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ENe.default;
    }, "get")
  });
  Object.defineProperty(se, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return eNe.default;
    }, "get")
  });
  se.react = void 0;
  Object.defineProperty(se, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Vwe.default;
    }, "get")
  });
  Object.defineProperty(se, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return tNe.default;
    }, "get")
  });
  Object.defineProperty(se, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return rNe.default;
    }, "get")
  });
  Object.defineProperty(se, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return sNe.default;
    }, "get")
  });
  Object.defineProperty(se, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return oNe.default;
    }, "get")
  });
  Object.defineProperty(se, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Wwe.default;
    }, "get")
  });
  Object.defineProperty(se, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ywe.default;
    }, "get")
  });
  Object.defineProperty(se, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Jwe.default;
    }, "get")
  });
  Object.defineProperty(se, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Xwe.default;
    }, "get")
  });
  Object.defineProperty(se, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $we.default;
    }, "get")
  });
  Object.defineProperty(se, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Hwe.default;
    }, "get")
  });
  Object.defineProperty(se, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return zwe.default;
    }, "get")
  });
  Object.defineProperty(se, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Nc.default;
    }, "get")
  });
  Object.defineProperty(se, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return aNe.default;
    }, "get")
  });
  Object.defineProperty(se, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ANe.default;
    }, "get")
  });
  Object.defineProperty(se, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Gwe.default;
    }, "get")
  });
  var vwe = vC(), Cwe = CC(), Iwe = uI(), wwe = cI(), P0 = pI();
  Object.keys(P0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ms, t) || t in se && se[t] === P0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return P0[t];
      }, "get")
    });
  });
  var Nwe = fI(), cw = mI(), Owe = xI(), E0 = Ar();
  Object.keys(E0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ms, t) || t in se && se[t] === E0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return E0[t];
      }, "get")
    });
  });
  var A0 = SI();
  Object.keys(A0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ms, t) || t in se && se[t] === A0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return A0[t];
      }, "get")
    });
  });
  var v0 = PI();
  Object.keys(v0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ms, t) || t in se && se[t] === v0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return v0[t];
      }, "get")
    });
  });
  var kwe = hi(), Dwe = wI(), _we = NI(), Lwe = OI(), Mwe = kI(), Bwe = DI(), Fwe = vT(), jwe = NT(), Rwe = kT(), Uwe = MT(), qwe = _T(), Vwe = _I(),
  C0 = LI();
  Object.keys(C0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ms, t) || t in se && se[t] === C0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return C0[t];
      }, "get")
    });
  });
  var I0 = ci();
  Object.keys(I0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ms, t) || t in se && se[t] === I0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return I0[t];
      }, "get")
    });
  });
  var Kwe = MI(), Wwe = BI(), Ywe = RT(), Jwe = FI(), Xwe = jI(), $we = VT(), Hwe = qI(), zwe = VI(), Gwe = KI(), w0 = Vr();
  Object.keys(w0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ms, t) || t in se && se[t] === w0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return w0[t];
      }, "get")
    });
  });
  var Qwe = WI(), Zwe = JI(), eNe = XI(), tNe = HT(), rNe = GT(), sNe = dT(), iNe = Bo(), nNe = $I(), Nc = HI();
  Object.keys(Nc).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ms, t) || t in se && se[t] === Nc[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Nc[t];
      }, "get")
    });
  });
  var aNe = XT(), oNe = ac(), lNe = Yn(), uNe = zI(), cNe = QI(), pNe = ZI(), fNe = u0(), hNe = pT(), dNe = tw(), mNe = Vy(), yNe = rw(), TNe = sw(),
  bNe = nw(), xNe = lc(), SNe = aw(), gNe = Jn(), PNe = ow(), ENe = By(), ANe = hc(), vNe = jy(), N0 = Rt();
  Object.keys(N0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ms, t) || t in se && se[t] === N0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return N0[t];
      }, "get")
    });
  });
  var CNe = Ao(), mUe = se.react = {
    isReactComponent: vwe.default,
    isCompatTag: Cwe.default,
    buildChildren: Iwe.default
  };
  se.toSequenceExpression = uw().default;
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/lib/index.js
var yw = w((O0) => {
  "use strict";
  Object.defineProperty(O0, "__esModule", {
    value: !0
  });
  O0.default = XNe;
  var dw = PC(), INe = ko(), {
    NOT_LOCAL_BINDING: pw,
    cloneNode: wNe,
    identifier: NNe,
    isAssignmentExpression: ONe,
    isAssignmentPattern: kNe,
    isFunction: mw,
    isIdentifier: fw,
    isLiteral: hw,
    isNullLiteral: DNe,
    isObjectMethod: _Ne,
    isObjectProperty: LNe,
    isRegExpLiteral: MNe,
    isRestElement: BNe,
    isTemplateLiteral: FNe,
    isVariableDeclarator: jNe,
    toBindingIdentifierName: RNe
  } = INe;
  function UNe(t) {
    let e = t.params.findIndex((r) => kNe(r) || BNe(r));
    return e === -1 ? t.params.length : e;
  }
  n(UNe, "getFunctionArity");
  var qNe = dw.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`), VNe = dw.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`), KNe = {
    "ReferencedIdentifier|BindingIdentifier"(t, e) {
      t.node.name !== e.name || t.scope.getBindingIdentifier(e.name) !== e.outerDeclar || (e.selfReference = !0, t.stop());
    }
  };
  function WNe(t) {
    return DNe(t) ? "null" : MNe(t) ? `_${t.pattern}_${t.flags}` : FNe(t) ? t.quasis.map((e) => e.value.raw).join("") : t.value !== void 0 ?
    t.value + "" : "";
  }
  n(WNe, "getNameFromLiteralId");
  function YNe(t, e, r, s) {
    if (t.selfReference)
      if (s.hasBinding(r.name) && !s.hasGlobal(r.name))
        s.rename(r.name);
      else {
        if (!mw(e)) return;
        let i = qNe;
        e.generator && (i = VNe);
        let a = i({
          FUNCTION: e,
          FUNCTION_ID: r,
          FUNCTION_KEY: s.generateUidIdentifier(r.name)
        }).expression, o = a.callee.body.body[0].params;
        for (let l = 0, u = UNe(e); l < u; l++)
          o.push(s.generateUidIdentifier("x"));
        return a;
      }
    e.id = r, s.getProgramParent().references[r.name] = !0;
  }
  n(YNe, "wrap");
  function JNe(t, e, r) {
    let s = {
      selfAssignment: !1,
      selfReference: !1,
      outerDeclar: r.getBindingIdentifier(e),
      name: e
    }, i = r.getOwnBinding(e);
    return i ? i.kind === "param" && (s.selfReference = !0) : (s.outerDeclar || r.hasGlobal(e)) && r.traverse(t, KNe, s), s;
  }
  n(JNe, "visit");
  function XNe({
    node: t,
    parent: e,
    scope: r,
    id: s
  }, i = !1, a = !1) {
    if (t.id) return;
    if ((LNe(e) || _Ne(e, {
      kind: "method"
    })) && (!e.computed || hw(e.key)))
      s = e.key;
    else if (jNe(e)) {
      if (s = e.id, fw(s) && !i) {
        let c = r.parent.getBinding(s.name);
        if (c && c.constant && r.getBinding(s.name) === c) {
          t.id = wNe(s), t.id[pw] = !0;
          return;
        }
      }
    } else if (ONe(e, {
      operator: "="
    }))
      s = e.left;
    else if (!s)
      return;
    let o;
    if (s && hw(s) ? o = WNe(s) : s && fw(s) && (o = s.name), o === void 0 || !a && mw(t) && /[\uD800-\uDFFF]/.test(o))
      return;
    o = RNe(o);
    let l = NNe(o);
    l[pw] = !0;
    let u = JNe(t, o, r);
    return YNe(u, t, l, r) || t;
  }
  n(XNe, "_default");
});

// ../node_modules/@babel/traverse/lib/path/conversion.js
var gw = w((tn) => {
  "use strict";
  Object.defineProperty(tn, "__esModule", {
    value: !0
  });
  tn.arrowFunctionToExpression = m2e;
  tn.ensureBlock = f2e;
  tn.toComputedKey = p2e;
  tn.unwrapFunctionEnvironment = h2e;
  var $Ne = Ce(), _0 = Xh(), HNe = yw(), L0 = Ma(), {
    arrowFunctionExpression: M0,
    assignmentExpression: en,
    binaryExpression: k0,
    blockStatement: zNe,
    callExpression: Hn,
    conditionalExpression: GNe,
    expressionStatement: Tw,
    identifier: kt,
    isIdentifier: QNe,
    jsxIdentifier: ZNe,
    logicalExpression: e2e,
    LOGICAL_OPERATORS: t2e,
    memberExpression: Zr,
    metaProperty: r2e,
    numericLiteral: s2e,
    objectExpression: i2e,
    restElement: n2e,
    returnStatement: a2e,
    sequenceExpression: o2e,
    spreadElement: l2e,
    stringLiteral: bw,
    super: D0,
    thisExpression: Fo,
    toExpression: u2e,
    unaryExpression: c2e
  } = $Ne;
  function p2e() {
    let t;
    if (this.isMemberExpression())
      t = this.node.property;
    else if (this.isProperty() || this.isMethod())
      t = this.node.key;
    else
      throw new ReferenceError("todo");
    return this.node.computed || QNe(t) && (t = bw(t.name)), t;
  }
  n(p2e, "toComputedKey");
  function f2e() {
    let t = this.get("body"), e = t.node;
    if (Array.isArray(t))
      throw new Error("Can't convert array path to a block statement");
    if (!e)
      throw new Error("Can't convert node without a body");
    if (t.isBlockStatement())
      return e;
    let r = [], s = "body", i, a;
    t.isStatement() ? (a = "body", i = 0, r.push(t.node)) : (s += ".body.0", this.isFunction() ? (i = "argument", r.push(a2e(t.node))) : (i =
    "expression", r.push(Tw(t.node)))), this.node.body = zNe(r);
    let o = this.get(s);
    return t.setup(o, a ? o.node[a] : o.node, a, i), this.node;
  }
  n(f2e, "ensureBlock");
  tn.arrowFunctionToShadowed = function() {
    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
  };
  function h2e() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    xw(this);
  }
  n(h2e, "unwrapFunctionEnvironment");
  function d2e(t, e) {
    t.node.type = e;
  }
  n(d2e, "setType");
  function m2e({
    allowInsertArrow: t = !0,
    allowInsertArrowWithRest: e = t,
    noNewArrows: r = !((s) => (s = arguments[0]) == null ? void 0 : s.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    let {
      thisBinding: s,
      fnPath: i
    } = xw(this, r, t, e);
    if (i.ensureBlock(), d2e(i, "FunctionExpression"), !r) {
      let a = s ? null : i.scope.generateUidIdentifier("arrowCheckId");
      return a && i.parentPath.scope.push({
        id: a,
        init: i2e([])
      }), i.get("body").unshiftContainer("body", Tw(Hn(this.hub.addHelper("newArrowCheck"), [Fo(), kt(a ? a.name : s)]))), i.replaceWith(Hn(
      Zr((0, HNe.default)(this, !0) || i.node, kt("bind")), [a ? kt(a.name) : Fo()])), i.get("callee.object");
    }
    return i;
  }
  n(m2e, "arrowFunctionToExpression");
  var y2e = (0, L0.merge)([{
    CallExpression(t, {
      allSuperCalls: e
    }) {
      t.get("callee").isSuper() && e.push(t);
    }
  }, _0.default]);
  function xw(t, e = !0, r = !0, s = !0) {
    let i, a = t.findParent((y) => {
      if (y.isArrowFunctionExpression()) {
        var T;
        return (T = i) != null || (i = y), !1;
      }
      return y.isFunction() || y.isProgram() || y.isClassProperty({
        static: !1
      }) || y.isClassPrivateProperty({
        static: !1
      });
    }), o = a.isClassMethod({
      kind: "constructor"
    });
    if (a.isClassProperty() || a.isClassPrivateProperty())
      if (i)
        a = i;
      else if (r)
        t.replaceWith(Hn(M0([], u2e(t.node)), [])), a = t.get("callee"), t = a.get("body");
      else
        throw t.buildCodeFrameError("Unable to transform arrow inside class property");
    let {
      thisPaths: l,
      argumentsPaths: u,
      newTargetPaths: c,
      superProps: p,
      superCalls: f
    } = A2e(t);
    if (o && f.length > 0) {
      if (!r)
        throw f[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an a\
rrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      if (!s)
        throw f[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow \
function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration\
.");
      let y = [];
      a.traverse(y2e, {
        allSuperCalls: y
      });
      let T = g2e(a);
      y.forEach((L) => {
        let q = kt(T);
        q.loc = L.node.callee.loc, L.get("callee").replaceWith(q);
      });
    }
    if (u.length > 0) {
      let y = jo(a, "arguments", () => {
        let T = /* @__PURE__ */ n(() => kt("arguments"), "args");
        return a.scope.path.isProgram() ? GNe(k0("===", c2e("typeof", T()), bw("undefined")), a.scope.buildUndefinedNode(), T()) : T();
      });
      u.forEach((T) => {
        let L = kt(y);
        L.loc = T.node.loc, T.replaceWith(L);
      });
    }
    if (c.length > 0) {
      let y = jo(a, "newtarget", () => r2e(kt("new"), kt("target")));
      c.forEach((T) => {
        let L = kt(y);
        L.loc = T.node.loc, T.replaceWith(L);
      });
    }
    if (p.length > 0) {
      if (!r)
        throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in a\
n arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      p.reduce((T, L) => T.concat(b2e(L)), []).forEach((T) => {
        let L = T.node.computed ? "" : T.get("property").node.name, q = T.parentPath, _ = q.isAssignmentExpression({
          left: T.node
        }), U = q.isCallExpression({
          callee: T.node
        }), J = q.isTaggedTemplateExpression({
          tag: T.node
        }), ie = P2e(a, _, L), de = [];
        if (T.node.computed && de.push(T.get("property").node), _) {
          let Be = q.node.right;
          de.push(Be);
        }
        let ne = Hn(kt(ie), de);
        U ? (q.unshiftContainer("arguments", Fo()), T.replaceWith(Zr(ne, kt("call"))), l.push(q.get("arguments.0"))) : _ ? q.replaceWith(ne) :
        J ? (T.replaceWith(Hn(Zr(ne, kt("bind"), !1), [Fo()])), l.push(T.get("arguments.0"))) : T.replaceWith(ne);
      });
    }
    let m;
    return (l.length > 0 || !e) && (m = S2e(a, o), (e || o && Sw(a)) && (l.forEach((y) => {
      let T = y.isJSX() ? ZNe(m) : kt(m);
      T.loc = y.node.loc, y.replaceWith(T);
    }), e || (m = null))), {
      thisBinding: m,
      fnPath: t
    };
  }
  n(xw, "hoistFunctionEnvironment");
  function T2e(t) {
    return t2e.includes(t);
  }
  n(T2e, "isLogicalOp");
  function b2e(t) {
    if (t.parentPath.isAssignmentExpression() && t.parentPath.node.operator !== "=") {
      let r = t.parentPath, s = r.node.operator.slice(0, -1), i = r.node.right, a = T2e(s);
      if (t.node.computed) {
        let o = t.scope.generateDeclaredUidIdentifier("tmp"), l = t.node.object, u = t.node.property;
        r.get("left").replaceWith(Zr(l, en("=", o, u), !0)), r.get("right").replaceWith(e(a ? "=" : s, Zr(l, kt(o.name), !0), i));
      } else {
        let o = t.node.object, l = t.node.property;
        r.get("left").replaceWith(Zr(o, l)), r.get("right").replaceWith(e(a ? "=" : s, Zr(o, kt(l.name)), i));
      }
      return a ? r.replaceWith(e2e(s, r.node.left, r.node.right)) : r.node.operator = "=", [r.get("left"), r.get("right").get("left")];
    } else if (t.parentPath.isUpdateExpression()) {
      let r = t.parentPath, s = t.scope.generateDeclaredUidIdentifier("tmp"), i = t.node.computed ? t.scope.generateDeclaredUidIdentifier("p\
rop") : null, a = [en("=", s, Zr(t.node.object, i ? en("=", i, t.node.property) : t.node.property, t.node.computed)), en("=", Zr(t.node.object,
      i ? kt(i.name) : t.node.property, t.node.computed), k0(t.parentPath.node.operator[0], kt(s.name), s2e(1)))];
      t.parentPath.node.prefix || a.push(kt(s.name)), r.replaceWith(o2e(a));
      let o = r.get("expressions.0.right"), l = r.get("expressions.1.left");
      return [o, l];
    }
    return [t];
    function e(r, s, i) {
      return r === "=" ? en("=", s, i) : k0(r, s, i);
    }
  }
  n(b2e, "standardizeSuperProperty");
  function Sw(t) {
    return t.isClassMethod() && !!t.parentPath.parentPath.node.superClass;
  }
  n(Sw, "hasSuperClass");
  var x2e = (0, L0.merge)([{
    CallExpression(t, {
      supers: e,
      thisBinding: r
    }) {
      t.get("callee").isSuper() && (e.has(t.node) || (e.add(t.node), t.replaceWithMultiple([t.node, en("=", kt(r), kt("this"))])));
    }
  }, _0.default]);
  function S2e(t, e) {
    return jo(t, "this", (r) => {
      if (!e || !Sw(t)) return Fo();
      t.traverse(x2e, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding: r
      });
    });
  }
  n(S2e, "getThisBinding");
  function g2e(t) {
    return jo(t, "supercall", () => {
      let e = t.scope.generateUidIdentifier("args");
      return M0([n2e(e)], Hn(D0(), [l2e(kt(e.name))]));
    });
  }
  n(g2e, "getSuperBinding");
  function P2e(t, e, r) {
    return jo(t, `superprop_${e ? "set" : "get"}:${r || ""}`, () => {
      let i = [], a;
      if (r)
        a = Zr(D0(), kt(r));
      else {
        let o = t.scope.generateUidIdentifier("prop");
        i.unshift(o), a = Zr(D0(), kt(o.name), !0);
      }
      if (e) {
        let o = t.scope.generateUidIdentifier("value");
        i.push(o), a = en("=", a, kt(o.name));
      }
      return M0(i, a);
    });
  }
  n(P2e, "getSuperPropBinding");
  function jo(t, e, r) {
    let s = "binding:" + e, i = t.getData(s);
    if (!i) {
      let a = t.scope.generateUidIdentifier(e);
      i = a.name, t.setData(s, i), t.scope.push({
        id: a,
        init: r(i)
      });
    }
    return i;
  }
  n(jo, "getBinding");
  var E2e = (0, L0.merge)([{
    ThisExpression(t, {
      thisPaths: e
    }) {
      e.push(t);
    },
    JSXIdentifier(t, {
      thisPaths: e
    }) {
      t.node.name === "this" && (!t.parentPath.isJSXMemberExpression({
        object: t.node
      }) && !t.parentPath.isJSXOpeningElement({
        name: t.node
      }) || e.push(t));
    },
    CallExpression(t, {
      superCalls: e
    }) {
      t.get("callee").isSuper() && e.push(t);
    },
    MemberExpression(t, {
      superProps: e
    }) {
      t.get("object").isSuper() && e.push(t);
    },
    Identifier(t, {
      argumentsPaths: e
    }) {
      if (!t.isReferencedIdentifier({
        name: "arguments"
      })) return;
      let r = t.scope;
      do {
        if (r.hasOwnBinding("arguments")) {
          r.rename("arguments");
          return;
        }
        if (r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
      } while (r = r.parent);
      e.push(t);
    },
    MetaProperty(t, {
      newTargetPaths: e
    }) {
      t.get("meta").isIdentifier({
        name: "new"
      }) && t.get("property").isIdentifier({
        name: "target"
      }) && e.push(t);
    }
  }, _0.default]);
  function A2e(t) {
    let e = [], r = [], s = [], i = [], a = [];
    return t.traverse(E2e, {
      thisPaths: e,
      argumentsPaths: r,
      newTargetPaths: s,
      superProps: i,
      superCalls: a
    }), {
      thisPaths: e,
      argumentsPaths: r,
      newTargetPaths: s,
      superProps: i,
      superCalls: a
    };
  }
  n(A2e, "getScopeInformation");
});

// ../node_modules/@babel/traverse/lib/path/introspection.js
var Iw = w((Bt) => {
  "use strict";
  Object.defineProperty(Bt, "__esModule", {
    value: !0
  });
  Bt._guessExecutionStatusRelativeTo = X2e;
  Bt._resolve = G2e;
  Bt.canHaveVariableDeclarationOrExpression = R2e;
  Bt.canSwapBetweenExpressionAndStatement = U2e;
  Bt.equals = F2e;
  Bt.getSource = W2e;
  Bt.has = Cw;
  Bt.is = void 0;
  Bt.isCompletionRecord = q2e;
  Bt.isConstantExpression = Q2e;
  Bt.isInStrictMode = Z2e;
  Bt.isNodeType = j2e;
  Bt.isStatementOrBlock = V2e;
  Bt.isStatic = M2e;
  Bt.isnt = B2e;
  Bt.matchesPattern = L2e;
  Bt.referencesImport = K2e;
  Bt.resolve = z2e;
  Bt.willIMaybeExecuteBefore = Y2e;
  var v2e = Ce(), {
    STATEMENT_OR_BLOCK_KEYS: C2e,
    VISITOR_KEYS: I2e,
    isBlockStatement: vw,
    isExpression: w2e,
    isIdentifier: N2e,
    isLiteral: O2e,
    isStringLiteral: k2e,
    isType: D2e,
    matchesPattern: _2e
  } = v2e;
  function L2e(t, e) {
    return _2e(this.node, t, e);
  }
  n(L2e, "matchesPattern");
  function Cw(t) {
    let e = this.node && this.node[t];
    return e && Array.isArray(e) ? !!e.length : !!e;
  }
  n(Cw, "has");
  function M2e() {
    return this.scope.isStatic(this.node);
  }
  n(M2e, "isStatic");
  var PUe = Bt.is = Cw;
  function B2e(t) {
    return !this.has(t);
  }
  n(B2e, "isnt");
  function F2e(t, e) {
    return this.node[t] === e;
  }
  n(F2e, "equals");
  function j2e(t) {
    return D2e(this.type, t);
  }
  n(j2e, "isNodeType");
  function R2e() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  n(R2e, "canHaveVariableDeclarationOrExpression");
  function U2e(t) {
    return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? vw(t) : this.isBlockStatement() ?
    w2e(t) : !1;
  }
  n(U2e, "canSwapBetweenExpressionAndStatement");
  function q2e(t) {
    let e = this, r = !0;
    do {
      let {
        type: s,
        container: i
      } = e;
      if (!r && (e.isFunction() || s === "StaticBlock"))
        return !!t;
      if (r = !1, Array.isArray(i) && e.key !== i.length - 1)
        return !1;
    } while ((e = e.parentPath) && !e.isProgram() && !e.isDoExpression());
    return !0;
  }
  n(q2e, "isCompletionRecord");
  function V2e() {
    return this.parentPath.isLabeledStatement() || vw(this.container) ? !1 : C2e.includes(this.key);
  }
  n(V2e, "isStatementOrBlock");
  function K2e(t, e) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === e || (this.isMemberExpression() || this.isOptionalMemberExpression()) &&
      (this.node.computed ? k2e(this.node.property, {
        value: e
      }) : this.node.property.name === e)) {
        let a = this.get("object");
        return a.isReferencedIdentifier() && a.referencesImport(t, "*");
      }
      return !1;
    }
    let r = this.scope.getBinding(this.node.name);
    if (!r || r.kind !== "module") return !1;
    let s = r.path, i = s.parentPath;
    if (!i.isImportDeclaration()) return !1;
    if (i.node.source.value === t) {
      if (!e) return !0;
    } else
      return !1;
    return !!(s.isImportDefaultSpecifier() && e === "default" || s.isImportNamespaceSpecifier() && e === "*" || s.isImportSpecifier() && N2e(
    s.node.imported, {
      name: e
    }));
  }
  n(K2e, "referencesImport");
  function W2e() {
    let t = this.node;
    if (t.end) {
      let e = this.hub.getCode();
      if (e) return e.slice(t.start, t.end);
    }
    return "";
  }
  n(W2e, "getSource");
  function Y2e(t) {
    return this._guessExecutionStatusRelativeTo(t) !== "after";
  }
  n(Y2e, "willIMaybeExecuteBefore");
  function Pw(t) {
    return t.isProgram() ? t : (t.parentPath.scope.getFunctionParent() || t.parentPath.scope.getProgramParent()).path;
  }
  n(Pw, "getOuterFunction");
  function J2e(t, e) {
    switch (t) {
      case "LogicalExpression":
        return e === "right";
      case "ConditionalExpression":
      case "IfStatement":
        return e === "consequent" || e === "alternate";
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return e === "body";
      case "ForStatement":
        return e === "body" || e === "update";
      case "SwitchStatement":
        return e === "cases";
      case "TryStatement":
        return e === "handler";
      case "AssignmentPattern":
        return e === "right";
      case "OptionalMemberExpression":
        return e === "property";
      case "OptionalCallExpression":
        return e === "arguments";
      default:
        return !1;
    }
  }
  n(J2e, "isExecutionUncertain");
  function Ew(t, e) {
    for (let r = 0; r < e; r++) {
      let s = t[r];
      if (J2e(s.parent.type, s.parentKey))
        return !0;
    }
    return !1;
  }
  n(Ew, "isExecutionUncertainInList");
  var Aw = Symbol();
  function X2e(t) {
    return B0(this, t, /* @__PURE__ */ new Map());
  }
  n(X2e, "_guessExecutionStatusRelativeTo");
  function B0(t, e, r) {
    let s = {
      this: Pw(t),
      target: Pw(e)
    };
    if (s.target.node !== s.this.node)
      return H2e(t, s.target, r);
    let i = {
      target: e.getAncestry(),
      this: t.getAncestry()
    };
    if (i.target.indexOf(t) >= 0) return "after";
    if (i.this.indexOf(e) >= 0) return "before";
    let a, o = {
      target: 0,
      this: 0
    };
    for (; !a && o.this < i.this.length; ) {
      let p = i.this[o.this];
      o.target = i.target.indexOf(p), o.target >= 0 ? a = p : o.this++;
    }
    if (!a)
      throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (Ew(i.this, o.this - 1) || Ew(i.target, o.target - 1))
      return "unknown";
    let l = {
      this: i.this[o.this - 1],
      target: i.target[o.target - 1]
    };
    if (l.target.listKey && l.this.listKey && l.target.container === l.this.container)
      return l.target.key > l.this.key ? "before" : "after";
    let u = I2e[a.type], c = {
      this: u.indexOf(l.this.parentKey),
      target: u.indexOf(l.target.parentKey)
    };
    return c.target > c.this ? "before" : "after";
  }
  n(B0, "_guessExecutionStatusRelativeToCached");
  function $2e(t, e, r) {
    if (e.isFunctionDeclaration()) {
      if (e.parentPath.isExportDeclaration())
        return "unknown";
    } else return B0(t, e, r) === "before" ? "before" : "unknown";
    let s = e.scope.getBinding(e.node.id.name);
    if (!s.references) return "before";
    let i = s.referencePaths, a;
    for (let o of i) {
      if (!!o.find((c) => c.node === e.node)) continue;
      if (o.key !== "callee" || !o.parentPath.isCallExpression())
        return "unknown";
      let u = B0(t, o, r);
      if (a && a !== u)
        return "unknown";
      a = u;
    }
    return a;
  }
  n($2e, "_guessExecutionStatusRelativeToDifferentFunctionsInternal");
  function H2e(t, e, r) {
    let s = r.get(t.node), i;
    if (!s)
      r.set(t.node, s = /* @__PURE__ */ new Map());
    else if (i = s.get(e.node))
      return i === Aw ? "unknown" : i;
    s.set(e.node, Aw);
    let a = $2e(t, e, r);
    return s.set(e.node, a), a;
  }
  n(H2e, "_guessExecutionStatusRelativeToDifferentFunctionsCached");
  function z2e(t, e) {
    return this._resolve(t, e) || this;
  }
  n(z2e, "resolve");
  function G2e(t, e) {
    if (!(e && e.indexOf(this) >= 0))
      if (e = e || [], e.push(this), this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier())
          return this.get("init").resolve(t, e);
      } else if (this.isReferencedIdentifier()) {
        let r = this.scope.getBinding(this.node.name);
        if (!r || !r.constant || r.kind === "module") return;
        if (r.path !== this) {
          let s = r.path.resolve(t, e);
          return this.find((i) => i.node === s.node) ? void 0 : s;
        }
      } else {
        if (this.isTypeCastExpression())
          return this.get("expression").resolve(t, e);
        if (t && this.isMemberExpression()) {
          let r = this.toComputedKey();
          if (!O2e(r)) return;
          let s = r.value, i = this.get("object").resolve(t, e);
          if (i.isObjectExpression()) {
            let a = i.get("properties");
            for (let o of a) {
              if (!o.isProperty()) continue;
              let l = o.get("key"), u = o.isnt("computed") && l.isIdentifier({
                name: s
              });
              if (u = u || l.isLiteral({
                value: s
              }), u) return o.get("value").resolve(t, e);
            }
          } else if (i.isArrayExpression() && !isNaN(+s)) {
            let o = i.get("elements")[s];
            if (o) return o.resolve(t, e);
          }
        }
      }
  }
  n(G2e, "_resolve");
  function Q2e() {
    if (this.isIdentifier()) {
      let t = this.scope.getBinding(this.node.name);
      return t ? t.constant : !1;
    }
    if (this.isLiteral())
      return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((t) => t.isConstantExpression()) : !0;
    if (this.isUnaryExpression())
      return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
    if (this.isBinaryExpression()) {
      let {
        operator: t
      } = this.node;
      return t !== "in" && t !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
      name: "Symbol"
    }) && !this.scope.hasBinding("Symbol", {
      noGlobals: !0
    }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding(
    "Symbol", {
      noGlobals: !0
    }) && this.get("arguments")[0].isStringLiteral() : !1;
  }
  n(Q2e, "isConstantExpression");
  function Z2e() {
    return !!(this.isProgram() ? this : this.parentPath).find((r) => {
      if (r.isProgram({
        sourceType: "module"
      }) || r.isClass()) return !0;
      if (r.isArrowFunctionExpression() && !r.get("body").isBlockStatement())
        return !1;
      let s;
      if (r.isFunction())
        s = r.node.body;
      else if (r.isProgram())
        s = r.node;
      else
        return !1;
      for (let i of s.directives)
        if (i.value.value === "use strict")
          return !0;
    });
  }
  n(Z2e, "isInStrictMode");
});

// ../node_modules/@babel/traverse/lib/path/context.js
var Ow = w((Lt) => {
  "use strict";
  Object.defineProperty(Lt, "__esModule", {
    value: !0
  });
  Lt._call = rOe;
  Lt._getQueueContexts = SOe;
  Lt._resyncKey = fOe;
  Lt._resyncList = hOe;
  Lt._resyncParent = pOe;
  Lt._resyncRemoved = dOe;
  Lt.call = tOe;
  Lt.isBlacklisted = Lt.isDenylisted = sOe;
  Lt.popContext = mOe;
  Lt.pushContext = yOe;
  Lt.requeue = xOe;
  Lt.resync = cOe;
  Lt.setContext = uOe;
  Lt.setKey = bOe;
  Lt.setScope = lOe;
  Lt.setup = TOe;
  Lt.skip = nOe;
  Lt.skipKey = aOe;
  Lt.stop = oOe;
  Lt.visit = iOe;
  var eOe = ru(), ww = ai();
  function tOe(t) {
    let e = this.opts;
    if (this.debug(t), this.node && this._call(e[t]))
      return !0;
    if (this.node) {
      var r;
      return this._call((r = e[this.node.type]) == null ? void 0 : r[t]);
    }
    return !1;
  }
  n(tOe, "call");
  function rOe(t) {
    if (!t) return !1;
    for (let e of t) {
      if (!e) continue;
      let r = this.node;
      if (!r) return !0;
      let s = e.call(this.state, this, this.state);
      if (s && typeof s == "object" && typeof s.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not suppo\
rt. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (s)
        throw new Error(`Unexpected return value from visitor method ${e}`);
      if (this.node !== r || this._traverseFlags > 0) return !0;
    }
    return !1;
  }
  n(rOe, "_call");
  function sOe() {
    var t;
    let e = (t = this.opts.denylist) != null ? t : this.opts.blacklist;
    return e && e.indexOf(this.node.type) > -1;
  }
  n(sOe, "isDenylisted");
  function Nw(t, e) {
    t.context !== e && (t.context = e, t.state = e.state, t.opts = e.opts);
  }
  n(Nw, "restoreContext");
  function iOe() {
    var t, e;
    if (!this.node || this.isDenylisted() || (t = (e = this.opts).shouldSkip) != null && t.call(e, this))
      return !1;
    let r = this.context;
    return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (Nw(this, r), this.debug("Recursing into..."),
    this.shouldStop = (0, eOe.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), Nw(this, r), this.call("exit"),
    this.shouldStop);
  }
  n(iOe, "visit");
  function nOe() {
    this.shouldSkip = !0;
  }
  n(nOe, "skip");
  function aOe(t) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[t] = !0;
  }
  n(aOe, "skipKey");
  function oOe() {
    this._traverseFlags |= ww.SHOULD_SKIP | ww.SHOULD_STOP;
  }
  n(oOe, "stop");
  function lOe() {
    var t, e;
    if ((t = this.opts) != null && t.noScope) return;
    let r = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && r.isMethod() || this.key === "discriminant" && r.isSwitchStatement()) && (r = r.
    parentPath);
    let s;
    for (; r && !s; ) {
      var i;
      if ((i = r.opts) != null && i.noScope) return;
      s = r.scope, r = r.parentPath;
    }
    this.scope = this.getScope(s), (e = this.scope) == null || e.init();
  }
  n(lOe, "setScope");
  function uOe(t) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, t && (this.context = t, this.state = t.state, this.opts =
    t.opts), this.setScope(), this;
  }
  n(uOe, "setContext");
  function cOe() {
    this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
  }
  n(cOe, "resync");
  function pOe() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  n(pOe, "_resyncParent");
  function fOe() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let t = 0; t < this.container.length; t++)
          if (this.container[t] === this.node) {
            this.setKey(t);
            return;
          }
      } else
        for (let t of Object.keys(this.container))
          if (this.container[t] === this.node) {
            this.setKey(t);
            return;
          }
      this.key = null;
    }
  }
  n(fOe, "_resyncKey");
  function hOe() {
    if (!this.parent || !this.inList) return;
    let t = this.parent[this.listKey];
    this.container !== t && (this.container = t || null);
  }
  n(hOe, "_resyncList");
  function dOe() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && this._markRemoved();
  }
  n(dOe, "_resyncRemoved");
  function mOe() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  n(mOe, "popContext");
  function yOe(t) {
    this.contexts.push(t), this.setContext(t);
  }
  n(yOe, "pushContext");
  function TOe(t, e, r, s) {
    this.listKey = r, this.container = e, this.parentPath = t || this.parentPath, this.setKey(s);
  }
  n(TOe, "setup");
  function bOe(t) {
    var e;
    this.key = t, this.node = this.container[this.key], this.type = (e = this.node) == null ? void 0 : e.type;
  }
  n(bOe, "setKey");
  function xOe(t = this) {
    if (t.removed) return;
    let e = this.contexts;
    for (let r of e)
      r.maybeQueue(t);
  }
  n(xOe, "requeue");
  function SOe() {
    let t = this, e = this.contexts;
    for (; !e.length && (t = t.parentPath, !!t); )
      e = t.contexts;
    return e;
  }
  n(SOe, "_getQueueContexts");
});

// ../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var kw = w((Oc) => {
  "use strict";
  Object.defineProperty(Oc, "__esModule", {
    value: !0
  });
  Oc.hooks = void 0;
  var IUe = Oc.hooks = [function(t, e) {
    if (t.key === "test" && (e.isWhile() || e.isSwitchCase()) || t.key === "declaration" && e.isExportDeclaration() || t.key === "body" && e.
    isLabeledStatement() || t.listKey === "declarations" && e.isVariableDeclaration() && e.node.declarations.length === 1 || t.key === "expr\
ession" && e.isExpressionStatement())
      return e.remove(), !0;
  }, function(t, e) {
    if (e.isSequenceExpression() && e.node.expressions.length === 1)
      return e.replaceWith(e.node.expressions[0]), !0;
  }, function(t, e) {
    if (e.isBinary())
      return t.key === "left" ? e.replaceWith(e.node.right) : e.replaceWith(e.node.left), !0;
  }, function(t, e) {
    if (e.isIfStatement() && t.key === "consequent" || t.key === "body" && (e.isLoop() || e.isArrowFunctionExpression()))
      return t.replaceWith({
        type: "BlockStatement",
        body: []
      }), !0;
  }];
});

// ../node_modules/@babel/traverse/lib/path/removal.js
var _w = w((mi) => {
  "use strict";
  Object.defineProperty(mi, "__esModule", {
    value: !0
  });
  mi._assertUnremoved = OOe;
  mi._callRemovalHooks = IOe;
  mi._markRemoved = NOe;
  mi._remove = wOe;
  mi._removeFromScope = COe;
  mi.remove = vOe;
  var gOe = kw(), POe = Mi(), Dw = ai(), EOe = Ce(), {
    getBindingIdentifiers: AOe
  } = EOe;
  function vOe() {
    var t;
    if (this._assertUnremoved(), this.resync(), (t = this.opts) != null && t.noScope || this._removeFromScope(), this._callRemovalHooks()) {
      this._markRemoved();
      return;
    }
    this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
  }
  n(vOe, "remove");
  function COe() {
    let t = AOe(this.node, !1, !1, !0);
    Object.keys(t).forEach((e) => this.scope.removeBinding(e));
  }
  n(COe, "_removeFromScope");
  function IOe() {
    if (this.parentPath) {
      for (let t of gOe.hooks)
        if (t(this, this.parentPath)) return !0;
    }
  }
  n(IOe, "_callRemovalHooks");
  function wOe() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
  }
  n(wOe, "_remove");
  function NOe() {
    this._traverseFlags |= Dw.SHOULD_SKIP | Dw.REMOVED, this.parent && (0, POe.getCachedPaths)(this.hub, this.parent).delete(this.node), this.
    node = null;
  }
  n(NOe, "_markRemoved");
  function OOe() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  n(OOe, "_assertUnremoved");
});

// ../node_modules/@babel/traverse/lib/path/lib/hoister.js
var Mw = w((kc) => {
  "use strict";
  Object.defineProperty(kc, "__esModule", {
    value: !0
  });
  kc.default = void 0;
  var Lw = Ce(), kOe = Lw, {
    react: DOe
  } = Lw, {
    cloneNode: _Oe,
    jsxExpressionContainer: LOe,
    variableDeclaration: MOe,
    variableDeclarator: BOe
  } = kOe, FOe = {
    ReferencedIdentifier(t, e) {
      if (t.isJSXIdentifier() && DOe.isCompatTag(t.node.name) && !t.parentPath.isJSXMemberExpression())
        return;
      if (t.node.name === "this") {
        let s = t.scope;
        do
          if (s.path.isFunction() && !s.path.isArrowFunctionExpression())
            break;
        while (s = s.parent);
        s && e.breakOnScopePaths.push(s.path);
      }
      let r = t.scope.getBinding(t.node.name);
      if (r) {
        for (let s of r.constantViolations)
          if (s.scope !== r.path.scope) {
            e.mutableBinding = !0, t.stop();
            return;
          }
        r === e.scope.getBinding(t.node.name) && (e.bindings[t.node.name] = r);
      }
    }
  }, F0 = class {
    static {
      n(this, "PathHoister");
    }
    constructor(e, r) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.
      path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [],
      this.scope = r, this.path = e, this.attachAfter = !1;
    }
    isCompatibleScope(e) {
      for (let r of Object.keys(this.bindings)) {
        let s = this.bindings[r];
        if (!e.bindingIdentifierEquals(r, s.identifier))
          return !1;
      }
      return !0;
    }
    getCompatibleScopes() {
      let e = this.path.scope;
      do {
        if (this.isCompatibleScope(e))
          this.scopes.push(e);
        else
          break;
        if (this.breakOnScopePaths.indexOf(e.path) >= 0)
          break;
      } while (e = e.parent);
    }
    getAttachmentPath() {
      let e = this._getAttachmentPath();
      if (!e) return;
      let r = e.scope;
      if (r.path === e && (r = e.scope.parent), r.path.isProgram() || r.path.isFunction())
        for (let s of Object.keys(this.bindings)) {
          if (!r.hasOwnBinding(s)) continue;
          let i = this.bindings[s];
          if (i.kind === "param" || i.path.parentKey === "params")
            continue;
          if (this.getAttachmentParentForPath(i.path).key >= e.key) {
            this.attachAfter = !0, e = i.path;
            for (let o of i.constantViolations)
              this.getAttachmentParentForPath(o).key > e.key && (e = o);
          }
        }
      return e;
    }
    _getAttachmentPath() {
      let r = this.scopes.pop();
      if (r) {
        if (r.path.isFunction())
          if (this.hasOwnParamBindings(r)) {
            if (this.scope === r) return;
            let s = r.path.get("body").get("body");
            for (let i = 0; i < s.length; i++)
              if (!s[i].node._blockHoist)
                return s[i];
          } else
            return this.getNextScopeAttachmentParent();
        else if (r.path.isProgram())
          return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      let e = this.scopes.pop();
      if (e) return this.getAttachmentParentForPath(e.path);
    }
    getAttachmentParentForPath(e) {
      do
        if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
          return e;
      while (e = e.parentPath);
    }
    hasOwnParamBindings(e) {
      for (let r of Object.keys(this.bindings)) {
        if (!e.hasOwnBinding(r)) continue;
        let s = this.bindings[r];
        if (s.kind === "param" && s.constant) return !0;
      }
      return !1;
    }
    run() {
      if (this.path.traverse(FOe, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      let e = this.getAttachmentPath();
      if (!e || e.getFunctionParent() === this.path.getFunctionParent()) return;
      let r = e.scope.generateUidIdentifier("ref"), s = BOe(r, this.path.node), i = this.attachAfter ? "insertAfter" : "insertBefore", [a] = e[i](
      [e.isVariableDeclarator() ? s : MOe("var", [s])]), o = this.path.parentPath;
      return o.isJSXElement() && this.path.container === o.node.children && (r = LOe(r)), this.path.replaceWith(_Oe(r)), e.isVariableDeclarator() ?
      a.get("init") : a.get("declarations.0.init");
    }
  };
  kc.default = F0;
});

// ../node_modules/@babel/traverse/lib/path/modification.js
var Uw = w((Kr) => {
  "use strict";
  Object.defineProperty(Kr, "__esModule", {
    value: !0
  });
  Kr._containerInsert = ZOe;
  Kr._containerInsertAfter = tke;
  Kr._containerInsertBefore = eke;
  Kr._verifyNodeList = nke;
  Kr.hoist = lke;
  Kr.insertAfter = ske;
  Kr.insertBefore = QOe;
  Kr.pushContainer = oke;
  Kr.unshiftContainer = ake;
  Kr.updateSiblingKeys = ike;
  var jOe = Mi(), ROe = Mw(), U0 = ai(), UOe = Ce(), {
    arrowFunctionExpression: qOe,
    assertExpression: VOe,
    assignmentExpression: KOe,
    blockStatement: Bw,
    callExpression: WOe,
    cloneNode: j0,
    expressionStatement: R0,
    isAssignmentExpression: YOe,
    isCallExpression: JOe,
    isExportNamedDeclaration: Fw,
    isExpression: XOe,
    isIdentifier: $Oe,
    isSequenceExpression: HOe,
    isSuper: zOe,
    thisExpression: GOe
  } = UOe;
  function QOe(t) {
    this._assertUnremoved();
    let e = this._verifyNodeList(t), {
      parentPath: r,
      parent: s
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || Fw(s) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertBefore(e);
    if (this.isNodeType("Expression") && !this.isJSXElement() || r.isForStatement() && this.key === "init")
      return this.node && e.push(this.node), this.replaceExpressionWithStatements(e);
    if (Array.isArray(this.container))
      return this._containerInsertBefore(e);
    if (this.isStatementOrBlock()) {
      let i = this.node, a = i && (!this.isExpressionStatement() || i.expression != null);
      return this.replaceWith(Bw(a ? [i] : [])), this.unshiftContainer("body", e);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  n(QOe, "insertBefore");
  function ZOe(t, e) {
    this.updateSiblingKeys(t, e.length);
    let r = [];
    this.container.splice(t, 0, ...e);
    for (let a = 0; a < e.length; a++) {
      var s;
      let o = t + a, l = this.getSibling(o);
      r.push(l), (s = this.context) != null && s.queue && l.pushContext(this.context);
    }
    let i = this._getQueueContexts();
    for (let a of r) {
      a.setScope(), a.debug("Inserted.");
      for (let o of i)
        o.maybeQueue(a, !0);
    }
    return r;
  }
  n(ZOe, "_containerInsert");
  function eke(t) {
    return this._containerInsert(this.key, t);
  }
  n(eke, "_containerInsertBefore");
  function tke(t) {
    return this._containerInsert(this.key + 1, t);
  }
  n(tke, "_containerInsertAfter");
  var jw = /* @__PURE__ */ n((t) => t[t.length - 1], "last");
  function Rw(t) {
    return HOe(t.parent) && (jw(t.parent.expressions) !== t.node || Rw(t.parentPath));
  }
  n(Rw, "isHiddenInSequenceExpression");
  function rke(t, e) {
    if (!YOe(t) || !$Oe(t.left))
      return !1;
    let r = e.getBlockParent();
    return r.hasOwnBinding(t.left.name) && r.getOwnBinding(t.left.name).constantViolations.length <= 1;
  }
  n(rke, "isAlmostConstantAssignment");
  function ske(t) {
    if (this._assertUnremoved(), this.isSequenceExpression())
      return jw(this.get("expressions")).insertAfter(t);
    let e = this._verifyNodeList(t), {
      parentPath: r,
      parent: s
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || Fw(s) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertAfter(e.map((i) => XOe(i) ? R0(i) : i));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !r.isJSXElement() || r.isForStatement() && this.key === "init") {
      if (this.node) {
        let i = this.node, {
          scope: a
        } = this;
        if (a.path.isPattern())
          return VOe(i), this.replaceWith(WOe(qOe([], i), [])), this.get("callee.body").insertAfter(e), [this];
        if (Rw(this))
          e.unshift(i);
        else if (JOe(i) && zOe(i.callee))
          e.unshift(i), e.push(GOe());
        else if (rke(i, a))
          e.unshift(i), e.push(j0(i.left));
        else if (a.isPure(i, !0))
          e.push(i);
        else {
          r.isMethod({
            computed: !0,
            key: i
          }) && (a = a.parent);
          let o = a.generateDeclaredUidIdentifier();
          e.unshift(R0(KOe("=", j0(o), i))), e.push(R0(j0(o)));
        }
      }
      return this.replaceExpressionWithStatements(e);
    } else {
      if (Array.isArray(this.container))
        return this._containerInsertAfter(e);
      if (this.isStatementOrBlock()) {
        let i = this.node, a = i && (!this.isExpressionStatement() || i.expression != null);
        return this.replaceWith(Bw(a ? [i] : [])), this.pushContainer("body", e);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  n(ske, "insertAfter");
  function ike(t, e) {
    if (!this.parent) return;
    let r = (0, jOe.getCachedPaths)(this.hub, this.parent) || [];
    for (let [, s] of r)
      typeof s.key == "number" && s.key >= t && (s.key += e);
  }
  n(ike, "updateSiblingKeys");
  function nke(t) {
    if (!t)
      return [];
    Array.isArray(t) || (t = [t]);
    for (let e = 0; e < t.length; e++) {
      let r = t[e], s;
      if (r ? typeof r != "object" ? s = "contains a non-object node" : r.type ? r instanceof U0.default && (s = "has a NodePath when it exp\
ected a raw object") : s = "without a type" : s = "has falsy node", s) {
        let i = Array.isArray(r) ? "array" : typeof r;
        throw new Error(`Node list ${s} with the index of ${e} and type of ${i}`);
      }
    }
    return t;
  }
  n(nke, "_verifyNodeList");
  function ake(t, e) {
    return this._assertUnremoved(), e = this._verifyNodeList(e), U0.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[t],
      listKey: t,
      key: 0
    }).setContext(this.context)._containerInsertBefore(e);
  }
  n(ake, "unshiftContainer");
  function oke(t, e) {
    this._assertUnremoved();
    let r = this._verifyNodeList(e), s = this.node[t];
    return U0.default.get({
      parentPath: this,
      parent: this.node,
      container: s,
      listKey: t,
      key: s.length
    }).setContext(this.context).replaceWithMultiple(r);
  }
  n(oke, "pushContainer");
  function lke(t = this.scope) {
    return new ROe.default(this, t).run();
  }
  n(lke, "hoist");
});

// ../node_modules/@babel/traverse/lib/path/family.js
var Kw = w((ar) => {
  "use strict";
  Object.defineProperty(ar, "__esModule", {
    value: !0
  });
  ar._getKey = Cke;
  ar._getPattern = Ike;
  ar.get = vke;
  ar.getAllNextSiblings = Eke;
  ar.getAllPrevSiblings = Ake;
  ar.getBindingIdentifierPaths = Oke;
  ar.getBindingIdentifiers = wke;
  ar.getCompletionRecords = xke;
  ar.getNextSibling = Pke;
  ar.getOpposite = yke;
  ar.getOuterBindingIdentifierPaths = kke;
  ar.getOuterBindingIdentifiers = Nke;
  ar.getPrevSibling = gke;
  ar.getSibling = Ske;
  var V0 = ai(), uke = Ce(), {
    getBindingIdentifiers: Vw,
    getOuterBindingIdentifiers: cke,
    isDeclaration: pke,
    numericLiteral: fke,
    unaryExpression: hke
  } = uke, K0 = 0, Ro = 1;
  function dke(t) {
    return {
      type: K0,
      path: t
    };
  }
  n(dke, "NormalCompletion");
  function mke(t) {
    return {
      type: Ro,
      path: t
    };
  }
  n(mke, "BreakCompletion");
  function yke() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  n(yke, "getOpposite");
  function zn(t, e, r) {
    return t && e.push(...Gn(t, r)), e;
  }
  n(zn, "addCompletionRecords");
  function Tke(t, e, r) {
    let s = [];
    for (let i = 0; i < t.length; i++) {
      let a = t[i], o = Gn(a, r), l = [], u = [];
      for (let c of o)
        c.type === K0 && l.push(c), c.type === Ro && u.push(c);
      l.length && (s = l), e.push(...u);
    }
    return e.push(...s), e;
  }
  n(Tke, "completionRecordForSwitch");
  function bke(t) {
    t.forEach((e) => {
      e.type = Ro;
    });
  }
  n(bke, "normalCompletionToBreak");
  function q0(t, e) {
    t.forEach((r) => {
      r.path.isBreakStatement({
        label: null
      }) && (e ? r.path.replaceWith(hke("void", fke(0))) : r.path.remove());
    });
  }
  n(q0, "replaceBreakStatementInBreakCompletion");
  function qw(t, e) {
    let r = [];
    if (e.canHaveBreak) {
      let s = [];
      for (let i = 0; i < t.length; i++) {
        let a = t[i], o = Object.assign({}, e, {
          inCaseClause: !1
        });
        a.isBlockStatement() && (e.inCaseClause || e.shouldPopulateBreak) ? o.shouldPopulateBreak = !0 : o.shouldPopulateBreak = !1;
        let l = Gn(a, o);
        if (l.length > 0 && l.every((u) => u.type === Ro)) {
          s.length > 0 && l.every((u) => u.path.isBreakStatement({
            label: null
          })) ? (bke(s), r.push(...s), s.some((u) => u.path.isDeclaration()) && (r.push(...l), q0(l, !0)), q0(l, !1)) : (r.push(...l), e.shouldPopulateBreak ||
          q0(l, !0));
          break;
        }
        if (i === t.length - 1)
          r.push(...l);
        else {
          s = [];
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c.type === Ro && r.push(c), c.type === K0 && s.push(c);
          }
        }
      }
    } else if (t.length)
      for (let s = t.length - 1; s >= 0; s--) {
        let i = Gn(t[s], e);
        if (i.length > 1 || i.length === 1 && !i[0].path.isVariableDeclaration()) {
          r.push(...i);
          break;
        }
      }
    return r;
  }
  n(qw, "getStatementListCompletion");
  function Gn(t, e) {
    let r = [];
    if (t.isIfStatement())
      r = zn(t.get("consequent"), r, e), r = zn(t.get("alternate"), r, e);
    else {
      if (t.isDoExpression() || t.isFor() || t.isWhile() || t.isLabeledStatement())
        return zn(t.get("body"), r, e);
      if (t.isProgram() || t.isBlockStatement())
        return qw(t.get("body"), e);
      if (t.isFunction())
        return Gn(t.get("body"), e);
      if (t.isTryStatement())
        r = zn(t.get("block"), r, e), r = zn(t.get("handler"), r, e);
      else {
        if (t.isCatchClause())
          return zn(t.get("body"), r, e);
        if (t.isSwitchStatement())
          return Tke(t.get("cases"), r, e);
        if (t.isSwitchCase())
          return qw(t.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0
          });
        t.isBreakStatement() ? r.push(mke(t)) : r.push(dke(t));
      }
    }
    return r;
  }
  n(Gn, "_getCompletionRecords");
  function xke() {
    return Gn(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1
    }).map((e) => e.path);
  }
  n(xke, "getCompletionRecords");
  function Ske(t) {
    return V0.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: t
    }).setContext(this.context);
  }
  n(Ske, "getSibling");
  function gke() {
    return this.getSibling(this.key - 1);
  }
  n(gke, "getPrevSibling");
  function Pke() {
    return this.getSibling(this.key + 1);
  }
  n(Pke, "getNextSibling");
  function Eke() {
    let t = this.key, e = this.getSibling(++t), r = [];
    for (; e.node; )
      r.push(e), e = this.getSibling(++t);
    return r;
  }
  n(Eke, "getAllNextSiblings");
  function Ake() {
    let t = this.key, e = this.getSibling(--t), r = [];
    for (; e.node; )
      r.push(e), e = this.getSibling(--t);
    return r;
  }
  n(Ake, "getAllPrevSiblings");
  function vke(t, e = !0) {
    e === !0 && (e = this.context);
    let r = t.split(".");
    return r.length === 1 ? this._getKey(t, e) : this._getPattern(r, e);
  }
  n(vke, "get");
  function Cke(t, e) {
    let r = this.node, s = r[t];
    return Array.isArray(s) ? s.map((i, a) => V0.default.get({
      listKey: t,
      parentPath: this,
      parent: r,
      container: s,
      key: a
    }).setContext(e)) : V0.default.get({
      parentPath: this,
      parent: r,
      container: r,
      key: t
    }).setContext(e);
  }
  n(Cke, "_getKey");
  function Ike(t, e) {
    let r = this;
    for (let s of t)
      s === "." ? r = r.parentPath : Array.isArray(r) ? r = r[s] : r = r.get(s, e);
    return r;
  }
  n(Ike, "_getPattern");
  function wke(t) {
    return Vw(this.node, t);
  }
  n(wke, "getBindingIdentifiers");
  function Nke(t) {
    return cke(this.node, t);
  }
  n(Nke, "getOuterBindingIdentifiers");
  function Oke(t = !1, e = !1) {
    let s = [this], i = /* @__PURE__ */ Object.create(null);
    for (; s.length; ) {
      let a = s.shift();
      if (!a || !a.node) continue;
      let o = Vw.keys[a.node.type];
      if (a.isIdentifier()) {
        t ? (i[a.node.name] = i[a.node.name] || []).push(a) : i[a.node.name] = a;
        continue;
      }
      if (a.isExportDeclaration()) {
        let l = a.get("declaration");
        pke(l) && s.push(l);
        continue;
      }
      if (e) {
        if (a.isFunctionDeclaration()) {
          s.push(a.get("id"));
          continue;
        }
        if (a.isFunctionExpression())
          continue;
      }
      if (o)
        for (let l = 0; l < o.length; l++) {
          let u = o[l], c = a.get(u);
          Array.isArray(c) ? s.push(...c) : c.node && s.push(c);
        }
    }
    return i;
  }
  n(Oke, "getBindingIdentifierPaths");
  function kke(t = !1) {
    return this.getBindingIdentifierPaths(t, !0);
  }
  n(kke, "getOuterBindingIdentifierPaths");
});

// ../node_modules/@babel/traverse/lib/path/comments.js
var Yw = w((Uo) => {
  "use strict";
  Object.defineProperty(Uo, "__esModule", {
    value: !0
  });
  Uo.addComment = Bke;
  Uo.addComments = Fke;
  Uo.shareCommentsWithSiblings = Mke;
  var Dke = Ce(), {
    addComment: _ke,
    addComments: Lke
  } = Dke;
  function Mke() {
    if (typeof this.key == "string") return;
    let t = this.node;
    if (!t) return;
    let e = t.trailingComments, r = t.leadingComments;
    if (!e && !r) return;
    let s = this.getSibling(this.key - 1), i = this.getSibling(this.key + 1), a = !!s.node, o = !!i.node;
    a && (r && s.addComments("trailing", Ww(r, s.node.trailingComments)), e && !o && s.addComments("trailing", e)), o && (e && i.addComments(
    "leading", Ww(e, i.node.leadingComments)), r && !a && i.addComments("leading", r));
  }
  n(Mke, "shareCommentsWithSiblings");
  function Ww(t, e) {
    if (!(e != null && e.length)) return t;
    let r = new Set(e);
    return t.filter((s) => !r.has(s));
  }
  n(Ww, "removeIfExisting");
  function Bke(t, e, r) {
    _ke(this.node, t, e, r);
  }
  n(Bke, "addComment");
  function Fke(t, e) {
    Lke(this.node, t, e);
  }
  n(Fke, "addComments");
});

// ../node_modules/@babel/traverse/lib/path/index.js
var ai = w((ps) => {
  "use strict";
  Object.defineProperty(ps, "__esModule", {
    value: !0
  });
  ps.default = ps.SHOULD_STOP = ps.SHOULD_SKIP = ps.REMOVED = void 0;
  var jke = Mh(), Rke = PP(), Uke = ji(), qke = Zh(), Xw = Ce(), Dc = Xw, Vke = Mi(), Kke = kE(), Wke = DE(), Yke = GE(), Jke = R1(), Xke = K1(),
  $ke = gw(), $w = Iw(), Hke = Ow(), zke = _w(), Gke = Uw(), Qke = Kw(), Zke = Yw(), eDe = Fh(), {
    validate: tDe
  } = Xw, Jw = Rke("babel"), W0 = ps.REMOVED = 1, Y0 = ps.SHOULD_STOP = 2, J0 = ps.SHOULD_SKIP = 4, yi = class t {
    static {
      n(this, "NodePath");
    }
    constructor(e, r) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container =
      null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = r, this.hub = e, this.data = null, this.
      context = null, this.scope = null;
    }
    static get({
      hub: e,
      parentPath: r,
      parent: s,
      container: i,
      listKey: a,
      key: o
    }) {
      if (!e && r && (e = r.hub), !s)
        throw new Error("To get a node path the parent needs to exist");
      let l = i[o], u = Vke.getOrCreateCachedPaths(e, s), c = u.get(l);
      return c || (c = new t(e, s), l && u.set(l, c)), c.setup(r, i, a, o), c;
    }
    getScope(e) {
      return this.isScope() ? new qke.default(this) : e;
    }
    setData(e, r) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[e] = r;
    }
    getData(e, r) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let s = this.data[e];
      return s === void 0 && r !== void 0 && (s = this.data[e] = r), s;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(e, r = SyntaxError) {
      return this.hub.buildError(this.node, e, r);
    }
    traverse(e, r) {
      (0, Uke.default)(this.node, e, this.scope, r, this);
    }
    set(e, r) {
      tDe(this.node, e, r), this.node[e] = r;
    }
    getPathLocation() {
      let e = [], r = this;
      do {
        let s = r.key;
        r.inList && (s = `${r.listKey}[${s}]`), e.unshift(s);
      } while (r = r.parentPath);
      return e.join(".");
    }
    debug(e) {
      Jw.enabled && Jw(`${this.getPathLocation()} ${this.type}: ${e}`);
    }
    toString() {
      return (0, Kke.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(e) {
      e || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
    get shouldSkip() {
      return !!(this._traverseFlags & J0);
    }
    set shouldSkip(e) {
      e ? this._traverseFlags |= J0 : this._traverseFlags &= ~J0;
    }
    get shouldStop() {
      return !!(this._traverseFlags & Y0);
    }
    set shouldStop(e) {
      e ? this._traverseFlags |= Y0 : this._traverseFlags &= ~Y0;
    }
    get removed() {
      return !!(this._traverseFlags & W0);
    }
    set removed(e) {
      e ? this._traverseFlags |= W0 : this._traverseFlags &= ~W0;
    }
  };
  Object.assign(yi.prototype, Wke, Yke, Jke, Xke, $ke, $w, Hke, zke, Gke, Qke, Zke);
  yi.prototype._guessExecutionStatusRelativeToDifferentFunctions = $w._guessExecutionStatusRelativeTo;
  for (let t of Dc.TYPES) {
    let e = `is${t}`, r = Dc[e];
    yi.prototype[e] = function(s) {
      return r(this.node, s);
    }, yi.prototype[`assert${t}`] = function(s) {
      if (!r(this.node, s))
        throw new TypeError(`Expected node path of type ${t}`);
    };
  }
  Object.assign(yi.prototype, eDe);
  for (let t of Object.keys(jke))
    t[0] !== "_" && (Dc.TYPES.includes(t) || Dc.TYPES.push(t));
  var RUe = ps.default = yi;
});

// ../node_modules/@babel/traverse/lib/context.js
var Hw = w((_c) => {
  "use strict";
  Object.defineProperty(_c, "__esModule", {
    value: !0
  });
  _c.default = void 0;
  var rDe = ai(), sDe = Ce(), {
    VISITOR_KEYS: iDe
  } = sDe, X0 = class {
    static {
      n(this, "TraversalContext");
    }
    constructor(e, r, s, i) {
      this.queue = null, this.priorityQueue = null, this.parentPath = i, this.scope = e, this.state = s, this.opts = r;
    }
    shouldVisit(e) {
      let r = this.opts;
      if (r.enter || r.exit || r[e.type]) return !0;
      let s = iDe[e.type];
      if (!(s != null && s.length)) return !1;
      for (let i of s)
        if (e[i])
          return !0;
      return !1;
    }
    create(e, r, s, i) {
      return rDe.default.get({
        parentPath: this.parentPath,
        parent: e,
        container: r,
        key: s,
        listKey: i
      });
    }
    maybeQueue(e, r) {
      this.queue && (r ? this.queue.push(e) : this.priorityQueue.push(e));
    }
    visitMultiple(e, r, s) {
      if (e.length === 0) return !1;
      let i = [];
      for (let a = 0; a < e.length; a++) {
        let o = e[a];
        o && this.shouldVisit(o) && i.push(this.create(r, e, a, s));
      }
      return this.visitQueue(i);
    }
    visitSingle(e, r) {
      return this.shouldVisit(e[r]) ? this.visitQueue([this.create(e, e, r)]) : !1;
    }
    visitQueue(e) {
      this.queue = e, this.priorityQueue = [];
      let r = /* @__PURE__ */ new WeakSet(), s = !1, i = 0;
      for (; i < e.length; ) {
        let a = e[i];
        if (i++, a.resync(), (a.contexts.length === 0 || a.contexts[a.contexts.length - 1] !== this) && a.pushContext(this), a.key === null)
         continue;
        let {
          node: o
        } = a;
        if (!r.has(o)) {
          if (o && r.add(o), a.visit()) {
            s = !0;
            break;
          }
          if (this.priorityQueue.length && (s = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = e, s))
            break;
        }
      }
      for (let a = 0; a < i; a++)
        e[a].popContext();
      return this.queue = null, s;
    }
    visit(e, r) {
      let s = e[r];
      return s ? Array.isArray(s) ? this.visitMultiple(s, e, r) : this.visitSingle(e, r) : !1;
    }
  };
  _c.default = X0;
});

// ../node_modules/@babel/traverse/lib/traverse-node.js
var ru = w(($0) => {
  "use strict";
  Object.defineProperty($0, "__esModule", {
    value: !0
  });
  $0.traverseNode = lDe;
  var nDe = Hw(), aDe = Ce(), {
    VISITOR_KEYS: oDe
  } = aDe;
  function lDe(t, e, r, s, i, a, o) {
    let l = oDe[t.type];
    if (!l) return !1;
    let u = new nDe.default(r, e, s, i);
    if (o)
      return a != null && a[i.parentKey] ? !1 : u.visitQueue([i]);
    for (let c of l)
      if (!(a != null && a[c]) && u.visit(t, c))
        return !0;
    return !1;
  }
  n(lDe, "traverseNode");
});

// ../node_modules/@babel/traverse/lib/hub.js
var zw = w((Lc) => {
  "use strict";
  Object.defineProperty(Lc, "__esModule", {
    value: !0
  });
  Lc.default = void 0;
  var H0 = class {
    static {
      n(this, "Hub");
    }
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(e, r, s = TypeError) {
      return new s(r);
    }
  };
  Lc.default = H0;
});

// ../node_modules/@babel/traverse/lib/index.js
var ji = w((Bs) => {
  "use strict";
  Object.defineProperty(Bs, "__esModule", {
    value: !0
  });
  Object.defineProperty(Bs, "Hub", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return hDe.default;
    }, "get")
  });
  Object.defineProperty(Bs, "NodePath", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return pDe.default;
    }, "get")
  });
  Object.defineProperty(Bs, "Scope", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return fDe.default;
    }, "get")
  });
  Bs.visitors = Bs.default = void 0;
  var qo = Ma();
  Bs.visitors = qo;
  var uDe = Ce(), cDe = Mi(), Gw = ru(), pDe = ai(), fDe = Zh(), hDe = zw(), {
    VISITOR_KEYS: dDe,
    removeProperties: mDe,
    traverseFast: Qw
  } = uDe;
  function Wr(t, e = {}, r, s, i, a) {
    if (t) {
      if (!e.noScope && !r && t.type !== "Program" && t.type !== "File")
        throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${t.
        type} node without passing scope and parentPath.`);
      if (!i && a)
        throw new Error("visitSelf can only be used when providing a NodePath.");
      dDe[t.type] && (qo.explode(e), (0, Gw.traverseNode)(t, e, r, s, i, null, a));
    }
  }
  n(Wr, "traverse");
  var $Ue = Bs.default = Wr;
  Wr.visitors = qo;
  Wr.verify = qo.verify;
  Wr.explode = qo.explode;
  Wr.cheap = function(t, e) {
    Qw(t, e);
  };
  Wr.node = function(t, e, r, s, i, a) {
    (0, Gw.traverseNode)(t, e, r, s, i, a);
  };
  Wr.clearNode = function(t, e) {
    mDe(t, e);
  };
  Wr.removeProperties = function(t, e) {
    return Qw(t, Wr.clearNode, e), t;
  };
  function yDe(t, e) {
    t.node.type === e.type && (e.has = !0, t.stop());
  }
  n(yDe, "hasDenylistedType");
  Wr.hasType = function(t, e, r) {
    if (r != null && r.includes(t.type)) return !1;
    if (t.type === e) return !0;
    let s = {
      has: !1,
      type: e
    };
    return Wr(t, {
      noScope: !0,
      denylist: r,
      enter: yDe
    }, null, s), s.has;
  };
  Wr.cache = cDe;
});

// ../node_modules/@babel/parser/lib/index.js
var kN = w((Qo) => {
  "use strict";
  Object.defineProperty(Qo, "__esModule", {
    value: !0
  });
  function dN(t, e) {
    if (t == null) return {};
    var r = {}, s = Object.keys(t), i, a;
    for (a = 0; a < s.length; a++)
      i = s[a], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
    return r;
  }
  n(dN, "_objectWithoutPropertiesLoose");
  var hs = class {
    static {
      n(this, "Position");
    }
    constructor(e, r, s) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = r, this.index = s;
    }
  }, ta = class {
    static {
      n(this, "SourceLocation");
    }
    constructor(e, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = r;
    }
  };
  function Cr(t, e) {
    let {
      line: r,
      column: s,
      index: i
    } = t;
    return new hs(r, s + e, i + e);
  }
  n(Cr, "createPositionWithColumnOffset");
  var Zw = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", TDe = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: Zw
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: Zw
    }
  }, eN = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, Fc = /* @__PURE__ */ n((t) => t.type === "UpdateExpression" ? eN.UpdateExpression[`${t.prefix}`] : eN[t.type], "toNodeDescription"), bDe = {
    AccessorIsGenerator: /* @__PURE__ */ n(({
      kind: t
    }) => `A ${t}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ n(({
      kind: t
    }) => `Missing initializer in ${t} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ n(({
      exportName: t
    }) => `\`${t}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ n(({
      phase: t
    }) => `'import.${t}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ n(({
      localName: t,
      exportName: e
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t}' as '${e}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ n(({
      type: t
    }) => `'${t === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ n(({
      type: t
    }) => `Unsyntactic ${t === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ n(({
      importName: t
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: /* @__PURE__ */ n(({
      maxArgumentCount: t
    }) => `\`import()\` requires exactly ${t === 1 ? "one argument" : "one or two arguments"}.`, "ImportCallArity"),
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ n(({
      radix: t
    }) => `Expected number in radix ${t}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Escape sequence in keyword ${t}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Invalid identifier ${t}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid left-hand side in ${Fc(t)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Binding invalid left-hand side in ${Fc(t)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid optional chaining in the left-hand side of ${Fc(t)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t
    }) => `Unexpected character '${t}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private name #${t} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ n(({
      labelName: t
    }) => `Label '${t}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling the parser plugin: ${t.map((e) => JSON.stringify(e)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${t.map((e) => JSON.stringify(e)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ n(({
      key: t
    }) => `Duplicate key "${t}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ n(({
      surrogateCharCode: t
    }) => `An export name cannot include a lone surrogate, found '\\u${t.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ n(({
      localName: t
    }) => `Export '${t}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private names are only allowed in property accesses (\`obj.#${t}\`) or in \`in\` expressions (\`#${t} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Duplicate private name #${t}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ n(({
      keyword: t
    }) => `Unexpected keyword '${t}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Unexpected reserved word '${t}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ n(({
      expected: t,
      unexpected: e
    }) => `Unexpected token${e ? ` '${e}'.` : ""}${t ? `, expected "${t}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ n(({
      target: t,
      onlyValidPropertyName: e
    }) => `The only valid meta property for ${t} is ${t}.${e}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Identifier '${t}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, xDe = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ n(({
      referenceName: t
    }) => `Assigning to '${t}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ n(({
      bindingName: t
    }) => `Binding '${t}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, SDe = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), gDe = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ n(({
      token: t
    }) => `Invalid topic token ${t}. In order to use ${t} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${t}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ n(({
      type: t
    }) => `Hack-style pipe body cannot be an unparenthesized ${Fc({
      type: t
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody"),
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }, PDe = ["toMessage"], EDe = ["message"];
  function tN(t, e, r) {
    Object.defineProperty(t, e, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  n(tN, "defineHidden");
  function ADe(t) {
    let {
      toMessage: e
    } = t, r = dN(t, PDe);
    return /* @__PURE__ */ n(function s(i, a) {
      let o = new SyntaxError();
      return Object.assign(o, r, {
        loc: i,
        pos: i.index
      }), "missingPlugin" in a && Object.assign(o, {
        missingPlugin: a.missingPlugin
      }), tN(o, "clone", /* @__PURE__ */ n(function(u = {}) {
        var c;
        let {
          line: p,
          column: f,
          index: m
        } = (c = u.loc) != null ? c : i;
        return s(new hs(p, f, m), Object.assign({}, a, u.details));
      }, "clone")), tN(o, "details", a), Object.defineProperty(o, "message", {
        configurable: !0,
        get() {
          let l = `${e(a)} (${i.line}:${i.column})`;
          return this.message = l, l;
        },
        set(l) {
          Object.defineProperty(this, "message", {
            value: l,
            writable: !0
          });
        }
      }), o;
    }, "constructor");
  }
  n(ADe, "toParseErrorConstructor");
  function Us(t, e) {
    if (Array.isArray(t))
      return (s) => Us(s, t[0]);
    let r = {};
    for (let s of Object.keys(t)) {
      let i = t[s], a = typeof i == "string" ? {
        message: /* @__PURE__ */ n(() => i, "message")
      } : typeof i == "function" ? {
        message: i
      } : i, {
        message: o
      } = a, l = dN(a, EDe), u = typeof o == "string" ? () => o : o;
      r[s] = ADe(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: s,
        toMessage: u
      }, e ? {
        syntaxPlugin: e
      } : {}, l));
    }
    return r;
  }
  n(Us, "ParseErrorEnum");
  var B = Object.assign({}, Us(TDe), Us(bDe), Us(xDe), Us`pipelineOperator`(gDe)), {
    defineProperty: vDe
  } = Object, rN = /* @__PURE__ */ n((t, e) => vDe(t, e, {
    enumerable: !1,
    value: t[e]
  }), "toUnenumerable");
  function Vo(t) {
    return t.loc.start && rN(t.loc.start, "index"), t.loc.end && rN(t.loc.end, "index"), t;
  }
  n(Vo, "toESTreeLocation");
  var CDe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "ESTreeParserMixin");
    }
    parse() {
      let r = Vo(super.parse());
      return this.options.tokens && (r.tokens = r.tokens.map(Vo)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: s
    }) {
      let i = null;
      try {
        i = new RegExp(r, s);
      } catch {
      }
      let a = this.estreeParseLiteral(i);
      return a.regex = {
        pattern: r,
        flags: s
      }, a;
    }
    parseBigIntLiteral(r) {
      let s;
      try {
        s = BigInt(r);
      } catch {
        s = null;
      }
      let i = this.estreeParseLiteral(s);
      return i.bigint = String(i.value || r), i;
    }
    parseDecimalLiteral(r) {
      let i = this.estreeParseLiteral(null);
      return i.decimal = String(i.value || r), i;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    directiveToStmt(r) {
      let s = r.value;
      delete r.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
      let i = r;
      return i.type = "ExpressionStatement", i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
    }
    initFunction(r, s) {
      super.initFunction(r, s), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var s;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((s = r.expression.
      extra) != null && s.parenthesized);
    }
    parseBlockBody(r, s, i, a, o) {
      super.parseBlockBody(r, s, i, a, o);
      let l = r.directives.map((u) => this.directiveToStmt(u));
      r.body = l.concat(r.body), delete r.directives;
    }
    pushClassMethod(r, s, i, a, o, l) {
      this.parseMethod(s, i, a, o, l, "ClassMethod", !0), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters),
      r.body.push(s);
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let s = super.getPrivateNameSV(r);
      return r = r, delete r.id, r.name = s, r.type = "PrivateIdentifier", r;
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, s) {
      let i = super.parseLiteral(r, s);
      return i.raw = i.extra.raw, delete i.extra, i;
    }
    parseFunctionBody(r, s, i = !1) {
      super.parseFunctionBody(r, s, i), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, s, i, a, o, l, u = !1) {
      let c = this.startNode();
      return c.kind = r.kind, c = super.parseMethod(c, s, i, a, o, l, u), c.type = "FunctionExpression", delete c.kind, r.value = c, l === "\
ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
    }
    nameIsConstructor(r) {
      return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
    }
    parseClassProperty(...r) {
      let s = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition"), s;
    }
    parseClassPrivateProperty(...r) {
      let s = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition", s.computed = !1), s;
    }
    parseObjectMethod(r, s, i, a, o) {
      let l = super.parseObjectMethod(r, s, i, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(r, s, i, a) {
      let o = super.parseObjectProperty(r, s, i, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(r, s, i) {
      return r === "Property" ? "value" : super.isValidLVal(r, s, i);
    }
    isAssignable(r, s) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: i,
          value: a
        } = r;
        this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(a, s);
      } else
        super.toAssignable(r, s);
    }
    toAssignableObjectExpressionProp(r, s, i) {
      r.type === "Property" && (r.kind === "get" || r.kind === "set") ? this.raise(B.PatternHasAccessor, r.key) : r.type === "Property" && r.
      method ? this.raise(B.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, s, i);
    }
    finishCallExpression(r, s) {
      let i = super.finishCallExpression(r, s);
      if (i.callee.type === "Import") {
        if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var a, o;
          i.options = (a = i.arguments[1]) != null ? a : null, i.attributes = (o = i.arguments[1]) != null ? o : null;
        }
        delete i.arguments, delete i.callee;
      }
      return i;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, s) {
      let i = this.state.lastTokStartLoc, a = super.parseExport(r, s);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, i);
          }
          break;
      }
      return a;
    }
    parseSubscript(r, s, i, a) {
      let o = super.parseSubscript(r, s, i, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
    }
    finishNodeAt(r, s, i) {
      return Vo(super.finishNodeAt(r, s, i));
    }
    resetStartLocation(r, s) {
      super.resetStartLocation(r, s), Vo(r);
    }
    resetEndLocation(r, s = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, s), Vo(r);
    }
  }, "estree"), nn = class {
    static {
      n(this, "TokContext");
    }
    constructor(e, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!r;
    }
  }, Pt = {
    brace: new nn("{"),
    j_oTag: new nn("<tag"),
    j_cTag: new nn("</tag"),
    j_expr: new nn("<tag>...</tag>", !0)
  };
  Pt.template = new nn("`", !0);
  var $e = !0, le = !0, z0 = !0, Ko = !0, Ti = !0, IDe = !0, qc = class {
    static {
      n(this, "ExportedTokenType");
    }
    constructor(e, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, gb = /* @__PURE__ */ new Map();
  function tt(t, e = {}) {
    e.keyword = t;
    let r = ve(t, e);
    return gb.set(t, r), r;
  }
  n(tt, "createKeyword");
  function vr(t, e) {
    return ve(t, {
      beforeExpr: $e,
      binop: e
    });
  }
  n(vr, "createBinop");
  var Xo = -1, js = [], Pb = [], Eb = [], Ab = [], vb = [], Cb = [];
  function ve(t, e = {}) {
    var r, s, i, a;
    return ++Xo, Pb.push(t), Eb.push((r = e.binop) != null ? r : -1), Ab.push((s = e.beforeExpr) != null ? s : !1), vb.push((i = e.startsExpr) !=
    null ? i : !1), Cb.push((a = e.prefix) != null ? a : !1), js.push(new qc(t, e)), Xo;
  }
  n(ve, "createToken");
  function Xe(t, e = {}) {
    var r, s, i, a;
    return ++Xo, gb.set(t, Xo), Pb.push(t), Eb.push((r = e.binop) != null ? r : -1), Ab.push((s = e.beforeExpr) != null ? s : !1), vb.push((i =
    e.startsExpr) != null ? i : !1), Cb.push((a = e.prefix) != null ? a : !1), js.push(new qc("name", e)), Xo;
  }
  n(Xe, "createKeywordLike");
  var wDe = {
    bracketL: ve("[", {
      beforeExpr: $e,
      startsExpr: le
    }),
    bracketHashL: ve("#[", {
      beforeExpr: $e,
      startsExpr: le
    }),
    bracketBarL: ve("[|", {
      beforeExpr: $e,
      startsExpr: le
    }),
    bracketR: ve("]"),
    bracketBarR: ve("|]"),
    braceL: ve("{", {
      beforeExpr: $e,
      startsExpr: le
    }),
    braceBarL: ve("{|", {
      beforeExpr: $e,
      startsExpr: le
    }),
    braceHashL: ve("#{", {
      beforeExpr: $e,
      startsExpr: le
    }),
    braceR: ve("}"),
    braceBarR: ve("|}"),
    parenL: ve("(", {
      beforeExpr: $e,
      startsExpr: le
    }),
    parenR: ve(")"),
    comma: ve(",", {
      beforeExpr: $e
    }),
    semi: ve(";", {
      beforeExpr: $e
    }),
    colon: ve(":", {
      beforeExpr: $e
    }),
    doubleColon: ve("::", {
      beforeExpr: $e
    }),
    dot: ve("."),
    question: ve("?", {
      beforeExpr: $e
    }),
    questionDot: ve("?."),
    arrow: ve("=>", {
      beforeExpr: $e
    }),
    template: ve("template"),
    ellipsis: ve("...", {
      beforeExpr: $e
    }),
    backQuote: ve("`", {
      startsExpr: le
    }),
    dollarBraceL: ve("${", {
      beforeExpr: $e,
      startsExpr: le
    }),
    templateTail: ve("...`", {
      startsExpr: le
    }),
    templateNonTail: ve("...${", {
      beforeExpr: $e,
      startsExpr: le
    }),
    at: ve("@"),
    hash: ve("#", {
      startsExpr: le
    }),
    interpreterDirective: ve("#!..."),
    eq: ve("=", {
      beforeExpr: $e,
      isAssign: Ko
    }),
    assign: ve("_=", {
      beforeExpr: $e,
      isAssign: Ko
    }),
    slashAssign: ve("_=", {
      beforeExpr: $e,
      isAssign: Ko
    }),
    xorAssign: ve("_=", {
      beforeExpr: $e,
      isAssign: Ko
    }),
    moduloAssign: ve("_=", {
      beforeExpr: $e,
      isAssign: Ko
    }),
    incDec: ve("++/--", {
      prefix: Ti,
      postfix: IDe,
      startsExpr: le
    }),
    bang: ve("!", {
      beforeExpr: $e,
      prefix: Ti,
      startsExpr: le
    }),
    tilde: ve("~", {
      beforeExpr: $e,
      prefix: Ti,
      startsExpr: le
    }),
    doubleCaret: ve("^^", {
      startsExpr: le
    }),
    doubleAt: ve("@@", {
      startsExpr: le
    }),
    pipeline: vr("|>", 0),
    nullishCoalescing: vr("??", 1),
    logicalOR: vr("||", 1),
    logicalAND: vr("&&", 2),
    bitwiseOR: vr("|", 3),
    bitwiseXOR: vr("^", 4),
    bitwiseAND: vr("&", 5),
    equality: vr("==/!=/===/!==", 6),
    lt: vr("</>/<=/>=", 7),
    gt: vr("</>/<=/>=", 7),
    relational: vr("</>/<=/>=", 7),
    bitShift: vr("<</>>/>>>", 8),
    bitShiftL: vr("<</>>/>>>", 8),
    bitShiftR: vr("<</>>/>>>", 8),
    plusMin: ve("+/-", {
      beforeExpr: $e,
      binop: 9,
      prefix: Ti,
      startsExpr: le
    }),
    modulo: ve("%", {
      binop: 10,
      startsExpr: le
    }),
    star: ve("*", {
      binop: 10
    }),
    slash: vr("/", 10),
    exponent: ve("**", {
      beforeExpr: $e,
      binop: 11,
      rightAssociative: !0
    }),
    _in: tt("in", {
      beforeExpr: $e,
      binop: 7
    }),
    _instanceof: tt("instanceof", {
      beforeExpr: $e,
      binop: 7
    }),
    _break: tt("break"),
    _case: tt("case", {
      beforeExpr: $e
    }),
    _catch: tt("catch"),
    _continue: tt("continue"),
    _debugger: tt("debugger"),
    _default: tt("default", {
      beforeExpr: $e
    }),
    _else: tt("else", {
      beforeExpr: $e
    }),
    _finally: tt("finally"),
    _function: tt("function", {
      startsExpr: le
    }),
    _if: tt("if"),
    _return: tt("return", {
      beforeExpr: $e
    }),
    _switch: tt("switch"),
    _throw: tt("throw", {
      beforeExpr: $e,
      prefix: Ti,
      startsExpr: le
    }),
    _try: tt("try"),
    _var: tt("var"),
    _const: tt("const"),
    _with: tt("with"),
    _new: tt("new", {
      beforeExpr: $e,
      startsExpr: le
    }),
    _this: tt("this", {
      startsExpr: le
    }),
    _super: tt("super", {
      startsExpr: le
    }),
    _class: tt("class", {
      startsExpr: le
    }),
    _extends: tt("extends", {
      beforeExpr: $e
    }),
    _export: tt("export"),
    _import: tt("import", {
      startsExpr: le
    }),
    _null: tt("null", {
      startsExpr: le
    }),
    _true: tt("true", {
      startsExpr: le
    }),
    _false: tt("false", {
      startsExpr: le
    }),
    _typeof: tt("typeof", {
      beforeExpr: $e,
      prefix: Ti,
      startsExpr: le
    }),
    _void: tt("void", {
      beforeExpr: $e,
      prefix: Ti,
      startsExpr: le
    }),
    _delete: tt("delete", {
      beforeExpr: $e,
      prefix: Ti,
      startsExpr: le
    }),
    _do: tt("do", {
      isLoop: z0,
      beforeExpr: $e
    }),
    _for: tt("for", {
      isLoop: z0
    }),
    _while: tt("while", {
      isLoop: z0
    }),
    _as: Xe("as", {
      startsExpr: le
    }),
    _assert: Xe("assert", {
      startsExpr: le
    }),
    _async: Xe("async", {
      startsExpr: le
    }),
    _await: Xe("await", {
      startsExpr: le
    }),
    _defer: Xe("defer", {
      startsExpr: le
    }),
    _from: Xe("from", {
      startsExpr: le
    }),
    _get: Xe("get", {
      startsExpr: le
    }),
    _let: Xe("let", {
      startsExpr: le
    }),
    _meta: Xe("meta", {
      startsExpr: le
    }),
    _of: Xe("of", {
      startsExpr: le
    }),
    _sent: Xe("sent", {
      startsExpr: le
    }),
    _set: Xe("set", {
      startsExpr: le
    }),
    _source: Xe("source", {
      startsExpr: le
    }),
    _static: Xe("static", {
      startsExpr: le
    }),
    _using: Xe("using", {
      startsExpr: le
    }),
    _yield: Xe("yield", {
      startsExpr: le
    }),
    _asserts: Xe("asserts", {
      startsExpr: le
    }),
    _checks: Xe("checks", {
      startsExpr: le
    }),
    _exports: Xe("exports", {
      startsExpr: le
    }),
    _global: Xe("global", {
      startsExpr: le
    }),
    _implements: Xe("implements", {
      startsExpr: le
    }),
    _intrinsic: Xe("intrinsic", {
      startsExpr: le
    }),
    _infer: Xe("infer", {
      startsExpr: le
    }),
    _is: Xe("is", {
      startsExpr: le
    }),
    _mixins: Xe("mixins", {
      startsExpr: le
    }),
    _proto: Xe("proto", {
      startsExpr: le
    }),
    _require: Xe("require", {
      startsExpr: le
    }),
    _satisfies: Xe("satisfies", {
      startsExpr: le
    }),
    _keyof: Xe("keyof", {
      startsExpr: le
    }),
    _readonly: Xe("readonly", {
      startsExpr: le
    }),
    _unique: Xe("unique", {
      startsExpr: le
    }),
    _abstract: Xe("abstract", {
      startsExpr: le
    }),
    _declare: Xe("declare", {
      startsExpr: le
    }),
    _enum: Xe("enum", {
      startsExpr: le
    }),
    _module: Xe("module", {
      startsExpr: le
    }),
    _namespace: Xe("namespace", {
      startsExpr: le
    }),
    _interface: Xe("interface", {
      startsExpr: le
    }),
    _type: Xe("type", {
      startsExpr: le
    }),
    _opaque: Xe("opaque", {
      startsExpr: le
    }),
    name: ve("name", {
      startsExpr: le
    }),
    string: ve("string", {
      startsExpr: le
    }),
    num: ve("num", {
      startsExpr: le
    }),
    bigint: ve("bigint", {
      startsExpr: le
    }),
    decimal: ve("decimal", {
      startsExpr: le
    }),
    regexp: ve("regexp", {
      startsExpr: le
    }),
    privateName: ve("#name", {
      startsExpr: le
    }),
    eof: ve("eof"),
    jsxName: ve("jsxName"),
    jsxText: ve("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: ve("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: ve("jsxTagEnd"),
    placeholder: ve("%%", {
      startsExpr: !0
    })
  };
  function mt(t) {
    return t >= 93 && t <= 132;
  }
  n(mt, "tokenIsIdentifier");
  function NDe(t) {
    return t <= 92;
  }
  n(NDe, "tokenKeywordOrIdentifierIsKeyword");
  function es(t) {
    return t >= 58 && t <= 132;
  }
  n(es, "tokenIsKeywordOrIdentifier");
  function mN(t) {
    return t >= 58 && t <= 136;
  }
  n(mN, "tokenIsLiteralPropertyName");
  function ODe(t) {
    return Ab[t];
  }
  n(ODe, "tokenComesBeforeExpression");
  function tb(t) {
    return vb[t];
  }
  n(tb, "tokenCanStartExpression");
  function kDe(t) {
    return t >= 29 && t <= 33;
  }
  n(kDe, "tokenIsAssignment");
  function sN(t) {
    return t >= 129 && t <= 131;
  }
  n(sN, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function DDe(t) {
    return t >= 90 && t <= 92;
  }
  n(DDe, "tokenIsLoop");
  function Ib(t) {
    return t >= 58 && t <= 92;
  }
  n(Ib, "tokenIsKeyword");
  function _De(t) {
    return t >= 39 && t <= 59;
  }
  n(_De, "tokenIsOperator");
  function LDe(t) {
    return t === 34;
  }
  n(LDe, "tokenIsPostfix");
  function MDe(t) {
    return Cb[t];
  }
  n(MDe, "tokenIsPrefix");
  function BDe(t) {
    return t >= 121 && t <= 123;
  }
  n(BDe, "tokenIsTSTypeOperator");
  function FDe(t) {
    return t >= 124 && t <= 130;
  }
  n(FDe, "tokenIsTSDeclarationStart");
  function xi(t) {
    return Pb[t];
  }
  n(xi, "tokenLabelName");
  function jc(t) {
    return Eb[t];
  }
  n(jc, "tokenOperatorPrecedence");
  function jDe(t) {
    return t === 57;
  }
  n(jDe, "tokenIsRightAssociative");
  function Vc(t) {
    return t >= 24 && t <= 25;
  }
  n(Vc, "tokenIsTemplate");
  function Fs(t) {
    return js[t];
  }
  n(Fs, "getExportedToken");
  js[8].updateContext = (t) => {
    t.pop();
  }, js[5].updateContext = js[7].updateContext = js[23].updateContext = (t) => {
    t.push(Pt.brace);
  }, js[22].updateContext = (t) => {
    t[t.length - 1] === Pt.template ? t.pop() : t.push(Pt.template);
  }, js[142].updateContext = (t) => {
    t.push(Pt.j_expr, Pt.j_oTag);
  };
  var wb = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  yN = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", RDe = new RegExp("[" + wb + "]"), UDe = new RegExp("[" + wb + yN + "\
]");
  wb = yN = null;
  var TN = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], qDe = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41,
  2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9,
  6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function rb(t, e) {
    let r = 65536;
    for (let s = 0, i = e.length; s < i; s += 2) {
      if (r += e[s], r > t) return !1;
      if (r += e[s + 1], r >= t) return !0;
    }
    return !1;
  }
  n(rb, "isInAstralSet");
  function Rs(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && RDe.test(String.fromCharCode(t)) :
    rb(t, TN);
  }
  n(Rs, "isIdentifierStart");
  function Zn(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && UDe.test(
    String.fromCharCode(t)) : rb(t, TN) || rb(t, qDe);
  }
  n(Zn, "isIdentifierChar");
  var Nb = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, VDe = new Set(Nb.keyword), KDe = new Set(Nb.strict), WDe = new Set(Nb.strictBind);
  function bN(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(bN, "isReservedWord");
  function xN(t, e) {
    return bN(t, e) || KDe.has(t);
  }
  n(xN, "isStrictReservedWord");
  function SN(t) {
    return WDe.has(t);
  }
  n(SN, "isStrictBindOnlyReservedWord");
  function gN(t, e) {
    return xN(t, e) || SN(t);
  }
  n(gN, "isStrictBindReservedWord");
  function YDe(t) {
    return VDe.has(t);
  }
  n(YDe, "isKeyword");
  function JDe(t, e, r) {
    return t === 64 && e === 64 && Rs(r);
  }
  n(JDe, "isIteratorStart");
  var XDe = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function $De(t) {
    return XDe.has(t);
  }
  n($De, "canBeReservedWord");
  var Ho = class {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
    }
  }, zo = class {
    static {
      n(this, "ScopeHandler");
    }
    constructor(e, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let e = this.currentThisScopeFlags();
      return (e & 64) > 0 && (e & 2) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 128)
          return !0;
        if (r & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new Ho(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
    }
    declareName(e, r, s) {
      let i = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(i, e, r, s);
        let a = i.names.get(e) || 0;
        r & 16 ? a = a | 4 : (i.firstLexicalName || (i.firstLexicalName = e), a = a | 2), i.names.set(e, a), r & 8 && this.maybeExportDefined(
        i, e);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (i = this.scopeStack[a], this.checkRedeclarationInScope(i, e, r, s), i.names.set(
        e, (i.names.get(e) || 0) | 1), this.maybeExportDefined(i, e), !(i.flags & 387)); --a)
          ;
      this.parser.inModule && i.flags & 1 && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, r) {
      this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(e, r, s, i) {
      this.isRedeclaredInScope(e, r, s) && this.parser.raise(B.VarRedeclaration, i, {
        identifierName: r
      });
    }
    isRedeclaredInScope(e, r, s) {
      if (!(s & 1)) return !1;
      if (s & 8)
        return e.names.has(r);
      let i = e.names.get(r);
      return s & 16 ? (i & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (i & 1) > 0 : (i & 2) > 0 && !(e.flags & 8 && e.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(e) && (i & 4) > 0;
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 387)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 451 && !(r & 4))
          return r;
      }
    }
  }, sb = class extends Ho {
    static {
      n(this, "FlowScope");
    }
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, ib = class extends zo {
    static {
      n(this, "FlowScopeHandler");
    }
    createScope(e) {
      return new sb(e);
    }
    declareName(e, r, s) {
      let i = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(i, e, r, s), this.maybeExportDefined(i, e), i.declareFunctions.add(e);
        return;
      }
      super.declareName(e, r, s);
    }
    isRedeclaredInScope(e, r, s) {
      if (super.isRedeclaredInScope(e, r, s)) return !0;
      if (s & 2048 && !e.declareFunctions.has(r)) {
        let i = e.names.get(r);
        return (i & 4) > 0 || (i & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }, nb = class {
    static {
      n(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        let [r, s] = e;
        if (!this.hasPlugin(r))
          return !1;
        let i = this.plugins.get(r);
        for (let a of Object.keys(s))
          if (i?.[a] !== s[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(e, r) {
      var s;
      return (s = this.plugins.get(e)) == null ? void 0 : s[r];
    }
  };
  function PN(t, e) {
    t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
  }
  n(PN, "setTrailingComments");
  function HDe(t, e) {
    t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
  }
  n(HDe, "setLeadingComments");
  function Go(t, e) {
    t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
  }
  n(Go, "setInnerComments");
  function Wo(t, e, r) {
    let s = null, i = e.length;
    for (; s === null && i > 0; )
      s = e[--i];
    s === null || s.start > r.start ? Go(t, r.comments) : PN(s, r.comments);
  }
  n(Wo, "adjustInnerComments");
  var ab = class extends nb {
    static {
      n(this, "CommentsParser");
    }
    addComment(e) {
      this.filename && (e.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length !== r && (this.comments.length = r), this.comments.push(e), this.state.commentsLen++;
    }
    processComment(e) {
      let {
        commentStack: r
      } = this.state, s = r.length;
      if (s === 0) return;
      let i = s - 1, a = r[i];
      a.start === e.end && (a.leadingNode = e, i--);
      let {
        start: o
      } = e;
      for (; i >= 0; i--) {
        let l = r[i], u = l.end;
        if (u > o)
          l.containingNode = e, this.finalizeComment(l), r.splice(i, 1);
        else {
          u === o && (l.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      let {
        comments: r
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && PN(e.leadingNode, r), e.trailingNode !== null && HDe(e.trailingNode, r);
      else {
        let {
          containingNode: s,
          start: i
        } = e;
        if (this.input.charCodeAt(i - 1) === 44)
          switch (s.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Wo(s, s.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Wo(s, s.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Wo(s, s.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Wo(s, s.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Wo(s, s.specifiers, e);
              break;
            default:
              Go(s, r);
          }
        else
          Go(s, r);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: e
      } = this.state;
      for (let r = e.length - 1; r >= 0; r--)
        this.finalizeComment(e[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      if (s === 0) return;
      let i = r[s - 1];
      i.leadingNode === e && (i.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      s !== 0 && (r[s - 1].trailingNode === e ? r[s - 1].trailingNode = null : s >= 2 && r[s - 2].trailingNode === e && (r[s - 2].trailingNode =
      null));
    }
    takeSurroundingComments(e, r, s) {
      let {
        commentStack: i
      } = this.state, a = i.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = i[o], u = l.end;
        if (l.start === s)
          l.leadingNode = e;
        else if (u === r)
          l.trailingNode = e;
        else if (u < r)
          break;
      }
    }
  }, EN = /\r\n?|[\n\u2028\u2029]/, Mc = new RegExp(EN.source, "g");
  function $o(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  n($o, "isNewLine");
  var G0 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Rc = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, iN = new RegExp("(?=(" + Rc.source + "))\\\
1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function zDe(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  n(zDe, "isWhitespace");
  var ob = class t {
    static {
      n(this, "State");
    }
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.
      potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [Pt.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(e) {
      e ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: e,
      sourceType: r,
      startLine: s,
      startColumn: i
    }) {
      this.strict = e === !1 ? !1 : e === !0 ? !0 : r === "module", this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new hs(
      s, i, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(e) {
      e ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(e) {
      e ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(e) {
      e ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(e) {
      e ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(e) {
      e ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(e) {
      e ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(e) {
      e ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(e) {
      e ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(e) {
      e ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(e) {
      e ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(e) {
      e ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new hs(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let e = new t();
      return e.flags = this.flags, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.startLoc, e.endLoc = this.endLoc,
      e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.slice(), e.noArrowParamsConversionAt =
      this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.slice(), e.commentsLen = this.commentsLen,
      e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value = this.value, e.start = this.start, e.end = this.
      end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.context = this.context.slice(), e.firstInvalidTemplateEscapePos =
      this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors, e.tokensLength = this.tokensLength, e;
    }
  }, GDe = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), nN = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Bc = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function aN(t, e, r, s, i, a) {
    let o = r, l = s, u = i, c = "", p = null, f = r, {
      length: m
    } = e;
    for (; ; ) {
      if (r >= m) {
        a.unterminated(o, l, u), c += e.slice(f, r);
        break;
      }
      let y = e.charCodeAt(r);
      if (QDe(t, y, e, r)) {
        c += e.slice(f, r);
        break;
      }
      if (y === 92) {
        c += e.slice(f, r);
        let T = ZDe(e, r, s, i, t === "template", a);
        T.ch === null && !p ? p = {
          pos: r,
          lineStart: s,
          curLine: i
        } : c += T.ch, {
          pos: r,
          lineStart: s,
          curLine: i
        } = T, f = r;
      } else y === 8232 || y === 8233 ? (++r, ++i, s = r) : y === 10 || y === 13 ? t === "template" ? (c += e.slice(f, r) + `
`, ++r, y === 13 && e.charCodeAt(r) === 10 && ++r, ++i, f = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: s,
      curLine: i,
      containsInvalid: !!p
    };
  }
  n(aN, "readStringContents");
  function QDe(t, e, r, s) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(s + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(QDe, "isStringEnd");
  function ZDe(t, e, r, s, i, a) {
    let o = !i;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = lb(t, e, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = vN(t, e, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (i)
          return l(null);
        a.strictNumericEscape(e - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, f = t.slice(c, e + 2).match(/^[0-7]+/)[0], m = parseInt(f, 8);
          m > 255 && (f = f.slice(0, -1), m = parseInt(f, 8)), e += f.length - 1;
          let y = t.charCodeAt(e);
          if (f !== "0" || y === 56 || y === 57) {
            if (i)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(m));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(ZDe, "readEscapedChar");
  function lb(t, e, r, s, i, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = AN(t, e, r, s, 16, i, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(lb, "readHexChar");
  function AN(t, e, r, s, i, a, o, l, u, c) {
    let p = e, f = i === 16 ? nN.hex : nN.decBinOct, m = i === 16 ? Bc.hex : i === 10 ? Bc.dec : i === 8 ? Bc.oct : Bc.bin, y = !1, T = 0;
    for (let L = 0, q = a ?? 1 / 0; L < q; ++L) {
      let _ = t.charCodeAt(e), U;
      if (_ === 95 && l !== "bail") {
        let J = t.charCodeAt(e - 1), ie = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(ie) || !m(ie) || f.has(J) || f.has(ie)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, s);
        }
        ++e;
        continue;
      }
      if (_ >= 97 ? U = _ - 97 + 10 : _ >= 65 ? U = _ - 65 + 10 : GDe(_) ? U = _ - 48 : U = 1 / 0, U >= i) {
        if (U <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (U <= 9 && u.invalidDigit(e, r, s, i))
          U = 0;
        else if (o)
          U = 0, y = !0;
        else
          break;
      }
      ++e, T = T * i + U;
    }
    return e === p || a != null && e - p !== a || y ? {
      n: null,
      pos: e
    } : {
      n: T,
      pos: e
    };
  }
  n(AN, "readInt");
  function vN(t, e, r, s, i, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = lb(t, e, r, s, t.indexOf("}", e) - e, !0, i, a), ++e, l !== null && l > 1114111)
        if (i)
          a.invalidCodePoint(e, r, s);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = lb(t, e, r, s, 4, !1, i, a));
    return {
      code: l,
      pos: e
    };
  }
  n(vN, "readCodePoint");
  function Yo(t, e, r) {
    return new hs(r, t - e, t);
  }
  n(Yo, "buildPosition");
  var e_e = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), fs = class {
    static {
      n(this, "Token");
    }
    constructor(e) {
      this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, this.loc = new ta(e.startLoc, e.endLoc);
    }
  }, ub = class extends ab {
    static {
      n(this, "Tokenizer");
    }
    constructor(e, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ n((s, i, a, o) => this.options.errorRecovery ? (this.raise(B.InvalidDigit, Yo(s, i, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(B.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(B.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(B.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(B.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ n((s, i, a) => {
          this.recordStrictModeErrors(B.StrictNumericEscape, Yo(s, i, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ n((s, i, a) => {
          throw this.raise(B.UnterminatedString, Yo(s - 1, i, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(B.StrictNumericEscape),
        unterminated: /* @__PURE__ */ n((s, i, a) => {
          throw this.raise(B.UnterminatedTemplate, Yo(s, i, a));
        }, "unterminated")
      }), this.state = new ob(), this.state.init(e), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new fs(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.
      state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      let e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = e, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return G0.lastIndex = e, G0.test(this.input) ? G0.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e) {
      return Rc.lastIndex = e, Rc.test(this.input) ? Rc.lastIndex : e;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e) {
      let r = this.input.charCodeAt(e);
      if ((r & 64512) === 55296 && ++e < this.input.length) {
        let s = this.input.charCodeAt(e);
        (s & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (s & 1023));
      }
      return r;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([r, s]) => this.raise(r, s)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let s = this.state.pos, i = this.input.indexOf(e, s + 2);
      if (i === -1)
        throw this.raise(B.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = i + e.length, Mc.lastIndex = s + 2; Mc.test(this.input) && Mc.lastIndex <= i; )
        ++this.state.curLine, this.state.lineStart = Mc.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(s + 2, i),
        start: s,
        end: i + e.length,
        loc: new ta(r, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(a), a;
    }
    skipLineComment(e) {
      let r = this.state.pos, s;
      this.isLookahead || (s = this.state.curPosition());
      let i = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !$o(i) && ++this.state.pos < this.length; )
          i = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(r + e, a),
        start: r,
        end: a,
        loc: new ta(s, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(l), l;
    }
    skipSpace() {
      let e = this.state.pos, r = [];
      e: for (; this.state.pos < this.length; ) {
        let s = this.input.charCodeAt(this.state.pos);
        switch (s) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let i = this.skipBlockComment("*/");
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              case 47: {
                let i = this.skipLineComment(2);
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (zDe(s))
              ++this.state.pos;
            else if (s === 45 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else if (s === 60 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r.length > 0) {
        let s = this.state.pos, i = {
          start: e,
          end: s,
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(i);
      }
    }
    finishToken(e, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let s = this.state.type;
      this.state.type = e, this.state.value = r, this.isLookahead || this.updateContext(s);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let e = this.state.pos + 1, r = this.codePointAtPos(e);
      if (r >= 48 && r <= 57)
        throw this.raise(B.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? B.RecordExpressionHashIncorrectStartSyntaxType : B.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else Rs(r) ? (++this.state.pos, this.finishToken(138, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(138, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(!0);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !$o(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      let s = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, s), !0;
    }
    readToken_mult_modulo(e) {
      let r = e === 42 ? 55 : 54, s = 1, i = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && i === 42 && (s++, i = this.input.charCodeAt(this.state.pos + 2), r = 57), i === 61 && !this.state.inType && (s++, r = e ===
      37 ? 33 : 30), this.finishOp(r, s);
    }
    readToken_pipe_amp(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(B.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(B.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 62) {
        let s = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + s) === 61) {
          this.finishOp(30, s + 1);
          return;
        }
        this.finishOp(52, s);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let e = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(B.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(B.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Rs(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(B.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, r) {
      let s = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(e, s);
    }
    readRegexp() {
      let e = this.state.startLoc, r = this.state.start + 1, s, i, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(B.UnterminatedRegExp, Cr(e, 1));
        let c = this.input.charCodeAt(a);
        if ($o(c))
          throw this.raise(B.UnterminatedRegExp, Cr(e, 1));
        if (s)
          s = !1;
        else {
          if (c === 91)
            i = !0;
          else if (c === 93 && i)
            i = !1;
          else if (c === 47 && !i)
            break;
          s = c === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let l = "", u = /* @__PURE__ */ n(() => Cr(e, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (e_e.has(c))
          c === 118 ? l.includes("u") && this.raise(B.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(B.IncompatibleRegExpUVFlags,
          u()), l.includes(p) && this.raise(B.DuplicateRegExpFlags, u());
        else if (Zn(c) || c === 92)
          this.raise(B.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += p;
      }
      this.state.pos = a, this.finishToken(137, {
        pattern: o,
        flags: l
      });
    }
    readInt(e, r, s = !1, i = !0) {
      let {
        n: a,
        pos: o
      } = AN(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, r, s, i, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(e) {
      let r = this.state.curPosition(), s = !1;
      this.state.pos += 2;
      let i = this.readInt(e);
      i == null && this.raise(B.InvalidDigit, Cr(r, 2), {
        radix: e
      });
      let a = this.input.charCodeAt(this.state.pos);
      if (a === 110)
        ++this.state.pos, s = !0;
      else if (a === 109)
        throw this.raise(B.InvalidDecimal, r);
      if (Rs(this.codePointAtPos(this.state.pos)))
        throw this.raise(B.NumberIdentifier, this.state.curPosition());
      if (s) {
        let o = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, o);
        return;
      }
      this.finishToken(134, i);
    }
    readNumber(e) {
      let r = this.state.pos, s = this.state.curPosition(), i = !1, a = !1, o = !1, l = !1, u = !1;
      !e && this.readInt(10) === null && this.raise(B.InvalidNumber, this.state.curPosition());
      let c = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (c) {
        let y = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(B.StrictOctalLiteral, s), !this.state.strict) {
          let T = y.indexOf("_");
          T > 0 && this.raise(B.ZeroDigitNumericSeparator, Cr(s, T));
        }
        u = c && !/[89]/.test(y);
      }
      let p = this.input.charCodeAt(this.state.pos);
      if (p === 46 && !u && (++this.state.pos, this.readInt(10), i = !0, p = this.input.charCodeAt(this.state.pos)), (p === 69 || p === 101) &&
      !u && (p = this.input.charCodeAt(++this.state.pos), (p === 43 || p === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      B.InvalidOrMissingExponent, s), i = !0, l = !0, p = this.input.charCodeAt(this.state.pos)), p === 110 && ((i || c) && this.raise(B.InvalidBigIntLiteral,
      s), ++this.state.pos, a = !0), p === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (l || c) && this.raise(B.InvalidDecimal,
      s), ++this.state.pos, o = !0), Rs(this.codePointAtPos(this.state.pos)))
        throw this.raise(B.NumberIdentifier, this.state.curPosition());
      let f = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(135, f);
        return;
      }
      if (o) {
        this.finishToken(136, f);
        return;
      }
      let m = u ? parseInt(f, 8) : parseFloat(f);
      this.finishToken(134, m);
    }
    readCodePoint(e) {
      let {
        code: r,
        pos: s
      } = vN(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
      return this.state.pos = s, r;
    }
    readString(e) {
      let {
        str: r,
        pos: s,
        curLine: i,
        lineStart: a
      } = aN(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = i, this.finishToken(133, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: s,
        pos: i,
        curLine: a,
        lineStart: o
      } = aN("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = i + 1, this.state.lineStart = o, this.state.curLine = a, s && (this.state.firstInvalidTemplateEscapePos = new hs(s.curLine,
      s.pos - s.lineStart, s.pos)), this.input.codePointAt(i) === 96 ? this.finishToken(24, s ? null : e + r + "`") : (this.state.pos++, this.
      finishToken(25, s ? null : e + r + "${"));
    }
    recordStrictModeErrors(e, r) {
      let s = r.index;
      this.state.strict && !this.state.strictErrors.has(s) ? this.raise(e, r) : this.state.strictErrors.set(s, [e, r]);
    }
    readWord1(e) {
      this.state.containsEsc = !1;
      let r = "", s = this.state.pos, i = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (Zn(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(i, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === s ? Rs : Zn;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(B.MissingUnicodeEscape, this.state.curPosition()), i = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(B.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(u)), i = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(i, this.state.pos);
    }
    readWord(e) {
      let r = this.readWord1(e), s = gb.get(r);
      s !== void 0 ? this.finishToken(s, xi(s)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: e
      } = this.state;
      Ib(e) && this.state.containsEsc && this.raise(B.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: xi(e)
      });
    }
    raise(e, r, s = {}) {
      let i = r instanceof hs ? r : r.loc.start, a = e(i, s);
      if (!this.options.errorRecovery) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(e, r, s = {}) {
      let i = r instanceof hs ? r : r.loc.start, a = i.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = e(i, s);
        if (u.loc.index < a) break;
      }
      return this.raise(e, r, s);
    }
    updateContext(e) {
    }
    unexpected(e, r) {
      throw this.raise(B.UnexpectedToken, e ?? this.state.startLoc, {
        expected: r ? xi(r) : null
      });
    }
    expectPlugin(e, r) {
      if (this.hasPlugin(e))
        return !0;
      throw this.raise(B.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((r) => this.hasPlugin(r)))
        throw this.raise(B.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: e
        });
    }
    errorBuilder(e) {
      return (r, s, i) => {
        this.raise(e, Yo(r, s, i));
      };
    }
  }, cb = class {
    static {
      n(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, pb = class {
    static {
      n(this, "ClassScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new cb());
    }
    exit() {
      let e = this.stack.pop(), r = this.current();
      for (let [s, i] of Array.from(e.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(s) || r.undefinedPrivateNames.set(s, i) : this.parser.raise(B.InvalidPrivateFieldResolution, i, {
          identifierName: s
        });
    }
    declarePrivateName(e, r, s) {
      let {
        privateNames: i,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = i.has(e);
      if (r & 3) {
        let u = l && a.get(e);
        if (u) {
          let c = u & 4, p = r & 4, f = u & 3, m = r & 3;
          l = f === m || c !== p, l || a.delete(e);
        } else l || a.set(e, r);
      }
      l && this.parser.raise(B.PrivateNameRedeclaration, s, {
        identifierName: e
      }), i.add(e), o.delete(e);
    }
    usePrivateName(e, r) {
      let s;
      for (s of this.stack)
        if (s.privateNames.has(e)) return;
      s ? s.undefinedPrivateNames.set(e, r) : this.parser.raise(B.InvalidPrivateFieldResolution, r, {
        identifierName: e
      });
    }
  }, ra = class {
    static {
      n(this, "ExpressionScope");
    }
    constructor(e = 0) {
      this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, Kc = class extends ra {
    static {
      n(this, "ArrowHeadParsingScope");
    }
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, r) {
      let s = r.index;
      this.declarationErrors.set(s, [e, r]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }, fb = class {
    static {
      n(this, "ExpressionScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [new ra()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, r) {
      let s = r.loc.start, {
        stack: i
      } = this, a = i.length - 1, o = i[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(e, s);
        else
          return;
        o = i[--a];
      }
      this.parser.raise(e, s);
    }
    recordArrowParameterBindingError(e, r) {
      let {
        stack: s
      } = this, i = s[s.length - 1], a = r.loc.start;
      if (i.isCertainlyParameterDeclaration())
        this.parser.raise(e, a);
      else if (i.canBeArrowParameterDeclaration())
        i.recordDeclarationError(e, a);
      else
        return;
    }
    recordAsyncArrowParametersError(e) {
      let {
        stack: r
      } = this, s = r.length - 1, i = r[s];
      for (; i.canBeArrowParameterDeclaration(); )
        i.type === 2 && i.recordDeclarationError(B.AwaitBindingIdentifier, e), i = r[--s];
    }
    validateAsPattern() {
      let {
        stack: e
      } = this, r = e[e.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([s, i]) => {
        this.parser.raise(s, i);
        let a = e.length - 2, o = e[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(i.index), o = e[--a];
      });
    }
  };
  function t_e() {
    return new ra(3);
  }
  n(t_e, "newParameterDeclarationScope");
  function r_e() {
    return new Kc(1);
  }
  n(r_e, "newArrowHeadScope");
  function s_e() {
    return new Kc(2);
  }
  n(s_e, "newAsyncArrowScope");
  function CN() {
    return new ra();
  }
  n(CN, "newExpressionScope");
  var hb = class {
    static {
      n(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function Uc(t, e) {
    return (t ? 2 : 0) | (e ? 1 : 0);
  }
  n(Uc, "functionFlags");
  var db = class extends ub {
    static {
      n(this, "UtilParser");
    }
    addExtra(e, r, s, i = !0) {
      if (!e) return;
      let a = e.extra = e.extra || {};
      i ? a[r] = s : Object.defineProperty(a, r, {
        enumerable: i,
        value: s
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, r) {
      let s = e + r.length;
      if (this.input.slice(e, s) === r) {
        let i = this.input.charCodeAt(s);
        return !(Zn(i) || (i & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(e) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1;
    }
    expectContextual(e, r) {
      if (!this.eatContextual(e)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, e);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return EN.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return iN.lastIndex = this.state.end, iN.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = !0) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(B.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e, r) {
      this.eat(e) || this.unexpected(r, e);
    }
    tryParse(e, r = this.state.clone()) {
      let s = {
        node: null
      };
      try {
        let i = e((a = null) => {
          throw s.node = a, s;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: i,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: i,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (i) {
        let a = this.state;
        if (this.state = r, i instanceof SyntaxError)
          return {
            node: null,
            error: i,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (i === s)
          return {
            node: s.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw i;
      }
    }
    checkExpressionErrors(e, r) {
      if (!e) return !1;
      let {
        shorthandAssignLoc: s,
        doubleProtoLoc: i,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = e, l = !!s || !!i || !!o || !!a;
      if (!r)
        return l;
      s != null && this.raise(B.InvalidCoverInitializedName, s), i != null && this.raise(B.DuplicateProto, i), a != null && this.raise(B.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return mN(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let s = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let i = this.inModule;
      this.inModule = e;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, e);
      let l = this.prodParam;
      this.prodParam = new hb();
      let u = this.classScope;
      this.classScope = new pb(this);
      let c = this.expressionScope;
      return this.expressionScope = new fb(this), () => {
        this.state.labels = r, this.exportedIdentifiers = s, this.inModule = i, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let e = 0;
      this.inModule && (e |= 2), this.scope.enter(1), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      let {
        privateKeyLoc: r
      } = e;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, ea = class {
    static {
      n(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, sa = class {
    static {
      n(this, "Node");
    }
    constructor(e, r, s) {
      this.type = "", this.start = r, this.end = 0, this.loc = new ta(s), e != null && e.options.ranges && (this.range = [r, 0]), e != null &&
      e.filename && (this.loc.filename = e.filename);
    }
  }, Ob = sa.prototype;
  Ob.__clone = function() {
    let t = new sa(void 0, this.start, this.loc.start), e = Object.keys(this);
    for (let r = 0, s = e.length; r < s; r++) {
      let i = e[r];
      i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (t[i] = this[i]);
    }
    return t;
  };
  function i_e(t) {
    return qs(t);
  }
  n(i_e, "clonePlaceholder");
  function qs(t) {
    let {
      type: e,
      start: r,
      end: s,
      loc: i,
      range: a,
      extra: o,
      name: l
    } = t, u = Object.create(Ob);
    return u.type = e, u.start = r, u.end = s, u.loc = i, u.range = a, u.extra = o, u.name = l, e === "Placeholder" && (u.expectedNode = t.expectedNode),
    u;
  }
  n(qs, "cloneIdentifier");
  function n_e(t) {
    let {
      type: e,
      start: r,
      end: s,
      loc: i,
      range: a,
      extra: o
    } = t;
    if (e === "Placeholder")
      return i_e(t);
    let l = Object.create(Ob);
    return l.type = e, l.start = r, l.end = s, l.loc = i, l.range = a, t.raw !== void 0 ? l.raw = t.raw : l.extra = o, l.value = t.value, l;
  }
  n(n_e, "cloneStringLiteral");
  var mb = class extends db {
    static {
      n(this, "NodeUtils");
    }
    startNode() {
      let e = this.state.startLoc;
      return new sa(this, e.index, e);
    }
    startNodeAt(e) {
      return new sa(this, e.index, e);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.loc.start);
    }
    finishNode(e, r) {
      return this.finishNodeAt(e, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, r, s) {
      return e.type = r, e.end = s.index, e.loc.end = s, this.options.ranges && (e.range[1] = s.index), this.options.attachComment && this.processComment(
      e), e;
    }
    resetStartLocation(e, r) {
      e.start = r.index, e.loc.start = r, this.options.ranges && (e.range[0] = r.index);
    }
    resetEndLocation(e, r = this.state.lastTokEndLoc) {
      e.end = r.index, e.loc.end = r, this.options.ranges && (e.range[1] = r.index);
    }
    resetStartLocationFromNode(e, r) {
      this.resetStartLocation(e, r.loc.start);
    }
  }, a_e = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "sta\
tic", "string", "true", "typeof", "void"]), ke = Us`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Cannot overwrite reserved type ${t}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Boolean enum members need to be initialized. Use either \`${t} = true,\` or \`${t} = false,\` in enum \`${e}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Enum member names need to be unique, but the name \`${t}\` has already been used before in enum \`${e}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ n(({
      enumName: t
    }) => `Enum \`${t}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ n(({
      invalidEnumType: t,
      enumName: e
    }) => `Enum type \`${t}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ n(({
      enumName: t
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      explicitType: r
    }) => `Enum \`${t}\` has type \`${r}\`, so the initializer of \`${e}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${t}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${t}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${r}\`, in enum \`${t}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${t}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ n(({
      enumName: t
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Unexpected reserved type ${t}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ n(({
      unsupportedExportKind: t,
      suggestion: e
    }) => `\`declare export ${t}\` is not supported. Use \`${e}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function o_e(t) {
    return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "T\
ypeAlias" && t.declaration.type !== "InterfaceDeclaration");
  }
  n(o_e, "isEsModuleType");
  function oN(t) {
    return t.importKind === "type" || t.importKind === "typeof";
  }
  n(oN, "hasTypeImportKind");
  var l_e = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function u_e(t, e) {
    let r = [], s = [];
    for (let i = 0; i < t.length; i++)
      (e(t[i], i, t) ? r : s).push(t[i]);
    return [r, s];
  }
  n(u_e, "partition");
  var c_e = /\*?\s*@((?:no)?flow)\b/, p_e = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return ib;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(r, s) {
      r !== 133 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, s);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let s = c_e.exec(r.value);
        if (s) if (s[1] === "flow")
          this.flowPragma = "flow";
        else if (s[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let s = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let i = this.flowParseType();
      return this.state.inType = s, i;
    }
    flowParsePredicate() {
      let r = this.startNode(), s = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(ke.UnexpectedSpaceBetweenModuloChecks,
      s), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let s = null, i = null;
      return this.match(54) ? (this.state.inType = r, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = r, this.
      match(54) && (i = this.flowParsePredicate())), [s, i];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let s = r.id = this.parseIdentifier(), i = this.startNode(), a = this.startNode();
      this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return i.params = o.params, i.rest = o.rest, i.this = o._this, this.expect(11), [i.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      s), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, s) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (s && this.raise(ke.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, s);
      this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(133) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let s = r.body = this.startNode(), i = s.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(ke.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, ke.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), i.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
      let a = null, o = !1;
      return i.forEach((l) => {
        o_e(l) ? (a === "CommonJS" && this.raise(ke.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(ke.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(ke.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, s) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
        let i = this.state.value;
        throw this.raise(ke.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: i,
          suggestion: l_e[i]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.
        exportKind), r.type = "Declare" + r.type, r;
      this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let s = this.flowParseTypeAlias(r);
      return s.type = "DeclareTypeAlias", s;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let s = this.flowParseOpaqueType(r, !0);
      return s.type = "DeclareOpaqueType", s;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, s) {
      if (r.id = this.flowParseRestrictedIdentifier(!s, !0), this.scope.declareName(r.id.name, s ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!s && this.eat(12));
      if (s) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: s,
        allowExact: !1,
        allowSpread: !1,
        allowProto: s,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(ke.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, s, i) {
      a_e.has(r) && this.raise(i ? ke.AssignReservedType : ke.UnexpectedReservedType, s, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, s) {
      return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, s) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, s || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let s = this.state.startLoc, i = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return i.name = o.name, i.variance = a, i.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) :
      r && this.raise(ke.MissingTypeParamDefault, s), this.finishNode(i, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, s = this.startNode();
      s.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = !1;
      do {
        let a = this.flowParseTypeParameter(i);
        s.params.push(a), a.default && (i = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(s, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), s = this.state.inType;
      r.params = [], this.state.inType = !0, this.expect(47);
      let i = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let r = this.startNode(), s = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, s, i) {
      return r.static = s, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = i, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, s) {
      return r.static = s, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, s) {
      let i = this.startNode();
      return r.static = s, r.value = this.flowParseObjectTypeMethodish(i), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: s,
      allowSpread: i,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, p, f = !1;
      for (s && this.match(6) ? (this.expect(6), c = 9, p = !0) : (this.expect(5), c = 8, p = !1), u.exact = p; !this.match(c); ) {
        let y = !1, T = null, L = null, q = this.startNode();
        if (a && this.isContextual(118)) {
          let U = this.lookahead();
          U.type !== 14 && U.type !== 17 && (this.next(), T = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let U = this.lookahead();
          U.type !== 14 && U.type !== 17 && (this.next(), y = !0);
        }
        let _ = this.flowParseVariance();
        if (this.eat(0))
          T != null && this.unexpected(T), this.eat(0) ? (_ && this.unexpected(_.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          q, y))) : u.indexers.push(this.flowParseObjectTypeIndexer(q, y, _));
        else if (this.match(10) || this.match(47))
          T != null && this.unexpected(T), _ && this.unexpected(_.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(q, y));
        else {
          let U = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let ie = this.lookahead();
            mN(ie.type) && (U = this.state.value, this.next());
          }
          let J = this.flowParseObjectTypeProperty(q, y, T, _, U, i, o ?? !p);
          J === null ? (f = !0, L = this.state.lastTokStartLoc) : u.properties.push(J);
        }
        this.flowObjectTypeSemicolon(), L && !this.match(8) && !this.match(9) && this.raise(ke.UnexpectedExplicitInexactInObject, L);
      }
      this.expect(c), i && (u.inexact = f);
      let m = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, m;
    }
    flowParseObjectTypeProperty(r, s, i, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(ke.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(ke.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(ke.InexactVariance, a), null) : (l || this.raise(
        ke.UnexpectedSpreadType, this.state.lastTokStartLoc), i != null && this.unexpected(i), a && this.raise(ke.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = s, r.proto = i != null, r.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, i != null && this.unexpected(i), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !l && r.key.name === "constructor" && r.value.this && this.raise(ke.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (c = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = c, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let s = r.kind === "get" ? 0 : 1, i = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? ke.GetterMayNotHaveThisParam : ke.SetterMayNotHaveThisParam, r.value.this), i !== s && this.
      raise(r.kind === "get" ? B.BadGetterArity : B.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(B.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, s) {
      var i;
      (i = r) != null || (r = this.state.startLoc);
      let a = s || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let o = this.startNodeAt(r);
        o.qualification = a, o.id = this.flowParseRestrictedIdentifier(!0), a = this.finishNode(o, "QualifiedTypeIdentifier");
      }
      return a;
    }
    flowParseGenericType(r, s) {
      let i = this.startNodeAt(r);
      return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(r, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(i, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let s = null, i = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !r && this.raise(ke.ThisParamMustBeFirst, o), s = this.parseIdentifier(u), this.eat(17) &&
      (i = !0, u && this.raise(ke.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = s,
      o.optional = i, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let s = this.startNodeAt(r.loc.start);
      return s.name = null, s.optional = !1, s.typeAnnotation = r, this.finishNode(s, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let s = null, i = null;
      for (this.match(78) && (i = this.flowParseFunctionTypeParam(!0), i.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (s = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: s,
        _this: i
      };
    }
    flowIdentToTypeAnnotation(r, s, i) {
      switch (i.name) {
        case "any":
          return this.finishNode(s, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(s, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(s, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(s, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(s, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(s, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(s, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(i.name), this.flowParseGenericType(r, i);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, s = this.startNode(), i, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47: {
          let u = this.startNode();
          return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), u.params =
          i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(
          u, "FunctionTypeAnnotation");
        }
        case 10: {
          let u = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (mt(this.state.type) || this.match(78)) {
              let c = this.lookahead().type;
              o = c !== 17 && c !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : i = this.flowParseFunctionTypeParams(),
          u.params = i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters =
          null, this.finishNode(u, "FunctionTypeAnnotation");
        }
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
            throw this.raise(ke.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(s, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(s, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Ib(this.state.type)) {
            let u = xi(this.state.type);
            return this.next(), super.createIdentifier(s, u);
          } else if (mt(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, s, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, s = this.flowParsePrimaryType(), i = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        i = i || o, this.expect(0), !o && this.match(3) ? (a.elementType = s, this.next(), s = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = s, a.indexType = this.flowParseType(), this.expect(3), i ? (a.optional = o, s = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : s = this.finishNode(a, "IndexedAccessType"));
      }
      return s;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let s = this.startNodeAt(r.loc.start);
        return s.params = [this.reinterpretTypeAsFunctionTypeParam(r)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.
        typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let s = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [s]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? s : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let s = this.flowParseIntersectionType();
      for (r.types = [s]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? s : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let s = this.flowParseUnionType();
      return this.state.inType = r, s;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, s = this.parseIdentifier();
        return this.flowParseGenericType(r, s);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let s = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, s, i = !1) {
      if (s) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, i));
        return;
      }
      super.parseFunctionBody(r, !1, i);
    }
    parseFunctionBodyAndFinish(r, s, i = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, s, i);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let i = this.lookahead();
        if (es(i.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      }
      let s = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
    }
    parseExpressionStatement(r, s, i) {
      if (s.type === "Identifier") {
        if (s.name === "declare") {
          if (this.match(80) || mt(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (mt(this.state.type)) {
          if (s.name === "interface")
            return this.flowParseInterface(r);
          if (s.name === "type")
            return this.flowParseTypeAlias(r);
          if (s.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, s, i);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return sN(r) || this.shouldParseEnums() && r === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return sN(r) || this.shouldParseEnums() && r === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, s, i) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let m = this.lookaheadCharCode();
        if (m === 44 || m === 61 || m === 58 || m === 41)
          return this.setOptionalParametersError(i), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(s), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [p, f] = this.getArrowLikeExpressions(u);
      if (c || f.length > 0) {
        let m = [...o];
        if (f.length > 0) {
          this.state = a, this.state.noArrowAt = m;
          for (let y = 0; y < f.length; y++)
            m.push(f[y].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [p, f] = this.getArrowLikeExpressions(u);
        }
        c && p.length > 1 && this.raise(ke.AmbiguousConditionalArrow, a.startLoc), c && p.length === 1 && (this.state = a, m.push(p[0].start),
        this.state.noArrowAt = m, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = r, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), s = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: s
      };
    }
    getArrowLikeExpressions(r, s) {
      let i = [r], a = [];
      for (; i.length !== 0; ) {
        let o = i.pop();
        o.type === "ArrowFunctionExpression" && o.body.type !== "BlockStatement" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(
        o) : a.push(o), i.push(o.body)) : o.type === "ConditionalExpression" && (i.push(o.consequent), i.push(o.alternate));
      }
      return s ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : u_e(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(r) {
      var s;
      this.toAssignableList(r.params, (s = r.extra) == null ? void 0 : s.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, s) {
      let i;
      return this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), i =
      s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
    }
    parseParenItem(r, s) {
      let i = super.parseParenItem(r, s);
      if (this.eat(17) && (i.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(s);
        return a.expression = i, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
      }
      return i;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        s);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseOpaqueType(s, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseInterface(s);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        r.exportKind = "value";
        let s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: s
      } = this.state, i = super.maybeParseExportNamespaceSpecifier(r);
      return i && r.exportKind === "type" && this.unexpected(s), i;
    }
    parseClassId(r, s, i) {
      super.parseClassId(r, s, i), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, s, i) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, s))
          return;
        s.declare = !0;
      }
      super.parseClassMember(r, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "Property\
Definition" ? this.raise(ke.DeclareClassElement, a) : s.value && this.raise(ke.DeclareClassFieldInitializer, s.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), s = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(B.InvalidIdentifier, this.state.curPosition(), {
        identifierName: s
      }), this.finishToken(132, s);
    }
    getTokenFromCode(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : JDe(r, s, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, s) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      !s && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, s);
    }
    toAssignableList(r, s, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, i);
    }
    toReferencedList(r, s) {
      for (let a = 0; a < r.length; a++) {
        var i;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((i = o.extra) != null && i.parenthesized) && (r.length > 1 || !s) && this.raise(ke.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, s, i, a) {
      let o = super.parseArrayLike(r, s, i, a);
      return s && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(r, s, i) {
      return r === "TypeCastExpression" || super.isValidLVal(r, s, i);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, s, i, a, o, l) {
      if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, s, i, a, o, l), s.params && o) {
        let u = s.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(ke.ThisParamBannedInConstructor, s);
      } else if (s.type === "MethodDefinition" && o && s.value.params) {
        let u = s.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(ke.ThisParamBannedInConstructor, s);
      }
    }
    pushClassPrivateMethod(r, s, i, a) {
      s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, s, i, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.
      isContextual(113)) {
        this.next();
        let s = r.implements = [];
        do {
          let i = this.startNode();
          i.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.
          typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let s = this.getObjectOrClassMethodParams(r);
      if (s.length > 0) {
        let i = s[0];
        this.isThisParam(i) && r.kind === "get" ? this.raise(ke.GetterMayNotHaveThisParam, i) : this.isThisParam(i) && this.raise(ke.SetterMayNotHaveThisParam,
        i);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, s, i, a, o, l, u) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let p = super.parseObjPropValue(r, s, i, a, o, l, u);
      return c && ((p.value || p).typeParameters = c), p;
    }
    parseAssignableListItemTypes(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(ke.PatternIsOptional, r), this.isThisParam(r) && this.raise(ke.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(ke.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(ke.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, s) {
      let i = super.parseMaybeDefault(r, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(ke.TypeBeforeInitializer,
      i.typeAnnotation), i;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(ke.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, s, i) {
      s.local = oN(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(s,
      i));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let s = this.lookaheadCharCode();
        return s === 123 || s === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, i, a) {
      if (super.applyImportPhase(r, s, i, a), s) {
        if (!i && this.match(65))
          return;
        r.exportKind = i === "type" ? i : "value";
      } else
        i === "type" && this.match(55) && this.unexpected(), r.importKind = i === "type" || i === "typeof" ? i : "value";
    }
    parseImportSpecifier(r, s, i, a, o) {
      let l = r.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let f = this.parseIdentifier(!0);
        u !== null && !es(this.state.type) ? (r.imported = f, r.importKind = u, r.local = qs(f)) : (r.imported = l, r.importKind = null, r.local =
        this.parseIdentifier());
      } else {
        if (u !== null && es(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = u;
        else {
          if (s)
            throw this.raise(B.ImportBindingIsString, r, {
              importName: l.value
            });
          r.imported = l, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (c = !0, r.local = qs(r.imported));
      }
      let p = oN(r);
      return i && p && this.raise(ke.ImportTypeShorthandOnlyInPureImport, r), (i || p) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), c && !i && !p && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, s) {
      let i = r.kind;
      i !== "get" && i !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      if (this.match(14)) {
        let i = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
      }
      return super.parseAsyncArrowFromCallExpression(r, s);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, s) {
      var i;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, s), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, p = c[c.length - 1];
        (p === Pt.j_oTag || p === Pt.j_expr) && c.pop();
      }
      if ((i = o) != null && i.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, p = this.tryParse((m) => {
          var y;
          c = this.flowParseTypeParameterDeclaration();
          let T = this.forwardNoArrowParamsConversionAt(c, () => {
            let q = super.parseMaybeAssign(r, s);
            return this.resetStartLocationFromNode(q, c), q;
          });
          (y = T.extra) != null && y.parenthesized && m();
          let L = this.maybeUnwrapTypeCastExpression(T);
          return L.type !== "ArrowFunctionExpression" && m(), L.typeParameters = c, this.resetStartLocationFromNode(L, c), T;
        }, a), f = null;
        if (p.node && this.maybeUnwrapTypeCastExpression(p.node).type === "ArrowFunctionExpression") {
          if (!p.error && !p.aborted)
            return p.node.async && this.raise(ke.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), p.node;
          f = p.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (f)
          return this.state = p.failState, f;
        throw (u = o) != null && u.thrown ? o.error : p.thrown ? p.error : this.raise(ke.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse(() => {
          let i = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (s.thrown) return null;
        s.error && (this.state = s.failState), r.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, s) {
      this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? r.params = s : super.setArrowFunctionParameters(r, s);
    }
    checkParams(r, s, i, a = !0) {
      if (!(i && this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1)) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(ke.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, s, i, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(r, s, i) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.indexOf(s.index) !== -1) {
        this.next();
        let a = this.startNodeAt(s);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(11, !1), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(s) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(r, s, i), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(r, s, i);
    }
    parseSubscript(r, s, i, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, i)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(s);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11, !1), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!i && this.shouldParseTypes() && this.match(47)) {
        let o = this.startNodeAt(s);
        o.callee = r;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11, !1), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(r, s, i, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let s = null;
      this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      s;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let s = this.startNodeAt(r);
      if (this.parseFunctionParams(s, !1), !!this.parseArrow(s))
        return super.parseArrowExpression(s, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && s === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && s === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, s) {
      let i = super.parseTopLevel(r, s);
      return this.state.hasFlowComment && this.raise(ke.UnterminatedFlowComment, this.state.curPosition()), i;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(ke.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, s = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + s)); )
        s++;
      let i = this.input.charCodeAt(s + r), a = this.input.charCodeAt(s + r + 1);
      return i === 58 && a === 58 ? s + 2 : this.input.slice(s + r, s + r + 12) === "flow-include" ? s + 12 : i === 58 && a !== 58 ? s : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(B.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: s,
      memberName: i
    }) {
      this.raise(ke.EnumBooleanMemberNotInitialized, r, {
        memberName: i,
        enumName: s
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, s) {
      return this.raise(s.explicitType ? s.explicitType === "symbol" ? ke.EnumInvalidMemberInitializerSymbolType : ke.EnumInvalidMemberInitializerPrimaryType :
      ke.EnumInvalidMemberInitializerUnknownType, r, s);
    }
    flowEnumErrorNumberMemberNotInitialized(r, s) {
      this.raise(ke.EnumNumberMemberNotInitialized, r, s);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, s) {
      this.raise(ke.EnumStringMemberInconsistentlyInitialized, r, s);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, s = /* @__PURE__ */ n(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 134: {
          let i = this.parseNumericLiteral(this.state.value);
          return s() ? {
            type: "number",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 133: {
          let i = this.parseStringLiteral(this.state.value);
          return s() ? {
            type: "string",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let i = this.parseBooleanLiteral(this.match(85));
          return s() ? {
            type: "boolean",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, s = this.parseIdentifier(!0), i = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: s,
        init: i
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, s, i) {
      let {
        explicitType: a
      } = s;
      a !== null && a !== i && this.flowEnumErrorInvalidMemberInitializer(r, s);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: s
    }) {
      let i = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), p = u.name;
        if (p === "")
          continue;
        /^[a-z]/.test(p) && this.raise(ke.EnumInvalidMemberName, u, {
          memberName: p,
          suggestion: p[0].toUpperCase() + p.slice(1),
          enumName: r
        }), i.has(p) && this.raise(ke.EnumDuplicateMemberName, u, {
          memberName: p,
          enumName: r
        }), i.add(p);
        let f = {
          enumName: r,
          explicitType: s,
          memberName: p
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, f);
          case "none":
            switch (s) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, f);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, f);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, s, {
      enumName: i
    }) {
      if (r.length === 0)
        return s;
      if (s.length === 0)
        return r;
      if (s.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return s;
      } else {
        for (let a of s)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!mt(this.state.type))
        throw this.raise(ke.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: s
      } = this.state;
      return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(ke.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: s
      }), s;
    }
    flowEnumBody(r, s) {
      let i = s.name, a = s.loc.start, o = this.flowEnumParseExplicitType({
        enumName: i
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: i,
        explicitType: o
      });
      switch (r.hasUnknownMembers = u, o) {
        case "boolean":
          return r.explicitType = !0, r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: i
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = l.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ n(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let p = l.booleanMembers.length, f = l.numberMembers.length, m = l.stringMembers.length, y = l.defaultedMembers.length;
          if (!p && !f && !m && !y)
            return c();
          if (!p && !f)
            return r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: i
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!f && !m && p >= y) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(T.loc.start, {
                enumName: i,
                memberName: T.id.name
              });
            return r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!p && !m && f >= y) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(T.loc.start, {
                enumName: i,
                memberName: T.id.name
              });
            return r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(ke.EnumInconsistentMemberValues, a, {
              enumName: i
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let s = this.parseIdentifier();
      return r.id = s, r.body = this.flowEnumBody(this.startNode(), s), this.finishNode(r, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let s = this.input.charCodeAt(r + 1);
        return s !== 60 && s !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), f_e = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, rn = Us`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ n(({
      openingTagName: t
    }) => `Expected corresponding JSX closing tag for <${t}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t,
      HTMLEntity: e
    }) => `Unexpected token \`${t}\`. Did you mean \`${e}\` or \`{'${t}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function bi(t) {
    return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : !1;
  }
  n(bi, "isFragment");
  function Qn(t) {
    if (t.type === "JSXIdentifier")
      return t.name;
    if (t.type === "JSXNamespacedName")
      return t.namespace.name + ":" + t.name.name;
    if (t.type === "JSXMemberExpression")
      return Qn(t.object) + "." + Qn(t.property);
    throw new Error("Node had unexpected type: " + t.type);
  }
  n(Qn, "getQualifiedJSXName");
  var h_e = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", s = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(rn.UnterminatedJsxContent, this.state.startLoc);
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(i);
              return;
            }
            r += this.input.slice(s, this.state.pos), this.finishToken(141, r);
            return;
          case 38:
            r += this.input.slice(s, this.state.pos), r += this.jsxReadEntity(), s = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            $o(i) ? (r += this.input.slice(s, this.state.pos), r += this.jsxReadNewLine(!0), s = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let s = this.input.charCodeAt(this.state.pos), i;
      return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = r ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
    }
    jsxReadString(r) {
      let s = "", i = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(B.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : $o(a) ? (s += this.input.slice(
        i, this.state.pos), s += this.jsxReadNewLine(!1), i = this.state.pos) : ++this.state.pos;
      }
      s += this.input.slice(i, this.state.pos++), this.finishToken(133, s);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let s = 10;
        this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
        let i = this.readInt(s, void 0, !1, "bail");
        if (i !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(i);
      } else {
        let s = 0, i = !1;
        for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (i) {
          let a = this.input.slice(r, this.state.pos), o = f_e[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, s = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (Zn(r) || r === 45);
      this.finishToken(140, this.input.slice(s, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(140) ? r.name = this.state.value : Ib(this.state.type) ? r.name = xi(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, s = this.jsxParseIdentifier();
      if (!this.eat(14)) return s;
      let i = this.startNodeAt(r);
      return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, s = this.jsxParseNamespacedName();
      if (s.type === "JSXNamespacedName")
        return s;
      for (; this.eat(16); ) {
        let i = this.startNodeAt(r);
        i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
      }
      return s;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(Pt.brace), this.next(), r = this.jsxParseExpressionContainer(r, Pt.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(rn.AttributeIsEmpty, r), r;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(rn.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(Pt.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, s) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let i = this.parseExpression();
        r.expression = i;
      }
      return this.setContext(s), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(Pt.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      Pt.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      s));
    }
    jsxParseOpeningElementAfterName(r) {
      let s = [];
      for (; !this.match(56) && !this.match(143); )
        s.push(this.jsxParseAttribute());
      return r.attributes = s, r.selfClosing = this.eat(56), this.expect(143), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(143), this.finishNode(
      s, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let s = this.startNodeAt(r), i = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 142:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              i.push(this.jsxParseElementAt(r));
              break;
            case 141:
              i.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(Pt.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(l)) : i.push(this.jsxParseExpressionContainer(
              l, Pt.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        bi(a) && !bi(o) && o !== null ? this.raise(rn.MissingClosingTagFragment, o) : !bi(a) && bi(o) ? this.raise(rn.MissingClosingTagElement,
        o, {
          openingTagName: Qn(a.name)
        }) : !bi(a) && !bi(o) && Qn(o.name) !== Qn(a.name) && this.raise(rn.MissingClosingTagElement, o, {
          openingTagName: Qn(a.name)
        });
      }
      if (bi(a) ? (s.openingFragment = a, s.closingFragment = o) : (s.openingElement = a, s.closingElement = o), s.children = i, this.match(
      47))
        throw this.raise(rn.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return bi(a) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: s
      } = this.state;
      s[s.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(
      142), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let s = this.curContext();
      if (s === Pt.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (s === Pt.j_oTag || s === Pt.j_cTag) {
        if (Rs(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((r === 34 || r === 39) && s === Pt.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: s,
        type: i
      } = this.state;
      if (i === 56 && r === 142)
        s.splice(-2, 2, Pt.j_cTag), this.state.canStartJSXElement = !1;
      else if (i === 142)
        s.push(Pt.j_oTag);
      else if (i === 143) {
        let a = s[s.length - 1];
        a === Pt.j_oTag && r === 56 || a === Pt.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === Pt.j_expr) : (this.setContext(
        Pt.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = ODe(i);
    }
  }, "jsx"), yb = class extends Ho {
    static {
      n(this, "TypeScriptScope");
    }
    constructor(...e) {
      super(...e), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, Tb = class extends zo {
    static {
      n(this, "TypeScriptScopeHandler");
    }
    constructor(...e) {
      super(...e), this.importsStack = [];
    }
    createScope(e) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new yb(e);
    }
    enter(e) {
      e === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e);
    }
    exit() {
      let e = super.exit();
      return e === 256 && this.importsStack.pop(), e;
    }
    hasImport(e, r) {
      let s = this.importsStack.length;
      if (this.importsStack[s - 1].has(e))
        return !0;
      if (!r && s > 1) {
        for (let i = 0; i < s - 1; i++)
          if (this.importsStack[i].has(e)) return !0;
      }
      return !1;
    }
    declareName(e, r, s) {
      if (r & 4096) {
        this.hasImport(e, !0) && this.parser.raise(B.VarRedeclaration, s, {
          identifierName: e
        }), this.importsStack[this.importsStack.length - 1].add(e);
        return;
      }
      let i = this.currentScope(), a = i.tsNames.get(e) || 0;
      if (r & 1024) {
        this.maybeExportDefined(i, e), i.tsNames.set(e, a | 16);
        return;
      }
      super.declareName(e, r, s), r & 2 && (r & 1 || (this.checkRedeclarationInScope(i, e, r, s), this.maybeExportDefined(i, e)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && i.tsNames.set(e, a);
    }
    isRedeclaredInScope(e, r, s) {
      let i = e.tsNames.get(r);
      if ((i & 2) > 0) {
        if (s & 256) {
          let a = !!(s & 512), o = (i & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return s & 128 && (i & 8) > 0 ? e.names.get(r) & 2 ? !!(s & 1) : !1 : s & 2 && (i & 1) > 0 ? !0 : super.isRedeclaredInScope(e, r, s);
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      if (this.hasImport(r)) return;
      let s = this.scopeStack.length;
      for (let i = s - 1; i >= 0; i--) {
        let o = this.scopeStack[i].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(e);
    }
  }, d_e = /* @__PURE__ */ n((t, e) => hasOwnProperty.call(t, e) && t[e], "getOwn$1"), IN = /* @__PURE__ */ n((t) => t.type === "Parenthesiz\
edExpression" ? IN(t.expression) : t, "unwrapParenthesizedExpression"), bb = class extends mb {
    static {
      n(this, "LValParser");
    }
    toAssignable(e, r = !1) {
      var s, i;
      let a;
      switch ((e.type === "ParenthesizedExpression" || (s = e.extra) != null && s.parenthesized) && (a = IN(e), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(B.InvalidParenthesizedAssignment, e) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(B.InvalidParenthesizedAssignment, e) : this.raise(B.InvalidParenthesizedAssignment, e)), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let l = 0, u = e.properties.length, c = u - 1; l < u; l++) {
            var o;
            let p = e.properties[l], f = l === c;
            this.toAssignableObjectExpressionProp(p, f, r), f && p.type === "RestElement" && (o = e.extra) != null && o.trailingCommaLoc && this.
            raise(B.RestTrailingComma, e.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = e;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (i = e.extra) == null ? void 0 : i.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(B.MissingEqInAssignment, e.left.loc.end), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(
          e.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, r, s) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? B.PatternHasAccessor : B.PatternHasMethod, e.key);
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        let i = e.argument;
        this.checkToRestConversion(i, !1), this.toAssignable(i, s), r || this.raise(B.RestTrailingComma, e);
      } else
        this.toAssignable(e, s);
    }
    toAssignableList(e, r, s) {
      let i = e.length - 1;
      for (let a = 0; a <= i; a++) {
        let o = e[a];
        if (o) {
          if (o.type === "SpreadElement") {
            o.type = "RestElement";
            let l = o.argument;
            this.checkToRestConversion(l, !0), this.toAssignable(l, s);
          } else
            this.toAssignable(o, s);
          o.type === "RestElement" && (a < i ? this.raise(B.RestTrailingComma, o) : r && this.raise(B.RestTrailingComma, r));
        }
      }
    }
    isAssignable(e, r) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let s = e.properties.length - 1;
          return e.properties.every((i, a) => i.type !== "ObjectMethod" && (a === s || i.type !== "SpreadElement") && this.isAssignable(i));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((s) => s === null || this.isAssignable(s));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(e, r) {
      return e;
    }
    toReferencedListDeep(e, r) {
      this.toReferencedList(e, r);
      for (let s of e)
        s?.type === "ArrayExpression" && this.toReferencedListDeep(s.elements);
    }
    parseSpread(e) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(e, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, 1), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, r, s) {
      let i = s & 1, a = [], o = !0;
      for (; !this.eat(e); )
        if (o ? o = !1 : this.expect(12), i && this.match(12))
          a.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            if (a.push(this.parseAssignableListItemTypes(this.parseRestBinding(), s)), !this.checkCommaAfterRest(r)) {
              this.expect(e);
              break;
            }
          } else {
            let l = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(B.UnsupportedParameterDecorator, this.state.startLoc); this.match(
            26); )
              l.push(this.parseDecorator());
            a.push(this.parseAssignableListItem(s, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      let {
        type: e,
        startLoc: r
      } = this.state;
      if (e === 21)
        return this.parseBindingRestProperty(this.startNode());
      let s = this.startNode();
      return e === 138 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), s.key = this.parsePrivateName()) :
      this.parsePropertyName(s), s.method = !1, this.parseObjPropValue(s, r, !1, !1, !0, !1);
    }
    parseAssignableListItem(e, r) {
      let s = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(s, e);
      let i = this.parseMaybeDefault(s.loc.start, s);
      return r.length && (s.decorators = r), i;
    }
    parseAssignableListItemTypes(e, r) {
      return e;
    }
    parseMaybeDefault(e, r) {
      var s, i;
      if ((s = e) != null || (e = this.state.startLoc), r = (i = r) != null ? i : this.parseBindingAtom(), !this.eat(29)) return r;
      let a = this.startNodeAt(e);
      return a.left = r, a.right = this.parseMaybeAssignAllowIn(), this.finishNode(a, "AssignmentPattern");
    }
    isValidLVal(e, r, s) {
      return d_e({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, e);
    }
    isOptionalMemberExpression(e) {
      return e.type === "OptionalMemberExpression";
    }
    checkLVal(e, {
      in: r,
      binding: s = 64,
      checkClashes: i = !1,
      strictModeChanged: a = !1,
      hasParenthesizedAncestor: o = !1
    }) {
      var l;
      let u = e.type;
      if (this.isObjectMethod(e)) return;
      let c = this.isOptionalMemberExpression(e);
      if (c || u === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", e.loc.start), r.type !== "AssignmentExpression" && this.raise(B.InvalidLhsOptionalChaining,
        e, {
          ancestor: r
        })), s !== 64 && this.raise(B.InvalidPropertyBindingPattern, e);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(e, s, a);
        let {
          name: T
        } = e;
        i && (i.has(T) ? this.raise(B.ParamDupe, e) : i.add(T));
        return;
      }
      let p = this.isValidLVal(u, !(o || (l = e.extra) != null && l.parenthesized) && r.type === "AssignmentExpression", s);
      if (p === !0) return;
      if (p === !1) {
        let T = s === 64 ? B.InvalidLhs : B.InvalidLhsBinding;
        this.raise(T, e, {
          ancestor: r
        });
        return;
      }
      let [f, m] = Array.isArray(p) ? p : [p, u === "ParenthesizedExpression"], y = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : r;
      for (let T of [].concat(e[f]))
        T && this.checkLVal(T, {
          in: y,
          binding: s,
          checkClashes: i,
          strictModeChanged: a,
          hasParenthesizedAncestor: m
        });
    }
    checkIdentifier(e, r, s = !1) {
      this.state.strict && (s ? gN(e.name, this.inModule) : SN(e.name)) && (r === 64 ? this.raise(B.StrictEvalArguments, e, {
        referenceName: e.name
      }) : this.raise(B.StrictEvalArgumentsBinding, e, {
        bindingName: e.name
      })), r & 8192 && e.name === "let" && this.raise(B.LetInLexicalBinding, e), r & 64 || this.declareNameFromIdentifier(e, r);
    }
    declareNameFromIdentifier(e, r) {
      this.scope.declareName(e.name, r, e.loc.start);
    }
    checkToRestConversion(e, r) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(B.InvalidRestAssignmentPattern, e);
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? B.RestTrailingComma : B.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  }, m_e = /* @__PURE__ */ n((t, e) => hasOwnProperty.call(t, e) && t[e], "getOwn");
  function y_e(t) {
    if (t == null)
      throw new Error(`Unexpected ${t} value.`);
    return t;
  }
  n(y_e, "nonNull");
  function lN(t) {
    if (!t)
      throw new Error("Assert fail");
  }
  n(lN, "assert");
  var Te = Us`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ n(({
      methodName: t
    }) => `Method '${t}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ n(({
      propertyName: t
    }) => `Property '${t}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or nu\
meric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ n(({
      kind: t
    }) => `'declare' is not allowed in ${t}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => `Duplicate modifier: '${t}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ n(({
      token: t
    }) => `'${t}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ n(({
      modifiers: t
    }) => `'${t[0]}' modifier cannot be used with '${t[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Index signatures cannot have an accessibility modifier ('${t}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ n(({
      orderedModifiers: t
    }) => `'${t[0]}' modifier must precede '${t[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Private elements cannot have an accessibility modifier ('${t}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ n(({
      typeParameterName: t
    }) => `Single type parameter ${t} should have a trailing comma. Example usage: <${t},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ n(({
      type: t
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t}.`, "UnsupportedSignatureParameterKind")
  });
  function T_e(t) {
    switch (t) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  n(T_e, "keywordTypeFromName");
  function uN(t) {
    return t === "private" || t === "public" || t === "protected";
  }
  n(uN, "tsIsAccessModifier");
  function b_e(t) {
    return t === "in" || t === "out";
  }
  n(b_e, "tsIsVarianceAnnotations");
  var x_e = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Te.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: Te.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Te.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return Tb;
    }
    tsIsIdentifier() {
      return mt(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.
      hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(r, s) {
      if (!mt(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let i = this.state.value;
      if (r.indexOf(i) !== -1) {
        if (s && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return i;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: s,
      stopOnStartOfClassStaticBlock: i,
      errorTemplate: a = Te.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ n((c, p, f, m) => {
        p === f && o[m] && this.raise(Te.InvalidModifiersOrder, c, {
          orderedModifiers: [f, m]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ n((c, p, f, m) => {
        (o[f] && p === m || o[m] && p === f) && this.raise(Te.IncompatibleModifiers, c, {
          modifiers: [f, m]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, p = this.tsParseModifier(r.concat(s ?? []), i);
        if (!p) break;
        uN(p) ? o.accessibility ? this.raise(Te.DuplicateAccessibilityModifier, c, {
          modifier: p
        }) : (l(c, p, p, "override"), l(c, p, p, "static"), l(c, p, p, "readonly"), o.accessibility = p) : b_e(p) ? (o[p] && this.raise(Te.DuplicateModifier,
        c, {
          modifier: p
        }), o[p] = !0, l(c, p, "in", "out")) : (hasOwnProperty.call(o, p) ? this.raise(Te.DuplicateModifier, c, {
          modifier: p
        }) : (l(c, p, "static", "readonly"), l(c, p, "static", "override"), l(c, p, "override", "readonly"), l(c, p, "abstract", "override"),
        u(c, p, "declare", "override"), u(c, p, "static", "abstract")), o[p] = !0), s != null && s.includes(p) && this.raise(a, c, {
          modifier: p
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, s) {
      let i = [];
      for (; !this.tsIsListTerminator(r); )
        i.push(s());
      return i;
    }
    tsParseDelimitedList(r, s, i) {
      return y_e(this.tsParseDelimitedListWorker(r, s, !0, i));
    }
    tsParseDelimitedListWorker(r, s, i, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(r); ) {
        l = -1;
        let u = s();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        i && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(r, s, i, a, o) {
      a || (i ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(r, s, o);
      return i ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(Te.UnsupportedImportTypeArgument, this.state.startLoc), r.argument =
      super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r.options = null), this.eat(12) &&
      (this.expectImportAttributesPlugin(), this.match(11) || (r.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11),
      this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(
      r, "TSImportType");
    }
    tsParseEntityName(r = !0) {
      let s = this.parseIdentifier(r);
      for (; this.eat(16); ) {
        let i = this.startNodeAtNode(s);
        i.left = s, i.right = this.parseIdentifier(r), s = this.finishNode(i, "TSQualifiedName");
      }
      return s;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let s = this.startNodeAtNode(r);
      return s.parameterName = r, s.typeAnnotation = this.tsParseTypeAnnotation(!1), s.asserts = !1, this.finishNode(s, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let s = this.startNode();
      return r(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(
      29), this.finishNode(s, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let s = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = {
        value: -1
      };
      return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, i), s.params.
      length === 0 && this.raise(Te.EmptyTypeParameters, s), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, s) {
      let i = r === 19, a = "parameters", o = "typeAnnotation";
      s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[a] = this.tsParseBindingListForSignature(),
      i ? s[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (s[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let s of r) {
        let {
          type: i
        } = s;
        (i === "AssignmentPattern" || i === "TSParameterProperty") && this.raise(Te.UnsupportedSignatureParameterKind, s, {
          type: i
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, s) {
      return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), mt(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let s = this.parseIdentifier();
      s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), r.parameters = [s];
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, s) {
      this.eat(17) && (r.optional = !0);
      let i = r;
      if (this.match(10) || this.match(47)) {
        s && this.raise(Te.ReadonlyForMethodSignature, r);
        let a = i;
        a.kind && this.match(47) && this.raise(Te.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(B.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(Te.AccesorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(B.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(Te.AccesorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(Te.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            Te.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          a[l] && this.raise(Te.SetAccesorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = i;
        s && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let i = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let s = this.tsTryParseIndexSignature(r);
      return s || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let r = this.startNode();
      return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), this.finishNode(r, "TSTypeParameter");
    }
    tsParseMappedType() {
      let r = this.startNode();
      return this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(
      122) && (r.readonly = !0), this.expect(0), r.typeParameter = this.tsParseMappedTypeParameter(), r.nameType = this.eatContextual(93) ? this.
      tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) &&
      (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let s = !1;
      return r.elementTypes.forEach((i) => {
        let {
          type: a
        } = i;
        s && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && i.optional) && this.raise(Te.OptionalTypeBeforeRequired,
        i), s || (s = a === "TSNamedTupleMember" && i.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let {
        startLoc: r
      } = this.state, s = this.eat(21), i, a, o, l, c = es(this.state.type) ? this.lookaheadCharCode() : null;
      if (c === 58)
        i = !0, o = !1, a = this.parseIdentifier(!0), this.expect(14), l = this.tsParseType();
      else if (c === 63) {
        o = !0;
        let p = this.state.startLoc, f = this.state.value, m = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (i = !0, a = this.createIdentifier(this.startNodeAt(p), f), this.expect(17), this.expect(14), l = this.
        tsParseType()) : (i = !1, l = m, this.expect(17));
      } else
        l = this.tsParseType(), o = this.eat(17), i = this.eat(14);
      if (i) {
        let p;
        a ? (p = this.startNodeAtNode(a), p.optional = o, p.label = a, p.elementType = l, this.eat(17) && (p.optional = !0, this.raise(Te.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (p = this.startNodeAtNode(l), p.optional = o, this.raise(Te.InvalidTupleMemberLabel, l), p.label = l,
        p.elementType = this.tsParseType()), l = this.finishNode(p, "TSNamedTupleMember");
      } else if (o) {
        let p = this.startNodeAtNode(l);
        p.typeAnnotation = l, l = this.finishNode(p, "TSOptionalType");
      }
      if (s) {
        let p = this.startNodeAt(r);
        p.typeAnnotation = l, l = this.finishNode(p, "TSRestType");
      }
      return l;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, s) {
      let i = this.startNode();
      return r === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, i)), this.finishNode(i, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let r = this.startNode();
      return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), s = this.lookahead();
            return s.type !== 134 && s.type !== 135 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (mt(r) || r === 88 || r === 84) {
            let s = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : T_e(this.state.value);
            if (s !== void 0 && this.lookaheadCharCode() !== 46) {
              let i = this.startNode();
              return this.next(), this.finishNode(i, s);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let r = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let s = this.startNodeAtNode(r);
          s.elementType = r, this.expect(3), r = this.finishNode(s, "TSArrayType");
        } else {
          let s = this.startNodeAtNode(r);
          s.objectType = r, s.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(s, "TSIndexedAccessType");
        }
      return r;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), s = this.state.value;
      return this.next(), r.operator = s, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(Te.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let s = this.startNode();
      return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(s, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return BDe(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, s, i) {
      let a = this.startNode(), o = this.eat(i), l = [];
      do
        l.push(s());
      while (this.eat(i));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (mt(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === s;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === s;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let s = this.startNode();
        this.expect(r);
        let i = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (i.parameterName = u, i.asserts = !0, i.typeAnnotation = null, u = this.finishNode(i, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, i), u.asserts = !0), s.typeAnnotation = u, this.finishNode(s, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (i.parameterName = this.parseIdentifier(), i.asserts = a, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i,
          "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, s);
        let l = this.tsParseTypeAnnotation(!1);
        return i.parameterName = o, i.typeAnnotation = l, i.asserts = a, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(
        s, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !mt(this.state.type) && !this.match(78) ? !1 : (r && this.raise(B.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, s = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), s.typeAnnotation = this.tsParseType();
      }), this.finishNode(s, "TSTypeAnnotation");
    }
    tsParseType() {
      lN(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let s = this.startNodeAtNode(r);
      return s.checkType = r, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(s, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Te.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let a = this.startNode();
        return a.expression = this.tsParseEntityName(), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
        a, "TSExpressionWithTypeArguments");
      });
      return i.length || this.raise(Te.EmptyHeritageClauseType, s, {
        token: r
      }), i;
    }
    tsParseInterfaceDeclaration(r, s = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), s.declare && (r.declare = !0), mt(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(Te.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let i = this.startNode();
      return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let s = this.startNode();
          return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInNoContext(r) {
      let s = this.state.context;
      this.state.context = [s[0]];
      try {
        return r();
      } finally {
        this.state.context = s;
      }
    }
    tsInType(r) {
      let s = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = s;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, s = {}) {
      return s.const && (r.const = !0), s.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, s = !1) {
      if (r.id = this.parseIdentifier(), s || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let i = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(i, !0), r.body = i;
      } else
        this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.global = !0, r.id = this.parseIdentifier()) : this.match(133) ? r.id = super.parseStringLiteral(this.
      state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(),
      this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(r, s, i) {
      r.isExport = i || !1, r.id = s || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(Te.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let s = this.state.clone(), i = r();
      return this.state = s, i;
    }
    tsTryParseAndCatch(r) {
      let s = this.tryParse((i) => r() || i());
      if (!(s.aborted || !s.node))
        return s.error && (this.state = s.failState), s.node;
    }
    tsTryParse(r) {
      let s = this.state.clone(), i = r();
      if (i !== void 0 && i !== !1)
        return i;
      this.state = s;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let s = this.state.type, i;
      return this.isContextual(100) && (s = 74, i = "let"), this.tsInAmbientContext(() => {
        switch (s) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, i || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (mt(s))
              return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, s, i) {
      switch (s.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(r);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = r;
            return a.global = !0, a.id = s, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a,
            "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, s.name, !1, i);
      }
    }
    tsParseDeclaration(r, s, i, a) {
      switch (s) {
        case "abstract":
          if (this.tsCheckLineTerminator(i) && (this.match(80) || mt(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(i)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (mt(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(i) && mt(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(i) && mt(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let s = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let i = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = s, !!i)
        return super.parseArrowExpression(i, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments",
      this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(Te.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      Pt.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return FDe(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(r, s) {
      let i = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(r & 4) && (o || u || l) && this.raise(Te.UnexpectedParameterModifier, i);
      let c = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(c, r);
      let p = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let f = this.startNodeAt(i);
        return s.length && (f.decorators = s), o && (f.accessibility = o), u && (f.readonly = u), l && (f.override = l), p.type !== "Identif\
ier" && p.type !== "AssignmentPattern" && this.raise(Te.UnsupportedParameterPropertyKind, f), f.parameter = p, this.finishNode(f, "TSParamet\
erProperty");
      }
      return s.length && (c.decorators = s), p;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let s of r.params)
        s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(Te.PatternIsOptional, s);
    }
    setArrowFunctionParameters(r, s, i) {
      super.setArrowFunctionParameters(r, s, i), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, s, i = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(Te.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, i) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, s, i));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((s) => {
        s?.type === "TSTypeCastExpression" && this.raise(Te.UnexpectedTypeAnnotation, s.typeAnnotation);
      });
    }
    toReferencedList(r, s) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, s, i, a) {
      let o = super.parseArrayLike(r, s, i, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(r, s, i, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(s);
        return l.expression = r, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (i)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!i && this.atPossibleAsyncArrow(r)) {
            let m = this.tsTryParseGenericAsyncArrowFunction(s);
            if (m)
              return m;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (Vc(this.state.type)) {
            let m = super.parseTaggedTemplateExpression(r, s, a);
            return m.typeParameters = c, m;
          }
          if (!i && this.eat(10)) {
            let m = this.startNodeAt(s);
            return m.callee = r, m.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(m.arguments), m.typeParameters =
            c, a.optionalChainMember && (m.optional = o), this.finishCallExpression(m, a.optionalChainMember);
          }
          let p = this.state.type;
          if (p === 48 || p === 52 || p !== 10 && tb(p) && !this.hasPrecedingLineBreak())
            return;
          let f = this.startNodeAt(s);
          return f.expression = r, f.typeParameters = c, this.finishNode(f, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          Te.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(r, s, i, a);
    }
    parseNewCallee(r) {
      var s;
      super.parseNewCallee(r);
      let {
        callee: i
      } = r;
      i.type === "TSInstantiationExpression" && !((s = i.extra) != null && s.parenthesized) && (r.typeParameters = i.typeParameters, r.callee =
      i.expression);
    }
    parseExprOp(r, s, i) {
      let a;
      if (jc(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(s);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(B.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, s, i);
      }
      return super.parseExprOp(r, s, i);
    }
    checkReservedWord(r, s, i, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, s, i, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Te.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let s = this.lookaheadCharCode();
        return r ? s === 123 || s === 42 : s !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, i, a) {
      super.applyImportPhase(r, s, i, a), s ? r.exportKind = i === "type" ? "type" : "value" : r.importKind = i === "type" || i === "typeof" ?
      i : "value";
    }
    parseImport(r) {
      if (this.match(133))
        return r.importKind = "value", super.parseImport(r);
      let s;
      if (mt(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let i = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, i);
        s = super.parseImportSpecifiersAndAfter(r, i);
      } else
        s = super.parseImport(r);
      return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(Te.TypeImportCannotSpecifyDefaultAndNamed,
      s), s;
    }
    parseExport(r, s) {
      if (this.match(83)) {
        this.next();
        let i = r, a = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(i, !1) : i.importKind = "value", this.
        tsParseImportEqualsDeclaration(i, a, !0);
      } else if (this.eat(29)) {
        let i = r;
        return i.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(i, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let i = r;
        return this.expectContextual(128), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, s);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, s, i = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, s, i || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (s !== "const" || l.typeAnnotation ? this.raise(Te.InitializerNotAllowedInAmbientContext, u) : g_e(u, this.hasPlugin("estree")) ||
        this.raise(Te.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(r, s) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let i = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(i, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let i = this.tsParseInterfaceDeclaration(this.startNode());
        if (i) return i;
      }
      return super.parseStatementContent(r, s);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, s) {
      return s.some((i) => uN(i) ? r.accessibility === i : !!r[i]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, s, i) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: Te.InvalidModifierOnTypeParameterPositions
      }, s);
      let o = /* @__PURE__ */ n(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, a) && this.raise(Te.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, s)) : this.parseClassMemberWithIsStatic(r, s, i, !!s.static);
      }, "callParseClassMemberWithIsStatic");
      s.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, s, i, a) {
      let o = this.tsTryParseIndexSignature(s);
      if (o) {
        r.body.push(o), s.abstract && this.raise(Te.IndexSignatureHasAbstract, s), s.accessibility && this.raise(Te.IndexSignatureHasAccessibility,
        s, {
          modifier: s.accessibility
        }), s.declare && this.raise(Te.IndexSignatureHasDeclare, s), s.override && this.raise(Te.IndexSignatureHasOverride, s);
        return;
      }
      !this.state.inAbstractClass && s.abstract && this.raise(Te.NonAbstractClassHasAbstractMethod, s), s.override && (i.hadSuperClass || this.
      raise(Te.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(r, s, i, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(Te.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(Te.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, s, i) {
      return (s.type === "Identifier" ? this.tsParseExpressionStatement(r, s, i) : void 0) || super.parseExpressionStatement(r, s, i);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, s, i) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(r, s, i);
      let a = this.tryParse(() => super.parseConditional(r, s));
      return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(i, a.error), r);
    }
    parseParenItem(r, s) {
      let i = super.parseParenItem(r, s);
      if (this.eat(17) && (i.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(s);
        return a.expression = r, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let s = this.state.startLoc, i = this.eatContextual(125);
      if (i && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(Te.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = mt(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || i) && (r.exportKind = "type"), i && (this.resetStartLocation(
      o, s), o.declare = !0), o) : null;
    }
    parseClassId(r, s, i, a) {
      if ((!s || i) && this.isContextual(113))
        return;
      super.parseClassId(r, s, i, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let s = this.tsTryParseTypeAnnotation();
      s && (r.typeAnnotation = s);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(Te.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: s
        } = r;
        this.raise(Te.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: s.type === "Identifier" && !r.computed ? s.name : `[${this.input.slice(s.start, s.end)}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(Te.PrivateElementHasAbstract, r), r.accessibility && this.raise(Te.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(Te.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, s, i, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(Te.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: p
      } = s;
      c && (p === "get" || p === "set") && this.raise(Te.DeclareAccessor, s, {
        kind: p
      }), u && (s.typeParameters = u), super.pushClassMethod(r, s, i, a, o, l);
    }
    pushClassPrivateMethod(r, s, i, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (s.typeParameters = o), super.pushClassPrivateMethod(r, s, i, a);
    }
    declareClassPrivateMethodInScope(r, s) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !hasOwnProperty.call(r.value, "body") || super.declareClassPrivateMethodInScope(
      r, s));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, s, i, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (r.typeParameters = c), super.parseObjPropValue(r, s, i, a, o, l, u);
    }
    parseFunctionParams(r, s) {
      let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      i && (r.typeParameters = i), super.parseFunctionParams(r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let i = this.tsTryParseTypeAnnotation();
      i && (r.id.typeAnnotation = i, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, s);
    }
    parseMaybeAssign(r, s) {
      var i, a, o, l, u;
      let c, p, f;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (c = this.state.clone(), p = this.tryParse(() => super.parseMaybeAssign(r, s), c), !p.error) return p.node;
        let {
          context: T
        } = this.state, L = T[T.length - 1];
        (L === Pt.j_oTag || L === Pt.j_expr) && T.pop();
      }
      if (!((i = p) != null && i.error) && !this.match(47))
        return super.parseMaybeAssign(r, s);
      (!c || c === this.state) && (c = this.state.clone());
      let m, y = this.tryParse((T) => {
        var L, q;
        m = this.tsParseTypeParameters(this.tsParseConstModifier);
        let _ = super.parseMaybeAssign(r, s);
        return (_.type !== "ArrowFunctionExpression" || (L = _.extra) != null && L.parenthesized) && T(), ((q = m) == null ? void 0 : q.params.
        length) !== 0 && this.resetStartLocationFromNode(_, m), _.typeParameters = m, _;
      }, c);
      if (!y.error && !y.aborted)
        return m && this.reportReservedArrowTypeParam(m), y.node;
      if (!p && (lN(!this.hasPlugin("jsx")), f = this.tryParse(() => super.parseMaybeAssign(r, s), c), !f.error))
        return f.node;
      if ((a = p) != null && a.node)
        return this.state = p.failState, p.node;
      if (y.node)
        return this.state = y.failState, m && this.reportReservedArrowTypeParam(m), y.node;
      if ((o = f) != null && o.node)
        return this.state = f.failState, f.node;
      throw ((l = p) == null ? void 0 : l.error) || y.error || ((u = f) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(r) {
      var s;
      r.params.length === 1 && !r.params[0].constraint && !((s = r.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(Te.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, s) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse((i) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && i(), a;
        });
        if (s.aborted) return;
        s.thrown || (s.error && (this.state = s.failState), r.returnType = s.node);
      }
      return super.parseArrow(r);
    }
    parseAssignableListItemTypes(r, s) {
      if (!(s & 2)) return r;
      this.eat(17) && (r.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.resetEndLocation(r), r;
    }
    isAssignable(r, s) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, s);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, s);
      }
    }
    toAssignable(r, s = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, s);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          s ? this.expressionScope.recordArrowParameterBindingError(Te.UnexpectedTypeCastInParameter, r) : this.raise(Te.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, s);
          break;
        case "AssignmentExpression":
          !s && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, s);
      }
    }
    toAssignableParenthesizedExpression(r, s) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, s);
          break;
        default:
          super.toAssignable(r, s);
      }
    }
    checkToRestConversion(r, s) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, s);
      }
    }
    isValidLVal(r, s, i) {
      return m_e({
        TSTypeCastExpression: !0,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSInstantiationExpression: "expression",
        TSAsExpression: (i !== 64 || !s) && ["expression", !0],
        TSSatisfiesExpression: (i !== 64 || !s) && ["expression", !0],
        TSTypeAssertion: (i !== 64 || !s) && ["expression", !0]
      }, r) || super.isValidLVal(r, s, i);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let i = super.parseMaybeDecoratorArguments(r);
          return i.typeParameters = s, i;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, s) {
      let i = super.parseMaybeDefault(r, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(Te.TypeAnnotationAfterAssign,
      i.typeAnnotation), i;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableList(r, s, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TSTypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, i);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((s) => this.isAssignable(s, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        s && (r.typeParameters = s);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let s = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? s + 1 : s;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
      return s && (r.typeAnnotation = s, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let s = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = s;
      }
    }
    parseClass(r, s, i) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, s, i);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, s) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(s, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return r.abstract = !0, this.raise(Te.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(r, s, i, a, o, l, u) {
      let c = super.parseMethod(r, s, i, a, o, l, u);
      if (c.abstract && (this.hasPlugin("estree") ? !!c.value.body : !!c.body)) {
        let {
          key: f
        } = c;
        this.raise(Te.AbstractMethodHasImplementation, c, {
          methodName: f.type === "Identifier" && !c.computed ? f.name : `[${this.input.slice(f.start, f.end)}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, s, i, a) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, i), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, s, i, a));
    }
    parseImportSpecifier(r, s, i, a, o) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, i), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, s, i, a, i ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, s, i) {
      let a = s ? "imported" : "local", o = s ? "local" : "exported", l = r[a], u, c = !1, p = !0, f = l.loc.start;
      if (this.isContextual(93)) {
        let y = this.parseIdentifier();
        if (this.isContextual(93)) {
          let T = this.parseIdentifier();
          es(this.state.type) ? (c = !0, l = y, u = s ? this.parseIdentifier() : this.parseModuleExportName(), p = !1) : (u = T, p = !1);
        } else es(this.state.type) ? (p = !1, u = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = y);
      } else es(this.state.type) && (c = !0, s ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && i && this.raise(s ? Te.TypeModifierIsUsedInTypeImports : Te.TypeModifierIsUsedInTypeExports, f), r[a] = l, r[o] = u;
      let m = s ? "importKind" : "exportKind";
      r[m] = c ? "type" : "value", p && this.eatContextual(93) && (r[o] = s ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = qs(r[a])), s && this.checkIdentifier(r[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function S_e(t) {
    if (t.type !== "MemberExpression") return !1;
    let {
      computed: e,
      property: r
    } = t;
    return e && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : NN(t.object);
  }
  n(S_e, "isPossiblyLiteralEnum");
  function g_e(t, e) {
    var r;
    let {
      type: s
    } = t;
    if ((r = t.extra) != null && r.parenthesized)
      return !1;
    if (e) {
      if (s === "Literal") {
        let {
          value: i
        } = t;
        if (typeof i == "string" || typeof i == "boolean")
          return !0;
      }
    } else if (s === "StringLiteral" || s === "BooleanLiteral")
      return !0;
    return !!(wN(t, e) || P_e(t, e) || s === "TemplateLiteral" && t.expressions.length === 0 || S_e(t));
  }
  n(g_e, "isValidAmbientConstInitializer");
  function wN(t, e) {
    return e ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLite\
ral";
  }
  n(wN, "isNumber");
  function P_e(t, e) {
    if (t.type === "UnaryExpression") {
      let {
        operator: r,
        argument: s
      } = t;
      if (r === "-" && wN(s, e))
        return !0;
    }
    return !1;
  }
  n(P_e, "isNegativeNumber");
  function NN(t) {
    return t.type === "Identifier" ? !0 : t.type !== "MemberExpression" || t.computed ? !1 : NN(t.object);
  }
  n(NN, "isUncomputedMemberExpressionChain");
  var cN = Us`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), E_e = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(144)) {
        let s = this.startNode();
        return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(
        s, r);
      }
    }
    finishPlaceholder(r, s) {
      let i = r;
      return (!i.expectedNode || !i.type) && (i = this.finishNode(i, "Placeholder")), i.expectedNode = s, i;
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, s, i, a) {
      r !== void 0 && super.checkReservedWord(r, s, i, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, s, i) {
      return r === "Placeholder" || super.isValidLVal(r, s, i);
    }
    toAssignable(r, s) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, s);
    }
    chStartsBindingIdentifier(r, s) {
      return !!(super.chStartsBindingIdentifier(r, s) || this.lookahead().type === 144);
    }
    verifyBreakContinue(r, s) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, s);
    }
    parseExpressionStatement(r, s) {
      var i;
      if (s.type !== "Placeholder" || (i = s.extra) != null && i.parenthesized)
        return super.parseExpressionStatement(r, s);
      if (this.match(14)) {
        let o = r;
        return o.label = this.finishPlaceholder(s, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(o, "LabeledStatement");
      }
      this.semicolon();
      let a = r;
      return a.name = s.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(r, s, i) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, s, i);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, s, i) {
      let a = s ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(144) || this.match(5))
          r.id = l;
        else {
          if (i || !s)
            return r.id = null, r.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(r, a);
          throw this.raise(cN.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, s, i);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, s) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseExport(r, s);
      let a = r;
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(a, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let o = this.startNode();
      return o.exported = i, a.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(a, s);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(xi(144), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, s) {
      var i;
      return (i = r.specifiers) != null && i.length ? !0 : super.maybeParseExportDefaultSpecifier(r, s);
    }
    checkExport(r) {
      let {
        specifiers: s
      } = r;
      s != null && s.length && (r.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = s;
    }
    parseImport(r) {
      let s = this.parsePlaceholder("Identifier");
      if (!s) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let i = this.startNodeAtNode(s);
      return i.local = s, r.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(cN.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), A_e = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, s = this.startNode();
        if (this.next(), mt(this.state.type)) {
          let i = this.parseIdentifierName(), a = this.createIdentifier(s, i);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic");
  function Yt(t, e) {
    let [r, s] = typeof e == "string" ? [e, {}] : e, i = Object.keys(s), a = i.length === 0;
    return t.some((o) => {
      if (typeof o == "string")
        return a && o === r;
      {
        let [l, u] = o;
        if (l !== r)
          return !1;
        for (let c of i)
          if (u[c] !== s[c])
            return !1;
        return !0;
      }
    });
  }
  n(Yt, "hasPlugin");
  function sn(t, e, r) {
    let s = t.find((i) => Array.isArray(i) ? i[0] === e : i === e);
    return s && Array.isArray(s) && s.length > 1 ? s[1][r] : null;
  }
  n(sn, "getPluginOption");
  var pN = ["minimal", "fsharp", "hack", "smart"], fN = ["^^", "@@", "^", "%", "#"];
  function v_e(t) {
    if (Yt(t, "decorators")) {
      if (Yt(t, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let e = sn(t, "decorators", "decoratorsBeforeExport");
      if (e != null && typeof e != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let r = sn(t, "decorators", "allowCallParenthesized");
      if (r != null && typeof r != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (Yt(t, "flow") && Yt(t, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Yt(t, "placeholders") && Yt(t, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Yt(t, "pipelineOperator")) {
      let e = sn(t, "pipelineOperator", "proposal");
      if (!pN.includes(e)) {
        let i = pN.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`);
      }
      let r = ["recordAndTuple", {
        syntaxType: "hash"
      }], s = Yt(t, r);
      if (e === "hack") {
        if (Yt(t, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Yt(t, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let i = sn(t, "pipelineOperator", "topicToken");
        if (!fN.includes(i)) {
          let a = fN.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}\
.`);
        }
        if (i === "#" && s)
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(r)}\
\`.`);
      } else if (e === "smart" && s)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(r)}\`.`);
    }
    if (Yt(t, "moduleAttributes")) {
      if (Yt(t, "importAssertions") || Yt(t, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (sn(t, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (Yt(t, "importAssertions") && Yt(t, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (Yt(t, "recordAndTuple")) {
      let e = sn(t, "recordAndTuple", "syntaxType");
      if (e != null) {
        let r = ["hash", "bar"];
        if (!r.includes(e))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + r.map((s) => `'${s}'`).join(", "));
      }
    }
    if (Yt(t, "asyncDoExpressions") && !Yt(t, "doExpressions")) {
      let e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e.missingPlugins = "doExpressions", e;
    }
    if (Yt(t, "optionalChainingAssign") && sn(t, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  n(v_e, "validatePlugins");
  var ON = {
    estree: CDe,
    jsx: h_e,
    flow: p_e,
    typescript: x_e,
    v8intrinsic: A_e,
    placeholders: E_e
  }, C_e = Object.keys(ON), Q0 = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowNewTargetOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createImportExpressions: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1,
    attachComment: !0,
    annexB: !0
  };
  function I_e(t) {
    if (t == null)
      return Object.assign({}, Q0);
    if (t.annexB != null && t.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let e = {};
    for (let s of Object.keys(Q0)) {
      var r;
      e[s] = (r = t[s]) != null ? r : Q0[s];
    }
    return e;
  }
  n(I_e, "getOptions");
  var xb = class extends bb {
    static {
      n(this, "ExpressionParser");
    }
    checkProto(e, r, s, i) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return;
      let a = e.key;
      if ((a.type === "Identifier" ? a.name : a.value) === "__proto__") {
        if (r) {
          this.raise(B.RecordNoProto, a);
          return;
        }
        s.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = a.loc.start) : this.raise(B.DuplicateProto, a)), s.used = !0;
      }
    }
    shouldExitDescending(e, r) {
      return e.type === "ArrowFunctionExpression" && e.start === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let e = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.comments, e.errors = this.state.errors,
      this.options.tokens && (e.tokens = this.tokens), e;
    }
    parseExpression(e, r) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(e) {
      let r = this.state.startLoc, s = this.parseMaybeAssign(e);
      if (this.match(12)) {
        let i = this.startNodeAt(r);
        for (i.expressions = [s]; this.eat(12); )
          i.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
      }
      return s;
    }
    parseMaybeAssignDisallowIn(e, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, r));
    }
    parseMaybeAssignAllowIn(e, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, r));
    }
    setOptionalParametersError(e, r) {
      var s;
      e.optionalParametersLoc = (s = r?.loc) != null ? s : this.state.startLoc;
    }
    parseMaybeAssign(e, r) {
      let s = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let l = this.parseYield();
        return r && (l = r.call(this, l, s)), l;
      }
      let i;
      e ? i = !1 : (e = new ea(), i = !0);
      let {
        type: a
      } = this.state;
      (a === 10 || mt(a)) && (this.state.potentialArrowAt = this.state.start);
      let o = this.parseMaybeConditional(e);
      if (r && (o = r.call(this, o, s)), kDe(this.state.type)) {
        let l = this.startNodeAt(s), u = this.state.value;
        if (l.operator = u, this.match(29)) {
          this.toAssignable(o, !0), l.left = o;
          let c = s.index;
          e.doubleProtoLoc != null && e.doubleProtoLoc.index >= c && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.
          index >= c && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= c && (this.checkDestructuringPrivate(
          e), e.privateKeyLoc = null);
        } else
          l.left = o;
        return this.next(), l.right = this.parseMaybeAssign(), this.checkLVal(o, {
          in: this.finishNode(l, "AssignmentExpression")
        }), l;
      } else i && this.checkExpressionErrors(e, !0);
      return o;
    }
    parseMaybeConditional(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprOps(e);
      return this.shouldExitDescending(i, s) ? i : this.parseConditional(i, r, e);
    }
    parseConditional(e, r, s) {
      if (this.eat(17)) {
        let i = this.startNodeAt(r);
        return i.test = e, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(
        i, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(i, s) ? i : this.parseExprOp(i, r, -1);
    }
    parseExprOp(e, r, s) {
      if (this.isPrivateName(e)) {
        let a = this.getPrivateNameSV(e);
        (s >= jc(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(B.PrivateInExpectedIn, e, {
          identifierName: a
        }), this.classScope.usePrivateName(a, e.loc.start);
      }
      let i = this.state.type;
      if (_De(i) && (this.prodParam.hasIn || !this.match(58))) {
        let a = jc(i);
        if (a > s) {
          if (i === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, r);
          }
          let o = this.startNodeAt(r);
          o.left = e, o.operator = this.state.value;
          let l = i === 41 || i === 42, u = i === 40;
          if (u && (a = jc(42)), this.next(), i === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(B.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(i, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
          if (u && (p === 41 || p === 42) || l && p === 40)
            throw this.raise(B.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, r, s);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, r) {
      let s = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(B.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, r), s);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
        default:
          return this.parseExprOpBaseRightExpr(e, r);
      }
    }
    parseExprOpBaseRightExpr(e, r) {
      let s = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, jDe(e) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var e;
      let {
        startLoc: r
      } = this.state, s = this.parseMaybeAssign();
      return SDe.has(s.type) && !((e = s.extra) != null && e.parenthesized) && this.raise(B.PipeUnparenthesizedBody, r, {
        type: s.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(B.PipeTopicUnused, r), s;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(B.UnexpectedTokenUnaryExponentiation, e.argument);
    }
    parseMaybeUnary(e, r) {
      let s = this.state.startLoc, i = this.isContextual(96);
      if (i && this.isAwaitAllowed()) {
        this.next();
        let u = this.parseAwait(s);
        return r || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (MDe(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(B.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(B.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, e);
      if (i) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? tb(u) : tb(u) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(B.AwaitNotInAsyncContext, s), this.parseAwait(s);
      }
      return l;
    }
    parseUpdate(e, r, s) {
      if (r) {
        let o = e;
        return this.checkLVal(o.argument, {
          in: this.finishNode(o, "UpdateExpression")
        }), e;
      }
      let i = this.state.startLoc, a = this.parseExprSubscripts(s);
      if (this.checkExpressionErrors(s, !1)) return a;
      for (; LDe(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(i);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, {
          in: a = this.finishNode(o, "UpdateExpression")
        });
      }
      return a;
    }
    parseExprSubscripts(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprAtom(e);
      return this.shouldExitDescending(i, s) ? i : this.parseSubscripts(i, r);
    }
    parseSubscripts(e, r, s) {
      let i = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: !1
      };
      do
        e = this.parseSubscript(e, r, s, i), i.maybeAsyncArrow = !1;
      while (!i.stop);
      return e;
    }
    parseSubscript(e, r, s, i) {
      let {
        type: a
      } = this.state;
      if (!s && a === 15)
        return this.parseBind(e, r, s, i);
      if (Vc(a))
        return this.parseTaggedTemplateExpression(e, r, i);
      let o = !1;
      if (a === 18) {
        if (s && (this.raise(B.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return i.stop = !0, e;
        i.optionalChainMember = o = !0, this.next();
      }
      if (!s && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, r, i, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(e, r, i, l, o) : (i.stop = !0, e);
      }
    }
    parseMember(e, r, s, i, a) {
      let o = this.startNodeAt(r);
      return o.object = e, o.computed = i, i ? (o.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (e.type === "Super" &&
      this.raise(B.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), s.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(e, r, s, i) {
      let a = this.startNodeAt(r);
      return a.object = e, this.next(), a.callee = this.parseNoCallExpr(), i.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, s);
    }
    parseCoverCallAndAsyncArrowHead(e, r, s, i) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(r);
      l.callee = e;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = s;
      u && (this.expressionScope.enter(s_e()), o = new ea()), c && (l.optional = i), i ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, e.type === "Import", e.type !== "Super", l, o);
      let p = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !i ? (s.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), p)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = a, p;
    }
    toReferencedArguments(e, r) {
      this.toReferencedListDeep(e.arguments, r);
    }
    parseTaggedTemplateExpression(e, r, s) {
      let i = this.startNodeAt(r);
      return i.tag = e, i.quasi = this.parseTemplate(!0), s.optionalChainMember && this.raise(B.OptionalChainingNoTemplate, r), this.finishNode(
      i, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end -
      e.start === 5 && e.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(e, r) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), e.arguments.length === 0 ||
        e.arguments.length > 2)
          this.raise(B.ImportCallArity, e, {
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ?
            2 : 1
          });
        else
          for (let s of e.arguments)
            s.type === "SpreadElement" && this.raise(B.ImportCallSpreadArgument, s);
      return this.finishNode(e, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, r, s, i, a) {
      let o = [], l = !0, u = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          r && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(
          B.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        o.push(this.parseExprListItem(!1, a, s));
      }
      return this.state.inFSharpPipelineDirectBody = u, o;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, r) {
      var s;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(e, r.arguments, !0, (s = r.extra) == null ?
      void 0 : s.trailingCommaLoc), r.innerComments && Go(e, r.innerComments), r.callee.trailingComments && Go(e, r.callee.trailingComments),
      e;
    }
    parseNoCallExpr() {
      let e = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, !0);
    }
    parseExprAtom(e) {
      let r, s = null, {
        type: i
      } = this.state;
      switch (i) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.options.createImportExpressions ?
          this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(B.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          s = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(B.UnsupportedBind, a);
        }
        case 138:
          return this.raise(B.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          Rs(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (mt(i)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (mt(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, r) {
      let s = this.getPluginOption("pipelineOperator", "proposal");
      if (s)
        return this.state.type = e, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = Cr(this.state.endLoc, -1),
        this.parseTopicReference(s);
      this.unexpected();
    }
    parseTopicReference(e) {
      let r = this.startNode(), s = this.state.startLoc, i = this.state.type;
      return this.next(), this.finishTopicReference(r, s, e, i);
    }
    finishTopicReference(e, r, s, i) {
      if (this.testTopicReferenceConfiguration(s, r, i)) {
        let a = s === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s === "smart" ? B.PrimaryTopicNotAllowed : B.PipeTopicUnbound, r),
        this.registerTopicReference(), this.finishNode(e, a);
      } else
        throw this.raise(B.PipeTopicUnconfiguredToken, r, {
          token: xi(i)
        });
    }
    testTopicReferenceConfiguration(e, r, s) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: xi(s)
          }]);
        case "smart":
          return s === 27;
        default:
          throw this.raise(B.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(Uc(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(B.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(e, r, !0);
    }
    parseDo(e, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), e.async = r, this.next();
      let s = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(),
      this.state.labels = s, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      let e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(B.SuperNotAllowed,
      e) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(B.UnexpectedSuper, e), !this.match(10) && !this.match(
      0) && !this.match(16) && this.raise(B.UnsupportedSuper, e), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      let e = this.startNode(), r = this.startNodeAt(Cr(this.state.startLoc, 1)), s = this.state.value;
      return this.next(), e.id = this.createIdentifier(r, s), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(e, r, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, r, s) {
      e.meta = r;
      let i = this.state.containsEsc;
      return e.property = this.parseIdentifier(!0), (e.property.name !== s || i) && this.raise(B.UnsupportedMetaProperty, e.property, {
        target: r.name,
        onlyValidPropertyName: s
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      let r = this.createIdentifier(this.startNodeAtNode(e), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(B.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let s = this.isContextual(105);
        if (s || this.unexpected(), this.expectPlugin(s ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(B.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), e.phase = s ? "source" : "defer", this.parseImportCall(e);
      }
      return this.parseMetaProperty(e, r, "meta");
    }
    parseLiteralAtNode(e, r, s) {
      return this.addExtra(s, "rawValue", e), this.addExtra(s, "raw", this.input.slice(s.start, this.state.end)), s.value = e, this.next(), this.
      finishNode(s, r);
    }
    parseLiteral(e, r) {
      let s = this.startNode();
      return this.parseLiteralAtNode(e, r, s);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      let r = this.parseLiteral(e.value, "RegExpLiteral");
      return r.pattern = e.pattern, r.flags = e.flags, r;
    }
    parseBooleanLiteral(e) {
      let r = this.startNode();
      return r.value = e, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      let r = this.state.startLoc, s;
      this.next(), this.expressionScope.enter(r_e());
      let i = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new ea(), c = !0, p, f;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          f = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let T = this.state.startLoc;
          if (p = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), T)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let m = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = a;
      let y = this.startNodeAt(r);
      return e && this.shouldParseArrow(l) && (y = this.parseArrow(y)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(y, l, !1), y) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), f && this.unexpected(f), p && this.unexpected(p), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (s = this.startNodeAt(o), s.expressions = l, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s,
      m)) : s = l[0], this.wrapParenthesis(r, s));
    }
    wrapParenthesis(e, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", e.index), this.takeSurroundingComments(r, e.index, this.
        state.lastTokEndLoc.index), r;
      let s = this.startNodeAt(e);
      return s.expression = r, this.finishNode(s, "ParenthesizedExpression");
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, r) {
      return e;
    }
    parseNewOrNewTarget() {
      let e = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        let s = this.parseMetaProperty(e, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(B.UnexpectedNewTarget,
        s), s;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), e.arguments = r;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      let r = this.match(83), s = this.parseNoCallExpr();
      e.callee = s, r && (s.type === "Import" || s.type === "ImportExpression") && this.raise(B.ImportCallNotNewExpression, s);
    }
    parseTemplateElement(e) {
      let {
        start: r,
        startLoc: s,
        end: i,
        value: a
      } = this.state, o = r + 1, l = this.startNodeAt(Cr(s, 1));
      a === null && (e || this.raise(B.InvalidEscapeSequenceTemplate, Cr(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, p = i + c;
      l.value = {
        raw: this.input.slice(o, p).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let f = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(f, Cr(this.state.lastTokEndLoc, c)), f;
    }
    parseTemplate(e) {
      let r = this.startNode(), s = this.parseTemplateElement(e), i = [s], a = [];
      for (; !s.tail; )
        a.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), i.push(s = this.parseTemplateElement(e));
      return r.expressions = a, r.quasis = i, this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, r, s, i) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = /* @__PURE__ */ Object.create(null), l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let p;
        r ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(i), this.checkProto(p, s, o, i)), s && !this.isObjectProperty(
        p) && p.type !== "SpreadElement" && this.raise(B.InvalidRecordProperty, p), p.shorthand && this.addExtra(p, "shorthand", !0), u.properties.
        push(p);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return r ? c = "ObjectPattern" : s && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(B.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let s = this.startNode(), i = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (s.decorators = r, r = []), s.method = !1, e && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(s);
      let u = this.state.containsEsc;
      if (this.parsePropertyName(s, e), !l && !u && this.maybeAsyncOrAccessorProp(s)) {
        let {
          key: c
        } = s, p = c.name;
        p === "async" && !this.hasPrecedingLineBreak() && (i = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        s)), (p === "get" || p === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), s.kind = p, this.match(55) && (l = !0, this.
        raise(B.AccessorIsGenerator, this.state.curPosition(), {
          kind: p
        }), this.next()), this.parsePropertyName(s));
      }
      return this.parseObjPropValue(s, o, l, i, !1, a, e);
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var r;
      let s = this.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e);
      i.length !== s && this.raise(e.kind === "get" ? B.BadGetterArity : B.BadSetterArity, e), e.kind === "set" && ((r = i[i.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(B.BadSetterRestParameter, e);
    }
    parseObjectMethod(e, r, s, i, a) {
      if (a) {
        let o = this.parseMethod(e, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (s || r || this.match(10))
        return i && this.unexpected(), e.kind = "method", e.method = !0, this.parseMethod(e, r, s, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(e, r, s, i) {
      if (e.shorthand = !1, this.eat(14))
        return e.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(e, "ObjectProper\
ty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), s)
          e.value = this.parseMaybeDefault(r, qs(e.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = a) : this.raise(B.InvalidCoverInitializedName, a), e.value = this.
          parseMaybeDefault(r, qs(e.key));
        } else
          e.value = qs(e.key);
        return e.shorthand = !0, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, r, s, i, a, o, l) {
      let u = this.parseObjectMethod(e, s, i, a, o) || this.parseObjectProperty(e, r, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(e, r) {
      if (this.eat(0))
        e.computed = !0, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: s,
          value: i
        } = this.state, a;
        if (es(s))
          a = this.parseIdentifier(!0);
        else
          switch (s) {
            case 134:
              a = this.parseNumericLiteral(i);
              break;
            case 133:
              a = this.parseStringLiteral(i);
              break;
            case 135:
              a = this.parseBigIntLiteral(i);
              break;
            case 136:
              a = this.parseDecimalLiteral(i);
              break;
            case 138: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(B.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        e.key = a, s !== 138 && (e.computed = !1);
      }
    }
    initFunction(e, r) {
      e.id = null, e.generator = !1, e.async = r;
    }
    parseMethod(e, r, s, i, a, o, l = !1) {
      this.initFunction(e, s), e.generator = r, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(Uc(s, e.generator)),
      this.parseFunctionParams(e, i);
      let u = this.parseFunctionBodyAndFinish(e, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(e, r, s, i) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(e, !s, i, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, s ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, r, s, i) {
      this.scope.enter(6);
      let a = Uc(s, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(e, s);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e, r, i)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(e, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(e, r, s) {
      this.toAssignableList(r, s, !1), e.params = r;
    }
    parseFunctionBodyAndFinish(e, r, s = !1) {
      return this.parseFunctionBody(e, !1, s), this.finishNode(e, r);
    }
    parseFunctionBody(e, r, s = !1) {
      let i = r && !this.match(5);
      if (this.expressionScope.enter(CN()), i)
        e.body = this.parseMaybeAssign(), this.checkParams(e, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), e.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(e.params);
          l && u && this.raise(B.IllegalLanguageModeDirective, (e.kind === "method" || e.kind === "constructor") && e.key ? e.key.loc.end : e);
          let c = !a && this.state.strict;
          this.checkParams(e, !this.state.strict && !r && !s && !u, r, c), this.state.strict && e.id && this.checkIdentifier(e.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let r = 0, s = e.length; r < s; r++)
        if (!this.isSimpleParameter(e[r])) return !1;
      return !0;
    }
    checkParams(e, r, s, i = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of e.params)
        this.checkLVal(l, {
          in: o,
          binding: 5,
          checkClashes: a,
          strictModeChanged: i
        });
    }
    parseExprList(e, r, s, i) {
      let a = [], o = !0;
      for (; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        a.push(this.parseExprListItem(r, s));
      }
      return a;
    }
    parseExprListItem(e, r, s) {
      let i;
      if (this.match(12))
        e || this.raise(B.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), i = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        i = this.parseParenItem(this.parseSpread(r), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), s || this.raise(B.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), i = this.finishNode(a, "ArgumentPlaceholder");
      } else
        i = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return i;
    }
    parseIdentifier(e) {
      let r = this.startNode(), s = this.parseIdentifierName(e);
      return this.createIdentifier(r, s);
    }
    createIdentifier(e, r) {
      return e.name = r, e.loc.identifierName = r, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e) {
      let r, {
        startLoc: s,
        type: i
      } = this.state;
      es(i) ? r = this.state.value : this.unexpected();
      let a = NDe(i);
      return e ? a && this.replaceToken(132) : this.checkReservedWord(r, s, a, !1), this.next(), r;
    }
    checkReservedWord(e, r, s, i) {
      if (e.length > 10 || !$De(e))
        return;
      if (s && YDe(e)) {
        this.raise(B.UnexpectedKeyword, r, {
          keyword: e
        });
        return;
      }
      if ((this.state.strict ? i ? gN : xN : bN)(e, this.inModule)) {
        this.raise(B.UnexpectedReservedWord, r, {
          reservedWord: e
        });
        return;
      } else if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(B.YieldBindingIdentifier, r);
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(B.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(B.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(B.ArgumentsInClass, r);
        return;
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(e) {
      let r = this.startNodeAt(e);
      return this.expressionScope.recordParameterInitializerError(B.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(B.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst =
      !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExp\
ression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || Vc(e) || e === 102 && !this.state.containsEsc || e === 137 || e === 56 || this.hasPlugin("v8\
intrinsic") && e === 54;
    }
    parseYield() {
      let e = this.startNode();
      this.expressionScope.recordParameterInitializerError(B.YieldInParameter, e), this.next();
      let r = !1, s = null;
      if (!this.hasPrecedingLineBreak())
        switch (r = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!r) break;
          default:
            s = this.parseMaybeAssign();
        }
      return e.delegate = r, e.argument = s, this.finishNode(e, "YieldExpression");
    }
    parseImportCall(e) {
      return this.next(), e.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) &&
      (e.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e.options = this.parseMaybeAssignAllowIn(),
      this.eat(12))), this.expect(11), this.finishNode(e, "ImportExpression");
    }
    checkPipelineAtInfixOperator(e, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(B.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(e, r) {
      if (this.isSimpleReference(e)) {
        let s = this.startNodeAt(r);
        return s.callee = e, this.finishNode(s, "PipelineBareFunction");
      } else {
        let s = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), s.expression = e, this.finishNode(s, "PipelineTopicExpression");
      }
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(B.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(B.PipelineTopicUnused, e);
    }
    withTopicBindingContext(e) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return e();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let s = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, e);
      return this.state.inFSharpPipelineDirectBody = s, i;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let e = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let s = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        e.body = this.parseProgram(r, 8, "module");
      } finally {
        s();
      }
      return this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }, Z0 = {
    kind: 1
  }, w_e = {
    kind: 2
  }, N_e = /[\uD800-\uDFFF]/u, eb = /in(?:stanceof)?/y;
  function O_e(t, e) {
    for (let r = 0; r < t.length; r++) {
      let s = t[r], {
        type: i
      } = s;
      if (typeof i == "number") {
        {
          if (i === 138) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, p = Cr(a.start, 1);
            t.splice(r, 1, new fs({
              type: Fs(27),
              value: "#",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }), new fs({
              type: Fs(132),
              value: l,
              start: c,
              end: u,
              startLoc: p,
              endLoc: a.end
            })), r++;
            continue;
          }
          if (Vc(i)) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, p = Cr(a.start, 1), f;
            e.charCodeAt(o) === 96 ? f = new fs({
              type: Fs(22),
              value: "`",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }) : f = new fs({
              type: Fs(8),
              value: "}",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            });
            let m, y, T, L;
            i === 24 ? (y = u - 1, T = Cr(a.end, -1), m = l === null ? null : l.slice(1, -1), L = new fs({
              type: Fs(22),
              value: "`",
              start: y,
              end: u,
              startLoc: T,
              endLoc: a.end
            })) : (y = u - 2, T = Cr(a.end, -2), m = l === null ? null : l.slice(1, -2), L = new fs({
              type: Fs(23),
              value: "${",
              start: y,
              end: u,
              startLoc: T,
              endLoc: a.end
            })), t.splice(r, 1, f, new fs({
              type: Fs(20),
              value: m,
              start: c,
              end: y,
              startLoc: p,
              endLoc: T
            }), L), r += 2;
            continue;
          }
        }
        s.type = Fs(i);
      }
    }
    return t;
  }
  n(O_e, "babel7CompatTokens");
  var Sb = class extends xb {
    static {
      n(this, "StatementParser");
    }
    parseTopLevel(e, r) {
      return e.program = this.parseProgram(r), e.comments = this.comments, this.options.tokens && (e.tokens = O_e(this.tokens, this.input)),
      this.finishNode(e, "File");
    }
    parseProgram(e, r = 139, s = this.options.sourceType) {
      if (e.sourceType = s, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, r), this.inModule && !this.options.
      allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [a, o] of Array.from(this.scope.undefinedExports))
          this.raise(B.ModuleExportUndefined, o, {
            localName: a
          });
      let i;
      return r === 139 ? i = this.finishNode(e, "Program") : i = this.finishNodeAt(e, "Program", Cr(this.state.startLoc, -1)), i;
    }
    stmtToDirective(e) {
      let r = e;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let s = r.value, i = s.value, a = this.input.slice(s.start, s.end), o = s.value = a.slice(1, -1);
      return this.addExtra(s, "raw", a), this.addExtra(s, "rawValue", o), this.addExtra(s, "expressionValue", i), s.type = "DirectiveLiteral",
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(e, r) {
      if (Rs(e)) {
        if (eb.lastIndex = r, eb.test(this.input)) {
          let s = this.codePointAtPos(eb.lastIndex);
          if (!Zn(s) && s !== 92)
            return !1;
        }
        return !0;
      } else return e === 92;
    }
    chStartsBindingPattern(e) {
      return e === 91 || e === 123;
    }
    hasFollowingBindingAtom() {
      let e = this.nextTokenStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, e);
    }
    hasInLineFollowingBindingIdentifier() {
      let e = this.nextTokenInLineStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingIdentifier(r, e);
    }
    startsUsingForOf() {
      let {
        type: e,
        containsEsc: r
      } = this.lookahead();
      if (e === 102 && !r)
        return !1;
      if (mt(e) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let e = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e, "using")) {
        e = this.nextTokenInLineStartSince(e + 5);
        let r = this.codePointAtPos(e);
        if (this.chStartsBindingIdentifier(r, e))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, e && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(e) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(e, r);
    }
    parseStatementContent(e, r) {
      let s = this.state.type, i = this.startNode(), a = !!(e & 2), o = !!(e & 4), l = e & 1;
      switch (s) {
        case 60:
          return this.parseBreakContinueStatement(i, !0);
        case 63:
          return this.parseBreakContinueStatement(i, !1);
        case 64:
          return this.parseDebuggerStatement(i);
        case 90:
          return this.parseDoWhileStatement(i);
        case 91:
          return this.parseForStatement(i);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? B.StrictFunction : this.options.annexB ? B.SloppyFunctionAnnexB : B.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(i, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, i), !0);
        case 69:
          return this.parseIfStatement(i);
        case 70:
          return this.parseReturnStatement(i);
        case 71:
          return this.parseSwitchStatement(i);
        case 72:
          return this.parseThrowStatement(i);
        case 73:
          return this.parseTryStatement(i);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? a || this.raise(B.UnexpectedLexicalDeclaration, i) : this.raise(B.AwaitUsingNotInAsyncContext, i),
            this.next(), this.parseVarStatement(i, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(B.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(B.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(i, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let p = this.nextTokenStart(), f = this.codePointAtPos(p);
          if (f !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(f, p) && f !== 123))
            break;
        }
        case 75:
          a || this.raise(B.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let p = this.state.value;
          return this.parseVarStatement(i, p);
        }
        case 92:
          return this.parseWhileStatement(i);
        case 76:
          return this.parseWithStatement(i);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(i);
        case 83: {
          let p = this.lookaheadCharCode();
          if (p === 40 || p === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !l && this.raise(B.UnexpectedImportExport, this.state.startLoc), this.next();
          let p;
          return s === 83 ? (p = this.parseImport(i), p.type === "ImportDeclaration" && (!p.importKind || p.importKind === "value") && (this.
          sawUnambiguousESM = !0)) : (p = this.parseExport(i, r), (p.type === "ExportNamedDeclaration" && (!p.exportKind || p.exportKind ===
          "value") || p.type === "ExportAllDeclaration" && (!p.exportKind || p.exportKind === "value") || p.type === "ExportDefaultDeclarati\
on") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(p), p;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(B.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return mt(s) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, u, c, e) : this.parseExpressionStatement(i, c,
      r);
    }
    assertModuleNodeAllowed(e) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(B.ImportOutsideModule, e);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(e, r, s) {
      return e && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolea\
n" && this.raise(B.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...e)) : r.decorators = e, this.resetStartLocationFromNode(
      r, e[0]), s && this.resetStartLocationFromNode(s, r)), r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(B.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(B.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, s;
        if (this.match(10)) {
          let i = this.state.startLoc;
          this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(i, s);
          let a = this.state.startLoc;
          e.expression = this.parseMaybeDecoratorArguments(s), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && e.expression !==
          s && this.raise(B.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (s = this.parseIdentifier(!1); this.eat(16); ) {
            let i = this.startNodeAt(r);
            i.object = s, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i.property = this.parsePrivateName()) :
            i.property = this.parseIdentifier(!0), i.computed = !1, s = this.finishNode(i, "MemberExpression");
          }
          e.expression = this.parseMaybeDecoratorArguments(s);
        }
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e) {
      if (this.eat(10)) {
        let r = this.startNodeAtNode(e);
        return r.callee = e, r.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(r.arguments), this.finishNode(r,
        "CallExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, r) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      e, r), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, r) {
      let s;
      for (s = 0; s < this.state.labels.length; ++s) {
        let i = this.state.labels[s];
        if ((e.label == null || i.name === e.label.name) && (i.kind != null && (r || i.kind === 1) || e.label && r))
          break;
      }
      if (s === this.state.labels.length) {
        let i = r ? "BreakStatement" : "ContinueStatement";
        this.raise(B.IllegalBreakContinue, e, {
          type: i
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoWhileStatement(e) {
      return this.next(), this.state.labels.push(Z0), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(Z0);
      let r = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(
      13))
        return r !== null && this.unexpected(r), this.parseFor(e, null);
      let s = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), c = u || this.isContextual(107) && this.startsUsingForOf(), p = s && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || p) {
          let f = this.startNode(), m;
          u ? (m = "await using", this.isAwaitAllowed() || this.raise(B.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : m =
          this.state.value, this.next(), this.parseVar(f, !0, m);
          let y = this.finishNode(f, "VariableDeclaration"), T = this.match(58);
          return T && c && this.raise(B.ForInUsing, y), (T || this.isContextual(102)) && y.declarations.length === 1 ? this.parseForIn(e, y,
          r) : (r !== null && this.unexpected(r), this.parseFor(e, y));
        }
      }
      let i = this.isContextual(95), a = new ea(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (s && this.raise(B.ForOfLet, o), r === null && i && o.type === "Identifier" && this.raise(B.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          in: {
            type: u
          }
        }), this.parseForIn(e, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(e, o);
    }
    parseFunctionStatement(e, r, s) {
      return this.next(), this.parseFunction(e, 1 | (s ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(B.IllegalReturn, this.state.startLoc), this.
      next(), this.isLineTerminator() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "Ret\
urnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      let r = e.cases = [];
      this.expect(5), this.state.labels.push(w_e), this.scope.enter(0);
      let s;
      for (let i; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          s && this.finishNode(s, "SwitchCase"), r.push(s = this.startNode()), s.consequent = [], this.next(), a ? s.test = this.parseExpression() :
          (i && this.raise(B.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i = !0, s.test = null), this.expect(14);
        } else
          s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchState\
ment");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(B.NewlineAfterThrow, this.state.lastTokEndLoc), e.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let e = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && e.type === "Identifier" ? 8 : 0), this.checkLVal(e, {
        in: {
          type: "CatchClause"
        },
        binding: 9
      }), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), e.handler = this.finishNode(
        r, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(B.NoCatchOrFinally, e), this.finishNode(
      e, "TryStatement");
    }
    parseVarStatement(e, r, s = !1) {
      return this.next(), this.parseVar(e, !1, r, s), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(Z0), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(B.StrictWith, this.state.startLoc), this.next(), e.object = this.parseHeaderExpression(), e.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, r, s, i) {
      for (let o of this.state.labels)
        o.name === r && this.raise(B.LabelRedeclaration, s, {
          labelName: r
        });
      let a = DDe(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === e.start)
          l.statementStart = this.state.start, l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.state.start
      }), e.body = i & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e.label =
      s, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, r, s) {
      return e.expression = r, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = !1, r = !0, s) {
      let i = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(i, e, !1, 8, s), r && this.
      scope.exit(), this.finishNode(i, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, r, s, i, a) {
      let o = e.body = [], l = e.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? l : void 0, s, i, a);
    }
    parseBlockOrModuleBlockBody(e, r, s, i, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(i); ) {
        let c = s ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !u) {
          if (this.isValidDirective(c)) {
            let p = this.stmtToDirective(c);
            r.push(p), !l && p.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        e.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(e, r) {
      return e.init = r, this.semicolon(!1), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, r, s) {
      let i = this.match(58);
      return this.next(), i ? s !== null && this.unexpected(s) : e.await = s !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!i || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(B.ForInOfLoopInitializer, r, {
        type: i ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(B.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = r, e.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, i ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, r, s, i = !1) {
      let a = e.declarations = [];
      for (e.kind = s; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, s), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !i && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(B.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(B.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: s
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return e;
    }
    parseVarId(e, r) {
      let s = this.parseBindingAtom();
      this.checkLVal(s, {
        in: {
          type: "VariableDeclarator"
        },
        binding: r === "var" ? 5 : 8201
      }), e.id = s;
    }
    parseAsyncFunctionExpression(e) {
      return this.parseFunction(e, 8);
    }
    parseFunction(e, r = 0) {
      let s = r & 2, i = !!(r & 1), a = i && !(r & 4), o = !!(r & 8);
      this.initFunction(e, o), this.match(55) && (s && this.raise(B.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e.
      generator = !0), i && (e.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(Uc(o, e.generator)), i || (e.id = this.parseFunctionId()),
      this.parseFunctionParams(e, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, i ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), i && !s && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = l, e;
    }
    parseFunctionId(e) {
      return e || mt(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, r) {
      this.expect(10), this.expressionScope.enter(t_e()), e.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, e.id.loc.start);
    }
    parseClass(e, r, s) {
      this.next();
      let i = this.state.strict;
      return this.state.strict = !0, this.parseClassId(e, r, s), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, i), this.
      finishNode(e, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(e) {
      return e.type === "Identifier" && e.name === "constructor" || e.type === "StringLiteral" && e.value === "constructor";
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && this.nameIsConstructor(e.key);
    }
    parseClassBody(e, r) {
      this.classScope.enter();
      let s = {
        hadConstructor: !1,
        hadSuperClass: e
      }, i = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (i.length > 0)
              throw this.raise(B.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            i.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          i.length && (o.decorators = i, this.resetStartLocationFromNode(o, i[0]), i = []), this.parseClassMember(a, o, s), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(B.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), i.length)
        throw this.raise(B.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(e, r) {
      let s = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let i = r;
        return i.kind = "method", i.computed = !1, i.key = s, i.static = !1, this.pushClassMethod(e, i, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let i = r;
        return i.computed = !1, i.key = s, i.static = !1, e.body.push(this.parseClassProperty(i)), !0;
      }
      return this.resetPreviousNodeTrailingComments(s), !1;
    }
    parseClassMember(e, r, s) {
      let i = this.isContextual(106);
      if (i) {
        if (this.parseClassMemberFromModifier(e, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, r, s, i);
    }
    parseClassMemberWithIsStatic(e, r, s, i) {
      let a = r, o = r, l = r, u = r, c = r, p = a, f = a;
      if (r.static = i, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        p.kind = "method";
        let _ = this.match(138);
        if (this.parseClassElementName(p), _) {
          this.pushClassPrivateMethod(e, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(B.ConstructorIsGenerator, a.key), this.pushClassMethod(e, a, !0, !1, !1, !1);
        return;
      }
      let m = !this.state.containsEsc && mt(this.state.type), y = this.parseClassElementName(r), T = m ? y.name : null, L = this.isPrivateName(
      y), q = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(f), this.isClassMethod()) {
        if (p.kind = "method", L) {
          this.pushClassPrivateMethod(e, o, !1, !1);
          return;
        }
        let _ = this.isNonstaticConstructor(a), U = !1;
        _ && (a.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(B.DuplicateConstructor, y), _ && this.
        hasPlugin("typescript") && r.override && this.raise(B.OverrideOnConstructor, y), s.hadConstructor = !0, U = s.hadSuperClass), this.pushClassMethod(
        e, a, !1, !1, _, U);
      } else if (this.isClassProperty())
        L ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l);
      else if (T === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(y);
        let _ = this.eat(55);
        f.optional && this.unexpected(q), p.kind = "method";
        let U = this.match(138);
        this.parseClassElementName(p), this.parsePostMemberNameModifiers(f), U ? this.pushClassPrivateMethod(e, o, _, !0) : (this.isNonstaticConstructor(
        a) && this.raise(B.ConstructorIsAsync, a.key), this.pushClassMethod(e, a, _, !0, !1, !1));
      } else if ((T === "get" || T === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(y), p.kind = T;
        let _ = this.match(138);
        this.parseClassElementName(a), _ ? this.pushClassPrivateMethod(e, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(B.ConstructorIsAccessor,
        a.key), this.pushClassMethod(e, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (T === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(y);
        let _ = this.match(138);
        this.parseClassElementName(l), this.pushClassAccessorProperty(e, c, _);
      } else this.isLineTerminator() ? L ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l) : this.unexpected();
    }
    parseClassElementName(e) {
      let {
        type: r,
        value: s
      } = this.state;
      if ((r === 132 || r === 133) && e.static && s === "prototype" && this.raise(B.StaticPrototype, this.state.startLoc), r === 138) {
        s === "constructor" && this.raise(B.ConstructorClassPrivateField, this.state.startLoc);
        let i = this.parsePrivateName();
        return e.key = i, i;
      }
      return this.parsePropertyName(e), e.key;
    }
    parseClassStaticBlock(e, r) {
      var s;
      this.scope.enter(208);
      let i = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, e.body.push(this.
      finishNode(r, "StaticBlock")), (s = r.decorators) != null && s.length && this.raise(B.DecoratorStaticBlock, r);
    }
    pushClassProperty(e, r) {
      !r.computed && this.nameIsConstructor(r.key) && this.raise(B.ConstructorClassField, r.key), e.body.push(this.parseClassProperty(r));
    }
    pushClassPrivateProperty(e, r) {
      let s = this.parseClassPrivateProperty(r);
      e.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
    }
    pushClassAccessorProperty(e, r, s) {
      !s && !r.computed && this.nameIsConstructor(r.key) && this.raise(B.ConstructorClassField, r.key);
      let i = this.parseClassAccessorProperty(r);
      e.body.push(i), s && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassMethod(e, r, s, i, a, o) {
      e.body.push(this.parseMethod(r, s, i, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(e, r, s, i) {
      let a = this.parseMethod(r, s, i, !1, !1, "ClassPrivateMethod", !0);
      e.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(e, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), r, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(80), this.expressionScope.enter(CN()), this.prodParam.enter(0), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, r, s, i = 8331) {
      if (mt(this.state.type))
        e.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(e.id, i);
      else if (s || !r)
        e.id = null;
      else
        throw this.raise(B.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e, r) {
      let s = this.parseMaybeImportPhase(e, !0), i = this.maybeParseExportDefaultSpecifier(e, s), a = !i || this.eat(12), o = a && this.eatExportStar(
      e), l = o && this.maybeParseExportNamespaceSpecifier(e), u = a && (!l || this.eat(12)), c = i || o;
      if (o && !l) {
        if (i && this.unexpected(), r)
          throw this.raise(B.UnsupportedDecoratorExport, e);
        return this.parseExportFrom(e, !0), this.finishNode(e, "ExportAllDeclaration");
      }
      let p = this.maybeParseExportNamedSpecifiers(e);
      i && a && !o && !p && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let f;
      if (c || p) {
        if (f = !1, r)
          throw this.raise(B.UnsupportedDecoratorExport, e);
        this.parseExportFrom(e, c);
      } else
        f = this.maybeParseExportDeclaration(e);
      if (c || p || f) {
        var m;
        let y = e;
        if (this.checkExport(y, !0, !1, !!y.source), ((m = y.declaration) == null ? void 0 : m.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, y.declaration, y);
        else if (r)
          throw this.raise(B.UnsupportedDecoratorExport, e);
        return this.finishNode(y, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let y = e, T = this.parseExportDefaultExpression();
        if (y.declaration = T, T.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, T, y);
        else if (r)
          throw this.raise(B.UnsupportedDecoratorExport, e);
        return this.checkExport(y, !0, !0), this.finishNode(y, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let s = r || this.parseIdentifier(!0), i = this.startNodeAtNode(s);
        return i.exported = s, e.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        var r, s;
        (s = (r = e).specifiers) != null || (r.specifiers = []);
        let i = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), i.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(i, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        let r = e;
        r.specifiers || (r.specifiers = []);
        let s = r.exportKind === "type";
        return r.specifiers.push(...this.parseExportSpecifiers(s)), r.source = null, r.declaration = null, this.hasPlugin("importAssertions") &&
        (r.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") && (e.assertions =
      []), e.declaration = this.parseExportDeclaration(e), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let e = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      let e = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(e, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(e, 13);
      if (this.match(80))
        return this.parseClass(e, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(B.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(B.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(e) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: e
      } = this.state;
      if (mt(e)) {
        if (e === 95 && !this.state.containsEsc || e === 100)
          return !1;
        if ((e === 130 || e === 129) && !this.state.containsEsc) {
          let {
            type: i
          } = this.lookahead();
          if (mt(i) && i !== 98 || i === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), s = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || mt(this.state.type) && s)
        return !0;
      if (this.match(65) && s) {
        let i = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return i === 34 || i === 39;
      }
      return !1;
    }
    parseExportFrom(e, r) {
      this.eatContextual(98) ? (e.source = this.parseImportSource(), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(
      e)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: e
      } = this.state;
      return e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(B.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.
      raise(B.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(B.UsingDeclarationExport,
      this.state.startLoc), !0) : e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, r, s, i) {
      if (r) {
        var a;
        if (s) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = e.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            B.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = e.specifiers) != null && a.length)
          for (let l of e.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !i && l.local) {
              let {
                local: p
              } = l;
              p.type !== "Identifier" ? this.raise(B.ExportBindingIsString, l, {
                localName: p.value,
                exportName: c
              }) : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p));
            }
          }
        else if (e.declaration) {
          let l = e.declaration;
          if (l.type === "FunctionDeclaration" || l.type === "ClassDeclaration") {
            let {
              id: u
            } = l;
            if (!u) throw new Error("Assertion failure");
            this.checkDuplicateExports(e, u.name);
          } else if (l.type === "VariableDeclaration")
            for (let u of l.declarations)
              this.checkDeclaration(u.id);
        }
      }
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (let r of e.properties)
          this.checkDeclaration(r);
      else if (e.type === "ArrayPattern")
        for (let r of e.elements)
          r && this.checkDeclaration(r);
      else e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type ===
      "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(B.DuplicateDefaultExport, e) : this.raise(B.DuplicateExport, e, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(e) {
      let r = [], s = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (s)
          s = !1;
        else if (this.expect(12), this.eat(8)) break;
        let i = this.isContextual(130), a = this.match(133), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, e, i));
      }
      return r;
    }
    parseExportSpecifier(e, r, s, i) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : r ? e.exported = n_e(e.local) : e.exported || (e.exported =
      qs(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let e = this.parseStringLiteral(this.state.value), r = e.value.match(N_e);
        return r && this.raise(B.ModuleExportNameHasLoneSurrogate, e, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: r,
        value: s
      }) => s.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(e) {
      let {
        specifiers: r
      } = e, s = r.length === 1 ? r[0].type : null;
      if (e.phase === "source")
        s !== "ImportDefaultSpecifier" && this.raise(B.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (e.phase === "defer")
        s !== "ImportNamespaceSpecifier" && this.raise(B.DeferImportRequiresNamespace, r[0].loc.start);
      else if (e.module) {
        var i;
        s !== "ImportDefaultSpecifier" && this.raise(B.ImportReflectionNotBinding, r[0].loc.start), ((i = e.assertions) == null ? void 0 : i.
        length) > 0 && this.raise(B.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = e;
        if (r != null) {
          let s = r.find((i) => {
            let a;
            if (i.type === "ExportSpecifier" ? a = i.local : i.type === "ImportSpecifier" && (a = i.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          s !== void 0 && this.raise(B.ImportJSONBindingNotDefault, s.loc.start);
        }
      }
    }
    isPotentialImportPhase(e) {
      return e ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(e, r, s, i) {
      r || (s === "module" ? (this.expectPlugin("importReflection", i), e.module = !0) : this.hasPlugin("importReflection") && (e.module = !1),
      s === "source" ? (this.expectPlugin("sourcePhaseImports", i), e.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", i), e.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
    }
    parseMaybeImportPhase(e, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(e, r, null), null;
      let s = this.parseIdentifier(!0), {
        type: i
      } = this.state;
      return (es(i) ? i !== 98 || this.lookaheadCharCode() === 102 : i !== 12) ? (this.resetPreviousIdentifierLeadingComments(s), this.applyImportPhase(
      e, r, s.name, s.loc.start), null) : (this.applyImportPhase(e, r, null), s);
    }
    isPrecedingIdImportPhase(e) {
      let {
        type: r
      } = this.state;
      return mt(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(e) {
      return this.match(133) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
    }
    parseImportSpecifiersAndAfter(e, r) {
      e.specifiers = [];
      let i = !this.maybeParseDefaultImportSpecifier(e, r) || this.eat(12), a = i && this.maybeParseStarImportSpecifier(e);
      return i && !a && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
    }
    parseImportSourceAndAttributes(e) {
      var r;
      return (r = e.specifiers) != null || (e.specifiers = []), e.source = this.parseImportSource(), this.maybeParseImportAttributes(e), this.
      checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(e, r, s) {
      r.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(r, s));
    }
    finishImportSpecifier(e, r, s = 8201) {
      return this.checkLVal(e.local, {
        in: {
          type: r
        },
        binding: s
      }), this.finishNode(e, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let s = this.startNode(), i = this.state.value;
        if (r.has(i) && this.raise(B.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: i
        }), r.add(i), this.match(133) ? s.key = this.parseStringLiteral(i) : s.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        133))
          throw this.raise(B.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), e;
    }
    parseModuleAttributes() {
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        let s = this.startNode();
        if (s.key = this.parseIdentifier(!0), s.key.name !== "type" && this.raise(B.ModuleAttributeDifferentFromType, s.key), r.has(s.key.name) &&
        this.raise(B.ModuleAttributesWithDuplicateKeys, s.key, {
          key: s.key.name
        }), r.add(s.key.name), this.expect(14), !this.match(133))
          throw this.raise(B.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAttributes(e) {
      let r, s = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), r = this.
        parseImportAttributes()), s = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(B.ImportAttributesUseAssert,
        this.state.startLoc), this.addExtra(e, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]),
        this.next(), r = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        r = [];
      else if (this.hasPlugin("moduleAttributes"))
        r = [];
      else return;
      !s && this.hasPlugin("importAssertions") ? e.assertions = r : e.attributes = r;
    }
    maybeParseDefaultImportSpecifier(e, r) {
      if (r) {
        let s = this.startNodeAtNode(r);
        return s.local = r, e.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), !0;
      } else if (es(this.state.type))
        return this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(e) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(B.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let s = this.startNode(), i = this.match(133), a = this.isContextual(130);
        s.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(s, i, e.importKind === "type" || e.importKind === "typeof", a, void 0);
        e.specifiers.push(o);
      }
    }
    parseImportSpecifier(e, r, s, i, a) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = e;
        if (r)
          throw this.raise(B.ImportBindingIsString, e, {
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, !0, !0), e.local || (e.local = qs(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier", a);
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }, Wc = class extends Sb {
    static {
      n(this, "Parser");
    }
    constructor(e, r) {
      e = I_e(e), super(e, r), this.options = e, this.initializeScopes(), this.plugins = k_e(this.options.plugins), this.filename = e.sourceFilename;
    }
    getScopeHandler() {
      return zo;
    }
    parse() {
      this.enterInitialScopes();
      let e = this.startNode(), r = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, r), e.errors = this.state.errors, e.comments.length = this.state.commentsLen,
      e;
    }
  };
  function k_e(t) {
    let e = /* @__PURE__ */ new Map();
    for (let r of t) {
      let [s, i] = Array.isArray(r) ? r : [r, {}];
      e.has(s) || e.set(s, i || {});
    }
    return e;
  }
  n(k_e, "pluginsMap");
  function D_e(t, e) {
    var r;
    if (((r = e) == null ? void 0 : r.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        let s = Jo(e, t), i = s.parse();
        if (s.sawUnambiguousESM)
          return i;
        if (s.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", Jo(e, t).parse();
          } catch {
          }
        else
          i.program.sourceType = "script";
        return i;
      } catch (s) {
        try {
          return e.sourceType = "script", Jo(e, t).parse();
        } catch {
        }
        throw s;
      }
    } else
      return Jo(e, t).parse();
  }
  n(D_e, "parse");
  function __e(t, e) {
    let r = Jo(e, t);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  n(__e, "parseExpression");
  function L_e(t) {
    let e = {};
    for (let r of Object.keys(t))
      e[r] = Fs(t[r]);
    return e;
  }
  n(L_e, "generateExportedTokenTypes");
  var M_e = L_e(wDe);
  function Jo(t, e) {
    let r = Wc;
    return t != null && t.plugins && (v_e(t.plugins), r = B_e(t.plugins)), new r(t, e);
  }
  n(Jo, "getParser");
  var hN = {};
  function B_e(t) {
    let e = C_e.filter((i) => Yt(t, i)), r = e.join("/"), s = hN[r];
    if (!s) {
      s = Wc;
      for (let i of e)
        s = ON[i](s);
      hN[r] = s;
    }
    return s;
  }
  n(B_e, "getParserClass");
  Qo.parse = D_e;
  Qo.parseExpression = __e;
  Qo.tokTypes = M_e;
});

// src/csf-tools/index.ts
var sLe = {};
p2(sLe, {
  ConfigFile: () => Hc,
  CsfFile: () => Xc,
  NoMetaError: () => el,
  babelParse: () => Si,
  babelParseExpression: () => R_e,
  babelPrint: () => j_e,
  enrichCsf: () => rLe,
  enrichCsfMeta: () => e2,
  enrichCsfStory: () => QN,
  extractDescription: () => Jb,
  extractSource: () => t2,
  formatConfig: () => XN,
  formatCsf: () => J_e,
  getStorySortParameter: () => eLe,
  isModuleMock: () => BN,
  loadConfig: () => JN,
  loadCsf: () => FN,
  parserOptions: () => kb,
  printConfig: () => $N,
  printCsf: () => jN,
  readConfig: () => H_e,
  readCsf: () => X_e,
  writeConfig: () => z_e,
  writeCsf: () => $_e
});
module.exports = f2(sLe);

// src/csf-tools/CsfFile.ts
var $c = require("node:fs/promises"), Zo = $t(ul(), 1), G = $t(Ce(), 1), Db = $t(_a(), 1), _b = $t(ji(), 1), Mb = $t(require("recast"), 1), gi = require("@storybook/csf");

// src/csf-tools/babelParse.ts
var Yc = $t(kN(), 1), Jc = $t(require("recast"), 1);
function F_e(t, e) {
  let i = /^\s*\/\/\s*@flow/.test(t) ? ["flow"] : ["typescript"], a = {
    ...e,
    plugins: [...e.plugins ?? [], ...i]
  };
  return Yc.parse(t, a);
}
n(F_e, "parseWithFlowOrTypescript");
var kb = {
  sourceType: "module",
  // FIXME: we should get this from the project config somehow?
  plugins: ["jsx", "decorators-legacy", "classProperties"],
  tokens: !0
}, Si = /* @__PURE__ */ n((t) => Jc.parse(t, {
  parser: {
    parse(e) {
      return F_e(e, kb);
    }
  }
}), "babelParse"), j_e = /* @__PURE__ */ n((t) => Jc.print(t, {
  quote: "single",
  trailingComma: !0,
  tabWidth: 2,
  wrapColumn: 80,
  arrowParensAlways: !0
}).code, "babelPrint"), R_e = /* @__PURE__ */ n((t) => Yc.parseExpression(t, kb), "babelParseExpression");

// src/csf-tools/findVarInitialization.ts
var Vs = $t(Ce(), 1);
var Ks = /* @__PURE__ */ n((t, e) => {
  let r = null, s = null;
  return e.body.find((i) => (Vs.isVariableDeclaration(i) ? s = i.declarations : Vs.isExportNamedDeclaration(i) && Vs.isVariableDeclaration(i.
  declaration) && (s = i.declaration.declarations), s && s.find((a) => Vs.isVariableDeclarator(a) && Vs.isIdentifier(a.id) && a.id.name === t ?
  (r = a.init, !0) : !1))), r;
}, "findVarInitialization");

// src/csf-tools/CsfFile.ts
var U_e = _b.default.default || _b.default, q_e = Db.default.default || Db.default, DN = console;
function V_e(t) {
  if (G.isArrayExpression(t))
    return t.elements.map((e) => {
      if (G.isStringLiteral(e)) return e.value;
      throw new Error(`Expected string literal: ${e}`);
    });
  if (G.isStringLiteral(t)) return new RegExp(t.value);
  if (G.isRegExpLiteral(t)) return new RegExp(t.pattern, t.flags);
  throw new Error(`Unknown include/exclude: ${t}`);
}
n(V_e, "parseIncludeExclude");
function _N(t) {
  if (!G.isArrayExpression(t))
    throw new Error("CSF: Expected tags array");
  return t.elements.map((e) => {
    if (G.isStringLiteral(e)) return e.value;
    throw new Error("CSF: Expected tag to be string literal");
  });
}
n(_N, "parseTags");
var Lb = /* @__PURE__ */ n((t, e) => {
  let { line: r, column: s } = t.loc?.start || {};
  return `${e || ""} (line ${r}, col ${s})`.trim();
}, "formatLocation"), BN = /* @__PURE__ */ n((t) => Y_e.test(t), "isModuleMock"), LN = /* @__PURE__ */ n((t, e, r) => {
  let s = t;
  if (G.isCallExpression(t)) {
    let { callee: i, arguments: a } = t;
    if (G.isProgram(e) && G.isMemberExpression(i) && G.isIdentifier(i.object) && G.isIdentifier(i.property) && i.property.name === "bind" &&
    (a.length === 0 || a.length === 1 && G.isObjectExpression(a[0]) && a[0].properties.length === 0)) {
      let o = i.object.name, l = Ks(o, e);
      l && (r._templates[o] = l, s = l);
    }
  }
  return G.isArrowFunctionExpression(s) || G.isFunctionDeclaration(s) ? s.params.length > 0 : !1;
}, "isArgsStory"), K_e = /* @__PURE__ */ n((t) => {
  if (G.isArrayExpression(t))
    return t.elements.map((e) => {
      if (G.isStringLiteral(e))
        return e.value;
      throw new Error(`Expected string literal named export: ${e}`);
    });
  throw new Error(`Expected array of string literals: ${t}`);
}, "parseExportsOrder"), MN = /* @__PURE__ */ n((t, e) => e.reduce(
  (r, s) => {
    let i = t[s];
    return i && (r[s] = i), r;
  },
  {}
), "sortExports"), W_e = /* @__PURE__ */ n((t) => {
  if (G.isArrowFunctionExpression(t) || G.isFunctionDeclaration(t)) {
    let e = t.params;
    if (e.length >= 1) {
      let [r] = e;
      if (G.isObjectPattern(r))
        return !!r.properties.find((s) => {
          if (G.isObjectProperty(s) && G.isIdentifier(s.key))
            return s.key.name === "mount";
        });
    }
  }
  return !1;
}, "hasMount"), Y_e = /^[.\/#].*\.mock($|\.[^.]*$)/i, el = class extends Error {
  static {
    n(this, "NoMetaError");
  }
  constructor(e, r, s) {
    super(Zo.dedent`
      CSF: ${e} ${Lb(r, s)}

      More info: https://storybook.js.org/docs/react/writing-stories#default-export
    `), this.name = this.constructor.name;
  }
}, Xc = class {
  static {
    n(this, "CsfFile");
  }
  _ast;
  _fileName;
  _rawComponentPath;
  _makeTitle;
  _meta;
  _stories = {};
  _metaAnnotations = {};
  _storyExports = {};
  _metaStatement;
  _metaNode;
  _storyStatements = {};
  _storyAnnotations = {};
  _templates = {};
  _namedExportsOrder;
  imports;
  constructor(e, { fileName: r, makeTitle: s }) {
    this._ast = e, this._fileName = r, this.imports = [], this._makeTitle = s;
  }
  _parseTitle(e) {
    let r = G.isIdentifier(e) ? Ks(e.name, this._ast.program) : e;
    if (G.isStringLiteral(r))
      return r.value;
    if (G.isTSSatisfiesExpression(r) && G.isStringLiteral(r.expression))
      return r.expression.value;
    throw new Error(Zo.dedent`
      CSF: unexpected dynamic title ${Lb(r, this._fileName)}

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#string-literal-titles
    `);
  }
  _parseMeta(e, r) {
    let s = {};
    e.properties.forEach((i) => {
      if (G.isIdentifier(i.key)) {
        if (this._metaAnnotations[i.key.name] = i.value, i.key.name === "title")
          s.title = this._parseTitle(i.value);
        else if (["includeStories", "excludeStories"].includes(i.key.name))
          s[i.key.name] = V_e(i.value);
        else if (i.key.name === "component") {
          let a = i.value;
          if (G.isIdentifier(a)) {
            let l = a.name, u = r.body.find(
              (c) => G.isImportDeclaration(c) && c.specifiers.find((p) => p.local.name === l)
            );
            if (u) {
              let { source: c } = u;
              G.isStringLiteral(c) && (this._rawComponentPath = c.value);
            }
          }
          let { code: o } = Mb.print(i.value, {});
          s.component = o;
        } else if (i.key.name === "tags") {
          let a = i.value;
          G.isIdentifier(a) && (a = Ks(a.name, this._ast.program)), s.tags = _N(a);
        } else if (i.key.name === "id")
          if (G.isStringLiteral(i.value))
            s.id = i.value.value;
          else
            throw new Error(`Unexpected component id: ${i.value}`);
      }
    }), this._meta = s;
  }
  getStoryExport(e) {
    let r = this._storyExports[e];
    if (r = G.isVariableDeclarator(r) ? r.init : r, G.isCallExpression(r)) {
      let { callee: s, arguments: i } = r;
      if (G.isMemberExpression(s) && G.isIdentifier(s.object) && G.isIdentifier(s.property) && s.property.name === "bind" && (i.length === 0 ||
      i.length === 1 && G.isObjectExpression(i[0]) && i[0].properties.length === 0)) {
        let { name: a } = s.object;
        r = this._templates[a];
      }
    }
    return r;
  }
  parse() {
    let e = this;
    if (U_e(this._ast, {
      ExportDefaultDeclaration: {
        enter({ node: s, parent: i }) {
          let a, o = G.isIdentifier(s.declaration) && G.isProgram(i), l;
          if (o) {
            let u = s.declaration.name, c = /* @__PURE__ */ n((p) => G.isIdentifier(p.id) && p.id.name === u, "isVariableDeclarator");
            e._metaStatement = e._ast.program.body.find(
              (p) => G.isVariableDeclaration(p) && p.declarations.find(c)
            ), l = (e?._metaStatement?.declarations || []).find(
              c
            )?.init;
          } else
            e._metaStatement = s, l = s.declaration;
          if (G.isObjectExpression(l) ? a = l : (
            // export default { ... } as Meta<...>
            (G.isTSAsExpression(l) || G.isTSSatisfiesExpression(l)) && G.isObjectExpression(l.expression) && (a = l.expression)
          ), !e._meta && a && G.isProgram(i) && (e._metaNode = a, e._parseMeta(a, i)), e._metaStatement && !e._metaNode)
            throw new el(
              "default export must be an object",
              e._metaStatement,
              e._fileName
            );
        }
      },
      ExportNamedDeclaration: {
        enter({ node: s, parent: i }) {
          let a;
          G.isVariableDeclaration(s.declaration) ? a = s.declaration.declarations.filter((o) => G.isVariableDeclarator(o)) : G.isFunctionDeclaration(
          s.declaration) && (a = [s.declaration]), a ? a.forEach((o) => {
            if (G.isIdentifier(o.id)) {
              let { name: l } = o.id;
              if (l === "__namedExportsOrder" && G.isVariableDeclarator(o)) {
                e._namedExportsOrder = K_e(o.init);
                return;
              }
              e._storyExports[l] = o, e._storyStatements[l] = s;
              let u = (0, gi.storyNameFromExport)(l);
              e._storyAnnotations[l] ? DN.warn(
                `Unexpected annotations for "${l}" before story declaration`
              ) : e._storyAnnotations[l] = {};
              let c;
              G.isVariableDeclarator(o) ? c = G.isTSAsExpression(o.init) || G.isTSSatisfiesExpression(o.init) ? o.init.expression : o.init :
              c = o;
              let p = {};
              G.isObjectExpression(c) ? (p.__isArgsStory = !0, c.properties.forEach((f) => {
                if (G.isIdentifier(f.key)) {
                  if (f.key.name === "render")
                    p.__isArgsStory = LN(
                      f.value,
                      i,
                      e
                    );
                  else if (f.key.name === "name" && G.isStringLiteral(f.value))
                    u = f.value.value;
                  else if (f.key.name === "storyName" && G.isStringLiteral(f.value))
                    DN.warn(
                      `Unexpected usage of "storyName" in "${l}". Please use "name" instead.`
                    );
                  else if (f.key.name === "parameters" && G.isObjectExpression(f.value)) {
                    let m = f.value.properties.find(
                      (y) => G.isObjectProperty(y) && G.isIdentifier(y.key) && y.key.name === "__id"
                    );
                    m && (p.__id = m.value.value);
                  }
                  e._storyAnnotations[l][f.key.name] = f.value;
                }
              })) : p.__isArgsStory = LN(c, i, e), e._stories[l] = {
                id: "FIXME",
                name: u,
                parameters: p,
                __stats: {}
              };
            }
          }) : s.specifiers.length > 0 && s.specifiers.forEach((o) => {
            if (G.isExportSpecifier(o) && G.isIdentifier(o.exported)) {
              let { name: l } = o.exported;
              if (l === "default") {
                let u, c = G.isProgram(i) ? Ks(o.local.name, i) : o.local;
                G.isObjectExpression(c) ? u = c : (
                  // export default { ... } as Meta<...>
                  G.isTSAsExpression(c) && G.isObjectExpression(c.expression) && (u = c.expression)
                ), !e._meta && u && G.isProgram(i) && e._parseMeta(u, i);
              } else
                e._storyAnnotations[l] = {}, e._stories[l] = {
                  id: "FIXME",
                  name: l,
                  parameters: {},
                  __stats: {}
                };
            }
          });
        }
      },
      ExpressionStatement: {
        enter({ node: s, parent: i }) {
          let { expression: a } = s;
          if (G.isProgram(i) && G.isAssignmentExpression(a) && G.isMemberExpression(a.left) && G.isIdentifier(a.left.object) && G.isIdentifier(
          a.left.property)) {
            let o = a.left.object.name, l = a.left.property.name, u = a.right;
            if (e._storyAnnotations[o] && (l === "story" && G.isObjectExpression(u) ? u.properties.forEach((c) => {
              G.isIdentifier(c.key) && (e._storyAnnotations[o][c.key.name] = c.value);
            }) : e._storyAnnotations[o][l] = u), l === "storyName" && G.isStringLiteral(u)) {
              let c = u.value, p = e._stories[o];
              if (!p) return;
              p.name = c;
            }
          }
        }
      },
      CallExpression: {
        enter({ node: s }) {
          let { callee: i } = s;
          if (G.isIdentifier(i) && i.name === "storiesOf")
            throw new Error(Zo.dedent`
              Unexpected \`storiesOf\` usage: ${Lb(s, e._fileName)}.

              SB8 does not support \`storiesOf\`. 
            `);
        }
      },
      ImportDeclaration: {
        enter({ node: s }) {
          let { source: i } = s;
          if (G.isStringLiteral(i))
            e.imports.push(i.value);
          else
            throw new Error("CSF: unexpected import source");
        }
      }
    }), !e._meta)
      throw new el("missing default export", e._ast, e._fileName);
    let r = Object.entries(e._stories);
    if (e._meta.title = this._makeTitle(e._meta?.title), e._metaAnnotations.play && (e._meta.tags = [...e._meta.tags || [], "play-fn"]), e._stories =
    r.reduce(
      (s, [i, a]) => {
        if (!(0, gi.isExportStory)(i, e._meta))
          return s;
        let o = a.parameters?.__id ?? (0, gi.toId)(e._meta?.id || e._meta?.title, (0, gi.storyNameFromExport)(i)), l = { ...a.parameters, __id: o },
        { includeStories: u } = e._meta || {};
        i === "__page" && (r.length === 1 || Array.isArray(u) && u.length === 1) && (l.docsOnly = !0), s[i] = { ...a, id: o, parameters: l };
        let c = e._storyAnnotations[i], { tags: p, play: f } = c;
        if (p) {
          let T = G.isIdentifier(p) ? Ks(p.name, this._ast.program) : p;
          s[i].tags = _N(T);
        }
        f && (s[i].tags = [...s[i].tags || [], "play-fn"]);
        let m = s[i].__stats;
        ["play", "render", "loaders", "beforeEach"].forEach((T) => {
          m[T] = !!c[T] || !!e._metaAnnotations[T];
        });
        let y = e.getStoryExport(i);
        return m.storyFn = !!(G.isArrowFunctionExpression(y) || G.isFunctionDeclaration(y)), m.mount = W_e(c.play ?? e._metaAnnotations.play),
        m.moduleMock = !!e.imports.find((T) => BN(T)), s;
      },
      {}
    ), Object.keys(e._storyExports).forEach((s) => {
      (0, gi.isExportStory)(s, e._meta) || (delete e._storyExports[s], delete e._storyAnnotations[s]);
    }), e._namedExportsOrder) {
      let s = Object.keys(e._storyExports);
      e._storyExports = MN(e._storyExports, e._namedExportsOrder), e._stories = MN(e._stories, e._namedExportsOrder);
      let i = Object.keys(e._storyExports);
      if (s.length !== i.length)
        throw new Error(
          `Missing exports after sort: ${s.filter(
            (a) => !i.includes(a)
          )}`
        );
    }
    return e;
  }
  get meta() {
    return this._meta;
  }
  get stories() {
    return Object.values(this._stories);
  }
  get indexInputs() {
    if (!this._fileName)
      throw new Error(
        Zo.dedent`Cannot automatically create index inputs with CsfFile.indexInputs because the CsfFile instance was created without a the fileName option.
        Either add the fileName option when creating the CsfFile instance, or create the index inputs manually.`
      );
    return Object.entries(this._stories).map(([e, r]) => {
      let s = [...this._meta?.tags ?? [], ...r.tags ?? []];
      return {
        type: "story",
        importPath: this._fileName,
        rawComponentPath: this._rawComponentPath,
        exportName: e,
        name: r.name,
        title: this.meta?.title,
        metaId: this.meta?.id,
        tags: s,
        __id: r.id,
        __stats: r.__stats
      };
    });
  }
}, FN = /* @__PURE__ */ n((t, e) => {
  let r = Si(t);
  return new Xc(r, e);
}, "loadCsf"), J_e = /* @__PURE__ */ n((t, e = { sourceMaps: !1 }, r) => {
  let s = q_e(t._ast, e, r);
  return e.sourceMaps ? s : s.code;
}, "formatCsf"), jN = /* @__PURE__ */ n((t, e = {}) => Mb.print(t._ast, e), "printCsf"), X_e = /* @__PURE__ */ n(async (t, e) => {
  let r = (await (0, $c.readFile)(t, "utf-8")).toString();
  return FN(r, { ...e, fileName: t });
}, "readCsf"), $_e = /* @__PURE__ */ n(async (t, e) => {
  if (!(e || t._fileName)) throw new Error("Please specify a fileName for writeCsf");
  await (0, $c.writeFile)(e, jN(t).code);
}, "writeCsf");

// src/csf-tools/ConfigFile.ts
var zc = require("node:fs/promises"), qN = $t(ul(), 1), W = $t(Ce(), 1), jb = $t(_a(), 1), Rb = $t(ji(), 1), VN = $t(require("recast"), 1);
var RN = Rb.default.default || Rb.default, UN = jb.default.default || jb.default, Bb = console, Fb = /* @__PURE__ */ n(({
  expectedType: t,
  foundType: e,
  node: r
}) => {
  let s = "";
  if (r)
    try {
      s = JSON.stringify(r);
    } catch {
    }
  return qN.dedent`
      CSF Parsing error: Expected '${t}' but found '${e}' instead in '${r?.type}'.
      ${s}
    `;
}, "getCsfParsingErrorMessage"), tl = /* @__PURE__ */ n((t) => W.isIdentifier(t.key) ? t.key.name : W.isStringLiteral(t.key) ? t.key.value :
null, "propKey"), KN = /* @__PURE__ */ n((t, e) => {
  if (t.length === 0)
    return e;
  if (W.isObjectExpression(e)) {
    let [r, ...s] = t, i = e.properties.find((a) => tl(a) === r);
    if (i)
      return KN(s, i.value);
  }
}, "_getPath"), WN = /* @__PURE__ */ n((t, e) => {
  if (t.length === 0) {
    if (W.isObjectExpression(e))
      return e.properties;
    throw new Error("Expected object expression");
  }
  if (W.isObjectExpression(e)) {
    let [r, ...s] = t, i = e.properties.find((a) => tl(a) === r);
    if (i)
      return s.length === 0 ? e.properties : WN(s, i.value);
  }
}, "_getPathProperties"), YN = /* @__PURE__ */ n((t, e) => {
  let r = null, s = null;
  return e.body.find((i) => (W.isVariableDeclaration(i) ? s = i.declarations : W.isExportNamedDeclaration(i) && W.isVariableDeclaration(i.declaration) &&
  (s = i.declaration.declarations), s && s.find((a) => W.isVariableDeclarator(a) && W.isIdentifier(a.id) && a.id.name === t ? (r = a, !0) : !1))),
  r;
}, "_findVarDeclarator"), ia = /* @__PURE__ */ n((t, e) => YN(t, e)?.init, "_findVarInitialization"), rl = /* @__PURE__ */ n((t, e) => {
  if (t.length === 0) return e;
  let [r, ...s] = t, i = rl(s, e);
  return W.objectExpression([W.objectProperty(W.identifier(r), i)]);
}, "_makeObjectExpression"), Ub = /* @__PURE__ */ n((t, e, r) => {
  let [s, ...i] = t, a = r.properties.find(
    (o) => tl(o) === s
  );
  a ? W.isObjectExpression(a.value) && i.length > 0 ? Ub(i, e, a.value) : a.value = rl(i, e) : r.properties.push(
    W.objectProperty(W.identifier(s), rl(i, e))
  );
}, "_updateExportNode"), Hc = class {
  static {
    n(this, "ConfigFile");
  }
  _ast;
  _code;
  _exports = {};
  // FIXME: this is a hack. this is only used in the case where the user is
  // modifying a named export that's a scalar. The _exports map is not suitable
  // for that. But rather than refactor the whole thing, we just use this as a stopgap.
  _exportDecls = {};
  _exportsObject;
  _quotes;
  fileName;
  hasDefaultExport = !1;
  constructor(e, r, s) {
    this._ast = e, this._code = r, this.fileName = s;
  }
  parse() {
    let e = this;
    return RN(this._ast, {
      ExportDefaultDeclaration: {
        enter({ node: r, parent: s }) {
          e.hasDefaultExport = !0;
          let i = W.isIdentifier(r.declaration) && W.isProgram(s) ? ia(r.declaration.name, s) : r.declaration;
          (W.isTSAsExpression(i) || W.isTSSatisfiesExpression(i)) && (i = i.expression), W.isObjectExpression(i) ? (e._exportsObject = i, i.
          properties.forEach((a) => {
            let o = tl(a);
            if (o) {
              let l = a.value;
              W.isIdentifier(l) && (l = ia(l.name, s)), e._exports[o] = l;
            }
          })) : Bb.warn(
            Fb({
              expectedType: "ObjectExpression",
              foundType: i?.type,
              node: i || r.declaration
            })
          );
        }
      },
      ExportNamedDeclaration: {
        enter({ node: r, parent: s }) {
          W.isVariableDeclaration(r.declaration) ? r.declaration.declarations.forEach((i) => {
            if (W.isVariableDeclarator(i) && W.isIdentifier(i.id)) {
              let { name: a } = i.id, o = i.init;
              W.isIdentifier(o) && (o = ia(o.name, s)), e._exports[a] = o, e._exportDecls[a] = i;
            }
          }) : r.specifiers ? r.specifiers.forEach((i) => {
            if (W.isExportSpecifier(i) && W.isIdentifier(i.local) && W.isIdentifier(i.exported)) {
              let { name: a } = i.local, { name: o } = i.exported, l = YN(a, s);
              e._exports[o] = l.init, e._exportDecls[o] = l;
            }
          }) : Bb.warn(
            Fb({
              expectedType: "VariableDeclaration",
              foundType: r.declaration?.type,
              node: r.declaration
            })
          );
        }
      },
      ExpressionStatement: {
        enter({ node: r, parent: s }) {
          if (W.isAssignmentExpression(r.expression) && r.expression.operator === "=") {
            let { left: i, right: a } = r.expression;
            if (W.isMemberExpression(i) && W.isIdentifier(i.object) && i.object.name === "module" && W.isIdentifier(i.property) && i.property.
            name === "exports") {
              let o = a;
              W.isIdentifier(a) && (o = ia(a.name, s)), (W.isTSAsExpression(o) || W.isTSSatisfiesExpression(o)) && (o = o.expression), W.isObjectExpression(
              o) ? (e._exportsObject = o, o.properties.forEach((l) => {
                let u = tl(l);
                if (u) {
                  let c = l.value;
                  W.isIdentifier(c) && (c = ia(
                    c.name,
                    s
                  )), e._exports[u] = c;
                }
              })) : Bb.warn(
                Fb({
                  expectedType: "ObjectExpression",
                  foundType: o?.type,
                  node: o
                })
              );
            }
          }
        }
      }
    }), e;
  }
  getFieldNode(e) {
    let [r, ...s] = e, i = this._exports[r];
    if (i)
      return KN(s, i);
  }
  getFieldProperties(e) {
    let [r, ...s] = e, i = this._exports[r];
    if (i)
      return WN(s, i);
  }
  getFieldValue(e) {
    let r = this.getFieldNode(e);
    if (r) {
      let { code: s } = UN(r, {});
      return (0, eval)(`(() => (${s}))()`);
    }
  }
  getSafeFieldValue(e) {
    try {
      return this.getFieldValue(e);
    } catch {
    }
  }
  setFieldNode(e, r) {
    let [s, ...i] = e, a = this._exports[s];
    if (this._exportsObject)
      Ub(e, r, this._exportsObject), this._exports[e[0]] = r;
    else if (a && W.isObjectExpression(a) && i.length > 0)
      Ub(i, r, a);
    else if (a && i.length === 0 && this._exportDecls[e[0]]) {
      let o = this._exportDecls[e[0]];
      o.init = rl([], r);
    } else {
      if (this.hasDefaultExport)
        throw new Error(
          `Could not set the "${e.join(
            "."
          )}" field as the default export is not an object in this file.`
        );
      {
        let o = rl(i, r), l = W.exportNamedDeclaration(
          W.variableDeclaration("const", [W.variableDeclarator(W.identifier(s), o)])
        );
        this._exports[s] = o, this._ast.program.body.push(l);
      }
    }
  }
  /**
   * Returns the name of a node in a given path, supporting the following formats:
   * 1. { framework: 'value' }
   * 2. { framework: { name: 'value', options: {} } }
   */
  /**
   * Returns the name of a node in a given path, supporting the following formats:
   * @example
   * // 1. { framework: 'framework-name' }
   * // 2. { framework: { name: 'framework-name', options: {} }
   * getNameFromPath(['framework']) // => 'framework-name'
   */
  getNameFromPath(e) {
    let r = this.getFieldNode(e);
    if (r)
      return this._getPresetValue(r, "name");
  }
  /**
   * Returns an array of names of a node in a given path, supporting the following formats:
   * @example
   * const config = {
   *   addons: [
   *     'first-addon',
   *     { name: 'second-addon', options: {} }
   *   ]
   * }
   * // => ['first-addon', 'second-addon']
   * getNamesFromPath(['addons'])
   *
   */
  getNamesFromPath(e) {
    let r = this.getFieldNode(e);
    if (!r)
      return;
    let s = [];
    return W.isArrayExpression(r) && r.elements.forEach((i) => {
      s.push(this._getPresetValue(i, "name"));
    }), s;
  }
  _getPnpWrappedValue(e) {
    if (W.isCallExpression(e)) {
      let r = e.arguments[0];
      if (W.isStringLiteral(r))
        return r.value;
    }
  }
  /**
   * Given a node and a fallback property, returns a **non-evaluated** string value of the node.
   * 1. { node: 'value' }
   * 2. { node: { fallbackProperty: 'value' } }
   */
  _getPresetValue(e, r) {
    let s;
    if (W.isStringLiteral(e) ? s = e.value : W.isObjectExpression(e) && e.properties.forEach((i) => {
      W.isObjectProperty(i) && W.isIdentifier(i.key) && i.key.name === r && (W.isStringLiteral(i.value) ? s = i.value.value : s = this._getPnpWrappedValue(
      i.value)), W.isObjectProperty(i) && W.isStringLiteral(i.key) && i.key.value === "name" && W.isStringLiteral(i.value) && (s = i.value.value);
    }), !s)
      throw new Error(
        `The given node must be a string literal or an object expression with a "${r}" property that is a string literal.`
      );
    return s;
  }
  removeField(e) {
    let r = /* @__PURE__ */ n((i, a) => {
      let o = i.findIndex(
        (l) => W.isIdentifier(l.key) && l.key.name === a || W.isStringLiteral(l.key) && l.key.value === a
      );
      o >= 0 && i.splice(o, 1);
    }, "removeProperty");
    if (e.length === 1) {
      let i = !1;
      if (this._ast.program.body.forEach((a) => {
        if (W.isExportNamedDeclaration(a) && W.isVariableDeclaration(a.declaration)) {
          let o = a.declaration.declarations[0];
          W.isIdentifier(o.id) && o.id.name === e[0] && (this._ast.program.body.splice(this._ast.program.body.indexOf(a), 1), i = !0);
        }
        if (W.isExportDefaultDeclaration(a)) {
          let o = a.declaration;
          if (W.isIdentifier(o) && (o = ia(o.name, this._ast.program)), (W.isTSAsExpression(o) || W.isTSSatisfiesExpression(o)) && (o = o.expression),
          W.isObjectExpression(o)) {
            let l = o.properties;
            r(l, e[0]), i = !0;
          }
        }
        if (W.isExpressionStatement(a) && W.isAssignmentExpression(a.expression) && W.isMemberExpression(a.expression.left) && W.isIdentifier(
        a.expression.left.object) && a.expression.left.object.name === "module" && W.isIdentifier(a.expression.left.property) && a.expression.
        left.property.name === "exports" && W.isObjectExpression(a.expression.right)) {
          let o = a.expression.right.properties;
          r(o, e[0]), i = !0;
        }
      }), i) return;
    }
    let s = this.getFieldProperties(e);
    if (s) {
      let i = e.at(-1);
      r(s, i);
    }
  }
  appendValueToArray(e, r) {
    let s = this.valueToNode(r);
    s && this.appendNodeToArray(e, s);
  }
  appendNodeToArray(e, r) {
    let s = this.getFieldNode(e);
    if (!s)
      this.setFieldNode(e, W.arrayExpression([r]));
    else if (W.isArrayExpression(s))
      s.elements.push(r);
    else
      throw new Error(`Expected array at '${e.join(".")}', got '${s.type}'`);
  }
  /**
   * Specialized helper to remove addons or other array entries
   * that can either be strings or objects with a name property.
   */
  removeEntryFromArray(e, r) {
    let s = this.getFieldNode(e);
    if (s)
      if (W.isArrayExpression(s)) {
        let i = s.elements.findIndex((a) => W.isStringLiteral(a) ? a.value === r : W.isObjectExpression(a) ? this._getPresetValue(a, "name") ===
        r : this._getPnpWrappedValue(a) === r);
        if (i >= 0)
          s.elements.splice(i, 1);
        else
          throw new Error(`Could not find '${r}' in array at '${e.join(".")}'`);
      } else
        throw new Error(`Expected array at '${e.join(".")}', got '${s.type}'`);
  }
  _inferQuotes() {
    if (!this._quotes) {
      let e = (this._ast.tokens || []).slice(0, 500).reduce(
        (r, s) => (s.type.label === "string" && (r[this._code[s.start]] += 1), r),
        { "'": 0, '"': 0 }
      );
      this._quotes = e["'"] > e['"'] ? "single" : "double";
    }
    return this._quotes;
  }
  valueToNode(e) {
    let r = this._inferQuotes(), s;
    if (r === "single") {
      let { code: i } = UN(W.valueToNode(e), { jsescOption: { quotes: r } }), a = Si(`const __x = ${i}`);
      RN(a, {
        VariableDeclaration: {
          enter({ node: o }) {
            o.declarations.length === 1 && W.isVariableDeclarator(o.declarations[0]) && W.isIdentifier(o.declarations[0].id) && o.declarations[0].
            id.name === "__x" && (s = o.declarations[0].init);
          }
        }
      });
    } else
      s = W.valueToNode(e);
    return s;
  }
  setFieldValue(e, r) {
    let s = this.valueToNode(r);
    if (!s)
      throw new Error(`Unexpected value ${JSON.stringify(r)}`);
    this.setFieldNode(e, s);
  }
  getBodyDeclarations() {
    return this._ast.program.body;
  }
  setBodyDeclaration(e) {
    this._ast.program.body.push(e);
  }
  /**
   * Import specifiers for a specific require import
   * @param importSpecifiers - The import specifiers to set. If a string is passed in, a default import will be set. Otherwise, an array of named imports will be set
   * @param fromImport - The module to import from
   * @example
   * // const { foo } = require('bar');
   * setRequireImport(['foo'], 'bar');
   *
   * // const foo = require('bar');
   * setRequireImport('foo', 'bar');
   *
   */
  setRequireImport(e, r) {
    let s = this._ast.program.body.find(
      (o) => W.isVariableDeclaration(o) && o.declarations.length === 1 && W.isVariableDeclarator(o.declarations[0]) && W.isCallExpression(o.
      declarations[0].init) && W.isIdentifier(o.declarations[0].init.callee) && o.declarations[0].init.callee.name === "require" && W.isStringLiteral(
      o.declarations[0].init.arguments[0]) && o.declarations[0].init.arguments[0].value === r
    ), i = /* @__PURE__ */ n((o) => W.isObjectPattern(s?.declarations[0].id) && s?.declarations[0].id.properties.find(
      (l) => W.isObjectProperty(l) && W.isIdentifier(l.key) && l.key.name === o
    ), "hasRequireSpecifier"), a = /* @__PURE__ */ n((o, l) => o.declarations.length === 1 && W.isVariableDeclarator(o.declarations[0]) && W.isIdentifier(
    o.declarations[0].id) && o.declarations[0].id.name === l, "hasDefaultRequireSpecifier");
    if (typeof e == "string") {
      let o = /* @__PURE__ */ n(() => {
        this._ast.program.body.unshift(
          W.variableDeclaration("const", [
            W.variableDeclarator(
              W.identifier(e),
              W.callExpression(W.identifier("require"), [W.stringLiteral(r)])
            )
          ])
        );
      }, "addDefaultRequireSpecifier");
      s && a(s, e) || o();
    } else s ? e.forEach((o) => {
      i(o) || s.declarations[0].id.properties.push(
        W.objectProperty(W.identifier(o), W.identifier(o), void 0, !0)
      );
    }) : this._ast.program.body.unshift(
      W.variableDeclaration("const", [
        W.variableDeclarator(
          W.objectPattern(
            e.map(
              (o) => W.objectProperty(W.identifier(o), W.identifier(o), void 0, !0)
            )
          ),
          W.callExpression(W.identifier("require"), [W.stringLiteral(r)])
        )
      ])
    );
  }
  /**
   * Set import specifiers for a given import statement.
   * @description Does not support setting type imports (yet)
   * @param importSpecifiers - The import specifiers to set. If a string is passed in, a default import will be set. Otherwise, an array of named imports will be set
   * @param fromImport - The module to import from
   * @example
   * // import { foo } from 'bar';
   * setImport(['foo'], 'bar');
   *
   * // import foo from 'bar';
   * setImport('foo', 'bar');
   *
   */
  setImport(e, r) {
    let s = /* @__PURE__ */ n((l) => W.importSpecifier(W.identifier(l), W.identifier(l)), "getNewImportSpecifier"), i = /* @__PURE__ */ n((l, u) => l.
    specifiers.find(
      (c) => W.isImportSpecifier(c) && W.isIdentifier(c.imported) && c.imported.name === u
    ), "hasImportSpecifier"), a = /* @__PURE__ */ n((l, u) => l.specifiers.find((c) => W.isImportDefaultSpecifier(c)), "hasDefaultImportSpec\
ifier"), o = this._ast.program.body.find(
      (l) => W.isImportDeclaration(l) && l.source.value === r
    );
    typeof e == "string" ? o ? a(o, e) || o.specifiers.push(
      W.importDefaultSpecifier(W.identifier(e))
    ) : this._ast.program.body.unshift(
      W.importDeclaration(
        [W.importDefaultSpecifier(W.identifier(e))],
        W.stringLiteral(r)
      )
    ) : o ? e.forEach((l) => {
      i(o, l) || o.specifiers.push(s(l));
    }) : this._ast.program.body.unshift(
      W.importDeclaration(
        e.map(
          (l) => W.importSpecifier(W.identifier(l), W.identifier(l))
        ),
        W.stringLiteral(r)
      )
    );
  }
}, JN = /* @__PURE__ */ n((t, e) => {
  let r = Si(t);
  return new Hc(r, t, e);
}, "loadConfig"), XN = /* @__PURE__ */ n((t) => $N(t).code, "formatConfig"), $N = /* @__PURE__ */ n((t, e = {}) => VN.print(t._ast, e), "pri\
ntConfig"), H_e = /* @__PURE__ */ n(async (t) => {
  let e = (await (0, zc.readFile)(t, "utf-8")).toString();
  return JN(e, t).parse();
}, "readConfig"), z_e = /* @__PURE__ */ n(async (t, e) => {
  let r = e || t.fileName;
  if (!r) throw new Error("Please specify a fileName for writeConfig");
  await (0, zc.writeFile)(r, XN(t));
}, "writeConfig");

// src/csf-tools/getStorySortParameter.ts
var ot = $t(Ce(), 1), qb = $t(ji(), 1), Vb = $t(_a(), 1), zN = $t(ul(), 1);
var G_e = qb.default.default || qb.default, HN = Vb.default.default || Vb.default, Q_e = console, Kb = /* @__PURE__ */ n((t, e) => {
  let r;
  return t.properties.forEach((s) => {
    ot.isIdentifier(s.key) && s.key.name === e && (r = s.value);
  }), r;
}, "getValue"), Wb = /* @__PURE__ */ n((t) => {
  let e = sl(t);
  if (ot.isArrayExpression(e))
    return e.elements.map((r) => Wb(r));
  if (ot.isObjectExpression(e))
    return e.properties.reduce((r, s) => (ot.isIdentifier(s.key) && (r[s.key.name] = Wb(s.value)), r), {});
  if (ot.isLiteral(e))
    return e.value;
  if (ot.isIdentifier(e))
    return na(e.name, !0);
  throw new Error(`Unknown node type ${e.type}`);
}, "parseValue"), na = /* @__PURE__ */ n((t, e) => {
  let r = zN.dedent`
    Unexpected '${t}'. Parameter 'options.storySort' should be defined inline e.g.:

    export default {
      parameters: {
        options: {
          storySort: <array | object | function>
        },
      },
    };
  `;
  if (e)
    throw new Error(r);
  Q_e.info(r);
}, "unsupported"), sl = /* @__PURE__ */ n((t) => ot.isTSAsExpression(t) || ot.isTSSatisfiesExpression(t) ? t.expression : t, "stripTSModifie\
rs"), GN = /* @__PURE__ */ n((t) => {
  let e = sl(t);
  if (ot.isObjectExpression(e)) {
    let r = Kb(e, "options");
    if (r) {
      if (ot.isObjectExpression(r))
        return Kb(r, "storySort");
      na("options", !0);
    }
  }
}, "parseParameters"), Z_e = /* @__PURE__ */ n((t, e) => {
  let r = sl(t);
  if (ot.isObjectExpression(r)) {
    let s = Kb(r, "parameters");
    if (ot.isIdentifier(s) && (s = Ks(s.name, e)), s)
      return GN(s);
  } else
    na("default", !0);
}, "parseDefault"), eLe = /* @__PURE__ */ n((t) => {
  if (!t.includes("storySort")) return;
  let e, r = Si(t);
  if (G_e(r, {
    ExportNamedDeclaration: {
      enter({ node: s }) {
        ot.isVariableDeclaration(s.declaration) ? s.declaration.declarations.forEach((i) => {
          if (ot.isVariableDeclarator(i) && ot.isIdentifier(i.id)) {
            let { name: a } = i.id;
            if (a === "parameters" && i.init) {
              let o = sl(i.init);
              e = GN(o);
            }
          }
        }) : s.specifiers.forEach((i) => {
          ot.isIdentifier(i.exported) && i.exported.name === "parameters" && na("parameters", !1);
        });
      }
    },
    ExportDefaultDeclaration: {
      enter({ node: s }) {
        let i = s.declaration;
        ot.isIdentifier(i) && (i = Ks(i.name, r.program)), i = sl(i), ot.isObjectExpression(i) ? e = Z_e(i, r.program) : na("default", !1);
      }
    }
  }), !!e) {
    if (ot.isArrowFunctionExpression(e)) {
      let { code: s } = HN(e, {});
      return (0, eval)(s);
    }
    if (ot.isFunctionExpression(e)) {
      let { code: s } = HN(e, {}), i = e.id?.name, a = `(a, b) => {
      ${s};
      return ${i}(a, b)
    }`;
      return (0, eval)(a);
    }
    return ot.isLiteral(e) || ot.isArrayExpression(e) || ot.isObjectExpression(e) ? Wb(e) : na("storySort", !0);
  }
}, "getStorySortParameter");

// src/csf-tools/enrichCsf.ts
var Ie = $t(Ce(), 1), Yb = $t(_a(), 1);
var tLe = Yb.default.default || Yb.default, QN = /* @__PURE__ */ n((t, e, r, s) => {
  let i = e.getStoryExport(r), a = !s?.disableSource && t2(i), o = !s?.disableDescription && Jb(e._storyStatements[r]), l = [], u = Ie.memberExpression(
  Ie.identifier(r), Ie.identifier("parameters"));
  l.push(Ie.spreadElement(u));
  let c = Ie.optionalMemberExpression(
    u,
    Ie.identifier("docs"),
    !1,
    !0
  ), p = [];
  if (a) {
    let f = Ie.optionalMemberExpression(
      c,
      Ie.identifier("source"),
      !1,
      !0
    );
    p.push(
      Ie.objectProperty(
        Ie.identifier("source"),
        Ie.objectExpression([
          Ie.objectProperty(Ie.identifier("originalSource"), Ie.stringLiteral(a)),
          Ie.spreadElement(f)
        ])
      )
    );
  }
  if (o) {
    let f = Ie.optionalMemberExpression(
      c,
      Ie.identifier("description"),
      !1,
      !0
    );
    p.push(
      Ie.objectProperty(
        Ie.identifier("description"),
        Ie.objectExpression([
          Ie.objectProperty(Ie.identifier("story"), Ie.stringLiteral(o)),
          Ie.spreadElement(f)
        ])
      )
    );
  }
  if (p.length > 0) {
    l.push(
      Ie.objectProperty(
        Ie.identifier("docs"),
        Ie.objectExpression([Ie.spreadElement(c), ...p])
      )
    );
    let f = Ie.expressionStatement(
      Ie.assignmentExpression("=", u, Ie.objectExpression(l))
    );
    t._ast.program.body.push(f);
  }
}, "enrichCsfStory"), ZN = /* @__PURE__ */ n((t, e, r) => {
  if (!e.length) {
    t.properties.find(
      (u) => Ie.isObjectProperty(u) && Ie.isIdentifier(u.key) && u.key.name === "component"
    ) || t.properties.unshift(r);
    return;
  }
  let [s, ...i] = e, a = t.properties.find(
    (l) => Ie.isObjectProperty(l) && Ie.isIdentifier(l.key) && l.key.name === s && Ie.isObjectExpression(l.value)
  ), o;
  a ? o = a.value : (o = Ie.objectExpression([]), t.properties.push(Ie.objectProperty(Ie.identifier(s), o))), ZN(o, i, r);
}, "addComponentDescription"), e2 = /* @__PURE__ */ n((t, e, r) => {
  let s = !r?.disableDescription && Jb(e._metaStatement);
  if (s) {
    let i = t._metaNode;
    i && Ie.isObjectExpression(i) && ZN(
      i,
      ["parameters", "docs", "description"],
      Ie.objectProperty(Ie.identifier("component"), Ie.stringLiteral(s))
    );
  }
}, "enrichCsfMeta"), rLe = /* @__PURE__ */ n((t, e, r) => {
  e2(t, e, r), Object.keys(t._storyExports).forEach((s) => {
    QN(t, e, s, r);
  });
}, "enrichCsf"), t2 = /* @__PURE__ */ n((t) => {
  let e = Ie.isVariableDeclarator(t) ? t.init : t, { code: r } = tLe(e, {});
  return r;
}, "extractSource"), Jb = /* @__PURE__ */ n((t) => t?.leadingComments ? t.leadingComments.map((r) => r.type === "CommentLine" || !r.value.startsWith(
"*") ? null : r.value.split(`
`).map((s) => s.replace(/^(\s+)?(\*+)?(\s)?/, "")).join(`
`).trim()).filter(Boolean).join(`
`) : "", "extractDescription");
